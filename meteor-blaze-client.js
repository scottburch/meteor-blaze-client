

//--------- underscore.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Package-scope variables */
var _, exports;

(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                       //
// packages/underscore/pre.js                                                                            //
//                                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                         //
// Define an object named exports. This will cause underscore.js to put `_` as a                         // 1
// field on it, instead of in the global namespace.  See also post.js.                                   // 2
exports = {};                                                                                            // 3
                                                                                                         // 4
///////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                       //
// packages/underscore/underscore.js                                                                     //
//                                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                         //
//     Underscore.js 1.5.2                                                                               // 1
//     http://underscorejs.org                                                                           // 2
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors                // 3
//     Underscore may be freely distributed under the MIT license.                                       // 4
                                                                                                         // 5
(function() {                                                                                            // 6
                                                                                                         // 7
  // Baseline setup                                                                                      // 8
  // --------------                                                                                      // 9
                                                                                                         // 10
  // Establish the root object, `window` in the browser, or `exports` on the server.                     // 11
  var root = this;                                                                                       // 12
                                                                                                         // 13
  // Save the previous value of the `_` variable.                                                        // 14
  var previousUnderscore = root._;                                                                       // 15
                                                                                                         // 16
  // Establish the object that gets returned to break out of a loop iteration.                           // 17
  var breaker = {};                                                                                      // 18
                                                                                                         // 19
  // Save bytes in the minified (but not gzipped) version:                                               // 20
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;         // 21
                                                                                                         // 22
  // Create quick reference variables for speed access to core prototypes.                               // 23
  var                                                                                                    // 24
    push             = ArrayProto.push,                                                                  // 25
    slice            = ArrayProto.slice,                                                                 // 26
    concat           = ArrayProto.concat,                                                                // 27
    toString         = ObjProto.toString,                                                                // 28
    hasOwnProperty   = ObjProto.hasOwnProperty;                                                          // 29
                                                                                                         // 30
  // All **ECMAScript 5** native function implementations that we hope to use                            // 31
  // are declared here.                                                                                  // 32
  var                                                                                                    // 33
    nativeForEach      = ArrayProto.forEach,                                                             // 34
    nativeMap          = ArrayProto.map,                                                                 // 35
    nativeReduce       = ArrayProto.reduce,                                                              // 36
    nativeReduceRight  = ArrayProto.reduceRight,                                                         // 37
    nativeFilter       = ArrayProto.filter,                                                              // 38
    nativeEvery        = ArrayProto.every,                                                               // 39
    nativeSome         = ArrayProto.some,                                                                // 40
    nativeIndexOf      = ArrayProto.indexOf,                                                             // 41
    nativeLastIndexOf  = ArrayProto.lastIndexOf,                                                         // 42
    nativeIsArray      = Array.isArray,                                                                  // 43
    nativeKeys         = Object.keys,                                                                    // 44
    nativeBind         = FuncProto.bind;                                                                 // 45
                                                                                                         // 46
  // Create a safe reference to the Underscore object for use below.                                     // 47
  var _ = function(obj) {                                                                                // 48
    if (obj instanceof _) return obj;                                                                    // 49
    if (!(this instanceof _)) return new _(obj);                                                         // 50
    this._wrapped = obj;                                                                                 // 51
  };                                                                                                     // 52
                                                                                                         // 53
  // Export the Underscore object for **Node.js**, with                                                  // 54
  // backwards-compatibility for the old `require()` API. If we're in                                    // 55
  // the browser, add `_` as a global object via a string identifier,                                    // 56
  // for Closure Compiler "advanced" mode.                                                               // 57
  if (typeof exports !== 'undefined') {                                                                  // 58
    if (typeof module !== 'undefined' && module.exports) {                                               // 59
      exports = module.exports = _;                                                                      // 60
    }                                                                                                    // 61
    exports._ = _;                                                                                       // 62
  } else {                                                                                               // 63
    root._ = _;                                                                                          // 64
  }                                                                                                      // 65
                                                                                                         // 66
  // Current version.                                                                                    // 67
  _.VERSION = '1.5.2';                                                                                   // 68
                                                                                                         // 69
  // Collection Functions                                                                                // 70
  // --------------------                                                                                // 71
                                                                                                         // 72
  // METEOR CHANGE: Define _isArguments instead of depending on                                          // 73
  // _.isArguments which is defined using each. In looksLikeArray                                        // 74
  // (which each depends on), we then use _isArguments instead of                                        // 75
  // _.isArguments.                                                                                      // 76
  var _isArguments = function (obj) {                                                                    // 77
    return toString.call(obj) === '[object Arguments]';                                                  // 78
  };                                                                                                     // 79
  // Define a fallback version of the method in browsers (ahem, IE), where                               // 80
  // there isn't any inspectable "Arguments" type.                                                       // 81
  if (!_isArguments(arguments)) {                                                                        // 82
    _isArguments = function (obj) {                                                                      // 83
      return !!(obj && hasOwnProperty.call(obj, 'callee') && typeof obj.callee === 'function');          // 84
    };                                                                                                   // 85
  }                                                                                                      // 86
                                                                                                         // 87
  // METEOR CHANGE: _.each({length: 5}) should be treated like an object, not an                         // 88
  // array. This looksLikeArray function is introduced by Meteor, and replaces                           // 89
  // all instances of `obj.length === +obj.length`.                                                      // 90
  // https://github.com/meteor/meteor/issues/594                                                         // 91
  // https://github.com/jashkenas/underscore/issues/770                                                  // 92
  var looksLikeArray = function (obj) {                                                                  // 93
    return (obj.length === +obj.length                                                                   // 94
            // _.isArguments not yet necessarily defined here                                            // 95
            && (_isArguments(obj) || obj.constructor !== Object));                                       // 96
  };                                                                                                     // 97
                                                                                                         // 98
  // The cornerstone, an `each` implementation, aka `forEach`.                                           // 99
  // Handles objects with the built-in `forEach`, arrays, and raw objects.                               // 100
  // Delegates to **ECMAScript 5**'s native `forEach` if available.                                      // 101
  var each = _.each = _.forEach = function(obj, iterator, context) {                                     // 102
    if (obj == null) return;                                                                             // 103
    if (nativeForEach && obj.forEach === nativeForEach) {                                                // 104
      obj.forEach(iterator, context);                                                                    // 105
    } else if (looksLikeArray(obj)) {                                                                    // 106
      for (var i = 0, length = obj.length; i < length; i++) {                                            // 107
        if (iterator.call(context, obj[i], i, obj) === breaker) return;                                  // 108
      }                                                                                                  // 109
    } else {                                                                                             // 110
      var keys = _.keys(obj);                                                                            // 111
      for (var i = 0, length = keys.length; i < length; i++) {                                           // 112
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;                      // 113
      }                                                                                                  // 114
    }                                                                                                    // 115
  };                                                                                                     // 116
                                                                                                         // 117
  // Return the results of applying the iterator to each element.                                        // 118
  // Delegates to **ECMAScript 5**'s native `map` if available.                                          // 119
  _.map = _.collect = function(obj, iterator, context) {                                                 // 120
    var results = [];                                                                                    // 121
    if (obj == null) return results;                                                                     // 122
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);                           // 123
    each(obj, function(value, index, list) {                                                             // 124
      results.push(iterator.call(context, value, index, list));                                          // 125
    });                                                                                                  // 126
    return results;                                                                                      // 127
  };                                                                                                     // 128
                                                                                                         // 129
  var reduceError = 'Reduce of empty array with no initial value';                                       // 130
                                                                                                         // 131
  // **Reduce** builds up a single result from a list of values, aka `inject`,                           // 132
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.                           // 133
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {                               // 134
    var initial = arguments.length > 2;                                                                  // 135
    if (obj == null) obj = [];                                                                           // 136
    if (nativeReduce && obj.reduce === nativeReduce) {                                                   // 137
      if (context) iterator = _.bind(iterator, context);                                                 // 138
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);                                // 139
    }                                                                                                    // 140
    each(obj, function(value, index, list) {                                                             // 141
      if (!initial) {                                                                                    // 142
        memo = value;                                                                                    // 143
        initial = true;                                                                                  // 144
      } else {                                                                                           // 145
        memo = iterator.call(context, memo, value, index, list);                                         // 146
      }                                                                                                  // 147
    });                                                                                                  // 148
    if (!initial) throw new TypeError(reduceError);                                                      // 149
    return memo;                                                                                         // 150
  };                                                                                                     // 151
                                                                                                         // 152
  // The right-associative version of reduce, also known as `foldr`.                                     // 153
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.                                  // 154
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {                                     // 155
    var initial = arguments.length > 2;                                                                  // 156
    if (obj == null) obj = [];                                                                           // 157
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {                                    // 158
      if (context) iterator = _.bind(iterator, context);                                                 // 159
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);                      // 160
    }                                                                                                    // 161
    var length = obj.length;                                                                             // 162
    if (!looksLikeArray(obj)) {                                                                          // 163
      var keys = _.keys(obj);                                                                            // 164
      length = keys.length;                                                                              // 165
    }                                                                                                    // 166
    each(obj, function(value, index, list) {                                                             // 167
      index = keys ? keys[--length] : --length;                                                          // 168
      if (!initial) {                                                                                    // 169
        memo = obj[index];                                                                               // 170
        initial = true;                                                                                  // 171
      } else {                                                                                           // 172
        memo = iterator.call(context, memo, obj[index], index, list);                                    // 173
      }                                                                                                  // 174
    });                                                                                                  // 175
    if (!initial) throw new TypeError(reduceError);                                                      // 176
    return memo;                                                                                         // 177
  };                                                                                                     // 178
                                                                                                         // 179
  // Return the first value which passes a truth test. Aliased as `detect`.                              // 180
  _.find = _.detect = function(obj, iterator, context) {                                                 // 181
    var result;                                                                                          // 182
    any(obj, function(value, index, list) {                                                              // 183
      if (iterator.call(context, value, index, list)) {                                                  // 184
        result = value;                                                                                  // 185
        return true;                                                                                     // 186
      }                                                                                                  // 187
    });                                                                                                  // 188
    return result;                                                                                       // 189
  };                                                                                                     // 190
                                                                                                         // 191
  // Return all the elements that pass a truth test.                                                     // 192
  // Delegates to **ECMAScript 5**'s native `filter` if available.                                       // 193
  // Aliased as `select`.                                                                                // 194
  _.filter = _.select = function(obj, iterator, context) {                                               // 195
    var results = [];                                                                                    // 196
    if (obj == null) return results;                                                                     // 197
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);               // 198
    each(obj, function(value, index, list) {                                                             // 199
      if (iterator.call(context, value, index, list)) results.push(value);                               // 200
    });                                                                                                  // 201
    return results;                                                                                      // 202
  };                                                                                                     // 203
                                                                                                         // 204
  // Return all the elements for which a truth test fails.                                               // 205
  _.reject = function(obj, iterator, context) {                                                          // 206
    return _.filter(obj, function(value, index, list) {                                                  // 207
      return !iterator.call(context, value, index, list);                                                // 208
    }, context);                                                                                         // 209
  };                                                                                                     // 210
                                                                                                         // 211
  // Determine whether all of the elements match a truth test.                                           // 212
  // Delegates to **ECMAScript 5**'s native `every` if available.                                        // 213
  // Aliased as `all`.                                                                                   // 214
  _.every = _.all = function(obj, iterator, context) {                                                   // 215
    iterator || (iterator = _.identity);                                                                 // 216
    var result = true;                                                                                   // 217
    if (obj == null) return result;                                                                      // 218
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);                   // 219
    each(obj, function(value, index, list) {                                                             // 220
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;              // 221
    });                                                                                                  // 222
    return !!result;                                                                                     // 223
  };                                                                                                     // 224
                                                                                                         // 225
  // Determine if at least one element in the object matches a truth test.                               // 226
  // Delegates to **ECMAScript 5**'s native `some` if available.                                         // 227
  // Aliased as `any`.                                                                                   // 228
  var any = _.some = _.any = function(obj, iterator, context) {                                          // 229
    iterator || (iterator = _.identity);                                                                 // 230
    var result = false;                                                                                  // 231
    if (obj == null) return result;                                                                      // 232
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);                       // 233
    each(obj, function(value, index, list) {                                                             // 234
      if (result || (result = iterator.call(context, value, index, list))) return breaker;               // 235
    });                                                                                                  // 236
    return !!result;                                                                                     // 237
  };                                                                                                     // 238
                                                                                                         // 239
  // Determine if the array or object contains a given value (using `===`).                              // 240
  // Aliased as `include`.                                                                               // 241
  _.contains = _.include = function(obj, target) {                                                       // 242
    if (obj == null) return false;                                                                       // 243
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;                // 244
    return any(obj, function(value) {                                                                    // 245
      return value === target;                                                                           // 246
    });                                                                                                  // 247
  };                                                                                                     // 248
                                                                                                         // 249
  // Invoke a method (with arguments) on every item in a collection.                                     // 250
  _.invoke = function(obj, method) {                                                                     // 251
    var args = slice.call(arguments, 2);                                                                 // 252
    var isFunc = _.isFunction(method);                                                                   // 253
    return _.map(obj, function(value) {                                                                  // 254
      return (isFunc ? method : value[method]).apply(value, args);                                       // 255
    });                                                                                                  // 256
  };                                                                                                     // 257
                                                                                                         // 258
  // Convenience version of a common use case of `map`: fetching a property.                             // 259
  _.pluck = function(obj, key) {                                                                         // 260
    return _.map(obj, function(value){ return value[key]; });                                            // 261
  };                                                                                                     // 262
                                                                                                         // 263
  // Convenience version of a common use case of `filter`: selecting only objects                        // 264
  // containing specific `key:value` pairs.                                                              // 265
  _.where = function(obj, attrs, first) {                                                                // 266
    if (_.isEmpty(attrs)) return first ? void 0 : [];                                                    // 267
    return _[first ? 'find' : 'filter'](obj, function(value) {                                           // 268
      for (var key in attrs) {                                                                           // 269
        if (attrs[key] !== value[key]) return false;                                                     // 270
      }                                                                                                  // 271
      return true;                                                                                       // 272
    });                                                                                                  // 273
  };                                                                                                     // 274
                                                                                                         // 275
  // Convenience version of a common use case of `find`: getting the first object                        // 276
  // containing specific `key:value` pairs.                                                              // 277
  _.findWhere = function(obj, attrs) {                                                                   // 278
    return _.where(obj, attrs, true);                                                                    // 279
  };                                                                                                     // 280
                                                                                                         // 281
  // Return the maximum element or (element-based computation).                                          // 282
  // Can't optimize arrays of integers longer than 65,535 elements.                                      // 283
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)                               // 284
  _.max = function(obj, iterator, context) {                                                             // 285
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {                       // 286
      return Math.max.apply(Math, obj);                                                                  // 287
    }                                                                                                    // 288
    if (!iterator && _.isEmpty(obj)) return -Infinity;                                                   // 289
    var result = {computed : -Infinity, value: -Infinity};                                               // 290
    each(obj, function(value, index, list) {                                                             // 291
      var computed = iterator ? iterator.call(context, value, index, list) : value;                      // 292
      computed > result.computed && (result = {value : value, computed : computed});                     // 293
    });                                                                                                  // 294
    return result.value;                                                                                 // 295
  };                                                                                                     // 296
                                                                                                         // 297
  // Return the minimum element (or element-based computation).                                          // 298
  _.min = function(obj, iterator, context) {                                                             // 299
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {                       // 300
      return Math.min.apply(Math, obj);                                                                  // 301
    }                                                                                                    // 302
    if (!iterator && _.isEmpty(obj)) return Infinity;                                                    // 303
    var result = {computed : Infinity, value: Infinity};                                                 // 304
    each(obj, function(value, index, list) {                                                             // 305
      var computed = iterator ? iterator.call(context, value, index, list) : value;                      // 306
      computed < result.computed && (result = {value : value, computed : computed});                     // 307
    });                                                                                                  // 308
    return result.value;                                                                                 // 309
  };                                                                                                     // 310
                                                                                                         // 311
  // Shuffle an array, using the modern version of the                                                   // 312
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle).                          // 313
  _.shuffle = function(obj) {                                                                            // 314
    var rand;                                                                                            // 315
    var index = 0;                                                                                       // 316
    var shuffled = [];                                                                                   // 317
    each(obj, function(value) {                                                                          // 318
      rand = _.random(index++);                                                                          // 319
      shuffled[index - 1] = shuffled[rand];                                                              // 320
      shuffled[rand] = value;                                                                            // 321
    });                                                                                                  // 322
    return shuffled;                                                                                     // 323
  };                                                                                                     // 324
                                                                                                         // 325
  // Sample **n** random values from an array.                                                           // 326
  // If **n** is not specified, returns a single random element from the array.                          // 327
  // The internal `guard` argument allows it to work with `map`.                                         // 328
  _.sample = function(obj, n, guard) {                                                                   // 329
    if (arguments.length < 2 || guard) {                                                                 // 330
      return obj[_.random(obj.length - 1)];                                                              // 331
    }                                                                                                    // 332
    return _.shuffle(obj).slice(0, Math.max(0, n));                                                      // 333
  };                                                                                                     // 334
                                                                                                         // 335
  // An internal function to generate lookup iterators.                                                  // 336
  var lookupIterator = function(value) {                                                                 // 337
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };                            // 338
  };                                                                                                     // 339
                                                                                                         // 340
  // Sort the object's values by a criterion produced by an iterator.                                    // 341
  _.sortBy = function(obj, value, context) {                                                             // 342
    var iterator = lookupIterator(value);                                                                // 343
    return _.pluck(_.map(obj, function(value, index, list) {                                             // 344
      return {                                                                                           // 345
        value: value,                                                                                    // 346
        index: index,                                                                                    // 347
        criteria: iterator.call(context, value, index, list)                                             // 348
      };                                                                                                 // 349
    }).sort(function(left, right) {                                                                      // 350
      var a = left.criteria;                                                                             // 351
      var b = right.criteria;                                                                            // 352
      if (a !== b) {                                                                                     // 353
        if (a > b || a === void 0) return 1;                                                             // 354
        if (a < b || b === void 0) return -1;                                                            // 355
      }                                                                                                  // 356
      return left.index - right.index;                                                                   // 357
    }), 'value');                                                                                        // 358
  };                                                                                                     // 359
                                                                                                         // 360
  // An internal function used for aggregate "group by" operations.                                      // 361
  var group = function(behavior) {                                                                       // 362
    return function(obj, value, context) {                                                               // 363
      var result = {};                                                                                   // 364
      var iterator = value == null ? _.identity : lookupIterator(value);                                 // 365
      each(obj, function(value, index) {                                                                 // 366
        var key = iterator.call(context, value, index, obj);                                             // 367
        behavior(result, key, value);                                                                    // 368
      });                                                                                                // 369
      return result;                                                                                     // 370
    };                                                                                                   // 371
  };                                                                                                     // 372
                                                                                                         // 373
  // Groups the object's values by a criterion. Pass either a string attribute                           // 374
  // to group by, or a function that returns the criterion.                                              // 375
  _.groupBy = group(function(result, key, value) {                                                       // 376
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);                                 // 377
  });                                                                                                    // 378
                                                                                                         // 379
  // Indexes the object's values by a criterion, similar to `groupBy`, but for                           // 380
  // when you know that your index values will be unique.                                                // 381
  _.indexBy = group(function(result, key, value) {                                                       // 382
    result[key] = value;                                                                                 // 383
  });                                                                                                    // 384
                                                                                                         // 385
  // Counts instances of an object that group by a certain criterion. Pass                               // 386
  // either a string attribute to count by, or a function that returns the                               // 387
  // criterion.                                                                                          // 388
  _.countBy = group(function(result, key) {                                                              // 389
    _.has(result, key) ? result[key]++ : result[key] = 1;                                                // 390
  });                                                                                                    // 391
                                                                                                         // 392
  // Use a comparator function to figure out the smallest index at which                                 // 393
  // an object should be inserted so as to maintain order. Uses binary search.                           // 394
  _.sortedIndex = function(array, obj, iterator, context) {                                              // 395
    iterator = iterator == null ? _.identity : lookupIterator(iterator);                                 // 396
    var value = iterator.call(context, obj);                                                             // 397
    var low = 0, high = array.length;                                                                    // 398
    while (low < high) {                                                                                 // 399
      var mid = (low + high) >>> 1;                                                                      // 400
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;                           // 401
    }                                                                                                    // 402
    return low;                                                                                          // 403
  };                                                                                                     // 404
                                                                                                         // 405
  // Safely create a real, live array from anything iterable.                                            // 406
  _.toArray = function(obj) {                                                                            // 407
    if (!obj) return [];                                                                                 // 408
    if (_.isArray(obj)) return slice.call(obj);                                                          // 409
    if (looksLikeArray(obj)) return _.map(obj, _.identity);                                              // 410
    return _.values(obj);                                                                                // 411
  };                                                                                                     // 412
                                                                                                         // 413
  // Return the number of elements in an object.                                                         // 414
  _.size = function(obj) {                                                                               // 415
    if (obj == null) return 0;                                                                           // 416
    return (looksLikeArray(obj)) ? obj.length : _.keys(obj).length;                                      // 417
  };                                                                                                     // 418
                                                                                                         // 419
  // Array Functions                                                                                     // 420
  // ---------------                                                                                     // 421
                                                                                                         // 422
  // Get the first element of an array. Passing **n** will return the first N                            // 423
  // values in the array. Aliased as `head` and `take`. The **guard** check                              // 424
  // allows it to work with `_.map`.                                                                     // 425
  _.first = _.head = _.take = function(array, n, guard) {                                                // 426
    if (array == null) return void 0;                                                                    // 427
    return (n == null) || guard ? array[0] : slice.call(array, 0, n);                                    // 428
  };                                                                                                     // 429
                                                                                                         // 430
  // Returns everything but the last entry of the array. Especially useful on                            // 431
  // the arguments object. Passing **n** will return all the values in                                   // 432
  // the array, excluding the last N. The **guard** check allows it to work with                         // 433
  // `_.map`.                                                                                            // 434
  _.initial = function(array, n, guard) {                                                                // 435
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));                          // 436
  };                                                                                                     // 437
                                                                                                         // 438
  // Get the last element of an array. Passing **n** will return the last N                              // 439
  // values in the array. The **guard** check allows it to work with `_.map`.                            // 440
  _.last = function(array, n, guard) {                                                                   // 441
    if (array == null) return void 0;                                                                    // 442
    if ((n == null) || guard) {                                                                          // 443
      return array[array.length - 1];                                                                    // 444
    } else {                                                                                             // 445
      return slice.call(array, Math.max(array.length - n, 0));                                           // 446
    }                                                                                                    // 447
  };                                                                                                     // 448
                                                                                                         // 449
  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.                  // 450
  // Especially useful on the arguments object. Passing an **n** will return                             // 451
  // the rest N values in the array. The **guard**                                                       // 452
  // check allows it to work with `_.map`.                                                               // 453
  _.rest = _.tail = _.drop = function(array, n, guard) {                                                 // 454
    return slice.call(array, (n == null) || guard ? 1 : n);                                              // 455
  };                                                                                                     // 456
                                                                                                         // 457
  // Trim out all falsy values from an array.                                                            // 458
  _.compact = function(array) {                                                                          // 459
    return _.filter(array, _.identity);                                                                  // 460
  };                                                                                                     // 461
                                                                                                         // 462
  // Internal implementation of a recursive `flatten` function.                                          // 463
  var flatten = function(input, shallow, output) {                                                       // 464
    if (shallow && _.every(input, _.isArray)) {                                                          // 465
      return concat.apply(output, input);                                                                // 466
    }                                                                                                    // 467
    each(input, function(value) {                                                                        // 468
      if (_.isArray(value) || _.isArguments(value)) {                                                    // 469
        shallow ? push.apply(output, value) : flatten(value, shallow, output);                           // 470
      } else {                                                                                           // 471
        output.push(value);                                                                              // 472
      }                                                                                                  // 473
    });                                                                                                  // 474
    return output;                                                                                       // 475
  };                                                                                                     // 476
                                                                                                         // 477
  // Flatten out an array, either recursively (by default), or just one level.                           // 478
  _.flatten = function(array, shallow) {                                                                 // 479
    return flatten(array, shallow, []);                                                                  // 480
  };                                                                                                     // 481
                                                                                                         // 482
  // Return a version of the array that does not contain the specified value(s).                         // 483
  _.without = function(array) {                                                                          // 484
    return _.difference(array, slice.call(arguments, 1));                                                // 485
  };                                                                                                     // 486
                                                                                                         // 487
  // Produce a duplicate-free version of the array. If the array has already                             // 488
  // been sorted, you have the option of using a faster algorithm.                                       // 489
  // Aliased as `unique`.                                                                                // 490
  _.uniq = _.unique = function(array, isSorted, iterator, context) {                                     // 491
    if (_.isFunction(isSorted)) {                                                                        // 492
      context = iterator;                                                                                // 493
      iterator = isSorted;                                                                               // 494
      isSorted = false;                                                                                  // 495
    }                                                                                                    // 496
    var initial = iterator ? _.map(array, iterator, context) : array;                                    // 497
    var results = [];                                                                                    // 498
    var seen = [];                                                                                       // 499
    each(initial, function(value, index) {                                                               // 500
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {           // 501
        seen.push(value);                                                                                // 502
        results.push(array[index]);                                                                      // 503
      }                                                                                                  // 504
    });                                                                                                  // 505
    return results;                                                                                      // 506
  };                                                                                                     // 507
                                                                                                         // 508
  // Produce an array that contains the union: each distinct element from all of                         // 509
  // the passed-in arrays.                                                                               // 510
  _.union = function() {                                                                                 // 511
    return _.uniq(_.flatten(arguments, true));                                                           // 512
  };                                                                                                     // 513
                                                                                                         // 514
  // Produce an array that contains every item shared between all the                                    // 515
  // passed-in arrays.                                                                                   // 516
  _.intersection = function(array) {                                                                     // 517
    var rest = slice.call(arguments, 1);                                                                 // 518
    return _.filter(_.uniq(array), function(item) {                                                      // 519
      return _.every(rest, function(other) {                                                             // 520
        return _.indexOf(other, item) >= 0;                                                              // 521
      });                                                                                                // 522
    });                                                                                                  // 523
  };                                                                                                     // 524
                                                                                                         // 525
  // Take the difference between one array and a number of other arrays.                                 // 526
  // Only the elements present in just the first array will remain.                                      // 527
  _.difference = function(array) {                                                                       // 528
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));                                       // 529
    return _.filter(array, function(value){ return !_.contains(rest, value); });                         // 530
  };                                                                                                     // 531
                                                                                                         // 532
  // Zip together multiple lists into a single array -- elements that share                              // 533
  // an index go together.                                                                               // 534
  _.zip = function() {                                                                                   // 535
    var length = _.max(_.pluck(arguments, "length").concat(0));                                          // 536
    var results = new Array(length);                                                                     // 537
    for (var i = 0; i < length; i++) {                                                                   // 538
      results[i] = _.pluck(arguments, '' + i);                                                           // 539
    }                                                                                                    // 540
    return results;                                                                                      // 541
  };                                                                                                     // 542
                                                                                                         // 543
  // Converts lists into objects. Pass either a single array of `[key, value]`                           // 544
  // pairs, or two parallel arrays of the same length -- one of keys, and one of                         // 545
  // the corresponding values.                                                                           // 546
  _.object = function(list, values) {                                                                    // 547
    if (list == null) return {};                                                                         // 548
    var result = {};                                                                                     // 549
    for (var i = 0, length = list.length; i < length; i++) {                                             // 550
      if (values) {                                                                                      // 551
        result[list[i]] = values[i];                                                                     // 552
      } else {                                                                                           // 553
        result[list[i][0]] = list[i][1];                                                                 // 554
      }                                                                                                  // 555
    }                                                                                                    // 556
    return result;                                                                                       // 557
  };                                                                                                     // 558
                                                                                                         // 559
  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),                       // 560
  // we need this function. Return the position of the first occurrence of an                            // 561
  // item in an array, or -1 if the item is not included in the array.                                   // 562
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.                                      // 563
  // If the array is large and already in sort order, pass `true`                                        // 564
  // for **isSorted** to use binary search.                                                              // 565
  _.indexOf = function(array, item, isSorted) {                                                          // 566
    if (array == null) return -1;                                                                        // 567
    var i = 0, length = array.length;                                                                    // 568
    if (isSorted) {                                                                                      // 569
      if (typeof isSorted == 'number') {                                                                 // 570
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);                                  // 571
      } else {                                                                                           // 572
        i = _.sortedIndex(array, item);                                                                  // 573
        return array[i] === item ? i : -1;                                                               // 574
      }                                                                                                  // 575
    }                                                                                                    // 576
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);          // 577
    for (; i < length; i++) if (array[i] === item) return i;                                             // 578
    return -1;                                                                                           // 579
  };                                                                                                     // 580
                                                                                                         // 581
  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.                                  // 582
  _.lastIndexOf = function(array, item, from) {                                                          // 583
    if (array == null) return -1;                                                                        // 584
    var hasIndex = from != null;                                                                         // 585
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {                                  // 586
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);                         // 587
    }                                                                                                    // 588
    var i = (hasIndex ? from : array.length);                                                            // 589
    while (i--) if (array[i] === item) return i;                                                         // 590
    return -1;                                                                                           // 591
  };                                                                                                     // 592
                                                                                                         // 593
  // Generate an integer Array containing an arithmetic progression. A port of                           // 594
  // the native Python `range()` function. See                                                           // 595
  // [the Python documentation](http://docs.python.org/library/functions.html#range).                    // 596
  _.range = function(start, stop, step) {                                                                // 597
    if (arguments.length <= 1) {                                                                         // 598
      stop = start || 0;                                                                                 // 599
      start = 0;                                                                                         // 600
    }                                                                                                    // 601
    step = arguments[2] || 1;                                                                            // 602
                                                                                                         // 603
    var length = Math.max(Math.ceil((stop - start) / step), 0);                                          // 604
    var idx = 0;                                                                                         // 605
    var range = new Array(length);                                                                       // 606
                                                                                                         // 607
    while(idx < length) {                                                                                // 608
      range[idx++] = start;                                                                              // 609
      start += step;                                                                                     // 610
    }                                                                                                    // 611
                                                                                                         // 612
    return range;                                                                                        // 613
  };                                                                                                     // 614
                                                                                                         // 615
  // Function (ahem) Functions                                                                           // 616
  // ------------------                                                                                  // 617
                                                                                                         // 618
  // Reusable constructor function for prototype setting.                                                // 619
  var ctor = function(){};                                                                               // 620
                                                                                                         // 621
  // Create a function bound to a given object (assigning `this`, and arguments,                         // 622
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if                              // 623
  // available.                                                                                          // 624
  _.bind = function(func, context) {                                                                     // 625
    var args, bound;                                                                                     // 626
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1)); // 627
    if (!_.isFunction(func)) throw new TypeError;                                                        // 628
    args = slice.call(arguments, 2);                                                                     // 629
    return bound = function() {                                                                          // 630
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));      // 631
      ctor.prototype = func.prototype;                                                                   // 632
      var self = new ctor;                                                                               // 633
      ctor.prototype = null;                                                                             // 634
      var result = func.apply(self, args.concat(slice.call(arguments)));                                 // 635
      if (Object(result) === result) return result;                                                      // 636
      return self;                                                                                       // 637
    };                                                                                                   // 638
  };                                                                                                     // 639
                                                                                                         // 640
  // Partially apply a function by creating a version that has had some of its                           // 641
  // arguments pre-filled, without changing its dynamic `this` context.                                  // 642
  _.partial = function(func) {                                                                           // 643
    var args = slice.call(arguments, 1);                                                                 // 644
    return function() {                                                                                  // 645
      return func.apply(this, args.concat(slice.call(arguments)));                                       // 646
    };                                                                                                   // 647
  };                                                                                                     // 648
                                                                                                         // 649
  // Bind all of an object's methods to that object. Useful for ensuring that                            // 650
  // all callbacks defined on an object belong to it.                                                    // 651
  _.bindAll = function(obj) {                                                                            // 652
    var funcs = slice.call(arguments, 1);                                                                // 653
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");                    // 654
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });                                          // 655
    return obj;                                                                                          // 656
  };                                                                                                     // 657
                                                                                                         // 658
  // Memoize an expensive function by storing its results.                                               // 659
  _.memoize = function(func, hasher) {                                                                   // 660
    var memo = {};                                                                                       // 661
    hasher || (hasher = _.identity);                                                                     // 662
    return function() {                                                                                  // 663
      var key = hasher.apply(this, arguments);                                                           // 664
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));                   // 665
    };                                                                                                   // 666
  };                                                                                                     // 667
                                                                                                         // 668
  // Delays a function for the given number of milliseconds, and then calls                              // 669
  // it with the arguments supplied.                                                                     // 670
  _.delay = function(func, wait) {                                                                       // 671
    var args = slice.call(arguments, 2);                                                                 // 672
    return setTimeout(function(){ return func.apply(null, args); }, wait);                               // 673
  };                                                                                                     // 674
                                                                                                         // 675
  // Defers a function, scheduling it to run after the current call stack has                            // 676
  // cleared.                                                                                            // 677
  _.defer = function(func) {                                                                             // 678
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));                                 // 679
  };                                                                                                     // 680
                                                                                                         // 681
  // Returns a function, that, when invoked, will only be triggered at most once                         // 682
  // during a given window of time. Normally, the throttled function will run                            // 683
  // as much as it can, without ever going more than once per `wait` duration;                           // 684
  // but if you'd like to disable the execution on the leading edge, pass                                // 685
  // `{leading: false}`. To disable execution on the trailing edge, ditto.                               // 686
  _.throttle = function(func, wait, options) {                                                           // 687
    var context, args, result;                                                                           // 688
    var timeout = null;                                                                                  // 689
    var previous = 0;                                                                                    // 690
    options || (options = {});                                                                           // 691
    var later = function() {                                                                             // 692
      previous = options.leading === false ? 0 : new Date;                                               // 693
      timeout = null;                                                                                    // 694
      result = func.apply(context, args);                                                                // 695
    };                                                                                                   // 696
    return function() {                                                                                  // 697
      var now = new Date;                                                                                // 698
      if (!previous && options.leading === false) previous = now;                                        // 699
      var remaining = wait - (now - previous);                                                           // 700
      context = this;                                                                                    // 701
      args = arguments;                                                                                  // 702
      if (remaining <= 0) {                                                                              // 703
        clearTimeout(timeout);                                                                           // 704
        timeout = null;                                                                                  // 705
        previous = now;                                                                                  // 706
        result = func.apply(context, args);                                                              // 707
      } else if (!timeout && options.trailing !== false) {                                               // 708
        timeout = setTimeout(later, remaining);                                                          // 709
      }                                                                                                  // 710
      return result;                                                                                     // 711
    };                                                                                                   // 712
  };                                                                                                     // 713
                                                                                                         // 714
  // Returns a function, that, as long as it continues to be invoked, will not                           // 715
  // be triggered. The function will be called after it stops being called for                           // 716
  // N milliseconds. If `immediate` is passed, trigger the function on the                               // 717
  // leading edge, instead of the trailing.                                                              // 718
  _.debounce = function(func, wait, immediate) {                                                         // 719
    var timeout, args, context, timestamp, result;                                                       // 720
    return function() {                                                                                  // 721
      context = this;                                                                                    // 722
      args = arguments;                                                                                  // 723
      timestamp = new Date();                                                                            // 724
      var later = function() {                                                                           // 725
        var last = (new Date()) - timestamp;                                                             // 726
        if (last < wait) {                                                                               // 727
          timeout = setTimeout(later, wait - last);                                                      // 728
        } else {                                                                                         // 729
          timeout = null;                                                                                // 730
          if (!immediate) result = func.apply(context, args);                                            // 731
        }                                                                                                // 732
      };                                                                                                 // 733
      var callNow = immediate && !timeout;                                                               // 734
      if (!timeout) {                                                                                    // 735
        timeout = setTimeout(later, wait);                                                               // 736
      }                                                                                                  // 737
      if (callNow) result = func.apply(context, args);                                                   // 738
      return result;                                                                                     // 739
    };                                                                                                   // 740
  };                                                                                                     // 741
                                                                                                         // 742
  // Returns a function that will be executed at most one time, no matter how                            // 743
  // often you call it. Useful for lazy initialization.                                                  // 744
  _.once = function(func) {                                                                              // 745
    var ran = false, memo;                                                                               // 746
    return function() {                                                                                  // 747
      if (ran) return memo;                                                                              // 748
      ran = true;                                                                                        // 749
      memo = func.apply(this, arguments);                                                                // 750
      func = null;                                                                                       // 751
      return memo;                                                                                       // 752
    };                                                                                                   // 753
  };                                                                                                     // 754
                                                                                                         // 755
  // Returns the first function passed as an argument to the second,                                     // 756
  // allowing you to adjust arguments, run code before and after, and                                    // 757
  // conditionally execute the original function.                                                        // 758
  _.wrap = function(func, wrapper) {                                                                     // 759
    return function() {                                                                                  // 760
      var args = [func];                                                                                 // 761
      push.apply(args, arguments);                                                                       // 762
      return wrapper.apply(this, args);                                                                  // 763
    };                                                                                                   // 764
  };                                                                                                     // 765
                                                                                                         // 766
  // Returns a function that is the composition of a list of functions, each                             // 767
  // consuming the return value of the function that follows.                                            // 768
  _.compose = function() {                                                                               // 769
    var funcs = arguments;                                                                               // 770
    return function() {                                                                                  // 771
      var args = arguments;                                                                              // 772
      for (var i = funcs.length - 1; i >= 0; i--) {                                                      // 773
        args = [funcs[i].apply(this, args)];                                                             // 774
      }                                                                                                  // 775
      return args[0];                                                                                    // 776
    };                                                                                                   // 777
  };                                                                                                     // 778
                                                                                                         // 779
  // Returns a function that will only be executed after being called N times.                           // 780
  _.after = function(times, func) {                                                                      // 781
    return function() {                                                                                  // 782
      if (--times < 1) {                                                                                 // 783
        return func.apply(this, arguments);                                                              // 784
      }                                                                                                  // 785
    };                                                                                                   // 786
  };                                                                                                     // 787
                                                                                                         // 788
  // Object Functions                                                                                    // 789
  // ----------------                                                                                    // 790
                                                                                                         // 791
  // Retrieve the names of an object's properties.                                                       // 792
  // Delegates to **ECMAScript 5**'s native `Object.keys`                                                // 793
  _.keys = nativeKeys || function(obj) {                                                                 // 794
    if (obj !== Object(obj)) throw new TypeError('Invalid object');                                      // 795
    var keys = [];                                                                                       // 796
    for (var key in obj) if (_.has(obj, key)) keys.push(key);                                            // 797
    return keys;                                                                                         // 798
  };                                                                                                     // 799
                                                                                                         // 800
  // Retrieve the values of an object's properties.                                                      // 801
  _.values = function(obj) {                                                                             // 802
    var keys = _.keys(obj);                                                                              // 803
    var length = keys.length;                                                                            // 804
    var values = new Array(length);                                                                      // 805
    for (var i = 0; i < length; i++) {                                                                   // 806
      values[i] = obj[keys[i]];                                                                          // 807
    }                                                                                                    // 808
    return values;                                                                                       // 809
  };                                                                                                     // 810
                                                                                                         // 811
  // Convert an object into a list of `[key, value]` pairs.                                              // 812
  _.pairs = function(obj) {                                                                              // 813
    var keys = _.keys(obj);                                                                              // 814
    var length = keys.length;                                                                            // 815
    var pairs = new Array(length);                                                                       // 816
    for (var i = 0; i < length; i++) {                                                                   // 817
      pairs[i] = [keys[i], obj[keys[i]]];                                                                // 818
    }                                                                                                    // 819
    return pairs;                                                                                        // 820
  };                                                                                                     // 821
                                                                                                         // 822
  // Invert the keys and values of an object. The values must be serializable.                           // 823
  _.invert = function(obj) {                                                                             // 824
    var result = {};                                                                                     // 825
    var keys = _.keys(obj);                                                                              // 826
    for (var i = 0, length = keys.length; i < length; i++) {                                             // 827
      result[obj[keys[i]]] = keys[i];                                                                    // 828
    }                                                                                                    // 829
    return result;                                                                                       // 830
  };                                                                                                     // 831
                                                                                                         // 832
  // Return a sorted list of the function names available on the object.                                 // 833
  // Aliased as `methods`                                                                                // 834
  _.functions = _.methods = function(obj) {                                                              // 835
    var names = [];                                                                                      // 836
    for (var key in obj) {                                                                               // 837
      if (_.isFunction(obj[key])) names.push(key);                                                       // 838
    }                                                                                                    // 839
    return names.sort();                                                                                 // 840
  };                                                                                                     // 841
                                                                                                         // 842
  // Extend a given object with all the properties in passed-in object(s).                               // 843
  _.extend = function(obj) {                                                                             // 844
    each(slice.call(arguments, 1), function(source) {                                                    // 845
      if (source) {                                                                                      // 846
        for (var prop in source) {                                                                       // 847
          obj[prop] = source[prop];                                                                      // 848
        }                                                                                                // 849
      }                                                                                                  // 850
    });                                                                                                  // 851
    return obj;                                                                                          // 852
  };                                                                                                     // 853
                                                                                                         // 854
  // Return a copy of the object only containing the whitelisted properties.                             // 855
  _.pick = function(obj) {                                                                               // 856
    var copy = {};                                                                                       // 857
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));                                       // 858
    each(keys, function(key) {                                                                           // 859
      if (key in obj) copy[key] = obj[key];                                                              // 860
    });                                                                                                  // 861
    return copy;                                                                                         // 862
  };                                                                                                     // 863
                                                                                                         // 864
   // Return a copy of the object without the blacklisted properties.                                    // 865
  _.omit = function(obj) {                                                                               // 866
    var copy = {};                                                                                       // 867
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));                                       // 868
    for (var key in obj) {                                                                               // 869
      if (!_.contains(keys, key)) copy[key] = obj[key];                                                  // 870
    }                                                                                                    // 871
    return copy;                                                                                         // 872
  };                                                                                                     // 873
                                                                                                         // 874
  // Fill in a given object with default properties.                                                     // 875
  _.defaults = function(obj) {                                                                           // 876
    each(slice.call(arguments, 1), function(source) {                                                    // 877
      if (source) {                                                                                      // 878
        for (var prop in source) {                                                                       // 879
          if (obj[prop] === void 0) obj[prop] = source[prop];                                            // 880
        }                                                                                                // 881
      }                                                                                                  // 882
    });                                                                                                  // 883
    return obj;                                                                                          // 884
  };                                                                                                     // 885
                                                                                                         // 886
  // Create a (shallow-cloned) duplicate of an object.                                                   // 887
  _.clone = function(obj) {                                                                              // 888
    if (!_.isObject(obj)) return obj;                                                                    // 889
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);                                             // 890
  };                                                                                                     // 891
                                                                                                         // 892
  // Invokes interceptor with the obj, and then returns obj.                                             // 893
  // The primary purpose of this method is to "tap into" a method chain, in                              // 894
  // order to perform operations on intermediate results within the chain.                               // 895
  _.tap = function(obj, interceptor) {                                                                   // 896
    interceptor(obj);                                                                                    // 897
    return obj;                                                                                          // 898
  };                                                                                                     // 899
                                                                                                         // 900
  // Internal recursive comparison function for `isEqual`.                                               // 901
  var eq = function(a, b, aStack, bStack) {                                                              // 902
    // Identical objects are equal. `0 === -0`, but they aren't identical.                               // 903
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).           // 904
    if (a === b) return a !== 0 || 1 / a == 1 / b;                                                       // 905
    // A strict comparison is necessary because `null == undefined`.                                     // 906
    if (a == null || b == null) return a === b;                                                          // 907
    // Unwrap any wrapped objects.                                                                       // 908
    if (a instanceof _) a = a._wrapped;                                                                  // 909
    if (b instanceof _) b = b._wrapped;                                                                  // 910
    // Compare `[[Class]]` names.                                                                        // 911
    var className = toString.call(a);                                                                    // 912
    if (className != toString.call(b)) return false;                                                     // 913
    switch (className) {                                                                                 // 914
      // Strings, numbers, dates, and booleans are compared by value.                                    // 915
      case '[object String]':                                                                            // 916
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is             // 917
        // equivalent to `new String("5")`.                                                              // 918
        return a == String(b);                                                                           // 919
      case '[object Number]':                                                                            // 920
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for               // 921
        // other numeric values.                                                                         // 922
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);                                  // 923
      case '[object Date]':                                                                              // 924
      case '[object Boolean]':                                                                           // 925
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their            // 926
        // millisecond representations. Note that invalid dates with millisecond representations         // 927
        // of `NaN` are not equivalent.                                                                  // 928
        return +a == +b;                                                                                 // 929
      // RegExps are compared by their source patterns and flags.                                        // 930
      case '[object RegExp]':                                                                            // 931
        return a.source == b.source &&                                                                   // 932
               a.global == b.global &&                                                                   // 933
               a.multiline == b.multiline &&                                                             // 934
               a.ignoreCase == b.ignoreCase;                                                             // 935
    }                                                                                                    // 936
    if (typeof a != 'object' || typeof b != 'object') return false;                                      // 937
    // Assume equality for cyclic structures. The algorithm for detecting cyclic                         // 938
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.                       // 939
    var length = aStack.length;                                                                          // 940
    while (length--) {                                                                                   // 941
      // Linear search. Performance is inversely proportional to the number of                           // 942
      // unique nested structures.                                                                       // 943
      if (aStack[length] == a) return bStack[length] == b;                                               // 944
    }                                                                                                    // 945
    // Objects with different constructors are not equivalent, but `Object`s                             // 946
    // from different frames are.                                                                        // 947
    var aCtor = a.constructor, bCtor = b.constructor;                                                    // 948
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&                          // 949
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {                         // 950
      return false;                                                                                      // 951
    }                                                                                                    // 952
    // Add the first object to the stack of traversed objects.                                           // 953
    aStack.push(a);                                                                                      // 954
    bStack.push(b);                                                                                      // 955
    var size = 0, result = true;                                                                         // 956
    // Recursively compare objects and arrays.                                                           // 957
    if (className == '[object Array]') {                                                                 // 958
      // Compare array lengths to determine if a deep comparison is necessary.                           // 959
      size = a.length;                                                                                   // 960
      result = size == b.length;                                                                         // 961
      if (result) {                                                                                      // 962
        // Deep compare the contents, ignoring non-numeric properties.                                   // 963
        while (size--) {                                                                                 // 964
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;                                   // 965
        }                                                                                                // 966
      }                                                                                                  // 967
    } else {                                                                                             // 968
      // Deep compare objects.                                                                           // 969
      for (var key in a) {                                                                               // 970
        if (_.has(a, key)) {                                                                             // 971
          // Count the expected number of properties.                                                    // 972
          size++;                                                                                        // 973
          // Deep compare each member.                                                                   // 974
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;                    // 975
        }                                                                                                // 976
      }                                                                                                  // 977
      // Ensure that both objects contain the same number of properties.                                 // 978
      if (result) {                                                                                      // 979
        for (key in b) {                                                                                 // 980
          if (_.has(b, key) && !(size--)) break;                                                         // 981
        }                                                                                                // 982
        result = !size;                                                                                  // 983
      }                                                                                                  // 984
    }                                                                                                    // 985
    // Remove the first object from the stack of traversed objects.                                      // 986
    aStack.pop();                                                                                        // 987
    bStack.pop();                                                                                        // 988
    return result;                                                                                       // 989
  };                                                                                                     // 990
                                                                                                         // 991
  // Perform a deep comparison to check if two objects are equal.                                        // 992
  _.isEqual = function(a, b) {                                                                           // 993
    return eq(a, b, [], []);                                                                             // 994
  };                                                                                                     // 995
                                                                                                         // 996
  // Is a given array, string, or object empty?                                                          // 997
  // An "empty" object has no enumerable own-properties.                                                 // 998
  _.isEmpty = function(obj) {                                                                            // 999
    if (obj == null) return true;                                                                        // 1000
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;                                      // 1001
    for (var key in obj) if (_.has(obj, key)) return false;                                              // 1002
    return true;                                                                                         // 1003
  };                                                                                                     // 1004
                                                                                                         // 1005
  // Is a given value a DOM element?                                                                     // 1006
  _.isElement = function(obj) {                                                                          // 1007
    return !!(obj && obj.nodeType === 1);                                                                // 1008
  };                                                                                                     // 1009
                                                                                                         // 1010
  // Is a given value an array?                                                                          // 1011
  // Delegates to ECMA5's native Array.isArray                                                           // 1012
  _.isArray = nativeIsArray || function(obj) {                                                           // 1013
    return toString.call(obj) == '[object Array]';                                                       // 1014
  };                                                                                                     // 1015
                                                                                                         // 1016
  // Is a given variable an object?                                                                      // 1017
  _.isObject = function(obj) {                                                                           // 1018
    return obj === Object(obj);                                                                          // 1019
  };                                                                                                     // 1020
                                                                                                         // 1021
  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.             // 1022
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {                 // 1023
    _['is' + name] = function(obj) {                                                                     // 1024
      return toString.call(obj) == '[object ' + name + ']';                                              // 1025
    };                                                                                                   // 1026
  });                                                                                                    // 1027
                                                                                                         // 1028
  // Define a fallback version of the method in browsers (ahem, IE), where                               // 1029
  // there isn't any inspectable "Arguments" type.                                                       // 1030
  if (!_.isArguments(arguments)) {                                                                       // 1031
    _.isArguments = function(obj) {                                                                      // 1032
      return !!(obj && _.has(obj, 'callee'));                                                            // 1033
    };                                                                                                   // 1034
  }                                                                                                      // 1035
                                                                                                         // 1036
  // Optimize `isFunction` if appropriate.                                                               // 1037
  if (typeof (/./) !== 'function') {                                                                     // 1038
    _.isFunction = function(obj) {                                                                       // 1039
      return typeof obj === 'function';                                                                  // 1040
    };                                                                                                   // 1041
  }                                                                                                      // 1042
                                                                                                         // 1043
  // Is a given object a finite number?                                                                  // 1044
  _.isFinite = function(obj) {                                                                           // 1045
    return isFinite(obj) && !isNaN(parseFloat(obj));                                                     // 1046
  };                                                                                                     // 1047
                                                                                                         // 1048
  // Is the given value `NaN`? (NaN is the only number which does not equal itself).                     // 1049
  _.isNaN = function(obj) {                                                                              // 1050
    return _.isNumber(obj) && obj != +obj;                                                               // 1051
  };                                                                                                     // 1052
                                                                                                         // 1053
  // Is a given value a boolean?                                                                         // 1054
  _.isBoolean = function(obj) {                                                                          // 1055
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';                    // 1056
  };                                                                                                     // 1057
                                                                                                         // 1058
  // Is a given value equal to null?                                                                     // 1059
  _.isNull = function(obj) {                                                                             // 1060
    return obj === null;                                                                                 // 1061
  };                                                                                                     // 1062
                                                                                                         // 1063
  // Is a given variable undefined?                                                                      // 1064
  _.isUndefined = function(obj) {                                                                        // 1065
    return obj === void 0;                                                                               // 1066
  };                                                                                                     // 1067
                                                                                                         // 1068
  // Shortcut function for checking if an object has a given property directly                           // 1069
  // on itself (in other words, not on a prototype).                                                     // 1070
  _.has = function(obj, key) {                                                                           // 1071
    return hasOwnProperty.call(obj, key);                                                                // 1072
  };                                                                                                     // 1073
                                                                                                         // 1074
  // Utility Functions                                                                                   // 1075
  // -----------------                                                                                   // 1076
                                                                                                         // 1077
  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its                           // 1078
  // previous owner. Returns a reference to the Underscore object.                                       // 1079
  _.noConflict = function() {                                                                            // 1080
    root._ = previousUnderscore;                                                                         // 1081
    return this;                                                                                         // 1082
  };                                                                                                     // 1083
                                                                                                         // 1084
  // Keep the identity function around for default iterators.                                            // 1085
  _.identity = function(value) {                                                                         // 1086
    return value;                                                                                        // 1087
  };                                                                                                     // 1088
                                                                                                         // 1089
  // Run a function **n** times.                                                                         // 1090
  _.times = function(n, iterator, context) {                                                             // 1091
    var accum = Array(Math.max(0, n));                                                                   // 1092
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);                                    // 1093
    return accum;                                                                                        // 1094
  };                                                                                                     // 1095
                                                                                                         // 1096
  // Return a random integer between min and max (inclusive).                                            // 1097
  _.random = function(min, max) {                                                                        // 1098
    if (max == null) {                                                                                   // 1099
      max = min;                                                                                         // 1100
      min = 0;                                                                                           // 1101
    }                                                                                                    // 1102
    return min + Math.floor(Math.random() * (max - min + 1));                                            // 1103
  };                                                                                                     // 1104
                                                                                                         // 1105
  // List of HTML entities for escaping.                                                                 // 1106
  var entityMap = {                                                                                      // 1107
    escape: {                                                                                            // 1108
      '&': '&amp;',                                                                                      // 1109
      '<': '&lt;',                                                                                       // 1110
      '>': '&gt;',                                                                                       // 1111
      '"': '&quot;',                                                                                     // 1112
      "'": '&#x27;'                                                                                      // 1113
    }                                                                                                    // 1114
  };                                                                                                     // 1115
  entityMap.unescape = _.invert(entityMap.escape);                                                       // 1116
                                                                                                         // 1117
  // Regexes containing the keys and values listed immediately above.                                    // 1118
  var entityRegexes = {                                                                                  // 1119
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),                            // 1120
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')                          // 1121
  };                                                                                                     // 1122
                                                                                                         // 1123
  // Functions for escaping and unescaping strings to/from HTML interpolation.                           // 1124
  _.each(['escape', 'unescape'], function(method) {                                                      // 1125
    _[method] = function(string) {                                                                       // 1126
      if (string == null) return '';                                                                     // 1127
      return ('' + string).replace(entityRegexes[method], function(match) {                              // 1128
        return entityMap[method][match];                                                                 // 1129
      });                                                                                                // 1130
    };                                                                                                   // 1131
  });                                                                                                    // 1132
                                                                                                         // 1133
  // If the value of the named `property` is a function then invoke it with the                          // 1134
  // `object` as context; otherwise, return it.                                                          // 1135
  _.result = function(object, property) {                                                                // 1136
    if (object == null) return void 0;                                                                   // 1137
    var value = object[property];                                                                        // 1138
    return _.isFunction(value) ? value.call(object) : value;                                             // 1139
  };                                                                                                     // 1140
                                                                                                         // 1141
  // Add your own custom functions to the Underscore object.                                             // 1142
  _.mixin = function(obj) {                                                                              // 1143
    each(_.functions(obj), function(name) {                                                              // 1144
      var func = _[name] = obj[name];                                                                    // 1145
      _.prototype[name] = function() {                                                                   // 1146
        var args = [this._wrapped];                                                                      // 1147
        push.apply(args, arguments);                                                                     // 1148
        return result.call(this, func.apply(_, args));                                                   // 1149
      };                                                                                                 // 1150
    });                                                                                                  // 1151
  };                                                                                                     // 1152
                                                                                                         // 1153
  // Generate a unique integer id (unique within the entire client session).                             // 1154
  // Useful for temporary DOM ids.                                                                       // 1155
  var idCounter = 0;                                                                                     // 1156
  _.uniqueId = function(prefix) {                                                                        // 1157
    var id = ++idCounter + '';                                                                           // 1158
    return prefix ? prefix + id : id;                                                                    // 1159
  };                                                                                                     // 1160
                                                                                                         // 1161
  // By default, Underscore uses ERB-style template delimiters, change the                               // 1162
  // following template settings to use alternative delimiters.                                          // 1163
  _.templateSettings = {                                                                                 // 1164
    evaluate    : /<%([\s\S]+?)%>/g,                                                                     // 1165
    interpolate : /<%=([\s\S]+?)%>/g,                                                                    // 1166
    escape      : /<%-([\s\S]+?)%>/g                                                                     // 1167
  };                                                                                                     // 1168
                                                                                                         // 1169
  // When customizing `templateSettings`, if you don't want to define an                                 // 1170
  // interpolation, evaluation or escaping regex, we need one that is                                    // 1171
  // guaranteed not to match.                                                                            // 1172
  var noMatch = /(.)^/;                                                                                  // 1173
                                                                                                         // 1174
  // Certain characters need to be escaped so that they can be put into a                                // 1175
  // string literal.                                                                                     // 1176
  var escapes = {                                                                                        // 1177
    "'":      "'",                                                                                       // 1178
    '\\':     '\\',                                                                                      // 1179
    '\r':     'r',                                                                                       // 1180
    '\n':     'n',                                                                                       // 1181
    '\t':     't',                                                                                       // 1182
    '\u2028': 'u2028',                                                                                   // 1183
    '\u2029': 'u2029'                                                                                    // 1184
  };                                                                                                     // 1185
                                                                                                         // 1186
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;                                                          // 1187
                                                                                                         // 1188
  // JavaScript micro-templating, similar to John Resig's implementation.                                // 1189
  // Underscore templating handles arbitrary delimiters, preserves whitespace,                           // 1190
  // and correctly escapes quotes within interpolated code.                                              // 1191
  _.template = function(text, data, settings) {                                                          // 1192
    var render;                                                                                          // 1193
    settings = _.defaults({}, settings, _.templateSettings);                                             // 1194
                                                                                                         // 1195
    // Combine delimiters into one regular expression via alternation.                                   // 1196
    var matcher = new RegExp([                                                                           // 1197
      (settings.escape || noMatch).source,                                                               // 1198
      (settings.interpolate || noMatch).source,                                                          // 1199
      (settings.evaluate || noMatch).source                                                              // 1200
    ].join('|') + '|$', 'g');                                                                            // 1201
                                                                                                         // 1202
    // Compile the template source, escaping string literals appropriately.                              // 1203
    var index = 0;                                                                                       // 1204
    var source = "__p+='";                                                                               // 1205
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {                       // 1206
      source += text.slice(index, offset)                                                                // 1207
        .replace(escaper, function(match) { return '\\' + escapes[match]; });                            // 1208
                                                                                                         // 1209
      if (escape) {                                                                                      // 1210
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";                             // 1211
      }                                                                                                  // 1212
      if (interpolate) {                                                                                 // 1213
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";                                  // 1214
      }                                                                                                  // 1215
      if (evaluate) {                                                                                    // 1216
        source += "';\n" + evaluate + "\n__p+='";                                                        // 1217
      }                                                                                                  // 1218
      index = offset + match.length;                                                                     // 1219
      return match;                                                                                      // 1220
    });                                                                                                  // 1221
    source += "';\n";                                                                                    // 1222
                                                                                                         // 1223
    // If a variable is not specified, place data values in local scope.                                 // 1224
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';                                // 1225
                                                                                                         // 1226
    source = "var __t,__p='',__j=Array.prototype.join," +                                                // 1227
      "print=function(){__p+=__j.call(arguments,'');};\n" +                                              // 1228
      source + "return __p;\n";                                                                          // 1229
                                                                                                         // 1230
    try {                                                                                                // 1231
      render = new Function(settings.variable || 'obj', '_', source);                                    // 1232
    } catch (e) {                                                                                        // 1233
      e.source = source;                                                                                 // 1234
      throw e;                                                                                           // 1235
    }                                                                                                    // 1236
                                                                                                         // 1237
    if (data) return render(data, _);                                                                    // 1238
    var template = function(data) {                                                                      // 1239
      return render.call(this, data, _);                                                                 // 1240
    };                                                                                                   // 1241
                                                                                                         // 1242
    // Provide the compiled function source as a convenience for precompilation.                         // 1243
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';                // 1244
                                                                                                         // 1245
    return template;                                                                                     // 1246
  };                                                                                                     // 1247
                                                                                                         // 1248
  // Add a "chain" function, which will delegate to the wrapper.                                         // 1249
  _.chain = function(obj) {                                                                              // 1250
    return _(obj).chain();                                                                               // 1251
  };                                                                                                     // 1252
                                                                                                         // 1253
  // OOP                                                                                                 // 1254
  // ---------------                                                                                     // 1255
  // If Underscore is called as a function, it returns a wrapped object that                             // 1256
  // can be used OO-style. This wrapper holds altered versions of all the                                // 1257
  // underscore functions. Wrapped objects may be chained.                                               // 1258
                                                                                                         // 1259
  // Helper function to continue chaining intermediate results.                                          // 1260
  var result = function(obj) {                                                                           // 1261
    return this._chain ? _(obj).chain() : obj;                                                           // 1262
  };                                                                                                     // 1263
                                                                                                         // 1264
  // Add all of the Underscore functions to the wrapper object.                                          // 1265
  _.mixin(_);                                                                                            // 1266
                                                                                                         // 1267
  // Add all mutator Array functions to the wrapper.                                                     // 1268
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {                // 1269
    var method = ArrayProto[name];                                                                       // 1270
    _.prototype[name] = function() {                                                                     // 1271
      var obj = this._wrapped;                                                                           // 1272
      method.apply(obj, arguments);                                                                      // 1273
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];                      // 1274
      return result.call(this, obj);                                                                     // 1275
    };                                                                                                   // 1276
  });                                                                                                    // 1277
                                                                                                         // 1278
  // Add all accessor Array functions to the wrapper.                                                    // 1279
  each(['concat', 'join', 'slice'], function(name) {                                                     // 1280
    var method = ArrayProto[name];                                                                       // 1281
    _.prototype[name] = function() {                                                                     // 1282
      return result.call(this, method.apply(this._wrapped, arguments));                                  // 1283
    };                                                                                                   // 1284
  });                                                                                                    // 1285
                                                                                                         // 1286
  _.extend(_.prototype, {                                                                                // 1287
                                                                                                         // 1288
    // Start chaining a wrapped Underscore object.                                                       // 1289
    chain: function() {                                                                                  // 1290
      this._chain = true;                                                                                // 1291
      return this;                                                                                       // 1292
    },                                                                                                   // 1293
                                                                                                         // 1294
    // Extracts the result from a wrapped and chained object.                                            // 1295
    value: function() {                                                                                  // 1296
      return this._wrapped;                                                                              // 1297
    }                                                                                                    // 1298
                                                                                                         // 1299
  });                                                                                                    // 1300
                                                                                                         // 1301
}).call(this);                                                                                           // 1302
                                                                                                         // 1303
///////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                       //
// packages/underscore/post.js                                                                           //
//                                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                         //
// This exports object was created in pre.js.  Now copy the `_` object from it                           // 1
// into the package-scope variable `_`, which will get exported.                                         // 2
_ = exports._;                                                                                           // 3
                                                                                                         // 4
///////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.underscore = {
  _: _
};

})();

//# sourceMappingURL=0a80a8623e1b40b5df5a05582f288ddd586eaa18.map


//--------- meteor.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var _ = Package.underscore._;

/* Package-scope variables */
var Meteor;

(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/client_environment.js                                                            //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
Meteor = {                                                                                          // 1
  isClient: true,                                                                                   // 2
  isServer: false                                                                                   // 3
};                                                                                                  // 4
                                                                                                    // 5
if (typeof __meteor_runtime_config__ === 'object' &&                                                // 6
    __meteor_runtime_config__.PUBLIC_SETTINGS) {                                                    // 7
  Meteor.settings = { 'public': __meteor_runtime_config__.PUBLIC_SETTINGS };                        // 8
}                                                                                                   // 9
                                                                                                    // 10
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/helpers.js                                                                       //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
if (Meteor.isServer)                                                                                // 1
  var Future = Npm.require('fibers/future');                                                        // 2
                                                                                                    // 3
if (typeof __meteor_runtime_config__ === 'object' &&                                                // 4
    __meteor_runtime_config__.meteorRelease)                                                        // 5
  Meteor.release = __meteor_runtime_config__.meteorRelease;                                         // 6
                                                                                                    // 7
// XXX find a better home for these? Ideally they would be _.get,                                   // 8
// _.ensure, _.delete..                                                                             // 9
                                                                                                    // 10
_.extend(Meteor, {                                                                                  // 11
  // _get(a,b,c,d) returns a[b][c][d], or else undefined if a[b] or                                 // 12
  // a[b][c] doesn't exist.                                                                         // 13
  //                                                                                                // 14
  _get: function (obj /*, arguments */) {                                                           // 15
    for (var i = 1; i < arguments.length; i++) {                                                    // 16
      if (!(arguments[i] in obj))                                                                   // 17
        return undefined;                                                                           // 18
      obj = obj[arguments[i]];                                                                      // 19
    }                                                                                               // 20
    return obj;                                                                                     // 21
  },                                                                                                // 22
                                                                                                    // 23
  // _ensure(a,b,c,d) ensures that a[b][c][d] exists. If it does not,                               // 24
  // it is created and set to {}. Either way, it is returned.                                       // 25
  //                                                                                                // 26
  _ensure: function (obj /*, arguments */) {                                                        // 27
    for (var i = 1; i < arguments.length; i++) {                                                    // 28
      var key = arguments[i];                                                                       // 29
      if (!(key in obj))                                                                            // 30
        obj[key] = {};                                                                              // 31
      obj = obj[key];                                                                               // 32
    }                                                                                               // 33
                                                                                                    // 34
    return obj;                                                                                     // 35
  },                                                                                                // 36
                                                                                                    // 37
  // _delete(a, b, c, d) deletes a[b][c][d], then a[b][c] unless it                                 // 38
  // isn't empty, then a[b] unless it isn't empty.                                                  // 39
  //                                                                                                // 40
  _delete: function (obj /*, arguments */) {                                                        // 41
    var stack = [obj];                                                                              // 42
    var leaf = true;                                                                                // 43
    for (var i = 1; i < arguments.length - 1; i++) {                                                // 44
      var key = arguments[i];                                                                       // 45
      if (!(key in obj)) {                                                                          // 46
        leaf = false;                                                                               // 47
        break;                                                                                      // 48
      }                                                                                             // 49
      obj = obj[key];                                                                               // 50
      if (typeof obj !== "object")                                                                  // 51
        break;                                                                                      // 52
      stack.push(obj);                                                                              // 53
    }                                                                                               // 54
                                                                                                    // 55
    for (var i = stack.length - 1; i >= 0; i--) {                                                   // 56
      var key = arguments[i+1];                                                                     // 57
                                                                                                    // 58
      if (leaf)                                                                                     // 59
        leaf = false;                                                                               // 60
      else                                                                                          // 61
        for (var other in stack[i][key])                                                            // 62
          return; // not empty -- we're done                                                        // 63
                                                                                                    // 64
      delete stack[i][key];                                                                         // 65
    }                                                                                               // 66
  },                                                                                                // 67
                                                                                                    // 68
  // _wrapAsync can wrap any function that takes some number of arguments that                      // 69
  // can't be undefined, followed by some optional arguments, where the callback                    // 70
  // is the last optional argument.                                                                 // 71
  // e.g. fs.readFile(pathname, [callback]),                                                        // 72
  // fs.open(pathname, flags, [mode], [callback])                                                   // 73
  // For maximum effectiveness and least confusion, wrapAsync should be used on                     // 74
  // functions where the callback is the only argument of type Function.                            // 75
  //                                                                                                // 76
  _wrapAsync: function (fn) {                                                                       // 77
    return function (/* arguments */) {                                                             // 78
      var self = this;                                                                              // 79
      var callback;                                                                                 // 80
      var fut;                                                                                      // 81
      var newArgs = _.toArray(arguments);                                                           // 82
                                                                                                    // 83
      var logErr = function (err) {                                                                 // 84
        if (err)                                                                                    // 85
          return Meteor._debug("Exception in callback of async function",                           // 86
                               err.stack ? err.stack : err);                                        // 87
      };                                                                                            // 88
                                                                                                    // 89
      // Pop off optional args that are undefined                                                   // 90
      while (newArgs.length > 0 &&                                                                  // 91
             typeof(newArgs[newArgs.length - 1]) === "undefined") {                                 // 92
        newArgs.pop();                                                                              // 93
      }                                                                                             // 94
      // If we have any left and the last one is a function, then that's our                        // 95
      // callback; otherwise, we don't have one.                                                    // 96
      if (newArgs.length > 0 &&                                                                     // 97
          newArgs[newArgs.length - 1] instanceof Function) {                                        // 98
        callback = newArgs.pop();                                                                   // 99
      } else {                                                                                      // 100
        if (Meteor.isClient) {                                                                      // 101
          callback = logErr;                                                                        // 102
        } else {                                                                                    // 103
          fut = new Future();                                                                       // 104
          callback = fut.resolver();                                                                // 105
        }                                                                                           // 106
      }                                                                                             // 107
      newArgs.push(Meteor.bindEnvironment(callback));                                               // 108
      var result = fn.apply(self, newArgs);                                                         // 109
      if (fut)                                                                                      // 110
        return fut.wait();                                                                          // 111
      return result;                                                                                // 112
    };                                                                                              // 113
  }                                                                                                 // 114
});                                                                                                 // 115
                                                                                                    // 116
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/setimmediate.js                                                                  //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
// Chooses one of three setImmediate implementations:                                               // 1
//                                                                                                  // 2
// * Native setImmediate (IE 10, Node 0.9+)                                                         // 3
//                                                                                                  // 4
// * postMessage (many browsers)                                                                    // 5
//                                                                                                  // 6
// * setTimeout  (fallback)                                                                         // 7
//                                                                                                  // 8
// The postMessage implementation is based on                                                       // 9
// https://github.com/NobleJS/setImmediate/tree/1.0.1                                               // 10
//                                                                                                  // 11
// Don't use `nextTick` for Node since it runs its callbacks before                                 // 12
// I/O, which is stricter than we're looking for.                                                   // 13
//                                                                                                  // 14
// Not installed as a polyfill, as our public API is `Meteor.defer`.                                // 15
// Since we're not trying to be a polyfill, we have some                                            // 16
// simplifications:                                                                                 // 17
//                                                                                                  // 18
// If one invocation of a setImmediate callback pauses itself by a                                  // 19
// call to alert/prompt/showModelDialog, the NobleJS polyfill                                       // 20
// implementation ensured that no setImmedate callback would run until                              // 21
// the first invocation completed.  While correct per the spec, what it                             // 22
// would mean for us in practice is that any reactive updates relying                               // 23
// on Meteor.defer would be hung in the main window until the modal                                 // 24
// dialog was dismissed.  Thus we only ensure that a setImmediate                                   // 25
// function is called in a later event loop.                                                        // 26
//                                                                                                  // 27
// We don't need to support using a string to be eval'ed for the                                    // 28
// callback, arguments to the function, or clearImmediate.                                          // 29
                                                                                                    // 30
"use strict";                                                                                       // 31
                                                                                                    // 32
var global = this;                                                                                  // 33
                                                                                                    // 34
                                                                                                    // 35
// IE 10, Node >= 9.1                                                                               // 36
                                                                                                    // 37
function useSetImmediate() {                                                                        // 38
  if (! global.setImmediate)                                                                        // 39
    return null;                                                                                    // 40
  else {                                                                                            // 41
    var setImmediate = function (fn) {                                                              // 42
      global.setImmediate(fn);                                                                      // 43
    };                                                                                              // 44
    setImmediate.implementation = 'setImmediate';                                                   // 45
    return setImmediate;                                                                            // 46
  }                                                                                                 // 47
}                                                                                                   // 48
                                                                                                    // 49
                                                                                                    // 50
// Android 2.3.6, Chrome 26, Firefox 20, IE 8-9, iOS 5.1.1 Safari                                   // 51
                                                                                                    // 52
function usePostMessage() {                                                                         // 53
  // The test against `importScripts` prevents this implementation                                  // 54
  // from being installed inside a web worker, where                                                // 55
  // `global.postMessage` means something completely different and                                  // 56
  // can't be used for this purpose.                                                                // 57
                                                                                                    // 58
  if (!global.postMessage || global.importScripts) {                                                // 59
    return null;                                                                                    // 60
  }                                                                                                 // 61
                                                                                                    // 62
  // Avoid synchronous post message implementations.                                                // 63
                                                                                                    // 64
  var postMessageIsAsynchronous = true;                                                             // 65
  var oldOnMessage = global.onmessage;                                                              // 66
  global.onmessage = function () {                                                                  // 67
      postMessageIsAsynchronous = false;                                                            // 68
  };                                                                                                // 69
  global.postMessage("", "*");                                                                      // 70
  global.onmessage = oldOnMessage;                                                                  // 71
                                                                                                    // 72
  if (! postMessageIsAsynchronous)                                                                  // 73
    return null;                                                                                    // 74
                                                                                                    // 75
  var funcIndex = 0;                                                                                // 76
  var funcs = {};                                                                                   // 77
                                                                                                    // 78
  // Installs an event handler on `global` for the `message` event: see                             // 79
  // * https://developer.mozilla.org/en/DOM/window.postMessage                                      // 80
  // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages // 81
                                                                                                    // 82
  // XXX use Random.id() here?                                                                      // 83
  var MESSAGE_PREFIX = "Meteor._setImmediate." + Math.random() + '.';                               // 84
                                                                                                    // 85
  function isStringAndStartsWith(string, putativeStart) {                                           // 86
    return (typeof string === "string" &&                                                           // 87
            string.substring(0, putativeStart.length) === putativeStart);                           // 88
  }                                                                                                 // 89
                                                                                                    // 90
  function onGlobalMessage(event) {                                                                 // 91
    // This will catch all incoming messages (even from other                                       // 92
    // windows!), so we need to try reasonably hard to avoid letting                                // 93
    // anyone else trick us into firing off. We test the origin is                                  // 94
    // still this window, and that a (randomly generated)                                           // 95
    // unpredictable identifying prefix is present.                                                 // 96
    if (event.source === global &&                                                                  // 97
        isStringAndStartsWith(event.data, MESSAGE_PREFIX)) {                                        // 98
      var index = event.data.substring(MESSAGE_PREFIX.length);                                      // 99
      try {                                                                                         // 100
        if (funcs[index])                                                                           // 101
          funcs[index]();                                                                           // 102
      }                                                                                             // 103
      finally {                                                                                     // 104
        delete funcs[index];                                                                        // 105
      }                                                                                             // 106
    }                                                                                               // 107
  }                                                                                                 // 108
                                                                                                    // 109
  if (global.addEventListener) {                                                                    // 110
    global.addEventListener("message", onGlobalMessage, false);                                     // 111
  } else {                                                                                          // 112
    global.attachEvent("onmessage", onGlobalMessage);                                               // 113
  }                                                                                                 // 114
                                                                                                    // 115
  var setImmediate = function (fn) {                                                                // 116
    // Make `global` post a message to itself with the handle and                                   // 117
    // identifying prefix, thus asynchronously invoking our                                         // 118
    // onGlobalMessage listener above.                                                              // 119
    ++funcIndex;                                                                                    // 120
    funcs[funcIndex] = fn;                                                                          // 121
    global.postMessage(MESSAGE_PREFIX + funcIndex, "*");                                            // 122
  };                                                                                                // 123
  setImmediate.implementation = 'postMessage';                                                      // 124
  return setImmediate;                                                                              // 125
}                                                                                                   // 126
                                                                                                    // 127
                                                                                                    // 128
function useTimeout() {                                                                             // 129
  var setImmediate = function (fn) {                                                                // 130
    global.setTimeout(fn, 0);                                                                       // 131
  };                                                                                                // 132
  setImmediate.implementation = 'setTimeout';                                                       // 133
  return setImmediate;                                                                              // 134
}                                                                                                   // 135
                                                                                                    // 136
                                                                                                    // 137
Meteor._setImmediate =                                                                              // 138
  useSetImmediate() ||                                                                              // 139
  usePostMessage() ||                                                                               // 140
  useTimeout();                                                                                     // 141
                                                                                                    // 142
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/timers.js                                                                        //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
var withoutInvocation = function (f) {                                                              // 1
  if (Package.livedata) {                                                                           // 2
    if (_CurrentInvocation.get() && _CurrentInvocation.get().isSimulation)                          // 4
      throw new Error("Can't set timers inside simulations");                                       // 5
    return function () { _CurrentInvocation.withValue(null, f); };                                  // 6
  }                                                                                                 // 7
  else                                                                                              // 8
    return f;                                                                                       // 9
};                                                                                                  // 10
                                                                                                    // 11
var bindAndCatch = function (context, f) {                                                          // 12
  return Meteor.bindEnvironment(withoutInvocation(f), context);                                     // 13
};                                                                                                  // 14
                                                                                                    // 15
_.extend(Meteor, {                                                                                  // 16
  // Meteor.setTimeout and Meteor.setInterval callbacks scheduled                                   // 17
  // inside a server method are not part of the method invocation and                               // 18
  // should clear out the CurrentInvocation environment variable.                                   // 19
                                                                                                    // 20
  setTimeout: function (f, duration) {                                                              // 21
    return setTimeout(bindAndCatch("setTimeout callback", f), duration);                            // 22
  },                                                                                                // 23
                                                                                                    // 24
  setInterval: function (f, duration) {                                                             // 25
    return setInterval(bindAndCatch("setInterval callback", f), duration);                          // 26
  },                                                                                                // 27
                                                                                                    // 28
  clearInterval: function(x) {                                                                      // 29
    return clearInterval(x);                                                                        // 30
  },                                                                                                // 31
                                                                                                    // 32
  clearTimeout: function(x) {                                                                       // 33
    return clearTimeout(x);                                                                         // 34
  },                                                                                                // 35
                                                                                                    // 36
  // XXX consider making this guarantee ordering of defer'd callbacks, like                         // 37
  // Deps.afterFlush or Node's nextTick (in practice). Then tests can do:                           // 38
  //    callSomethingThatDefersSomeWork();                                                          // 39
  //    Meteor.defer(expect(somethingThatValidatesThatTheWorkHappened));                            // 40
  defer: function (f) {                                                                             // 41
    Meteor._setImmediate(bindAndCatch("defer callback", f));                                        // 42
  }                                                                                                 // 43
});                                                                                                 // 44
                                                                                                    // 45
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/errors.js                                                                        //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
// http://davidshariff.com/blog/javascript-inheritance-patterns/                                    // 1
var inherits = function (child, parent) {                                                           // 2
  var tmp = function () {};                                                                         // 3
  tmp.prototype = parent.prototype;                                                                 // 4
  child.prototype = new tmp;                                                                        // 5
  child.prototype.constructor = child;                                                              // 6
};                                                                                                  // 7
                                                                                                    // 8
// Makes an error subclass which properly contains a stack trace in most                            // 9
// environments. constructor can set fields on `this` (and should probably set                      // 10
// `message`, which is what gets displayed at the top of a stack trace).                            // 11
//                                                                                                  // 12
Meteor.makeErrorType = function (name, constructor) {                                               // 13
  var errorClass = function (/*arguments*/) {                                                       // 14
    var self = this;                                                                                // 15
                                                                                                    // 16
    // Ensure we get a proper stack trace in most Javascript environments                           // 17
    if (Error.captureStackTrace) {                                                                  // 18
      // V8 environments (Chrome and Node.js)                                                       // 19
      Error.captureStackTrace(self, errorClass);                                                    // 20
    } else {                                                                                        // 21
      // Firefox                                                                                    // 22
      var e = new Error;                                                                            // 23
      e.__proto__ = errorClass.prototype;                                                           // 24
      if (e instanceof errorClass)                                                                  // 25
        self = e;                                                                                   // 26
    }                                                                                               // 27
    // Safari magically works.                                                                      // 28
                                                                                                    // 29
    constructor.apply(self, arguments);                                                             // 30
                                                                                                    // 31
    self.errorType = name;                                                                          // 32
                                                                                                    // 33
    return self;                                                                                    // 34
  };                                                                                                // 35
                                                                                                    // 36
  inherits(errorClass, Error);                                                                      // 37
                                                                                                    // 38
  return errorClass;                                                                                // 39
};                                                                                                  // 40
                                                                                                    // 41
// This should probably be in the livedata package, but we don't want                               // 42
// to require you to use the livedata package to get it. Eventually we                              // 43
// 'livedata' package (which we should rename to 'ddp' also.)                                       // 45
//                                                                                                  // 46
// containing 'error' and optionally 'reason' and 'details'.                                        // 48
// EJSON.addType here because the type is determined by location in the                             // 50
// protocol, not text on the wire.)                                                                 // 51
//                                                                                                  // 52
Meteor.Error = Meteor.makeErrorType(                                                                // 53
  "Meteor.Error",                                                                                   // 54
  function (error, reason, details) {                                                               // 55
    var self = this;                                                                                // 56
                                                                                                    // 57
    // Currently, a numeric code, likely similar to a HTTP code (eg,                                // 58
    // 404, 500). That is likely to change though.                                                  // 59
    self.error = error;                                                                             // 60
                                                                                                    // 61
    // Optional: A short human-readable summary of the error. Not                                   // 62
    // intended to be shown to end users, just developers. ("Not Found",                            // 63
    // "Internal Server Error")                                                                     // 64
    self.reason = reason;                                                                           // 65
                                                                                                    // 66
    // Optional: Additional information about the error, say for                                    // 67
    // debugging. It might be a (textual) stack trace if the server is                              // 68
    // willing to provide one. The corresponding thing in HTTP would be                             // 69
    // the body of a 404 or 500 response. (The difference is that we                                // 70
    // never expect this to be shown to end users, only developers, so                              // 71
    // it doesn't need to be pretty.)                                                               // 72
    self.details = details;                                                                         // 73
                                                                                                    // 74
    // This is what gets displayed at the top of a stack trace. Current                             // 75
    // format is "[404]" (if no reason is set) or "File not found [404]"                            // 76
    if (self.reason)                                                                                // 77
      self.message = self.reason + ' [' + self.error + ']';                                         // 78
    else                                                                                            // 79
      self.message = '[' + self.error + ']';                                                        // 80
  });                                                                                               // 81
                                                                                                    // 82
// properly EJSON-clone it. This is especially important because if a                               // 84
// Meteor.Error is thrown through a Future, the error, reason, and details                          // 85
// properties become non-enumerable so a standard Object clone won't preserve                       // 86
Meteor.Error.prototype.clone = function () {                                                        // 88
  var self = this;                                                                                  // 89
  return new Meteor.Error(self.error, self.reason, self.details);                                   // 90
};                                                                                                  // 91
                                                                                                    // 92
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/fiber_stubs_client.js                                                            //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
// This file is a partial analogue to fiber_helpers.js, which allows the client                     // 1
// to use a queue too, and also to call noYieldsAllowed.                                            // 2
                                                                                                    // 3
// The client has no ability to yield, so noYieldsAllowed is a noop.                                // 4
//                                                                                                  // 5
Meteor._noYieldsAllowed = function (f) {                                                            // 6
  return f();                                                                                       // 7
};                                                                                                  // 8
                                                                                                    // 9
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/unyielding_queue.js                                                              //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
// A simpler version of Meteor._SynchronousQueue with the same external                             // 1
// interface. It runs on both client and server, unlike _SynchronousQueue which                     // 2
// only runs on the server. When used on the server, tasks may not yield.  This                     // 3
// one just runs all the tasks when you call runTask or flush, synchronously.                       // 4
// It itself also does not yield.                                                                   // 5
//                                                                                                  // 6
Meteor._UnyieldingQueue = function () {                                                             // 7
  var self = this;                                                                                  // 8
  self._tasks = [];                                                                                 // 9
  self._running = false;                                                                            // 10
};                                                                                                  // 11
                                                                                                    // 12
_.extend(Meteor._UnyieldingQueue.prototype, {                                                       // 13
  runTask: function (task) {                                                                        // 14
    var self = this;                                                                                // 15
    if (!self.safeToRunTask())                                                                      // 16
      throw new Error("Could not synchronously run a task from a running task");                    // 17
    self._tasks.push(task);                                                                         // 18
    var tasks = self._tasks;                                                                        // 19
    self._tasks = [];                                                                               // 20
    self._running = true;                                                                           // 21
    try {                                                                                           // 22
      while (!_.isEmpty(tasks)) {                                                                   // 23
        var t = tasks.shift();                                                                      // 24
        try {                                                                                       // 25
          Meteor._noYieldsAllowed(function () {                                                     // 26
            t();                                                                                    // 27
          });                                                                                       // 28
        } catch (e) {                                                                               // 29
          if (_.isEmpty(tasks)) {                                                                   // 30
            // this was the last task, that is, the one we're calling runTask                       // 31
            // for.                                                                                 // 32
            throw e;                                                                                // 33
          } else {                                                                                  // 34
            Meteor._debug("Exception in queued task: " + e.stack);                                  // 35
          }                                                                                         // 36
        }                                                                                           // 37
      }                                                                                             // 38
    } finally {                                                                                     // 39
      self._running = false;                                                                        // 40
    }                                                                                               // 41
  },                                                                                                // 42
                                                                                                    // 43
  queueTask: function (task) {                                                                      // 44
    var self = this;                                                                                // 45
    var wasEmpty = _.isEmpty(self._tasks);                                                          // 46
    self._tasks.push(task);                                                                         // 47
    // Intentionally not using Meteor.setTimeout, because it doesn't like runing                    // 48
    // in stubs for now.                                                                            // 49
    if (wasEmpty)                                                                                   // 50
      setTimeout(_.bind(self.flush, self), 0);                                                      // 51
  },                                                                                                // 52
                                                                                                    // 53
  flush: function () {                                                                              // 54
    var self = this;                                                                                // 55
    self.runTask(function () {});                                                                   // 56
  },                                                                                                // 57
                                                                                                    // 58
  drain: function () {                                                                              // 59
    var self = this;                                                                                // 60
    if (!self.safeToRunTask())                                                                      // 61
      return;                                                                                       // 62
    while (!_.isEmpty(self._tasks)) {                                                               // 63
      self.flush();                                                                                 // 64
    }                                                                                               // 65
  },                                                                                                // 66
                                                                                                    // 67
  safeToRunTask: function () {                                                                      // 68
    var self = this;                                                                                // 69
    return !self._running;                                                                          // 70
  }                                                                                                 // 71
});                                                                                                 // 72
                                                                                                    // 73
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/startup_client.js                                                                //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
var queue = [];                                                                                     // 1
var loaded = document.readyState === "loaded" ||                                                    // 2
  document.readyState == "complete";                                                                // 3
                                                                                                    // 4
var ready = function() {                                                                            // 5
  loaded = true;                                                                                    // 6
  while (queue.length)                                                                              // 7
    (queue.shift())();                                                                              // 8
};                                                                                                  // 9
                                                                                                    // 10
if (document.addEventListener) {                                                                    // 11
  document.addEventListener('DOMContentLoaded', ready, false);                                      // 12
  window.addEventListener('load', ready, false);                                                    // 13
} else {                                                                                            // 14
  document.attachEvent('onreadystatechange', function () {                                          // 15
    if (document.readyState === "complete")                                                         // 16
      ready();                                                                                      // 17
  });                                                                                               // 18
  window.attachEvent('load', ready);                                                                // 19
}                                                                                                   // 20
                                                                                                    // 21
Meteor.startup = function (cb) {                                                                    // 22
  var doScroll = !document.addEventListener &&                                                      // 23
    document.documentElement.doScroll;                                                              // 24
                                                                                                    // 25
  if (!doScroll || window !== top) {                                                                // 26
    if (loaded)                                                                                     // 27
      cb();                                                                                         // 28
    else                                                                                            // 29
      queue.push(cb);                                                                               // 30
  } else {                                                                                          // 31
    try { doScroll('left'); }                                                                       // 32
    catch (e) {                                                                                     // 33
      setTimeout(function() { Meteor.startup(cb); }, 50);                                           // 34
      return;                                                                                       // 35
    };                                                                                              // 36
    cb();                                                                                           // 37
  }                                                                                                 // 38
};                                                                                                  // 39
                                                                                                    // 40
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/debug.js                                                                         //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
var suppress = 0;                                                                                   // 1
                                                                                                    // 2
// replacement for console.log. This is a temporary API. We should                                  // 3
// provide a real logging API soon (possibly just a polyfill for                                    // 4
// console?)                                                                                        // 5
//                                                                                                  // 6
// NOTE: this is used on the server to print the warning about                                      // 7
// having autopublish enabled when you probably meant to turn it                                    // 8
// off. it's not really the proper use of something called                                          // 9
// _debug. the intent is for this message to go to the terminal and                                 // 10
// be very visible. if you change _debug to go someplace else, etc,                                 // 11
// please fix the autopublish code to do something reasonable.                                      // 12
//                                                                                                  // 13
Meteor._debug = function (/* arguments */) {                                                        // 14
  if (suppress) {                                                                                   // 15
    suppress--;                                                                                     // 16
    return;                                                                                         // 17
  }                                                                                                 // 18
  if (typeof console !== 'undefined' &&                                                             // 19
      typeof console.log !== 'undefined') {                                                         // 20
    if (arguments.length == 0) { // IE Companion breaks otherwise                                   // 21
      // IE10 PP4 requires at least one argument                                                    // 22
      console.log('');                                                                              // 23
    } else {                                                                                        // 24
      // IE doesn't have console.log.apply, it's not a real Object.                                 // 25
      // http://stackoverflow.com/questions/5538972/console-log-apply-not-working-in-ie9            // 26
      // http://patik.com/blog/complete-cross-browser-console-log/                                  // 27
      if (typeof console.log.apply === "function") {                                                // 28
        // Most browsers                                                                            // 29
                                                                                                    // 30
        // Chrome and Safari only hyperlink URLs to source files in first argument of               // 31
        // console.log, so try to call it with one argument if possible.                            // 32
        // Approach taken here: If all arguments are strings, join them on space.                   // 33
        // See https://github.com/meteor/meteor/pull/732#issuecomment-13975991                      // 34
        var allArgumentsOfTypeString = true;                                                        // 35
        for (var i = 0; i < arguments.length; i++)                                                  // 36
          if (typeof arguments[i] !== "string")                                                     // 37
            allArgumentsOfTypeString = false;                                                       // 38
                                                                                                    // 39
        if (allArgumentsOfTypeString)                                                               // 40
          console.log.apply(console, [Array.prototype.join.call(arguments, " ")]);                  // 41
        else                                                                                        // 42
          console.log.apply(console, arguments);                                                    // 43
                                                                                                    // 44
      } else if (typeof Function.prototype.bind === "function") {                                   // 45
        // IE9                                                                                      // 46
        var log = Function.prototype.bind.call(console.log, console);                               // 47
        log.apply(console, arguments);                                                              // 48
      } else {                                                                                      // 49
        // IE8                                                                                      // 50
        Function.prototype.call.call(console.log, console, Array.prototype.slice.call(arguments));  // 51
      }                                                                                             // 52
    }                                                                                               // 53
  }                                                                                                 // 54
};                                                                                                  // 55
                                                                                                    // 56
// Suppress the next 'count' Meteor._debug messsages. Use this to                                   // 57
// stop tests from spamming the console.                                                            // 58
//                                                                                                  // 59
Meteor._suppress_log = function (count) {                                                           // 60
  suppress += count;                                                                                // 61
};                                                                                                  // 62
                                                                                                    // 63
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/dynamics_browser.js                                                              //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
// Simple implementation of dynamic scoping, for use in browsers                                    // 1
                                                                                                    // 2
var nextSlot = 0;                                                                                   // 3
var currentValues = [];                                                                             // 4
                                                                                                    // 5
Meteor.EnvironmentVariable = function () {                                                          // 6
  this.slot = nextSlot++;                                                                           // 7
};                                                                                                  // 8
                                                                                                    // 9
_.extend(Meteor.EnvironmentVariable.prototype, {                                                    // 10
  get: function () {                                                                                // 11
    return currentValues[this.slot];                                                                // 12
  },                                                                                                // 13
                                                                                                    // 14
  withValue: function (value, func) {                                                               // 15
    var saved = currentValues[this.slot];                                                           // 16
    try {                                                                                           // 17
      currentValues[this.slot] = value;                                                             // 18
      var ret = func();                                                                             // 19
    } finally {                                                                                     // 20
      currentValues[this.slot] = saved;                                                             // 21
    }                                                                                               // 22
    return ret;                                                                                     // 23
  }                                                                                                 // 24
});                                                                                                 // 25
                                                                                                    // 26
Meteor.bindEnvironment = function (func, onException, _this) {                                      // 27
  // needed in order to be able to create closures inside func and                                  // 28
  // have the closed variables not change back to their original                                    // 29
  // values                                                                                         // 30
  var boundValues = _.clone(currentValues);                                                         // 31
                                                                                                    // 32
  if (!onException || typeof(onException) === 'string') {                                           // 33
    var description = onException || "callback of async function";                                  // 34
    onException = function (error) {                                                                // 35
      Meteor._debug(                                                                                // 36
        "Exception in " + description + ":",                                                        // 37
        error && error.stack || error                                                               // 38
      );                                                                                            // 39
    };                                                                                              // 40
  }                                                                                                 // 41
                                                                                                    // 42
  return function (/* arguments */) {                                                               // 43
    var savedValues = currentValues;                                                                // 44
    try {                                                                                           // 45
      currentValues = boundValues;                                                                  // 46
      var ret = func.apply(_this, _.toArray(arguments));                                            // 47
    } catch (e) {                                                                                   // 48
      onException(e);                                                                               // 49
    } finally {                                                                                     // 50
      currentValues = savedValues;                                                                  // 51
    }                                                                                               // 52
    return ret;                                                                                     // 53
  };                                                                                                // 54
};                                                                                                  // 55
                                                                                                    // 56
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/url_common.js                                                                    //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
Meteor.absoluteUrl = function (path, options) {                                                     // 1
  // path is optional                                                                               // 2
  if (!options && typeof path === 'object') {                                                       // 3
    options = path;                                                                                 // 4
    path = undefined;                                                                               // 5
  }                                                                                                 // 6
  // merge options with defaults                                                                    // 7
  options = _.extend({}, Meteor.absoluteUrl.defaultOptions, options || {});                         // 8
                                                                                                    // 9
  var url = options.rootUrl;                                                                        // 10
  if (!url)                                                                                         // 11
    throw new Error("Must pass options.rootUrl or set ROOT_URL in the server environment");         // 12
                                                                                                    // 13
  if (!/^http[s]?:\/\//i.test(url)) // url starts with 'http://' or 'https://'                      // 14
    url = 'http://' + url; // we will later fix to https if options.secure is set                   // 15
                                                                                                    // 16
  if (!/\/$/.test(url)) // url ends with '/'                                                        // 17
    url += '/';                                                                                     // 18
                                                                                                    // 19
  if (path)                                                                                         // 20
    url += path;                                                                                    // 21
                                                                                                    // 22
  // turn http to https if secure option is set, and we're not talking                              // 23
  // to localhost.                                                                                  // 24
  if (options.secure &&                                                                             // 25
      /^http:/.test(url) && // url starts with 'http:'                                              // 26
      !/http:\/\/localhost[:\/]/.test(url) && // doesn't match localhost                            // 27
      !/http:\/\/127\.0\.0\.1[:\/]/.test(url)) // or 127.0.0.1                                      // 28
    url = url.replace(/^http:/, 'https:');                                                          // 29
                                                                                                    // 30
  if (options.replaceLocalhost)                                                                     // 31
    url = url.replace(/^http:\/\/localhost([:\/].*)/, 'http://127.0.0.1$1');                        // 32
                                                                                                    // 33
  return url;                                                                                       // 34
};                                                                                                  // 35
                                                                                                    // 36
// allow later packages to override default options                                                 // 37
Meteor.absoluteUrl.defaultOptions = { };                                                            // 38
if (typeof __meteor_runtime_config__ === "object" &&                                                // 39
    __meteor_runtime_config__.ROOT_URL)                                                             // 40
  Meteor.absoluteUrl.defaultOptions.rootUrl = __meteor_runtime_config__.ROOT_URL;                   // 41
                                                                                                    // 42
                                                                                                    // 43
Meteor._relativeToSiteRootUrl = function (link) {                                                   // 44
  if (typeof __meteor_runtime_config__ === "object" &&                                              // 45
      link.substr(0, 1) === "/")                                                                    // 46
    link = (__meteor_runtime_config__.ROOT_URL_PATH_PREFIX || "") + link;                           // 47
  return link;                                                                                      // 48
};                                                                                                  // 49
                                                                                                    // 50
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.meteor = {
  Meteor: Meteor
};

})();

//# sourceMappingURL=9383a03e35061e224183c68ad742bb7ca8262e9b.map


//--------- json.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;

/* Package-scope variables */
var JSON;

(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/json/json_native.js                                                                           //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
// Do we already have a global JSON object? Export it as our JSON object.                                 // 1
if (window.JSON)                                                                                          // 2
  JSON = window.JSON;                                                                                     // 3
                                                                                                          // 4
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/json/json2.js                                                                                 //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
/*                                                                                                        // 1
    json2.js                                                                                              // 2
    2012-10-08                                                                                            // 3
                                                                                                          // 4
    Public Domain.                                                                                        // 5
                                                                                                          // 6
    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.                                               // 7
                                                                                                          // 8
    See http://www.JSON.org/js.html                                                                       // 9
                                                                                                          // 10
                                                                                                          // 11
    This code should be minified before deployment.                                                       // 12
    See http://javascript.crockford.com/jsmin.html                                                        // 13
                                                                                                          // 14
    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO                            // 15
    NOT CONTROL.                                                                                          // 16
                                                                                                          // 17
                                                                                                          // 18
    This file creates a global JSON object containing two methods: stringify                              // 19
    and parse.                                                                                            // 20
                                                                                                          // 21
        JSON.stringify(value, replacer, space)                                                            // 22
            value       any JavaScript value, usually an object or array.                                 // 23
                                                                                                          // 24
            replacer    an optional parameter that determines how object                                  // 25
                        values are stringified for objects. It can be a                                   // 26
                        function or an array of strings.                                                  // 27
                                                                                                          // 28
            space       an optional parameter that specifies the indentation                              // 29
                        of nested structures. If it is omitted, the text will                             // 30
                        be packed without extra whitespace. If it is a number,                            // 31
                        it will specify the number of spaces to indent at each                            // 32
                        level. If it is a string (such as '\t' or '&nbsp;'),                              // 33
                        it contains the characters used to indent at each level.                          // 34
                                                                                                          // 35
            This method produces a JSON text from a JavaScript value.                                     // 36
                                                                                                          // 37
            When an object value is found, if the object contains a toJSON                                // 38
            method, its toJSON method will be called and the result will be                               // 39
            stringified. A toJSON method does not serialize: it returns the                               // 40
            value represented by the name/value pair that should be serialized,                           // 41
            or undefined if nothing should be serialized. The toJSON method                               // 42
            will be passed the key associated with the value, and this will be                            // 43
            bound to the value                                                                            // 44
                                                                                                          // 45
            For example, this would serialize Dates as ISO strings.                                       // 46
                                                                                                          // 47
                Date.prototype.toJSON = function (key) {                                                  // 48
                    function f(n) {                                                                       // 49
                        // Format integers to have at least two digits.                                   // 50
                        return n < 10 ? '0' + n : n;                                                      // 51
                    }                                                                                     // 52
                                                                                                          // 53
                    return this.getUTCFullYear()   + '-' +                                                // 54
                         f(this.getUTCMonth() + 1) + '-' +                                                // 55
                         f(this.getUTCDate())      + 'T' +                                                // 56
                         f(this.getUTCHours())     + ':' +                                                // 57
                         f(this.getUTCMinutes())   + ':' +                                                // 58
                         f(this.getUTCSeconds())   + 'Z';                                                 // 59
                };                                                                                        // 60
                                                                                                          // 61
            You can provide an optional replacer method. It will be passed the                            // 62
            key and value of each member, with this bound to the containing                               // 63
            object. The value that is returned from your method will be                                   // 64
            serialized. If your method returns undefined, then the member will                            // 65
            be excluded from the serialization.                                                           // 66
                                                                                                          // 67
            If the replacer parameter is an array of strings, then it will be                             // 68
            used to select the members to be serialized. It filters the results                           // 69
            such that only members with keys listed in the replacer array are                             // 70
            stringified.                                                                                  // 71
                                                                                                          // 72
            Values that do not have JSON representations, such as undefined or                            // 73
            functions, will not be serialized. Such values in objects will be                             // 74
            dropped; in arrays they will be replaced with null. You can use                               // 75
            a replacer function to replace those with JSON values.                                        // 76
            JSON.stringify(undefined) returns undefined.                                                  // 77
                                                                                                          // 78
            The optional space parameter produces a stringification of the                                // 79
            value that is filled with line breaks and indentation to make it                              // 80
            easier to read.                                                                               // 81
                                                                                                          // 82
            If the space parameter is a non-empty string, then that string will                           // 83
            be used for indentation. If the space parameter is a number, then                             // 84
            the indentation will be that many spaces.                                                     // 85
                                                                                                          // 86
            Example:                                                                                      // 87
                                                                                                          // 88
            text = JSON.stringify(['e', {pluribus: 'unum'}]);                                             // 89
            // text is '["e",{"pluribus":"unum"}]'                                                        // 90
                                                                                                          // 91
                                                                                                          // 92
            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');                                 // 93
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'                                   // 94
                                                                                                          // 95
            text = JSON.stringify([new Date()], function (key, value) {                                   // 96
                return this[key] instanceof Date ?                                                        // 97
                    'Date(' + this[key] + ')' : value;                                                    // 98
            });                                                                                           // 99
            // text is '["Date(---current time---)"]'                                                     // 100
                                                                                                          // 101
                                                                                                          // 102
        JSON.parse(text, reviver)                                                                         // 103
            This method parses a JSON text to produce an object or array.                                 // 104
            It can throw a SyntaxError exception.                                                         // 105
                                                                                                          // 106
            The optional reviver parameter is a function that can filter and                              // 107
            transform the results. It receives each of the keys and values,                               // 108
            and its return value is used instead of the original value.                                   // 109
            If it returns what it received, then the structure is not modified.                           // 110
            If it returns undefined then the member is deleted.                                           // 111
                                                                                                          // 112
            Example:                                                                                      // 113
                                                                                                          // 114
            // Parse the text. Values that look like ISO date strings will                                // 115
            // be converted to Date objects.                                                              // 116
                                                                                                          // 117
            myData = JSON.parse(text, function (key, value) {                                             // 118
                var a;                                                                                    // 119
                if (typeof value === 'string') {                                                          // 120
                    a =                                                                                   // 121
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);                               // 122
                    if (a) {                                                                              // 123
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],                          // 124
                            +a[5], +a[6]));                                                               // 125
                    }                                                                                     // 126
                }                                                                                         // 127
                return value;                                                                             // 128
            });                                                                                           // 129
                                                                                                          // 130
            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {                           // 131
                var d;                                                                                    // 132
                if (typeof value === 'string' &&                                                          // 133
                        value.slice(0, 5) === 'Date(' &&                                                  // 134
                        value.slice(-1) === ')') {                                                        // 135
                    d = new Date(value.slice(5, -1));                                                     // 136
                    if (d) {                                                                              // 137
                        return d;                                                                         // 138
                    }                                                                                     // 139
                }                                                                                         // 140
                return value;                                                                             // 141
            });                                                                                           // 142
                                                                                                          // 143
                                                                                                          // 144
    This is a reference implementation. You are free to copy, modify, or                                  // 145
    redistribute.                                                                                         // 146
*/                                                                                                        // 147
                                                                                                          // 148
/*jslint evil: true, regexp: true */                                                                      // 149
                                                                                                          // 150
/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,                                      // 151
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,                                            // 152
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,                                      // 153
    lastIndex, length, parse, prototype, push, replace, slice, stringify,                                 // 154
    test, toJSON, toString, valueOf                                                                       // 155
*/                                                                                                        // 156
                                                                                                          // 157
                                                                                                          // 158
// Create a JSON object only if one does not already exist. We create the                                 // 159
// methods in a closure to avoid creating global variables.                                               // 160
                                                                                                          // 161
if (typeof JSON !== 'object') {                                                                           // 162
    JSON = {};                                                                                            // 163
}                                                                                                         // 164
                                                                                                          // 165
(function () {                                                                                            // 166
    'use strict';                                                                                         // 167
                                                                                                          // 168
    function f(n) {                                                                                       // 169
        // Format integers to have at least two digits.                                                   // 170
        return n < 10 ? '0' + n : n;                                                                      // 171
    }                                                                                                     // 172
                                                                                                          // 173
    if (typeof Date.prototype.toJSON !== 'function') {                                                    // 174
                                                                                                          // 175
        Date.prototype.toJSON = function (key) {                                                          // 176
                                                                                                          // 177
            return isFinite(this.valueOf())                                                               // 178
                ? this.getUTCFullYear()     + '-' +                                                       // 179
                    f(this.getUTCMonth() + 1) + '-' +                                                     // 180
                    f(this.getUTCDate())      + 'T' +                                                     // 181
                    f(this.getUTCHours())     + ':' +                                                     // 182
                    f(this.getUTCMinutes())   + ':' +                                                     // 183
                    f(this.getUTCSeconds())   + 'Z'                                                       // 184
                : null;                                                                                   // 185
        };                                                                                                // 186
                                                                                                          // 187
        String.prototype.toJSON      =                                                                    // 188
            Number.prototype.toJSON  =                                                                    // 189
            Boolean.prototype.toJSON = function (key) {                                                   // 190
                return this.valueOf();                                                                    // 191
            };                                                                                            // 192
    }                                                                                                     // 193
                                                                                                          // 194
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,                                                                                              // 197
        indent,                                                                                           // 198
        meta = {    // table of character substitutions                                                   // 199
            '\b': '\\b',                                                                                  // 200
            '\t': '\\t',                                                                                  // 201
            '\n': '\\n',                                                                                  // 202
            '\f': '\\f',                                                                                  // 203
            '\r': '\\r',                                                                                  // 204
            '"' : '\\"',                                                                                  // 205
            '\\': '\\\\'                                                                                  // 206
        },                                                                                                // 207
        rep;                                                                                              // 208
                                                                                                          // 209
                                                                                                          // 210
    function quote(string) {                                                                              // 211
                                                                                                          // 212
// If the string contains no control characters, no quote characters, and no                              // 213
// backslash characters, then we can safely slap some quotes around it.                                   // 214
// Otherwise we must also replace the offending characters with safe escape                               // 215
// sequences.                                                                                             // 216
                                                                                                          // 217
        escapable.lastIndex = 0;                                                                          // 218
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {                    // 219
            var c = meta[a];                                                                              // 220
            return typeof c === 'string'                                                                  // 221
                ? c                                                                                       // 222
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);                              // 223
        }) + '"' : '"' + string + '"';                                                                    // 224
    }                                                                                                     // 225
                                                                                                          // 226
                                                                                                          // 227
    function str(key, holder) {                                                                           // 228
                                                                                                          // 229
// Produce a string from holder[key].                                                                     // 230
                                                                                                          // 231
        var i,          // The loop counter.                                                              // 232
            k,          // The member key.                                                                // 233
            v,          // The member value.                                                              // 234
            length,                                                                                       // 235
            mind = gap,                                                                                   // 236
            partial,                                                                                      // 237
            value = holder[key];                                                                          // 238
                                                                                                          // 239
// If the value has a toJSON method, call it to obtain a replacement value.                               // 240
                                                                                                          // 241
        if (value && typeof value === 'object' &&                                                         // 242
                typeof value.toJSON === 'function') {                                                     // 243
            value = value.toJSON(key);                                                                    // 244
        }                                                                                                 // 245
                                                                                                          // 246
// If we were called with a replacer function, then call the replacer to                                  // 247
// obtain a replacement value.                                                                            // 248
                                                                                                          // 249
        if (typeof rep === 'function') {                                                                  // 250
            value = rep.call(holder, key, value);                                                         // 251
        }                                                                                                 // 252
                                                                                                          // 253
// What happens next depends on the value's type.                                                         // 254
                                                                                                          // 255
        switch (typeof value) {                                                                           // 256
        case 'string':                                                                                    // 257
            return quote(value);                                                                          // 258
                                                                                                          // 259
        case 'number':                                                                                    // 260
                                                                                                          // 261
// JSON numbers must be finite. Encode non-finite numbers as null.                                        // 262
                                                                                                          // 263
            return isFinite(value) ? String(value) : 'null';                                              // 264
                                                                                                          // 265
        case 'boolean':                                                                                   // 266
        case 'null':                                                                                      // 267
                                                                                                          // 268
// If the value is a boolean or null, convert it to a string. Note:                                       // 269
// typeof null does not produce 'null'. The case is included here in                                      // 270
// the remote chance that this gets fixed someday.                                                        // 271
                                                                                                          // 272
            return String(value);                                                                         // 273
                                                                                                          // 274
// If the type is 'object', we might be dealing with an object or an array or                             // 275
// null.                                                                                                  // 276
                                                                                                          // 277
        case 'object':                                                                                    // 278
                                                                                                          // 279
// Due to a specification blunder in ECMAScript, typeof null is 'object',                                 // 280
// so watch out for that case.                                                                            // 281
                                                                                                          // 282
            if (!value) {                                                                                 // 283
                return 'null';                                                                            // 284
            }                                                                                             // 285
                                                                                                          // 286
// Make an array to hold the partial results of stringifying this object value.                           // 287
                                                                                                          // 288
            gap += indent;                                                                                // 289
            partial = [];                                                                                 // 290
                                                                                                          // 291
// Is the value an array?                                                                                 // 292
                                                                                                          // 293
            if (Object.prototype.toString.apply(value) === '[object Array]') {                            // 294
                                                                                                          // 295
// The value is an array. Stringify every element. Use null as a placeholder                              // 296
// for non-JSON values.                                                                                   // 297
                                                                                                          // 298
                length = value.length;                                                                    // 299
                for (i = 0; i < length; i += 1) {                                                         // 300
                    partial[i] = str(i, value) || 'null';                                                 // 301
                }                                                                                         // 302
                                                                                                          // 303
// Join all of the elements together, separated with commas, and wrap them in                             // 304
// brackets.                                                                                              // 305
                                                                                                          // 306
                v = partial.length === 0                                                                  // 307
                    ? '[]'                                                                                // 308
                    : gap                                                                                 // 309
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'                         // 310
                    : '[' + partial.join(',') + ']';                                                      // 311
                gap = mind;                                                                               // 312
                return v;                                                                                 // 313
            }                                                                                             // 314
                                                                                                          // 315
// If the replacer is an array, use it to select the members to be stringified.                           // 316
                                                                                                          // 317
            if (rep && typeof rep === 'object') {                                                         // 318
                length = rep.length;                                                                      // 319
                for (i = 0; i < length; i += 1) {                                                         // 320
                    if (typeof rep[i] === 'string') {                                                     // 321
                        k = rep[i];                                                                       // 322
                        v = str(k, value);                                                                // 323
                        if (v) {                                                                          // 324
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);                              // 325
                        }                                                                                 // 326
                    }                                                                                     // 327
                }                                                                                         // 328
            } else {                                                                                      // 329
                                                                                                          // 330
// Otherwise, iterate through all of the keys in the object.                                              // 331
                                                                                                          // 332
                for (k in value) {                                                                        // 333
                    if (Object.prototype.hasOwnProperty.call(value, k)) {                                 // 334
                        v = str(k, value);                                                                // 335
                        if (v) {                                                                          // 336
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);                              // 337
                        }                                                                                 // 338
                    }                                                                                     // 339
                }                                                                                         // 340
            }                                                                                             // 341
                                                                                                          // 342
// Join all of the member texts together, separated with commas,                                          // 343
// and wrap them in braces.                                                                               // 344
                                                                                                          // 345
            v = partial.length === 0                                                                      // 346
                ? '{}'                                                                                    // 347
                : gap                                                                                     // 348
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'                             // 349
                : '{' + partial.join(',') + '}';                                                          // 350
            gap = mind;                                                                                   // 351
            return v;                                                                                     // 352
        }                                                                                                 // 353
    }                                                                                                     // 354
                                                                                                          // 355
// If the JSON object does not yet have a stringify method, give it one.                                  // 356
                                                                                                          // 357
    if (typeof JSON.stringify !== 'function') {                                                           // 358
        JSON.stringify = function (value, replacer, space) {                                              // 359
                                                                                                          // 360
// The stringify method takes a value and an optional replacer, and an optional                           // 361
// space parameter, and returns a JSON text. The replacer can be a function                               // 362
// that can replace values, or an array of strings that will select the keys.                             // 363
// A default replacer method can be provided. Use of the space parameter can                              // 364
// produce text that is more easily readable.                                                             // 365
                                                                                                          // 366
            var i;                                                                                        // 367
            gap = '';                                                                                     // 368
            indent = '';                                                                                  // 369
                                                                                                          // 370
// If the space parameter is a number, make an indent string containing that                              // 371
// many spaces.                                                                                           // 372
                                                                                                          // 373
            if (typeof space === 'number') {                                                              // 374
                for (i = 0; i < space; i += 1) {                                                          // 375
                    indent += ' ';                                                                        // 376
                }                                                                                         // 377
                                                                                                          // 378
// If the space parameter is a string, it will be used as the indent string.                              // 379
                                                                                                          // 380
            } else if (typeof space === 'string') {                                                       // 381
                indent = space;                                                                           // 382
            }                                                                                             // 383
                                                                                                          // 384
// If there is a replacer, it must be a function or an array.                                             // 385
// Otherwise, throw an error.                                                                             // 386
                                                                                                          // 387
            rep = replacer;                                                                               // 388
            if (replacer && typeof replacer !== 'function' &&                                             // 389
                    (typeof replacer !== 'object' ||                                                      // 390
                    typeof replacer.length !== 'number')) {                                               // 391
                throw new Error('JSON.stringify');                                                        // 392
            }                                                                                             // 393
                                                                                                          // 394
// Make a fake root object containing our value under the key of ''.                                      // 395
// Return the result of stringifying the value.                                                           // 396
                                                                                                          // 397
            return str('', {'': value});                                                                  // 398
        };                                                                                                // 399
    }                                                                                                     // 400
                                                                                                          // 401
                                                                                                          // 402
// If the JSON object does not yet have a parse method, give it one.                                      // 403
                                                                                                          // 404
    if (typeof JSON.parse !== 'function') {                                                               // 405
        JSON.parse = function (text, reviver) {                                                           // 406
                                                                                                          // 407
// The parse method takes a text and an optional reviver function, and returns                            // 408
// a JavaScript value if the text is a valid JSON text.                                                   // 409
                                                                                                          // 410
            var j;                                                                                        // 411
                                                                                                          // 412
            function walk(holder, key) {                                                                  // 413
                                                                                                          // 414
// The walk method is used to recursively walk the resulting structure so                                 // 415
// that modifications can be made.                                                                        // 416
                                                                                                          // 417
                var k, v, value = holder[key];                                                            // 418
                if (value && typeof value === 'object') {                                                 // 419
                    for (k in value) {                                                                    // 420
                        if (Object.prototype.hasOwnProperty.call(value, k)) {                             // 421
                            v = walk(value, k);                                                           // 422
                            if (v !== undefined) {                                                        // 423
                                value[k] = v;                                                             // 424
                            } else {                                                                      // 425
                                delete value[k];                                                          // 426
                            }                                                                             // 427
                        }                                                                                 // 428
                    }                                                                                     // 429
                }                                                                                         // 430
                return reviver.call(holder, key, value);                                                  // 431
            }                                                                                             // 432
                                                                                                          // 433
                                                                                                          // 434
// Parsing happens in four stages. In the first stage, we replace certain                                 // 435
// Unicode characters with escape sequences. JavaScript handles many characters                           // 436
// incorrectly, either silently deleting them, or treating them as line endings.                          // 437
                                                                                                          // 438
            text = String(text);                                                                          // 439
            cx.lastIndex = 0;                                                                             // 440
            if (cx.test(text)) {                                                                          // 441
                text = text.replace(cx, function (a) {                                                    // 442
                    return '\\u' +                                                                        // 443
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);                                // 444
                });                                                                                       // 445
            }                                                                                             // 446
                                                                                                          // 447
// In the second stage, we run the text against regular expressions that look                             // 448
// for non-JSON patterns. We are especially concerned with '()' and 'new'                                 // 449
// because they can cause invocation, and '=' because it can cause mutation.                              // 450
// But just to be safe, we want to reject all unexpected forms.                                           // 451
                                                                                                          // 452
// We split the second stage into 4 regexp operations in order to work around                             // 453
// crippling inefficiencies in IE's and Safari's regexp engines. First we                                 // 454
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we                           // 455
// replace all simple value tokens with ']' characters. Third, we delete all                              // 456
// open brackets that follow a colon or comma or that begin the text. Finally,                            // 457
// we look to see that the remaining characters are only whitespace or ']' or                             // 458
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.                               // 459
                                                                                                          // 460
            if (/^[\],:{}\s]*$/                                                                           // 461
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')                        // 462
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']') // 463
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {                                          // 464
                                                                                                          // 465
// In the third stage we use the eval function to compile the text into a                                 // 466
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity                             // 467
// in JavaScript: it can begin a block or an object literal. We wrap the text                             // 468
// in parens to eliminate the ambiguity.                                                                  // 469
                                                                                                          // 470
                j = eval('(' + text + ')');                                                               // 471
                                                                                                          // 472
// In the optional fourth stage, we recursively walk the new structure, passing                           // 473
// each name/value pair to a reviver function for possible transformation.                                // 474
                                                                                                          // 475
                return typeof reviver === 'function'                                                      // 476
                    ? walk({'': j}, '')                                                                   // 477
                    : j;                                                                                  // 478
            }                                                                                             // 479
                                                                                                          // 480
// If the text is not JSON parseable, then a SyntaxError is thrown.                                       // 481
                                                                                                          // 482
            throw new SyntaxError('JSON.parse');                                                          // 483
        };                                                                                                // 484
    }                                                                                                     // 485
}());                                                                                                     // 486
                                                                                                          // 487
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.json = {
  JSON: JSON
};

})();

//# sourceMappingURL=e22856eae714c681199eabc5c0710b904b125554.map


//--------- ejson.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var JSON = Package.json.JSON;
var _ = Package.underscore._;

/* Package-scope variables */
var EJSON, EJSONTest, base64Encode, base64Decode;

(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                              //
// packages/ejson/ejson.js                                                                      //
//                                                                                              //
//////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                //
EJSON = {};                                                                                     // 1
EJSONTest = {};                                                                                 // 2
                                                                                                // 3
var customTypes = {};                                                                           // 4
// Add a custom type, using a method of your choice to get to and                               // 5
// from a basic JSON-able representation.  The factory argument                                 // 6
// is a function of JSON-able --> your object                                                   // 7
// The type you add must have:                                                                  // 8
// - A clone() method, so that Meteor can deep-copy it when necessary.                          // 9
// - A equals() method, so that Meteor can compare it                                           // 10
// - A toJSONValue() method, so that Meteor can serialize it                                    // 11
// - a typeName() method, to show how to look it up in our type table.                          // 12
// It is okay if these methods are monkey-patched on.                                           // 13
//                                                                                              // 14
EJSON.addType = function (name, factory) {                                                      // 15
  if (_.has(customTypes, name))                                                                 // 16
    throw new Error("Type " + name + " already present");                                       // 17
  customTypes[name] = factory;                                                                  // 18
};                                                                                              // 19
                                                                                                // 20
var isInfOrNan = function (obj) {                                                               // 21
  return _.isNaN(obj) || obj === Infinity || obj === -Infinity;                                 // 22
};                                                                                              // 23
                                                                                                // 24
var builtinConverters = [                                                                       // 25
  { // Date                                                                                     // 26
    matchJSONValue: function (obj) {                                                            // 27
      return _.has(obj, '$date') && _.size(obj) === 1;                                          // 28
    },                                                                                          // 29
    matchObject: function (obj) {                                                               // 30
      return obj instanceof Date;                                                               // 31
    },                                                                                          // 32
    toJSONValue: function (obj) {                                                               // 33
      return {$date: obj.getTime()};                                                            // 34
    },                                                                                          // 35
    fromJSONValue: function (obj) {                                                             // 36
      return new Date(obj.$date);                                                               // 37
    }                                                                                           // 38
  },                                                                                            // 39
  { // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'                     // 40
    // which we match.)                                                                         // 41
    matchJSONValue: function (obj) {                                                            // 42
      return _.has(obj, '$InfNaN') && _.size(obj) === 1;                                        // 43
    },                                                                                          // 44
    matchObject: isInfOrNan,                                                                    // 45
    toJSONValue: function (obj) {                                                               // 46
      var sign;                                                                                 // 47
      if (_.isNaN(obj))                                                                         // 48
        sign = 0;                                                                               // 49
      else if (obj === Infinity)                                                                // 50
        sign = 1;                                                                               // 51
      else                                                                                      // 52
        sign = -1;                                                                              // 53
      return {$InfNaN: sign};                                                                   // 54
    },                                                                                          // 55
    fromJSONValue: function (obj) {                                                             // 56
      return obj.$InfNaN/0;                                                                     // 57
    }                                                                                           // 58
  },                                                                                            // 59
  { // Binary                                                                                   // 60
    matchJSONValue: function (obj) {                                                            // 61
      return _.has(obj, '$binary') && _.size(obj) === 1;                                        // 62
    },                                                                                          // 63
    matchObject: function (obj) {                                                               // 64
      return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array                     // 65
        || (obj && _.has(obj, '$Uint8ArrayPolyfill'));                                          // 66
    },                                                                                          // 67
    toJSONValue: function (obj) {                                                               // 68
      return {$binary: base64Encode(obj)};                                                      // 69
    },                                                                                          // 70
    fromJSONValue: function (obj) {                                                             // 71
      return base64Decode(obj.$binary);                                                         // 72
    }                                                                                           // 73
  },                                                                                            // 74
  { // Escaping one level                                                                       // 75
    matchJSONValue: function (obj) {                                                            // 76
      return _.has(obj, '$escape') && _.size(obj) === 1;                                        // 77
    },                                                                                          // 78
    matchObject: function (obj) {                                                               // 79
      if (_.isEmpty(obj) || _.size(obj) > 2) {                                                  // 80
        return false;                                                                           // 81
      }                                                                                         // 82
      return _.any(builtinConverters, function (converter) {                                    // 83
        return converter.matchJSONValue(obj);                                                   // 84
      });                                                                                       // 85
    },                                                                                          // 86
    toJSONValue: function (obj) {                                                               // 87
      var newObj = {};                                                                          // 88
      _.each(obj, function (value, key) {                                                       // 89
        newObj[key] = EJSON.toJSONValue(value);                                                 // 90
      });                                                                                       // 91
      return {$escape: newObj};                                                                 // 92
    },                                                                                          // 93
    fromJSONValue: function (obj) {                                                             // 94
      var newObj = {};                                                                          // 95
      _.each(obj.$escape, function (value, key) {                                               // 96
        newObj[key] = EJSON.fromJSONValue(value);                                               // 97
      });                                                                                       // 98
      return newObj;                                                                            // 99
    }                                                                                           // 100
  },                                                                                            // 101
  { // Custom                                                                                   // 102
    matchJSONValue: function (obj) {                                                            // 103
      return _.has(obj, '$type') && _.has(obj, '$value') && _.size(obj) === 2;                  // 104
    },                                                                                          // 105
    matchObject: function (obj) {                                                               // 106
      return EJSON._isCustomType(obj);                                                          // 107
    },                                                                                          // 108
    toJSONValue: function (obj) {                                                               // 109
      return {$type: obj.typeName(), $value: obj.toJSONValue()};                                // 110
    },                                                                                          // 111
    fromJSONValue: function (obj) {                                                             // 112
      var typeName = obj.$type;                                                                 // 113
      var converter = customTypes[typeName];                                                    // 114
      return converter(obj.$value);                                                             // 115
    }                                                                                           // 116
  }                                                                                             // 117
];                                                                                              // 118
                                                                                                // 119
EJSON._isCustomType = function (obj) {                                                          // 120
  return obj &&                                                                                 // 121
    typeof obj.toJSONValue === 'function' &&                                                    // 122
    typeof obj.typeName === 'function' &&                                                       // 123
    _.has(customTypes, obj.typeName());                                                         // 124
};                                                                                              // 125
                                                                                                // 126
                                                                                                // 127
// for both arrays and objects, in-place modification.                                          // 128
var adjustTypesToJSONValue =                                                                    // 129
EJSON._adjustTypesToJSONValue = function (obj) {                                                // 130
  // Is it an atom that we need to adjust?                                                      // 131
  if (obj === null)                                                                             // 132
    return null;                                                                                // 133
  var maybeChanged = toJSONValueHelper(obj);                                                    // 134
  if (maybeChanged !== undefined)                                                               // 135
    return maybeChanged;                                                                        // 136
                                                                                                // 137
  // Other atoms are unchanged.                                                                 // 138
  if (typeof obj !== 'object')                                                                  // 139
    return obj;                                                                                 // 140
                                                                                                // 141
  // Iterate over array or object structure.                                                    // 142
  _.each(obj, function (value, key) {                                                           // 143
    if (typeof value !== 'object' && value !== undefined &&                                     // 144
        !isInfOrNan(value))                                                                     // 145
      return; // continue                                                                       // 146
                                                                                                // 147
    var changed = toJSONValueHelper(value);                                                     // 148
    if (changed) {                                                                              // 149
      obj[key] = changed;                                                                       // 150
      return; // on to the next key                                                             // 151
    }                                                                                           // 152
    // if we get here, value is an object but not adjustable                                    // 153
    // at this level.  recurse.                                                                 // 154
    adjustTypesToJSONValue(value);                                                              // 155
  });                                                                                           // 156
  return obj;                                                                                   // 157
};                                                                                              // 158
                                                                                                // 159
// Either return the JSON-compatible version of the argument, or undefined (if                  // 160
// the item isn't itself replaceable, but maybe some fields in it are)                          // 161
var toJSONValueHelper = function (item) {                                                       // 162
  for (var i = 0; i < builtinConverters.length; i++) {                                          // 163
    var converter = builtinConverters[i];                                                       // 164
    if (converter.matchObject(item)) {                                                          // 165
      return converter.toJSONValue(item);                                                       // 166
    }                                                                                           // 167
  }                                                                                             // 168
  return undefined;                                                                             // 169
};                                                                                              // 170
                                                                                                // 171
EJSON.toJSONValue = function (item) {                                                           // 172
  var changed = toJSONValueHelper(item);                                                        // 173
  if (changed !== undefined)                                                                    // 174
    return changed;                                                                             // 175
  if (typeof item === 'object') {                                                               // 176
    item = EJSON.clone(item);                                                                   // 177
    adjustTypesToJSONValue(item);                                                               // 178
  }                                                                                             // 179
  return item;                                                                                  // 180
};                                                                                              // 181
                                                                                                // 182
// for both arrays and objects. Tries its best to just                                          // 183
// use the object you hand it, but may return something                                         // 184
// different if the object you hand it itself needs changing.                                   // 185
//                                                                                              // 186
var adjustTypesFromJSONValue =                                                                  // 187
EJSON._adjustTypesFromJSONValue = function (obj) {                                              // 188
  if (obj === null)                                                                             // 189
    return null;                                                                                // 190
  var maybeChanged = fromJSONValueHelper(obj);                                                  // 191
  if (maybeChanged !== obj)                                                                     // 192
    return maybeChanged;                                                                        // 193
                                                                                                // 194
  // Other atoms are unchanged.                                                                 // 195
  if (typeof obj !== 'object')                                                                  // 196
    return obj;                                                                                 // 197
                                                                                                // 198
  _.each(obj, function (value, key) {                                                           // 199
    if (typeof value === 'object') {                                                            // 200
      var changed = fromJSONValueHelper(value);                                                 // 201
      if (value !== changed) {                                                                  // 202
        obj[key] = changed;                                                                     // 203
        return;                                                                                 // 204
      }                                                                                         // 205
      // if we get here, value is an object but not adjustable                                  // 206
      // at this level.  recurse.                                                               // 207
      adjustTypesFromJSONValue(value);                                                          // 208
    }                                                                                           // 209
  });                                                                                           // 210
  return obj;                                                                                   // 211
};                                                                                              // 212
                                                                                                // 213
// Either return the argument changed to have the non-json                                      // 214
// rep of itself (the Object version) or the argument itself.                                   // 215
                                                                                                // 216
// DOES NOT RECURSE.  For actually getting the fully-changed value, use                         // 217
// EJSON.fromJSONValue                                                                          // 218
var fromJSONValueHelper = function (value) {                                                    // 219
  if (typeof value === 'object' && value !== null) {                                            // 220
    if (_.size(value) <= 2                                                                      // 221
        && _.all(value, function (v, k) {                                                       // 222
          return typeof k === 'string' && k.substr(0, 1) === '$';                               // 223
        })) {                                                                                   // 224
      for (var i = 0; i < builtinConverters.length; i++) {                                      // 225
        var converter = builtinConverters[i];                                                   // 226
        if (converter.matchJSONValue(value)) {                                                  // 227
          return converter.fromJSONValue(value);                                                // 228
        }                                                                                       // 229
      }                                                                                         // 230
    }                                                                                           // 231
  }                                                                                             // 232
  return value;                                                                                 // 233
};                                                                                              // 234
                                                                                                // 235
EJSON.fromJSONValue = function (item) {                                                         // 236
  var changed = fromJSONValueHelper(item);                                                      // 237
  if (changed === item && typeof item === 'object') {                                           // 238
    item = EJSON.clone(item);                                                                   // 239
    adjustTypesFromJSONValue(item);                                                             // 240
    return item;                                                                                // 241
  } else {                                                                                      // 242
    return changed;                                                                             // 243
  }                                                                                             // 244
};                                                                                              // 245
                                                                                                // 246
EJSON.stringify = function (item, options) {                                                    // 247
  var json = EJSON.toJSONValue(item);                                                           // 248
  if (options && (options.canonical || options.indent)) {                                       // 249
    return EJSON._canonicalStringify(json, options);                                            // 250
  } else {                                                                                      // 251
    return JSON.stringify(json);                                                                // 252
  }                                                                                             // 253
};                                                                                              // 254
                                                                                                // 255
EJSON.parse = function (item) {                                                                 // 256
  if (typeof item !== 'string')                                                                 // 257
    throw new Error("EJSON.parse argument should be a string");                                 // 258
  return EJSON.fromJSONValue(JSON.parse(item));                                                 // 259
};                                                                                              // 260
                                                                                                // 261
EJSON.isBinary = function (obj) {                                                               // 262
  return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||                 // 263
    (obj && obj.$Uint8ArrayPolyfill));                                                          // 264
};                                                                                              // 265
                                                                                                // 266
EJSON.equals = function (a, b, options) {                                                       // 267
  var i;                                                                                        // 268
  var keyOrderSensitive = !!(options && options.keyOrderSensitive);                             // 269
  if (a === b)                                                                                  // 270
    return true;                                                                                // 271
  if (_.isNaN(a) && _.isNaN(b))                                                                 // 272
    return true; // This differs from the IEEE spec for NaN equality, b/c we don't want         // 273
                 // anything ever with a NaN to be poisoned from becoming equal to anything.    // 274
  if (!a || !b) // if either one is falsy, they'd have to be === to be equal                    // 275
    return false;                                                                               // 276
  if (!(typeof a === 'object' && typeof b === 'object'))                                        // 277
    return false;                                                                               // 278
  if (a instanceof Date && b instanceof Date)                                                   // 279
    return a.valueOf() === b.valueOf();                                                         // 280
  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {                                                 // 281
    if (a.length !== b.length)                                                                  // 282
      return false;                                                                             // 283
    for (i = 0; i < a.length; i++) {                                                            // 284
      if (a[i] !== b[i])                                                                        // 285
        return false;                                                                           // 286
    }                                                                                           // 287
    return true;                                                                                // 288
  }                                                                                             // 289
  if (typeof (a.equals) === 'function')                                                         // 290
    return a.equals(b, options);                                                                // 291
  if (a instanceof Array) {                                                                     // 292
    if (!(b instanceof Array))                                                                  // 293
      return false;                                                                             // 294
    if (a.length !== b.length)                                                                  // 295
      return false;                                                                             // 296
    for (i = 0; i < a.length; i++) {                                                            // 297
      if (!EJSON.equals(a[i], b[i], options))                                                   // 298
        return false;                                                                           // 299
    }                                                                                           // 300
    return true;                                                                                // 301
  }                                                                                             // 302
  // fall back to structural equality of objects                                                // 303
  var ret;                                                                                      // 304
  if (keyOrderSensitive) {                                                                      // 305
    var bKeys = [];                                                                             // 306
    _.each(b, function (val, x) {                                                               // 307
        bKeys.push(x);                                                                          // 308
    });                                                                                         // 309
    i = 0;                                                                                      // 310
    ret = _.all(a, function (val, x) {                                                          // 311
      if (i >= bKeys.length) {                                                                  // 312
        return false;                                                                           // 313
      }                                                                                         // 314
      if (x !== bKeys[i]) {                                                                     // 315
        return false;                                                                           // 316
      }                                                                                         // 317
      if (!EJSON.equals(val, b[bKeys[i]], options)) {                                           // 318
        return false;                                                                           // 319
      }                                                                                         // 320
      i++;                                                                                      // 321
      return true;                                                                              // 322
    });                                                                                         // 323
    return ret && i === bKeys.length;                                                           // 324
  } else {                                                                                      // 325
    i = 0;                                                                                      // 326
    ret = _.all(a, function (val, key) {                                                        // 327
      if (!_.has(b, key)) {                                                                     // 328
        return false;                                                                           // 329
      }                                                                                         // 330
      if (!EJSON.equals(val, b[key], options)) {                                                // 331
        return false;                                                                           // 332
      }                                                                                         // 333
      i++;                                                                                      // 334
      return true;                                                                              // 335
    });                                                                                         // 336
    return ret && _.size(b) === i;                                                              // 337
  }                                                                                             // 338
};                                                                                              // 339
                                                                                                // 340
EJSON.clone = function (v) {                                                                    // 341
  var ret;                                                                                      // 342
  if (typeof v !== "object")                                                                    // 343
    return v;                                                                                   // 344
  if (v === null)                                                                               // 345
    return null; // null has typeof "object"                                                    // 346
  if (v instanceof Date)                                                                        // 347
    return new Date(v.getTime());                                                               // 348
  if (EJSON.isBinary(v)) {                                                                      // 349
    ret = EJSON.newBinary(v.length);                                                            // 350
    for (var i = 0; i < v.length; i++) {                                                        // 351
      ret[i] = v[i];                                                                            // 352
    }                                                                                           // 353
    return ret;                                                                                 // 354
  }                                                                                             // 355
  // XXX: Use something better than underscore's isArray                                        // 356
  if (_.isArray(v) || _.isArguments(v)) {                                                       // 357
    // For some reason, _.map doesn't work in this context on Opera (weird test                 // 358
    // failures).                                                                               // 359
    ret = [];                                                                                   // 360
    for (i = 0; i < v.length; i++)                                                              // 361
      ret[i] = EJSON.clone(v[i]);                                                               // 362
    return ret;                                                                                 // 363
  }                                                                                             // 364
  // handle general user-defined typed Objects if they have a clone method                      // 365
  if (typeof v.clone === 'function') {                                                          // 366
    return v.clone();                                                                           // 367
  }                                                                                             // 368
  // handle other objects                                                                       // 369
  ret = {};                                                                                     // 370
  _.each(v, function (value, key) {                                                             // 371
    ret[key] = EJSON.clone(value);                                                              // 372
  });                                                                                           // 373
  return ret;                                                                                   // 374
};                                                                                              // 375
                                                                                                // 376
//////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                              //
// packages/ejson/stringify.js                                                                  //
//                                                                                              //
//////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                //
// Based on json2.js from https://github.com/douglascrockford/JSON-js                           // 1
//                                                                                              // 2
//    json2.js                                                                                  // 3
//    2012-10-08                                                                                // 4
//                                                                                              // 5
//    Public Domain.                                                                            // 6
//                                                                                              // 7
//    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.                                   // 8
                                                                                                // 9
function quote(string) {                                                                        // 10
  return JSON.stringify(string);                                                                // 11
}                                                                                               // 12
                                                                                                // 13
var str = function (key, holder, singleIndent, outerIndent, canonical) {                        // 14
                                                                                                // 15
  // Produce a string from holder[key].                                                         // 16
                                                                                                // 17
  var i;          // The loop counter.                                                          // 18
  var k;          // The member key.                                                            // 19
  var v;          // The member value.                                                          // 20
  var length;                                                                                   // 21
  var innerIndent = outerIndent;                                                                // 22
  var partial;                                                                                  // 23
  var value = holder[key];                                                                      // 24
                                                                                                // 25
  // What happens next depends on the value's type.                                             // 26
                                                                                                // 27
  switch (typeof value) {                                                                       // 28
  case 'string':                                                                                // 29
    return quote(value);                                                                        // 30
  case 'number':                                                                                // 31
    // JSON numbers must be finite. Encode non-finite numbers as null.                          // 32
    return isFinite(value) ? String(value) : 'null';                                            // 33
  case 'boolean':                                                                               // 34
    return String(value);                                                                       // 35
  // If the type is 'object', we might be dealing with an object or an array or                 // 36
  // null.                                                                                      // 37
  case 'object':                                                                                // 38
    // Due to a specification blunder in ECMAScript, typeof null is 'object',                   // 39
    // so watch out for that case.                                                              // 40
    if (!value) {                                                                               // 41
      return 'null';                                                                            // 42
    }                                                                                           // 43
    // Make an array to hold the partial results of stringifying this object value.             // 44
    innerIndent = outerIndent + singleIndent;                                                   // 45
    partial = [];                                                                               // 46
                                                                                                // 47
    // Is the value an array?                                                                   // 48
    if (_.isArray(value) || _.isArguments(value)) {                                             // 49
                                                                                                // 50
      // The value is an array. Stringify every element. Use null as a placeholder              // 51
      // for non-JSON values.                                                                   // 52
                                                                                                // 53
      length = value.length;                                                                    // 54
      for (i = 0; i < length; i += 1) {                                                         // 55
        partial[i] = str(i, value, singleIndent, innerIndent, canonical) || 'null';             // 56
      }                                                                                         // 57
                                                                                                // 58
      // Join all of the elements together, separated with commas, and wrap them in             // 59
      // brackets.                                                                              // 60
                                                                                                // 61
      if (partial.length === 0) {                                                               // 62
        v = '[]';                                                                               // 63
      } else if (innerIndent) {                                                                 // 64
        v = '[\n' + innerIndent + partial.join(',\n' + innerIndent) + '\n' + outerIndent + ']'; // 65
      } else {                                                                                  // 66
        v = '[' + partial.join(',') + ']';                                                      // 67
      }                                                                                         // 68
      return v;                                                                                 // 69
    }                                                                                           // 70
                                                                                                // 71
                                                                                                // 72
    // Iterate through all of the keys in the object.                                           // 73
    var keys = _.keys(value);                                                                   // 74
    if (canonical)                                                                              // 75
      keys = keys.sort();                                                                       // 76
    _.each(keys, function (k) {                                                                 // 77
      v = str(k, value, singleIndent, innerIndent, canonical);                                  // 78
      if (v) {                                                                                  // 79
        partial.push(quote(k) + (innerIndent ? ': ' : ':') + v);                                // 80
      }                                                                                         // 81
    });                                                                                         // 82
                                                                                                // 83
                                                                                                // 84
    // Join all of the member texts together, separated with commas,                            // 85
    // and wrap them in braces.                                                                 // 86
                                                                                                // 87
    if (partial.length === 0) {                                                                 // 88
      v = '{}';                                                                                 // 89
    } else if (innerIndent) {                                                                   // 90
      v = '{\n' + innerIndent + partial.join(',\n' + innerIndent) + '\n' + outerIndent + '}';   // 91
    } else {                                                                                    // 92
      v = '{' + partial.join(',') + '}';                                                        // 93
    }                                                                                           // 94
    return v;                                                                                   // 95
  }                                                                                             // 96
}                                                                                               // 97
                                                                                                // 98
// If the JSON object does not yet have a stringify method, give it one.                        // 99
                                                                                                // 100
EJSON._canonicalStringify = function (value, options) {                                         // 101
  // Make a fake root object containing our value under the key of ''.                          // 102
  // Return the result of stringifying the value.                                               // 103
  options = _.extend({                                                                          // 104
    indent: "",                                                                                 // 105
    canonical: false                                                                            // 106
  }, options);                                                                                  // 107
  if (options.indent === true) {                                                                // 108
    options.indent = "  ";                                                                      // 109
  } else if (typeof options.indent === 'number') {                                              // 110
    var newIndent = "";                                                                         // 111
    for (var i = 0; i < options.indent; i++) {                                                  // 112
      newIndent += ' ';                                                                         // 113
    }                                                                                           // 114
    options.indent = newIndent;                                                                 // 115
  }                                                                                             // 116
  return str('', {'': value}, options.indent, "", options.canonical);                           // 117
};                                                                                              // 118
                                                                                                // 119
//////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                              //
// packages/ejson/base64.js                                                                     //
//                                                                                              //
//////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                //
// Base 64 encoding                                                                             // 1
                                                                                                // 2
var BASE_64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";         // 3
                                                                                                // 4
var BASE_64_VALS = {};                                                                          // 5
                                                                                                // 6
for (var i = 0; i < BASE_64_CHARS.length; i++) {                                                // 7
  BASE_64_VALS[BASE_64_CHARS.charAt(i)] = i;                                                    // 8
};                                                                                              // 9
                                                                                                // 10
base64Encode = function (array) {                                                               // 11
  var answer = [];                                                                              // 12
  var a = null;                                                                                 // 13
  var b = null;                                                                                 // 14
  var c = null;                                                                                 // 15
  var d = null;                                                                                 // 16
  for (var i = 0; i < array.length; i++) {                                                      // 17
    switch (i % 3) {                                                                            // 18
    case 0:                                                                                     // 19
      a = (array[i] >> 2) & 0x3F;                                                               // 20
      b = (array[i] & 0x03) << 4;                                                               // 21
      break;                                                                                    // 22
    case 1:                                                                                     // 23
      b = b | (array[i] >> 4) & 0xF;                                                            // 24
      c = (array[i] & 0xF) << 2;                                                                // 25
      break;                                                                                    // 26
    case 2:                                                                                     // 27
      c = c | (array[i] >> 6) & 0x03;                                                           // 28
      d = array[i] & 0x3F;                                                                      // 29
      answer.push(getChar(a));                                                                  // 30
      answer.push(getChar(b));                                                                  // 31
      answer.push(getChar(c));                                                                  // 32
      answer.push(getChar(d));                                                                  // 33
      a = null;                                                                                 // 34
      b = null;                                                                                 // 35
      c = null;                                                                                 // 36
      d = null;                                                                                 // 37
      break;                                                                                    // 38
    }                                                                                           // 39
  }                                                                                             // 40
  if (a != null) {                                                                              // 41
    answer.push(getChar(a));                                                                    // 42
    answer.push(getChar(b));                                                                    // 43
    if (c == null)                                                                              // 44
      answer.push('=');                                                                         // 45
    else                                                                                        // 46
      answer.push(getChar(c));                                                                  // 47
    if (d == null)                                                                              // 48
      answer.push('=');                                                                         // 49
  }                                                                                             // 50
  return answer.join("");                                                                       // 51
};                                                                                              // 52
                                                                                                // 53
var getChar = function (val) {                                                                  // 54
  return BASE_64_CHARS.charAt(val);                                                             // 55
};                                                                                              // 56
                                                                                                // 57
var getVal = function (ch) {                                                                    // 58
  if (ch === '=') {                                                                             // 59
    return -1;                                                                                  // 60
  }                                                                                             // 61
  return BASE_64_VALS[ch];                                                                      // 62
};                                                                                              // 63
                                                                                                // 64
EJSON.newBinary = function (len) {                                                              // 65
  if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined') {                // 66
    var ret = [];                                                                               // 67
    for (var i = 0; i < len; i++) {                                                             // 68
      ret.push(0);                                                                              // 69
    }                                                                                           // 70
    ret.$Uint8ArrayPolyfill = true;                                                             // 71
    return ret;                                                                                 // 72
  }                                                                                             // 73
  return new Uint8Array(new ArrayBuffer(len));                                                  // 74
};                                                                                              // 75
                                                                                                // 76
base64Decode = function (str) {                                                                 // 77
  var len = Math.floor((str.length*3)/4);                                                       // 78
  if (str.charAt(str.length - 1) == '=') {                                                      // 79
    len--;                                                                                      // 80
    if (str.charAt(str.length - 2) == '=')                                                      // 81
      len--;                                                                                    // 82
  }                                                                                             // 83
  var arr = EJSON.newBinary(len);                                                               // 84
                                                                                                // 85
  var one = null;                                                                               // 86
  var two = null;                                                                               // 87
  var three = null;                                                                             // 88
                                                                                                // 89
  var j = 0;                                                                                    // 90
                                                                                                // 91
  for (var i = 0; i < str.length; i++) {                                                        // 92
    var c = str.charAt(i);                                                                      // 93
    var v = getVal(c);                                                                          // 94
    switch (i % 4) {                                                                            // 95
    case 0:                                                                                     // 96
      if (v < 0)                                                                                // 97
        throw new Error('invalid base64 string');                                               // 98
      one = v << 2;                                                                             // 99
      break;                                                                                    // 100
    case 1:                                                                                     // 101
      if (v < 0)                                                                                // 102
        throw new Error('invalid base64 string');                                               // 103
      one = one | (v >> 4);                                                                     // 104
      arr[j++] = one;                                                                           // 105
      two = (v & 0x0F) << 4;                                                                    // 106
      break;                                                                                    // 107
    case 2:                                                                                     // 108
      if (v >= 0) {                                                                             // 109
        two = two | (v >> 2);                                                                   // 110
        arr[j++] = two;                                                                         // 111
        three = (v & 0x03) << 6;                                                                // 112
      }                                                                                         // 113
      break;                                                                                    // 114
    case 3:                                                                                     // 115
      if (v >= 0) {                                                                             // 116
        arr[j++] = three | v;                                                                   // 117
      }                                                                                         // 118
      break;                                                                                    // 119
    }                                                                                           // 120
  }                                                                                             // 121
  return arr;                                                                                   // 122
};                                                                                              // 123
                                                                                                // 124
EJSONTest.base64Encode = base64Encode;                                                          // 125
                                                                                                // 126
EJSONTest.base64Decode = base64Decode;                                                          // 127
                                                                                                // 128
//////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.ejson = {
  EJSON: EJSON,
  EJSONTest: EJSONTest
};

})();

//# sourceMappingURL=6b96257c000bbb949b0e65eaacceeecba5bf84c6.map


//--------- logging.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var EJSON = Package.ejson.EJSON;

/* Package-scope variables */
var Log;

(function () {

/////////////////////////////////////////////////////////////////////////////////////////
//                                                                                     //
// packages/logging/logging.js                                                         //
//                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////
                                                                                       //
Log = function () {                                                                    // 1
  return Log.info.apply(this, arguments);                                              // 2
};                                                                                     // 3
                                                                                       // 4
/// FOR TESTING                                                                        // 5
var intercept = 0;                                                                     // 6
var interceptedLines = [];                                                             // 7
var suppress = 0;                                                                      // 8
                                                                                       // 9
// Intercept the next 'count' calls to a Log function. The actual                      // 10
// lines printed to the console can be cleared and read by calling                     // 11
// Log._intercepted().                                                                 // 12
Log._intercept = function (count) {                                                    // 13
  intercept += count;                                                                  // 14
};                                                                                     // 15
                                                                                       // 16
// Suppress the next 'count' calls to a Log function. Use this to stop                 // 17
// tests from spamming the console, especially with red errors that                    // 18
// might look like a failing test.                                                     // 19
Log._suppress = function (count) {                                                     // 20
  suppress += count;                                                                   // 21
};                                                                                     // 22
                                                                                       // 23
// Returns intercepted lines and resets the intercept counter.                         // 24
Log._intercepted = function () {                                                       // 25
  var lines = interceptedLines;                                                        // 26
  interceptedLines = [];                                                               // 27
  intercept = 0;                                                                       // 28
  return lines;                                                                        // 29
};                                                                                     // 30
                                                                                       // 31
// Either 'json' or 'colored-text'.                                                    // 32
//                                                                                     // 33
// When this is set to 'json', print JSON documents that are parsed by another         // 34
// process ('satellite' or 'meteor run'). This other process should call               // 35
// 'Log.format' for nice output.                                                       // 36
//                                                                                     // 37
// When this is set to 'colored-text', call 'Log.format' before printing.              // 38
// This should be used for logging from within satellite, since there is no            // 39
// other process that will be reading its standard output.                             // 40
Log.outputFormat = 'json';                                                             // 41
                                                                                       // 42
var LEVEL_COLORS = {                                                                   // 43
  debug: 'green',                                                                      // 44
  // leave info as the default color                                                   // 45
  warn: 'magenta',                                                                     // 46
  error: 'red'                                                                         // 47
};                                                                                     // 48
                                                                                       // 49
var META_COLOR = 'blue';                                                               // 50
                                                                                       // 51
// XXX package                                                                         // 52
var RESTRICTED_KEYS = ['time', 'timeInexact', 'level', 'file', 'line',                 // 53
                        'program', 'originApp', 'satellite', 'stderr'];                // 54
                                                                                       // 55
var FORMATTED_KEYS = RESTRICTED_KEYS.concat(['app', 'message']);                       // 56
                                                                                       // 57
var logInBrowser = function (obj) {                                                    // 58
  var str = Log.format(obj);                                                           // 59
                                                                                       // 60
  // XXX Some levels should be probably be sent to the server                          // 61
  var level = obj.level;                                                               // 62
                                                                                       // 63
  if ((typeof console !== 'undefined') && console[level]) {                            // 64
    console[level](str);                                                               // 65
  } else {                                                                             // 66
    // XXX Uses of Meteor._debug should probably be replaced by Log.debug or           // 67
    //     Log.info, and we should have another name for "do your best to              // 68
    //     call call console.log".                                                     // 69
    Meteor._debug(str);                                                                // 70
  }                                                                                    // 71
};                                                                                     // 72
                                                                                       // 73
// @returns {Object: { line: Number, file: String }}                                   // 74
Log._getCallerDetails = function () {                                                  // 75
  var getStack = function () {                                                         // 76
    // We do NOT use Error.prepareStackTrace here (a V8 extension that gets us a       // 77
    // pre-parsed stack) since it's impossible to compose it with the use of           // 78
    // Error.prepareStackTrace used on the server for source maps.                     // 79
    var err = new Error;                                                               // 80
    var stack = err.stack;                                                             // 81
    return stack;                                                                      // 82
  };                                                                                   // 83
                                                                                       // 84
  var stack = getStack();                                                              // 85
                                                                                       // 86
  if (!stack) return {};                                                               // 87
                                                                                       // 88
  var lines = stack.split('\n');                                                       // 89
                                                                                       // 90
  // looking for the first line outside the logging package (or an                     // 91
  // eval if we find that first)                                                       // 92
  var line;                                                                            // 93
  for (var i = 1; i < lines.length; ++i) {                                             // 94
    line = lines[i];                                                                   // 95
    if (line.match(/^\s*at eval \(eval/)) {                                            // 96
      return {file: "eval"};                                                           // 97
    }                                                                                  // 98
                                                                                       // 99
    // XXX probably wants to be / or .js in case no source maps                        // 100
    if (!line.match(/packages\/logging(?:\/|(?::tests)?\.js)/))                        // 101
      break;                                                                           // 102
  }                                                                                    // 103
                                                                                       // 104
  var details = {};                                                                    // 105
                                                                                       // 106
  // The format for FF is 'functionName@filePath:lineNumber'                           // 107
  // The format for V8 is 'functionName (packages/logging/logging.js:81)' or           // 108
  //                      'packages/logging/logging.js:81'                             // 109
  var match = /(?:[@(]| at )([^(]+?):([0-9:]+)(?:\)|$)/.exec(line);                    // 110
  if (!match)                                                                          // 111
    return details;                                                                    // 112
  // in case the matched block here is line:column                                     // 113
  details.line = match[2].split(':')[0];                                               // 114
                                                                                       // 115
  // Possible format: https://foo.bar.com/scripts/file.js?random=foobar                // 116
  // XXX: if you can write the following in better way, please do it                   // 117
  // XXX: what about evals?                                                            // 118
  details.file = match[1].split('/').slice(-1)[0].split('?')[0];                       // 119
                                                                                       // 120
  return details;                                                                      // 121
};                                                                                     // 122
                                                                                       // 123
_.each(['debug', 'info', 'warn', 'error'], function (level) {                          // 124
  // @param arg {String|Object}                                                        // 125
  Log[level] = function (arg) {                                                        // 126
    if (suppress) {                                                                    // 127
      suppress--;                                                                      // 128
      return;                                                                          // 129
    }                                                                                  // 130
                                                                                       // 131
    var intercepted = false;                                                           // 132
    if (intercept) {                                                                   // 133
      intercept--;                                                                     // 134
      intercepted = true;                                                              // 135
    }                                                                                  // 136
                                                                                       // 137
    var obj = (_.isObject(arg) && !_.isRegExp(arg) && !_.isDate(arg) ) ?               // 138
              arg : {message: new String(arg).toString() };                            // 139
                                                                                       // 140
    _.each(RESTRICTED_KEYS, function (key) {                                           // 141
      if (obj[key])                                                                    // 142
        throw new Error("Can't set '" + key + "' in log message");                     // 143
    });                                                                                // 144
                                                                                       // 145
    if (_.has(obj, 'message') && !_.isString(obj.message))                             // 146
      throw new Error("The 'message' field in log objects must be a string");          // 147
                                                                                       // 148
    obj = _.extend(Log._getCallerDetails(), obj);                                      // 149
    obj.time = new Date();                                                             // 150
    obj.level = level;                                                                 // 151
                                                                                       // 152
    // XXX allow you to enable 'debug', probably per-package                           // 153
    if (level === 'debug')                                                             // 154
      return;                                                                          // 155
                                                                                       // 156
    if (intercepted) {                                                                 // 157
      interceptedLines.push(EJSON.stringify(obj));                                     // 158
    } else if (Meteor.isServer) {                                                      // 159
      if (Log.outputFormat === 'colored-text') {                                       // 160
        console.log(Log.format(obj, {color: true}));                                   // 161
      } else if (Log.outputFormat === 'json') {                                        // 162
        console.log(EJSON.stringify(obj));                                             // 163
      } else {                                                                         // 164
        throw new Error("Unknown logging output format: " + Log.outputFormat);         // 165
      }                                                                                // 166
    } else {                                                                           // 167
      logInBrowser(obj);                                                               // 168
    }                                                                                  // 169
  };                                                                                   // 170
});                                                                                    // 171
                                                                                       // 172
// tries to parse line as EJSON. returns object if parse is successful, or null if not // 173
Log.parse = function (line) {                                                          // 174
  var obj = null;                                                                      // 175
  if (line && line.charAt(0) === '{') { // might be json generated from calling 'Log'  // 176
    try { obj = EJSON.parse(line); } catch (e) {}                                      // 177
  }                                                                                    // 178
                                                                                       // 179
  // XXX should probably check fields other than 'time'                                // 180
  if (obj && obj.time && (obj.time instanceof Date))                                   // 181
    return obj;                                                                        // 182
  else                                                                                 // 183
    return null;                                                                       // 184
};                                                                                     // 185
                                                                                       // 186
// formats a log object into colored human and machine-readable text                   // 187
Log.format = function (obj, options) {                                                 // 188
  obj = EJSON.clone(obj); // don't mutate the argument                                 // 189
  options = options || {};                                                             // 190
                                                                                       // 191
  var time = obj.time;                                                                 // 192
  if (!(time instanceof Date))                                                         // 193
    throw new Error("'time' must be a Date object");                                   // 194
  var timeInexact = obj.timeInexact;                                                   // 195
                                                                                       // 196
  // store fields that are in FORMATTED_KEYS since we strip them                       // 197
  var level = obj.level || 'info';                                                     // 198
  var file = obj.file;                                                                 // 199
  var lineNumber = obj.line;                                                           // 200
  var appName = obj.app || '';                                                         // 201
  var originApp = obj.originApp;                                                       // 202
  var message = obj.message || '';                                                     // 203
  var program = obj.program || '';                                                     // 204
  var satellite = obj.satellite;                                                       // 205
  var stderr = obj.stderr || '';                                                       // 206
                                                                                       // 207
  _.each(FORMATTED_KEYS, function(key) {                                               // 208
    delete obj[key];                                                                   // 209
  });                                                                                  // 210
                                                                                       // 211
  if (!_.isEmpty(obj)) {                                                               // 212
    if (message) message += " ";                                                       // 213
    message += EJSON.stringify(obj);                                                   // 214
  }                                                                                    // 215
                                                                                       // 216
  var pad2 = function(n) { return n < 10 ? '0' + n : n.toString(); };                  // 217
  var pad3 = function(n) { return n < 100 ? '0' + pad2(n) : n.toString(); };           // 218
                                                                                       // 219
  var dateStamp = time.getFullYear().toString() +                                      // 220
    pad2(time.getMonth() + 1 /*0-based*/) +                                            // 221
    pad2(time.getDate());                                                              // 222
  var timeStamp = pad2(time.getHours()) +                                              // 223
        ':' +                                                                          // 224
        pad2(time.getMinutes()) +                                                      // 225
        ':' +                                                                          // 226
        pad2(time.getSeconds()) +                                                      // 227
        '.' +                                                                          // 228
        pad3(time.getMilliseconds());                                                  // 229
                                                                                       // 230
  // eg in San Francisco in June this will be '(-7)'                                   // 231
  var utcOffsetStr = '(' + (-(new Date().getTimezoneOffset() / 60)) + ')';             // 232
                                                                                       // 233
  var appInfo = '';                                                                    // 234
  if (appName) appInfo += appName;                                                     // 235
  if (originApp && originApp !== appName) appInfo += ' via ' + originApp;              // 236
  if (appInfo) appInfo = '[' + appInfo + '] ';                                         // 237
                                                                                       // 238
  var sourceInfo = (file && lineNumber) ?                                              // 239
      ['(', (program ? program + ':' : ''), file, ':', lineNumber, ') '].join('')      // 240
      : '';                                                                            // 241
                                                                                       // 242
  if (satellite)                                                                       // 243
    sourceInfo += ['[', satellite, ']'].join('');                                      // 244
                                                                                       // 245
  var stderrIndicator = stderr ? '(STDERR) ' : '';                                     // 246
                                                                                       // 247
  var metaPrefix = [                                                                   // 248
    level.charAt(0).toUpperCase(),                                                     // 249
    dateStamp,                                                                         // 250
    '-',                                                                               // 251
    timeStamp,                                                                         // 252
    utcOffsetStr,                                                                      // 253
    timeInexact ? '? ' : ' ',                                                          // 254
    appInfo,                                                                           // 255
    sourceInfo,                                                                        // 256
    stderrIndicator].join('');                                                         // 257
                                                                                       // 258
  var prettify = function (line, color) {                                              // 259
    return (options.color && Meteor.isServer && color) ?                               // 260
      Npm.require('cli-color')[color](line) : line;                                    // 261
  };                                                                                   // 262
                                                                                       // 263
  return prettify(metaPrefix, META_COLOR)                                              // 264
    + prettify(message, LEVEL_COLORS[level]);                                          // 265
};                                                                                     // 266
                                                                                       // 267
// Turn a line of text into a loggable object.                                         // 268
// @param line {String}                                                                // 269
// @param override {Object}                                                            // 270
Log.objFromText = function (line, override) {                                          // 271
  var obj = {message: line, level: "info", time: new Date(), timeInexact: true};       // 272
  return _.extend(obj, override);                                                      // 273
};                                                                                     // 274
                                                                                       // 275
/////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.logging = {
  Log: Log
};

})();

//# sourceMappingURL=0b5bf4a50ca23ebf02c29f1243437e173a6b6c1a.map


//--------- reload.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var Log = Package.logging.Log;
var JSON = Package.json.JSON;

/* Package-scope variables */
var Reload;

(function () {

///////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                           //
// packages/reload/reload.js                                                                 //
//                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////
                                                                                             //
/**                                                                                          // 1
 * This code does _NOT_ support hot (session-restoring) reloads on                           // 2
 * IE6,7. It only works on browsers with sessionStorage support.                             // 3
 *                                                                                           // 4
 * There are a couple approaches to add IE6,7 support:                                       // 5
 *                                                                                           // 6
 * - use IE's "userData" mechanism in combination with window.name.                          // 7
 * This mostly works, however the problem is that it can not get to the                      // 8
 * data until after DOMReady. This is a problem for us since this API                        // 9
 * relies on the data being ready before API users run. We could                             // 10
 * refactor using Meteor.startup in all API users, but that might slow                       // 11
 * page loads as we couldn't start the stream until after DOMReady.                          // 12
 * Here are some resources on this approach:                                                 // 13
 * https://github.com/hugeinc/USTORE.js                                                      // 14
 * http://thudjs.tumblr.com/post/419577524/localstorage-userdata                             // 15
 * http://www.javascriptkit.com/javatutors/domstorage2.shtml                                 // 16
 *                                                                                           // 17
 * - POST the data to the server, and have the server send it back on                        // 18
 * page load. This is nice because it sidesteps all the local storage                        // 19
 * compatibility issues, however it is kinda tricky. We can use a unique                     // 20
 * token in the URL, then get rid of it with HTML5 pushstate, but that                       // 21
 * only works on pushstate browsers.                                                         // 22
 *                                                                                           // 23
 * This will all need to be reworked entirely when we add server-side                        // 24
 * HTML rendering. In that case, the server will need to have access to                      // 25
 * the client's session to render properly.                                                  // 26
 */                                                                                          // 27
                                                                                             // 28
// XXX when making this API public, also expose a flag for the app                           // 29
// developer to know whether a hot code push is happening. This is                           // 30
// useful for apps using `window.onbeforeunload`. See                                        // 31
// https://github.com/meteor/meteor/pull/657                                                 // 32
                                                                                             // 33
var KEY_NAME = 'Meteor_Reload';                                                              // 34
// after how long should we consider this no longer an automatic                             // 35
// reload, but a fresh restart. This only happens if a reload is                             // 36
// interrupted and a user manually restarts things. The only time                            // 37
// this is really weird is if a user navigates away mid-refresh,                             // 38
// then manually navigates back to the page.                                                 // 39
var TIMEOUT = 30000;                                                                         // 40
                                                                                             // 41
                                                                                             // 42
var old_data = {};                                                                           // 43
// read in old data at startup.                                                              // 44
var old_json;                                                                                // 45
// On Firefox with dom.storage.enabled set to false, sessionStorage is null,                 // 46
// so we have to both check to see if it is defined and not null.                            // 47
if (typeof sessionStorage !== "undefined" && sessionStorage) {                               // 48
  old_json = sessionStorage.getItem(KEY_NAME);                                               // 49
  sessionStorage.removeItem(KEY_NAME);                                                       // 50
} else {                                                                                     // 51
  // Unsupported browser (IE 6,7). No session resumption.                                    // 52
  // Meteor._debug("XXX UNSUPPORTED BROWSER");                                               // 53
}                                                                                            // 54
                                                                                             // 55
if (!old_json) old_json = '{}';                                                              // 56
var old_parsed = {};                                                                         // 57
try {                                                                                        // 58
  old_parsed = JSON.parse(old_json);                                                         // 59
  if (typeof old_parsed !== "object") {                                                      // 60
    Meteor._debug("Got bad data on reload. Ignoring.");                                      // 61
    old_parsed = {};                                                                         // 62
  }                                                                                          // 63
} catch (err) {                                                                              // 64
  Meteor._debug("Got invalid JSON on reload. Ignoring.");                                    // 65
}                                                                                            // 66
                                                                                             // 67
if (old_parsed.reload && typeof old_parsed.data === "object" &&                              // 68
    old_parsed.time + TIMEOUT > (new Date()).getTime()) {                                    // 69
  // Meteor._debug("Restoring reload data.");                                                // 70
  old_data = old_parsed.data;                                                                // 71
}                                                                                            // 72
                                                                                             // 73
                                                                                             // 74
var providers = [];                                                                          // 75
                                                                                             // 76
////////// External API //////////                                                           // 77
                                                                                             // 78
Reload = {};                                                                                 // 79
                                                                                             // 80
// Packages that support migration should register themselves by                             // 81
// calling this function. When it's time to migrate, callback will                           // 82
// be called with one argument, the "retry function." If the package                         // 83
// is ready to migrate, it should return [true, data], where data is                         // 84
// its migration data, an arbitrary JSON value (or [true] if it has                          // 85
// no migration data this time). If the package needs more time                              // 86
// before it is ready to migrate, it should return false. Then, once                         // 87
// it is ready to migrating again, it should call the retry                                  // 88
// function. The retry function will return immediately, but will                            // 89
// schedule the migration to be retried, meaning that every package                          // 90
// will be polled once again for its migration data. If they are all                         // 91
// ready this time, then the migration will happen. name must be set if there                // 92
// is migration data.                                                                        // 93
//                                                                                           // 94
Reload._onMigrate = function (name, callback) {                                              // 95
  if (!callback) {                                                                           // 96
    // name not provided, so first arg is callback.                                          // 97
    callback = name;                                                                         // 98
    name = undefined;                                                                        // 99
  }                                                                                          // 100
  providers.push({name: name, callback: callback});                                          // 101
};                                                                                           // 102
                                                                                             // 103
// Called by packages when they start up.                                                    // 104
// Returns the object that was saved, or undefined if none saved.                            // 105
//                                                                                           // 106
Reload._migrationData = function (name) {                                                    // 107
  return old_data[name];                                                                     // 108
};                                                                                           // 109
                                                                                             // 110
// Migrating reload: reload this page (presumably to pick up a new                           // 111
// version of the code or assets), but save the program state and                            // 112
// migrate it over. This function returns immediately. The reload                            // 113
// will happen at some point in the future once all of the packages                          // 114
// are ready to migrate.                                                                     // 115
//                                                                                           // 116
var reloading = false;                                                                       // 117
Reload._reload = function () {                                                               // 118
  if (reloading)                                                                             // 119
    return;                                                                                  // 120
  reloading = true;                                                                          // 121
                                                                                             // 122
  var tryReload = function () { _.defer(function () {                                        // 123
    // Make sure each package is ready to go, and collect their                              // 124
    // migration data                                                                        // 125
    var migrationData = {};                                                                  // 126
    var remaining = _.clone(providers);                                                      // 127
    while (remaining.length) {                                                               // 128
      var p = remaining.shift();                                                             // 129
      var status = p.callback(tryReload);                                                    // 130
      if (!status[0])                                                                        // 131
        return; // not ready yet..                                                           // 132
      if (status.length > 1 && p.name)                                                       // 133
        migrationData[p.name] = status[1];                                                   // 134
    };                                                                                       // 135
                                                                                             // 136
    try {                                                                                    // 137
      // Persist the migration data                                                          // 138
      var json = JSON.stringify({                                                            // 139
        time: (new Date()).getTime(), data: migrationData, reload: true                      // 140
      });                                                                                    // 141
    } catch (err) {                                                                          // 142
      Meteor._debug("Couldn't serialize data for migration", migrationData);                 // 143
      throw err;                                                                             // 144
    }                                                                                        // 145
                                                                                             // 146
    if (typeof sessionStorage !== "undefined" && sessionStorage) {                           // 147
      sessionStorage.setItem(KEY_NAME, json);                                                // 148
    } else {                                                                                 // 149
      Meteor._debug("Browser does not support sessionStorage. Not saving migration state."); // 150
    }                                                                                        // 151
                                                                                             // 152
    // Tell the browser to shut down this VM and make a new one                              // 153
    window.location.reload();                                                                // 154
  }); };                                                                                     // 155
                                                                                             // 156
  tryReload();                                                                               // 157
};                                                                                           // 158
                                                                                             // 159
///////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                           //
// packages/reload/deprecated.js                                                             //
//                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////
                                                                                             //
// Reload functionality used to live on Meteor._reload. Be nice and try not to               // 1
// break code that uses it, even though it's internal.                                       // 2
// XXX COMPAT WITH 0.6.4                                                                     // 3
Meteor._reload = {                                                                           // 4
  onMigrate: Reload._onMigrate,                                                              // 5
  migrationData: Reload._migrationData,                                                      // 6
  reload: Reload._reload                                                                     // 7
};                                                                                           // 8
                                                                                             // 9
///////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.reload = {
  Reload: Reload
};

})();

//# sourceMappingURL=8495281f1e90298939d33611f64cb97609664269.map


//--------- deps.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;

/* Package-scope variables */
var Deps;

(function () {

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// packages/deps/deps.js                                                        //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////
                                                                                //
//////////////////////////////////////////////////                              // 1
// Package docs at http://docs.meteor.com/#deps //                              // 2
//////////////////////////////////////////////////                              // 3
                                                                                // 4
Deps = {};                                                                      // 5
                                                                                // 6
// http://docs.meteor.com/#deps_active                                          // 7
Deps.active = false;                                                            // 8
                                                                                // 9
// http://docs.meteor.com/#deps_currentcomputation                              // 10
Deps.currentComputation = null;                                                 // 11
                                                                                // 12
var setCurrentComputation = function (c) {                                      // 13
  Deps.currentComputation = c;                                                  // 14
  Deps.active = !! c;                                                           // 15
};                                                                              // 16
                                                                                // 17
var _debugFunc = function () {                                                  // 18
  // lazy evaluation because `Meteor` does not exist right away                 // 19
  return (typeof Meteor !== "undefined" ? Meteor._debug :                       // 20
          ((typeof console !== "undefined") && console.log ? console.log :      // 21
           function () {}));                                                    // 22
};                                                                              // 23
                                                                                // 24
var nextId = 1;                                                                 // 25
// computations whose callbacks we should call at flush time                    // 26
var pendingComputations = [];                                                   // 27
// `true` if a Deps.flush is scheduled, or if we are in Deps.flush now          // 28
var willFlush = false;                                                          // 29
// `true` if we are in Deps.flush now                                           // 30
var inFlush = false;                                                            // 31
// `true` if we are computing a computation now, either first time              // 32
// or recompute.  This matches Deps.active unless we are inside                 // 33
// Deps.nonreactive, which nullfies currentComputation even though              // 34
// an enclosing computation may still be running.                               // 35
var inCompute = false;                                                          // 36
                                                                                // 37
var afterFlushCallbacks = [];                                                   // 38
                                                                                // 39
var requireFlush = function () {                                                // 40
  if (! willFlush) {                                                            // 41
    setTimeout(Deps.flush, 0);                                                  // 42
    willFlush = true;                                                           // 43
  }                                                                             // 44
};                                                                              // 45
                                                                                // 46
// Deps.Computation constructor is visible but private                          // 47
// (throws an error if you try to call it)                                      // 48
var constructingComputation = false;                                            // 49
                                                                                // 50
//                                                                              // 51
// http://docs.meteor.com/#deps_computation                                     // 52
//                                                                              // 53
Deps.Computation = function (f, parent) {                                       // 54
  if (! constructingComputation)                                                // 55
    throw new Error(                                                            // 56
      "Deps.Computation constructor is private; use Deps.autorun");             // 57
  constructingComputation = false;                                              // 58
                                                                                // 59
  var self = this;                                                              // 60
                                                                                // 61
  // http://docs.meteor.com/#computation_stopped                                // 62
  self.stopped = false;                                                         // 63
                                                                                // 64
  // http://docs.meteor.com/#computation_invalidated                            // 65
  self.invalidated = false;                                                     // 66
                                                                                // 67
  // http://docs.meteor.com/#computation_firstrun                               // 68
  self.firstRun = true;                                                         // 69
                                                                                // 70
  self._id = nextId++;                                                          // 71
  self._onInvalidateCallbacks = [];                                             // 72
  // the plan is at some point to use the parent relation                       // 73
  // to constrain the order that computations are processed                     // 74
  self._parent = parent;                                                        // 75
  self._func = f;                                                               // 76
  self._recomputing = false;                                                    // 77
                                                                                // 78
  var errored = true;                                                           // 79
  try {                                                                         // 80
    self._compute();                                                            // 81
    errored = false;                                                            // 82
  } finally {                                                                   // 83
    self.firstRun = false;                                                      // 84
    if (errored)                                                                // 85
      self.stop();                                                              // 86
  }                                                                             // 87
};                                                                              // 88
                                                                                // 89
_.extend(Deps.Computation.prototype, {                                          // 90
                                                                                // 91
  // http://docs.meteor.com/#computation_oninvalidate                           // 92
  onInvalidate: function (f) {                                                  // 93
    var self = this;                                                            // 94
                                                                                // 95
    if (typeof f !== 'function')                                                // 96
      throw new Error("onInvalidate requires a function");                      // 97
                                                                                // 98
    var g = function () {                                                       // 99
      Deps.nonreactive(function () {                                            // 100
        f(self);                                                                // 101
      });                                                                       // 102
    };                                                                          // 103
                                                                                // 104
    if (self.invalidated)                                                       // 105
      g();                                                                      // 106
    else                                                                        // 107
      self._onInvalidateCallbacks.push(g);                                      // 108
  },                                                                            // 109
                                                                                // 110
  // http://docs.meteor.com/#computation_invalidate                             // 111
  invalidate: function () {                                                     // 112
    var self = this;                                                            // 113
    if (! self.invalidated) {                                                   // 114
      // if we're currently in _recompute(), don't enqueue                      // 115
      // ourselves, since we'll rerun immediately anyway.                       // 116
      if (! self._recomputing && ! self.stopped) {                              // 117
        requireFlush();                                                         // 118
        pendingComputations.push(this);                                         // 119
      }                                                                         // 120
                                                                                // 121
      self.invalidated = true;                                                  // 122
                                                                                // 123
      // callbacks can't add callbacks, because                                 // 124
      // self.invalidated === true.                                             // 125
      for(var i = 0, f; f = self._onInvalidateCallbacks[i]; i++)                // 126
        f(); // already bound with self as argument                             // 127
      self._onInvalidateCallbacks = [];                                         // 128
    }                                                                           // 129
  },                                                                            // 130
                                                                                // 131
  // http://docs.meteor.com/#computation_stop                                   // 132
  stop: function () {                                                           // 133
    if (! this.stopped) {                                                       // 134
      this.stopped = true;                                                      // 135
      this.invalidate();                                                        // 136
    }                                                                           // 137
  },                                                                            // 138
                                                                                // 139
  _compute: function () {                                                       // 140
    var self = this;                                                            // 141
    self.invalidated = false;                                                   // 142
                                                                                // 143
    var previous = Deps.currentComputation;                                     // 144
    setCurrentComputation(self);                                                // 145
    var previousInCompute = inCompute;                                          // 146
    inCompute = true;                                                           // 147
    try {                                                                       // 148
      self._func(self);                                                         // 149
    } finally {                                                                 // 150
      setCurrentComputation(previous);                                          // 151
      inCompute = false;                                                        // 152
    }                                                                           // 153
  },                                                                            // 154
                                                                                // 155
  _recompute: function () {                                                     // 156
    var self = this;                                                            // 157
                                                                                // 158
    self._recomputing = true;                                                   // 159
    while (self.invalidated && ! self.stopped) {                                // 160
      try {                                                                     // 161
        self._compute();                                                        // 162
      } catch (e) {                                                             // 163
        _debugFunc()("Exception from Deps recompute:", e.stack || e.message);   // 164
      }                                                                         // 165
      // If _compute() invalidated us, we run again immediately.                // 166
      // A computation that invalidates itself indefinitely is an               // 167
      // infinite loop, of course.                                              // 168
      //                                                                        // 169
      // We could put an iteration counter here and catch run-away              // 170
      // loops.                                                                 // 171
    }                                                                           // 172
    self._recomputing = false;                                                  // 173
  }                                                                             // 174
});                                                                             // 175
                                                                                // 176
//                                                                              // 177
// http://docs.meteor.com/#deps_dependency                                      // 178
//                                                                              // 179
Deps.Dependency = function () {                                                 // 180
  this._dependentsById = {};                                                    // 181
};                                                                              // 182
                                                                                // 183
_.extend(Deps.Dependency.prototype, {                                           // 184
  // http://docs.meteor.com/#dependency_depend                                  // 185
  //                                                                            // 186
  // Adds `computation` to this set if it is not already                        // 187
  // present.  Returns true if `computation` is a new member of the set.        // 188
  // If no argument, defaults to currentComputation, or does nothing            // 189
  // if there is no currentComputation.                                         // 190
  depend: function (computation) {                                              // 191
    if (! computation) {                                                        // 192
      if (! Deps.active)                                                        // 193
        return false;                                                           // 194
                                                                                // 195
      computation = Deps.currentComputation;                                    // 196
    }                                                                           // 197
    var self = this;                                                            // 198
    var id = computation._id;                                                   // 199
    if (! (id in self._dependentsById)) {                                       // 200
      self._dependentsById[id] = computation;                                   // 201
      computation.onInvalidate(function () {                                    // 202
        delete self._dependentsById[id];                                        // 203
      });                                                                       // 204
      return true;                                                              // 205
    }                                                                           // 206
    return false;                                                               // 207
  },                                                                            // 208
                                                                                // 209
  // http://docs.meteor.com/#dependency_changed                                 // 210
  changed: function () {                                                        // 211
    var self = this;                                                            // 212
    for (var id in self._dependentsById)                                        // 213
      self._dependentsById[id].invalidate();                                    // 214
  },                                                                            // 215
                                                                                // 216
  // http://docs.meteor.com/#dependency_hasdependents                           // 217
  hasDependents: function () {                                                  // 218
    var self = this;                                                            // 219
    for(var id in self._dependentsById)                                         // 220
      return true;                                                              // 221
    return false;                                                               // 222
  }                                                                             // 223
});                                                                             // 224
                                                                                // 225
_.extend(Deps, {                                                                // 226
  // http://docs.meteor.com/#deps_flush                                         // 227
  flush: function () {                                                          // 228
    // Nested flush could plausibly happen if, say, a flush causes              // 229
    // DOM mutation, which causes a "blur" event, which runs an                 // 230
    // app event handler that calls Deps.flush.  At the moment                  // 231
    // Spark blocks event handlers during DOM mutation anyway,                  // 232
    // because the LiveRange tree isn't valid.  And we don't have               // 233
    // any useful notion of a nested flush.                                     // 234
    //                                                                          // 235
    // https://app.asana.com/0/159908330244/385138233856                        // 236
    if (inFlush)                                                                // 237
      throw new Error("Can't call Deps.flush while flushing");                  // 238
                                                                                // 239
    if (inCompute)                                                              // 240
      throw new Error("Can't flush inside Deps.autorun");                       // 241
                                                                                // 242
    inFlush = true;                                                             // 243
    willFlush = true;                                                           // 244
                                                                                // 245
    while (pendingComputations.length ||                                        // 246
           afterFlushCallbacks.length) {                                        // 247
                                                                                // 248
      // recompute all pending computations                                     // 249
      var comps = pendingComputations;                                          // 250
      pendingComputations = [];                                                 // 251
                                                                                // 252
      for (var i = 0, comp; comp = comps[i]; i++)                               // 253
        comp._recompute();                                                      // 254
                                                                                // 255
      if (afterFlushCallbacks.length) {                                         // 256
        // call one afterFlush callback, which may                              // 257
        // invalidate more computations                                         // 258
        var func = afterFlushCallbacks.shift();                                 // 259
        try {                                                                   // 260
          func();                                                               // 261
        } catch (e) {                                                           // 262
          _debugFunc()("Exception from Deps afterFlush function:",              // 263
                       e.stack || e.message);                                   // 264
        }                                                                       // 265
      }                                                                         // 266
    }                                                                           // 267
                                                                                // 268
    inFlush = false;                                                            // 269
    willFlush = false;                                                          // 270
  },                                                                            // 271
                                                                                // 272
  // http://docs.meteor.com/#deps_autorun                                       // 273
  //                                                                            // 274
  // Run f(). Record its dependencies. Rerun it whenever the                    // 275
  // dependencies change.                                                       // 276
  //                                                                            // 277
  // Returns a new Computation, which is also passed to f.                      // 278
  //                                                                            // 279
  // Links the computation to the current computation                           // 280
  // so that it is stopped if the current computation is invalidated.           // 281
  autorun: function (f) {                                                       // 282
    if (typeof f !== 'function')                                                // 283
      throw new Error('Deps.autorun requires a function argument');             // 284
                                                                                // 285
    constructingComputation = true;                                             // 286
    var c = new Deps.Computation(f, Deps.currentComputation);                   // 287
                                                                                // 288
    if (Deps.active)                                                            // 289
      Deps.onInvalidate(function () {                                           // 290
        c.stop();                                                               // 291
      });                                                                       // 292
                                                                                // 293
    return c;                                                                   // 294
  },                                                                            // 295
                                                                                // 296
  // http://docs.meteor.com/#deps_nonreactive                                   // 297
  //                                                                            // 298
  // Run `f` with no current computation, returning the return value            // 299
  // of `f`.  Used to turn off reactivity for the duration of `f`,              // 300
  // so that reactive data sources accessed by `f` will not result in any       // 301
  // computations being invalidated.                                            // 302
  nonreactive: function (f) {                                                   // 303
    var previous = Deps.currentComputation;                                     // 304
    setCurrentComputation(null);                                                // 305
    try {                                                                       // 306
      return f();                                                               // 307
    } finally {                                                                 // 308
      setCurrentComputation(previous);                                          // 309
    }                                                                           // 310
  },                                                                            // 311
                                                                                // 312
  // Wrap `f` so that it is always run nonreactively.                           // 313
  _makeNonreactive: function (f) {                                              // 314
    if (f.$isNonreactive) // avoid multiple layers of wrapping.                 // 315
      return f;                                                                 // 316
    var nonreactiveVersion = function (/*arguments*/) {                         // 317
      var self = this;                                                          // 318
      var args = _.toArray(arguments);                                          // 319
      var ret;                                                                  // 320
      Deps.nonreactive(function () {                                            // 321
        ret = f.apply(self, args);                                              // 322
      });                                                                       // 323
      return ret;                                                               // 324
    };                                                                          // 325
    nonreactiveVersion.$isNonreactive = true;                                   // 326
    return nonreactiveVersion;                                                  // 327
  },                                                                            // 328
                                                                                // 329
  // http://docs.meteor.com/#deps_oninvalidate                                  // 330
  onInvalidate: function (f) {                                                  // 331
    if (! Deps.active)                                                          // 332
      throw new Error("Deps.onInvalidate requires a currentComputation");       // 333
                                                                                // 334
    Deps.currentComputation.onInvalidate(f);                                    // 335
  },                                                                            // 336
                                                                                // 337
  // http://docs.meteor.com/#deps_afterflush                                    // 338
  afterFlush: function (f) {                                                    // 339
    afterFlushCallbacks.push(f);                                                // 340
    requireFlush();                                                             // 341
  },                                                                            // 342
                                                                                // 343
  // two values are equal if `equals(x, y)`, which defaults to `===`            // 344
  isolateValue: function (f, equals) {                                          // 345
    if (! Deps.active)                                                          // 346
      return f();                                                               // 347
                                                                                // 348
    var resultDep = new Deps.Dependency;                                        // 349
    var origResult;                                                             // 350
    Deps.autorun(function (c) {                                                 // 351
      var result = f();                                                         // 352
      if (c.firstRun)                                                           // 353
        origResult = result;                                                    // 354
      else if (! (equals ? equals(result, origResult) :                         // 355
                  result === origResult))                                       // 356
        resultDep.changed();                                                    // 357
    });                                                                         // 358
    resultDep.depend();                                                         // 359
                                                                                // 360
    return origResult;                                                          // 361
  }                                                                             // 362
});                                                                             // 363
                                                                                // 364
//////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// packages/deps/deprecated.js                                                  //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////
                                                                                //
// Deprecated (Deps-recated?) functions.                                        // 1
                                                                                // 2
// These functions used to be on the Meteor object (and worked slightly         // 3
// differently).                                                                // 4
// XXX COMPAT WITH 0.5.7                                                        // 5
Meteor.flush = Deps.flush;                                                      // 6
Meteor.autorun = Deps.autorun;                                                  // 7
                                                                                // 8
// We used to require a special "autosubscribe" call to reactively subscribe to // 9
// things. Now, it works with autorun.                                          // 10
// XXX COMPAT WITH 0.5.4                                                        // 11
Meteor.autosubscribe = Deps.autorun;                                            // 12
                                                                                // 13
// This Deps API briefly existed in 0.5.8 and 0.5.9                             // 14
// XXX COMPAT WITH 0.5.9                                                        // 15
Deps.depend = function (d) {                                                    // 16
  return d.depend();                                                            // 17
};                                                                              // 18
                                                                                // 19
//////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.deps = {
  Deps: Deps
};

})();

//# sourceMappingURL=34f4906d0a01d1c2873bed712b3bd039da3c9bab.map


//--------- random.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;

/* Package-scope variables */
var Random;

(function () {

//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
// packages/random/random.js                                                        //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////
                                                                                    //
// We use cryptographically strong PRNGs (crypto.getRandomBytes() on the server,    // 1
// window.crypto.getRandomValues() in the browser) when available. If these         // 2
// PRNGs fail, we fall back to the Alea PRNG, which is not cryptographically        // 3
// strong, and we seed it with various sources such as the date, Math.random,       // 4
// and window size on the client.  When using crypto.getRandomValues(), our         // 5
// primitive is hexString(), from which we construct fraction(). When using         // 6
// window.crypto.getRandomValues() or alea, the primitive is fraction and we use    // 7
// that to construct hex string.                                                    // 8
                                                                                    // 9
if (Meteor.isServer)                                                                // 10
  var nodeCrypto = Npm.require('crypto');                                           // 11
                                                                                    // 12
// see http://baagoe.org/en/wiki/Better_random_numbers_for_javascript               // 13
// for a full discussion and Alea implementation.                                   // 14
var Alea = function () {                                                            // 15
  function Mash() {                                                                 // 16
    var n = 0xefc8249d;                                                             // 17
                                                                                    // 18
    var mash = function(data) {                                                     // 19
      data = data.toString();                                                       // 20
      for (var i = 0; i < data.length; i++) {                                       // 21
        n += data.charCodeAt(i);                                                    // 22
        var h = 0.02519603282416938 * n;                                            // 23
        n = h >>> 0;                                                                // 24
        h -= n;                                                                     // 25
        h *= n;                                                                     // 26
        n = h >>> 0;                                                                // 27
        h -= n;                                                                     // 28
        n += h * 0x100000000; // 2^32                                               // 29
      }                                                                             // 30
      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32                           // 31
    };                                                                              // 32
                                                                                    // 33
    mash.version = 'Mash 0.9';                                                      // 34
    return mash;                                                                    // 35
  }                                                                                 // 36
                                                                                    // 37
  return (function (args) {                                                         // 38
    var s0 = 0;                                                                     // 39
    var s1 = 0;                                                                     // 40
    var s2 = 0;                                                                     // 41
    var c = 1;                                                                      // 42
                                                                                    // 43
    if (args.length == 0) {                                                         // 44
      args = [+new Date];                                                           // 45
    }                                                                               // 46
    var mash = Mash();                                                              // 47
    s0 = mash(' ');                                                                 // 48
    s1 = mash(' ');                                                                 // 49
    s2 = mash(' ');                                                                 // 50
                                                                                    // 51
    for (var i = 0; i < args.length; i++) {                                         // 52
      s0 -= mash(args[i]);                                                          // 53
      if (s0 < 0) {                                                                 // 54
        s0 += 1;                                                                    // 55
      }                                                                             // 56
      s1 -= mash(args[i]);                                                          // 57
      if (s1 < 0) {                                                                 // 58
        s1 += 1;                                                                    // 59
      }                                                                             // 60
      s2 -= mash(args[i]);                                                          // 61
      if (s2 < 0) {                                                                 // 62
        s2 += 1;                                                                    // 63
      }                                                                             // 64
    }                                                                               // 65
    mash = null;                                                                    // 66
                                                                                    // 67
    var random = function() {                                                       // 68
      var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32                   // 69
      s0 = s1;                                                                      // 70
      s1 = s2;                                                                      // 71
      return s2 = t - (c = t | 0);                                                  // 72
    };                                                                              // 73
    random.uint32 = function() {                                                    // 74
      return random() * 0x100000000; // 2^32                                        // 75
    };                                                                              // 76
    random.fract53 = function() {                                                   // 77
      return random() +                                                             // 78
        (random() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53                // 79
    };                                                                              // 80
    random.version = 'Alea 0.9';                                                    // 81
    random.args = args;                                                             // 82
    return random;                                                                  // 83
                                                                                    // 84
  } (Array.prototype.slice.call(arguments)));                                       // 85
};                                                                                  // 86
                                                                                    // 87
var UNMISTAKABLE_CHARS = "23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz"; // 88
                                                                                    // 89
// If seeds are provided, then the alea PRNG will be used, since cryptographic      // 90
// PRNGs (Node crypto and window.crypto.getRandomValues) don't allow us to          // 91
// specify seeds. The caller is responsible for making sure to provide a seed       // 92
// for alea if a csprng is not available.                                           // 93
var RandomGenerator = function (seedArray) {                                        // 94
  var self = this;                                                                  // 95
  if (seedArray !== undefined)                                                      // 96
    self.alea = Alea.apply(null, seedArray);                                        // 97
};                                                                                  // 98
                                                                                    // 99
RandomGenerator.prototype.fraction = function () {                                  // 100
  var self = this;                                                                  // 101
  if (self.alea) {                                                                  // 102
    return self.alea();                                                             // 103
  } else if (nodeCrypto) {                                                          // 104
    var numerator = parseInt(self.hexString(8), 16);                                // 105
    return numerator * 2.3283064365386963e-10; // 2^-32                             // 106
  } else if (typeof window !== "undefined" && window.crypto &&                      // 107
             window.crypto.getRandomValues) {                                       // 108
    var array = new Uint32Array(1);                                                 // 109
    window.crypto.getRandomValues(array);                                           // 110
    return array[0] * 2.3283064365386963e-10; // 2^-32                              // 111
  }                                                                                 // 112
};                                                                                  // 113
                                                                                    // 114
RandomGenerator.prototype.hexString = function (digits) {                           // 115
  var self = this;                                                                  // 116
  if (nodeCrypto && ! self.alea) {                                                  // 117
    var numBytes = Math.ceil(digits / 2);                                           // 118
    var bytes;                                                                      // 119
    // Try to get cryptographically strong randomness. Fall back to                 // 120
    // non-cryptographically strong if not available.                               // 121
    try {                                                                           // 122
      bytes = nodeCrypto.randomBytes(numBytes);                                     // 123
    } catch (e) {                                                                   // 124
      // XXX should re-throw any error except insufficient entropy                  // 125
      bytes = nodeCrypto.pseudoRandomBytes(numBytes);                               // 126
    }                                                                               // 127
    var result = bytes.toString("hex");                                             // 128
    // If the number of digits is odd, we'll have generated an extra 4 bits         // 129
    // of randomness, so we need to trim the last digit.                            // 130
    return result.substring(0, digits);                                             // 131
  } else {                                                                          // 132
    var hexDigits = [];                                                             // 133
    for (var i = 0; i < digits; ++i) {                                              // 134
      hexDigits.push(self.choice("0123456789abcdef"));                              // 135
    }                                                                               // 136
    return hexDigits.join('');                                                      // 137
  }                                                                                 // 138
};                                                                                  // 139
RandomGenerator.prototype.id = function () {                                        // 140
  var digits = [];                                                                  // 141
  var self = this;                                                                  // 142
  // Length of 17 preserves around 96 bits of entropy, which is the                 // 143
  // amount of state in the Alea PRNG.                                              // 144
  for (var i = 0; i < 17; i++) {                                                    // 145
    digits[i] = self.choice(UNMISTAKABLE_CHARS);                                    // 146
  }                                                                                 // 147
  return digits.join("");                                                           // 148
};                                                                                  // 149
                                                                                    // 150
RandomGenerator.prototype.choice = function (arrayOrString) {                       // 151
  var index = Math.floor(this.fraction() * arrayOrString.length);                   // 152
  if (typeof arrayOrString === "string")                                            // 153
    return arrayOrString.substr(index, 1);                                          // 154
  else                                                                              // 155
    return arrayOrString[index];                                                    // 156
};                                                                                  // 157
                                                                                    // 158
// instantiate RNG.  Heuristically collect entropy from various sources when a      // 159
// cryptographic PRNG isn't available.                                              // 160
                                                                                    // 161
// client sources                                                                   // 162
var height = (typeof window !== 'undefined' && window.innerHeight) ||               // 163
      (typeof document !== 'undefined'                                              // 164
       && document.documentElement                                                  // 165
       && document.documentElement.clientHeight) ||                                 // 166
      (typeof document !== 'undefined'                                              // 167
       && document.body                                                             // 168
       && document.body.clientHeight) ||                                            // 169
      1;                                                                            // 170
                                                                                    // 171
var width = (typeof window !== 'undefined' && window.innerWidth) ||                 // 172
      (typeof document !== 'undefined'                                              // 173
       && document.documentElement                                                  // 174
       && document.documentElement.clientWidth) ||                                  // 175
      (typeof document !== 'undefined'                                              // 176
       && document.body                                                             // 177
       && document.body.clientWidth) ||                                             // 178
      1;                                                                            // 179
                                                                                    // 180
var agent = (typeof navigator !== 'undefined' && navigator.userAgent) || "";        // 181
                                                                                    // 182
if (nodeCrypto ||                                                                   // 183
    (typeof window !== "undefined" &&                                               // 184
     window.crypto && window.crypto.getRandomValues))                               // 185
  Random = new RandomGenerator();                                                   // 186
else                                                                                // 187
  Random = new RandomGenerator([new Date(), height, width, agent, Math.random()]);  // 188
                                                                                    // 189
Random.create = function () {                                                       // 190
  return new RandomGenerator(arguments);                                            // 191
};                                                                                  // 192
                                                                                    // 193
//////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
// packages/random/deprecated.js                                                    //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////
                                                                                    //
// Before this package existed, we used to use this Meteor.uuid()                   // 1
// implementing the RFC 4122 v4 UUID. It is no longer documented                    // 2
// and will go away.                                                                // 3
// XXX COMPAT WITH 0.5.6                                                            // 4
Meteor.uuid = function () {                                                         // 5
  var HEX_DIGITS = "0123456789abcdef";                                              // 6
  var s = [];                                                                       // 7
  for (var i = 0; i < 36; i++) {                                                    // 8
    s[i] = Random.choice(HEX_DIGITS);                                               // 9
  }                                                                                 // 10
  s[14] = "4";                                                                      // 11
  s[19] = HEX_DIGITS.substr((parseInt(s[19],16) & 0x3) | 0x8, 1);                   // 12
  s[8] = s[13] = s[18] = s[23] = "-";                                               // 13
                                                                                    // 14
  var uuid = s.join("");                                                            // 15
  return uuid;                                                                      // 16
};                                                                                  // 17
                                                                                    // 18
//////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.random = {
  Random: Random
};

})();

//# sourceMappingURL=66f32d9674bbf319a47b2638439a6bf41565ebb9.map


//--------- retry.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var Random = Package.random.Random;

/* Package-scope variables */
var Retry;

(function () {

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// packages/retry/retry.js                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
                                                                           //
// Retry logic with an exponential backoff.                                // 1
//                                                                         // 2
// options:                                                                // 3
//  baseTimeout: time for initial reconnect attempt (ms).                  // 4
//  exponent: exponential factor to increase timeout each attempt.         // 5
//  maxTimeout: maximum time between retries (ms).                         // 6
//  minCount: how many times to reconnect "instantly".                     // 7
//  minTimeout: time to wait for the first `minCount` retries (ms).        // 8
//  fuzz: factor to randomize retry times by (to avoid retry storms).      // 9
                                                                           // 10
Retry = function (options) {                                               // 11
  var self = this;                                                         // 12
  _.extend(self, _.defaults(_.clone(options || {}), {                      // 13
    baseTimeout: 1000, // 1 second                                         // 14
    exponent: 2.2,                                                         // 15
    // The default is high-ish to ensure a server can recover from a       // 16
    // failure caused by load.                                             // 17
    maxTimeout: 5 * 60000, // 5 minutes                                    // 18
    minTimeout: 10,                                                        // 19
    minCount: 2,                                                           // 20
    fuzz: 0.5 // +- 25%                                                    // 21
  }));                                                                     // 22
  self.retryTimer = null;                                                  // 23
};                                                                         // 24
                                                                           // 25
_.extend(Retry.prototype, {                                                // 26
                                                                           // 27
  // Reset a pending retry, if any.                                        // 28
  clear: function () {                                                     // 29
    var self = this;                                                       // 30
    if (self.retryTimer)                                                   // 31
      clearTimeout(self.retryTimer);                                       // 32
    self.retryTimer = null;                                                // 33
  },                                                                       // 34
                                                                           // 35
  // Calculate how long to wait in milliseconds to retry, based on the     // 36
  // `count` of which retry this is.                                       // 37
  _timeout: function (count) {                                             // 38
    var self = this;                                                       // 39
                                                                           // 40
    if (count < self.minCount)                                             // 41
      return self.minTimeout;                                              // 42
                                                                           // 43
    var timeout = Math.min(                                                // 44
      self.maxTimeout,                                                     // 45
      self.baseTimeout * Math.pow(self.exponent, count));                  // 46
    // fuzz the timeout randomly, to avoid reconnect storms when a         // 47
    // server goes down.                                                   // 48
    timeout = timeout * ((Random.fraction() * self.fuzz) +                 // 49
                         (1 - self.fuzz/2));                               // 50
    return timeout;                                                        // 51
  },                                                                       // 52
                                                                           // 53
  // Call `fn` after a delay, based on the `count` of which retry this is. // 54
  retryLater: function (count, fn) {                                       // 55
    var self = this;                                                       // 56
    var timeout = self._timeout(count);                                    // 57
    if (self.retryTimer)                                                   // 58
      clearTimeout(self.retryTimer);                                       // 59
    self.retryTimer = setTimeout(fn, timeout);                             // 60
    return timeout;                                                        // 61
  }                                                                        // 62
                                                                           // 63
});                                                                        // 64
                                                                           // 65
/////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.retry = {
  Retry: Retry
};

})();

//# sourceMappingURL=600c247d43fa232f08a615c29d2b6f4d9e25e125.map


//--------- check.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var EJSON = Package.ejson.EJSON;

/* Package-scope variables */
var check, Match;

(function () {

///////////////////////////////////////////////////////////////////////////////////
//                                                                               //
// packages/check/match.js                                                       //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////
                                                                                 //
// XXX docs                                                                      // 1
                                                                                 // 2
// Things we explicitly do NOT support:                                          // 3
//    - heterogenous arrays                                                      // 4
                                                                                 // 5
var currentArgumentChecker = new Meteor.EnvironmentVariable;                     // 6
                                                                                 // 7
check = function (value, pattern) {                                              // 8
  // Record that check got called, if somebody cared.                            // 9
  var argChecker = currentArgumentChecker.get();                                 // 10
  if (argChecker)                                                                // 11
    argChecker.checking(value);                                                  // 12
  try {                                                                          // 13
    checkSubtree(value, pattern);                                                // 14
  } catch (err) {                                                                // 15
    if ((err instanceof Match.Error) && err.path)                                // 16
      err.message += " in field " + err.path;                                    // 17
    throw err;                                                                   // 18
  }                                                                              // 19
};                                                                               // 20
                                                                                 // 21
Match = {                                                                        // 22
  Optional: function (pattern) {                                                 // 23
    return new Optional(pattern);                                                // 24
  },                                                                             // 25
  OneOf: function (/*arguments*/) {                                              // 26
    return new OneOf(_.toArray(arguments));                                      // 27
  },                                                                             // 28
  Any: ['__any__'],                                                              // 29
  Where: function (condition) {                                                  // 30
    return new Where(condition);                                                 // 31
  },                                                                             // 32
  ObjectIncluding: function (pattern) {                                          // 33
    return new ObjectIncluding(pattern);                                         // 34
  },                                                                             // 35
  // Matches only signed 32-bit integers                                         // 36
  Integer: ['__integer__'],                                                      // 37
                                                                                 // 38
  // XXX matchers should know how to describe themselves for errors              // 39
  Error: Meteor.makeErrorType("Match.Error", function (msg) {                    // 40
    this.message = "Match error: " + msg;                                        // 41
    // The path of the value that failed to match. Initially empty, this gets    // 42
    // populated by catching and rethrowing the exception as it goes back up the // 43
    // stack.                                                                    // 44
    // E.g.: "vals[3].entity.created"                                            // 45
    this.path = "";                                                              // 46
    // provide something better than 500 Internal server error.                  // 48
    this.sanitizedError = new Meteor.Error(400, "Match failed");                 // 49
  }),                                                                            // 50
                                                                                 // 51
  // Tests to see if value matches pattern. Unlike check, it merely returns true // 52
  // or false (unless an error other than Match.Error was thrown). It does not   // 53
  // interact with _failIfArgumentsAreNotAllChecked.                             // 54
  // XXX maybe also implement a Match.match which returns more information about // 55
  //     failures but without using exception handling or doing what check()     // 56
  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion  // 57
  test: function (value, pattern) {                                              // 58
    try {                                                                        // 59
      checkSubtree(value, pattern);                                              // 60
      return true;                                                               // 61
    } catch (e) {                                                                // 62
      if (e instanceof Match.Error)                                              // 63
        return false;                                                            // 64
      // Rethrow other errors.                                                   // 65
      throw e;                                                                   // 66
    }                                                                            // 67
  },                                                                             // 68
                                                                                 // 69
  // Runs `f.apply(context, args)`. If check() is not called on every element of // 70
  // `args` (either directly or in the first level of an array), throws an error // 71
  // (using `description` in the message).                                       // 72
  //                                                                             // 73
  _failIfArgumentsAreNotAllChecked: function (f, context, args, description) {   // 74
    var argChecker = new ArgumentChecker(args, description);                     // 75
    var result = currentArgumentChecker.withValue(argChecker, function () {      // 76
      return f.apply(context, args);                                             // 77
    });                                                                          // 78
    // If f didn't itself throw, make sure it checked all of its arguments.      // 79
    argChecker.throwUnlessAllArgumentsHaveBeenChecked();                         // 80
    return result;                                                               // 81
  }                                                                              // 82
};                                                                               // 83
                                                                                 // 84
var Optional = function (pattern) {                                              // 85
  this.pattern = pattern;                                                        // 86
};                                                                               // 87
                                                                                 // 88
var OneOf = function (choices) {                                                 // 89
  if (_.isEmpty(choices))                                                        // 90
    throw new Error("Must provide at least one choice to Match.OneOf");          // 91
  this.choices = choices;                                                        // 92
};                                                                               // 93
                                                                                 // 94
var Where = function (condition) {                                               // 95
  this.condition = condition;                                                    // 96
};                                                                               // 97
                                                                                 // 98
var ObjectIncluding = function (pattern) {                                       // 99
  this.pattern = pattern;                                                        // 100
};                                                                               // 101
                                                                                 // 102
var typeofChecks = [                                                             // 103
  [String, "string"],                                                            // 104
  [Number, "number"],                                                            // 105
  [Boolean, "boolean"],                                                          // 106
  // While we don't allow undefined in EJSON, this is good for optional          // 107
  // arguments with OneOf.                                                       // 108
  [undefined, "undefined"]                                                       // 109
];                                                                               // 110
                                                                                 // 111
var checkSubtree = function (value, pattern) {                                   // 112
  // Match anything!                                                             // 113
  if (pattern === Match.Any)                                                     // 114
    return;                                                                      // 115
                                                                                 // 116
  // Basic atomic types.                                                         // 117
  // Do not match boxed objects (e.g. String, Boolean)                           // 118
  for (var i = 0; i < typeofChecks.length; ++i) {                                // 119
    if (pattern === typeofChecks[i][0]) {                                        // 120
      if (typeof value === typeofChecks[i][1])                                   // 121
        return;                                                                  // 122
      throw new Match.Error("Expected " + typeofChecks[i][1] + ", got " +        // 123
                            typeof value);                                       // 124
    }                                                                            // 125
  }                                                                              // 126
  if (pattern === null) {                                                        // 127
    if (value === null)                                                          // 128
      return;                                                                    // 129
    throw new Match.Error("Expected null, got " + EJSON.stringify(value));       // 130
  }                                                                              // 131
                                                                                 // 132
  // Match.Integer is special type encoded with array                            // 133
  if (pattern === Match.Integer) {                                               // 134
    // There is no consistent and reliable way to check if variable is a 64-bit  // 135
    // integer. One of the popular solutions is to get reminder of division by 1 // 136
    // but this method fails on really large floats with big precision.          // 137
    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8                               // 138
    // Bitwise operators work consistantly but always cast variable to 32-bit    // 139
    // signed integer according to JavaScript specs.                             // 140
    if (typeof value === "number" && (value | 0) === value)                      // 141
      return                                                                     // 142
    throw new Match.Error("Expected Integer, got "                               // 143
                + (value instanceof Object ? EJSON.stringify(value) : value));   // 144
  }                                                                              // 145
                                                                                 // 146
  // "Object" is shorthand for Match.ObjectIncluding({});                        // 147
  if (pattern === Object)                                                        // 148
    pattern = Match.ObjectIncluding({});                                         // 149
                                                                                 // 150
  // Array (checked AFTER Any, which is implemented as an Array).                // 151
  if (pattern instanceof Array) {                                                // 152
    if (pattern.length !== 1)                                                    // 153
      throw Error("Bad pattern: arrays must have one type element" +             // 154
                  EJSON.stringify(pattern));                                     // 155
    if (!_.isArray(value) && !_.isArguments(value)) {                            // 156
      throw new Match.Error("Expected array, got " + EJSON.stringify(value));    // 157
    }                                                                            // 158
                                                                                 // 159
    _.each(value, function (valueElement, index) {                               // 160
      try {                                                                      // 161
        checkSubtree(valueElement, pattern[0]);                                  // 162
      } catch (err) {                                                            // 163
        if (err instanceof Match.Error) {                                        // 164
          err.path = _prependPath(index, err.path);                              // 165
        }                                                                        // 166
        throw err;                                                               // 167
      }                                                                          // 168
    });                                                                          // 169
    return;                                                                      // 170
  }                                                                              // 171
                                                                                 // 172
  // Arbitrary validation checks. The condition can return false or throw a      // 173
  // Match.Error (ie, it can internally use check()) to fail.                    // 174
  if (pattern instanceof Where) {                                                // 175
    if (pattern.condition(value))                                                // 176
      return;                                                                    // 177
    // XXX this error is terrible                                                // 178
    throw new Match.Error("Failed Match.Where validation");                      // 179
  }                                                                              // 180
                                                                                 // 181
                                                                                 // 182
  if (pattern instanceof Optional)                                               // 183
    pattern = Match.OneOf(undefined, pattern.pattern);                           // 184
                                                                                 // 185
  if (pattern instanceof OneOf) {                                                // 186
    for (var i = 0; i < pattern.choices.length; ++i) {                           // 187
      try {                                                                      // 188
        checkSubtree(value, pattern.choices[i]);                                 // 189
        // No error? Yay, return.                                                // 190
        return;                                                                  // 191
      } catch (err) {                                                            // 192
        // Other errors should be thrown. Match errors just mean try another     // 193
        // choice.                                                               // 194
        if (!(err instanceof Match.Error))                                       // 195
          throw err;                                                             // 196
      }                                                                          // 197
    }                                                                            // 198
    // XXX this error is terrible                                                // 199
    throw new Match.Error("Failed Match.OneOf or Match.Optional validation");    // 200
  }                                                                              // 201
                                                                                 // 202
  // A function that isn't something we special-case is assumed to be a          // 203
  // constructor.                                                                // 204
  if (pattern instanceof Function) {                                             // 205
    if (value instanceof pattern)                                                // 206
      return;                                                                    // 207
    // XXX what if .name isn't defined                                           // 208
    throw new Match.Error("Expected " + pattern.name);                           // 209
  }                                                                              // 210
                                                                                 // 211
  var unknownKeysAllowed = false;                                                // 212
  if (pattern instanceof ObjectIncluding) {                                      // 213
    unknownKeysAllowed = true;                                                   // 214
    pattern = pattern.pattern;                                                   // 215
  }                                                                              // 216
                                                                                 // 217
  if (typeof pattern !== "object")                                               // 218
    throw Error("Bad pattern: unknown pattern type");                            // 219
                                                                                 // 220
  // An object, with required and optional keys. Note that this does NOT do      // 221
  // structural matches against objects of special types that happen to match    // 222
  // the pattern: this really needs to be a plain old {Object}!                  // 223
  if (typeof value !== 'object')                                                 // 224
    throw new Match.Error("Expected object, got " + typeof value);               // 225
  if (value === null)                                                            // 226
    throw new Match.Error("Expected object, got null");                          // 227
  if (value.constructor !== Object)                                              // 228
    throw new Match.Error("Expected plain object");                              // 229
                                                                                 // 230
  var requiredPatterns = {};                                                     // 231
  var optionalPatterns = {};                                                     // 232
  _.each(pattern, function (subPattern, key) {                                   // 233
    if (subPattern instanceof Optional)                                          // 234
      optionalPatterns[key] = subPattern.pattern;                                // 235
    else                                                                         // 236
      requiredPatterns[key] = subPattern;                                        // 237
  });                                                                            // 238
                                                                                 // 239
  _.each(value, function (subValue, key) {                                       // 240
    try {                                                                        // 241
      if (_.has(requiredPatterns, key)) {                                        // 242
        checkSubtree(subValue, requiredPatterns[key]);                           // 243
        delete requiredPatterns[key];                                            // 244
      } else if (_.has(optionalPatterns, key)) {                                 // 245
        checkSubtree(subValue, optionalPatterns[key]);                           // 246
      } else {                                                                   // 247
        if (!unknownKeysAllowed)                                                 // 248
          throw new Match.Error("Unknown key");                                  // 249
      }                                                                          // 250
    } catch (err) {                                                              // 251
      if (err instanceof Match.Error)                                            // 252
        err.path = _prependPath(key, err.path);                                  // 253
      throw err;                                                                 // 254
    }                                                                            // 255
  });                                                                            // 256
                                                                                 // 257
  _.each(requiredPatterns, function (subPattern, key) {                          // 258
    throw new Match.Error("Missing key '" + key + "'");                          // 259
  });                                                                            // 260
};                                                                               // 261
                                                                                 // 262
var ArgumentChecker = function (args, description) {                             // 263
  var self = this;                                                               // 264
  // Make a SHALLOW copy of the arguments. (We'll be doing identity checks       // 265
  // against its contents.)                                                      // 266
  self.args = _.clone(args);                                                     // 267
  // Since the common case will be to check arguments in order, and we splice    // 268
  // out arguments when we check them, make it so we splice out from the end     // 269
  // rather than the beginning.                                                  // 270
  self.args.reverse();                                                           // 271
  self.description = description;                                                // 272
};                                                                               // 273
                                                                                 // 274
_.extend(ArgumentChecker.prototype, {                                            // 275
  checking: function (value) {                                                   // 276
    var self = this;                                                             // 277
    if (self._checkingOneValue(value))                                           // 278
      return;                                                                    // 279
    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])   // 280
    // or check([foo, bar], [String]) to count... but only if value wasn't       // 281
    // itself an argument.                                                       // 282
    if (_.isArray(value) || _.isArguments(value)) {                              // 283
      _.each(value, _.bind(self._checkingOneValue, self));                       // 284
    }                                                                            // 285
  },                                                                             // 286
  _checkingOneValue: function (value) {                                          // 287
    var self = this;                                                             // 288
    for (var i = 0; i < self.args.length; ++i) {                                 // 289
      // Is this value one of the arguments? (This can have a false positive if  // 290
      // the argument is an interned primitive, but it's still a good enough     // 291
      // check.)                                                                 // 292
      if (value === self.args[i]) {                                              // 293
        self.args.splice(i, 1);                                                  // 294
        return true;                                                             // 295
      }                                                                          // 296
    }                                                                            // 297
    return false;                                                                // 298
  },                                                                             // 299
  throwUnlessAllArgumentsHaveBeenChecked: function () {                          // 300
    var self = this;                                                             // 301
    if (!_.isEmpty(self.args))                                                   // 302
      throw new Error("Did not check() all arguments during " +                  // 303
                      self.description);                                         // 304
  }                                                                              // 305
});                                                                              // 306
                                                                                 // 307
var _jsKeywords = ["do", "if", "in", "for", "let", "new", "try", "var", "case",  // 308
  "else", "enum", "eval", "false", "null", "this", "true", "void", "with",       // 309
  "break", "catch", "class", "const", "super", "throw", "while", "yield",        // 310
  "delete", "export", "import", "public", "return", "static", "switch",          // 311
  "typeof", "default", "extends", "finally", "package", "private", "continue",   // 312
  "debugger", "function", "arguments", "interface", "protected", "implements",   // 313
  "instanceof"];                                                                 // 314
                                                                                 // 315
// Assumes the base of path is already escaped properly                          // 316
// returns key + base                                                            // 317
var _prependPath = function (key, base) {                                        // 318
  if ((typeof key) === "number" || key.match(/^[0-9]+$/))                        // 319
    key = "[" + key + "]";                                                       // 320
  else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _.contains(_jsKeywords, key))  // 321
    key = JSON.stringify([key]);                                                 // 322
                                                                                 // 323
  if (base && base[0] !== "[")                                                   // 324
    return key + '.' + base;                                                     // 325
  return key + base;                                                             // 326
};                                                                               // 327
                                                                                 // 328
                                                                                 // 329
///////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.check = {
  check: check,
  Match: Match
};

})();

//# sourceMappingURL=a54cf3c7b3abe9208d064621eb80a3ecaf2f4add.map


//--------- ordered-dict.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;

/* Package-scope variables */
var OrderedDict;

(function () {

///////////////////////////////////////////////////////////////////////////////////
//                                                                               //
// packages/ordered-dict/ordered_dict.js                                         //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////
                                                                                 //
// This file defines an ordered dictionary abstraction that is useful for        // 1
// maintaining a dataset backed by observeChanges.  It supports ordering items   // 2
// by specifying the item they now come before.                                  // 3
                                                                                 // 4
// The implementation is a dictionary that contains nodes of a doubly-linked     // 5
// list as its values.                                                           // 6
                                                                                 // 7
// constructs a new element struct                                               // 8
// next and prev are whole elements, not keys.                                   // 9
var element = function (key, value, next, prev) {                                // 10
  return {                                                                       // 11
    key: key,                                                                    // 12
    value: value,                                                                // 13
    next: next,                                                                  // 14
    prev: prev                                                                   // 15
  };                                                                             // 16
};                                                                               // 17
OrderedDict = function (/* ... */) {                                             // 18
  var self = this;                                                               // 19
  self._dict = {};                                                               // 20
  self._first = null;                                                            // 21
  self._last = null;                                                             // 22
  self._size = 0;                                                                // 23
  var args = _.toArray(arguments);                                               // 24
  self._stringify = function (x) { return x; };                                  // 25
  if (typeof args[0] === 'function')                                             // 26
    self._stringify = args.shift();                                              // 27
  _.each(args, function (kv) {                                                   // 28
    self.putBefore(kv[0], kv[1], null);                                          // 29
  });                                                                            // 30
};                                                                               // 31
                                                                                 // 32
_.extend(OrderedDict.prototype, {                                                // 33
  // the "prefix keys with a space" thing comes from here                        // 34
  // https://github.com/documentcloud/underscore/issues/376#issuecomment-2815649 // 35
  _k: function (key) { return " " + this._stringify(key); },                     // 36
                                                                                 // 37
  empty: function () {                                                           // 38
    var self = this;                                                             // 39
    return !self._first;                                                         // 40
  },                                                                             // 41
  size: function () {                                                            // 42
    var self = this;                                                             // 43
    return self._size;                                                           // 44
  },                                                                             // 45
  _linkEltIn: function (elt) {                                                   // 46
    var self = this;                                                             // 47
    if (!elt.next) {                                                             // 48
      elt.prev = self._last;                                                     // 49
      if (self._last)                                                            // 50
        self._last.next = elt;                                                   // 51
      self._last = elt;                                                          // 52
    } else {                                                                     // 53
      elt.prev = elt.next.prev;                                                  // 54
      elt.next.prev = elt;                                                       // 55
      if (elt.prev)                                                              // 56
        elt.prev.next = elt;                                                     // 57
    }                                                                            // 58
    if (self._first === null || self._first === elt.next)                        // 59
      self._first = elt;                                                         // 60
  },                                                                             // 61
  _linkEltOut: function (elt) {                                                  // 62
    var self = this;                                                             // 63
    if (elt.next)                                                                // 64
      elt.next.prev = elt.prev;                                                  // 65
    if (elt.prev)                                                                // 66
      elt.prev.next = elt.next;                                                  // 67
    if (elt === self._last)                                                      // 68
      self._last = elt.prev;                                                     // 69
    if (elt === self._first)                                                     // 70
      self._first = elt.next;                                                    // 71
  },                                                                             // 72
  putBefore: function (key, item, before) {                                      // 73
    var self = this;                                                             // 74
    if (self._dict[self._k(key)])                                                // 75
      throw new Error("Item " + key + " already present in OrderedDict");        // 76
    var elt = before ?                                                           // 77
          element(key, item, self._dict[self._k(before)]) :                      // 78
          element(key, item, null);                                              // 79
    if (elt.next === undefined)                                                  // 80
      throw new Error("could not find item to put this one before");             // 81
    self._linkEltIn(elt);                                                        // 82
    self._dict[self._k(key)] = elt;                                              // 83
    self._size++;                                                                // 84
  },                                                                             // 85
  append: function (key, item) {                                                 // 86
    var self = this;                                                             // 87
    self.putBefore(key, item, null);                                             // 88
  },                                                                             // 89
  remove: function (key) {                                                       // 90
    var self = this;                                                             // 91
    var elt = self._dict[self._k(key)];                                          // 92
    if (elt === undefined)                                                       // 93
      throw new Error("Item " + key + " not present in OrderedDict");            // 94
    self._linkEltOut(elt);                                                       // 95
    self._size--;                                                                // 96
    delete self._dict[self._k(key)];                                             // 97
    return elt.value;                                                            // 98
  },                                                                             // 99
  get: function (key) {                                                          // 100
    var self = this;                                                             // 101
    if (self.has(key))                                                           // 102
        return self._dict[self._k(key)].value;                                   // 103
    return undefined;                                                            // 104
  },                                                                             // 105
  has: function (key) {                                                          // 106
    var self = this;                                                             // 107
    return _.has(self._dict, self._k(key));                                      // 108
  },                                                                             // 109
  // Iterate through the items in this dictionary in order, calling              // 110
  // iter(value, key, index) on each one.                                        // 111
                                                                                 // 112
  // Stops whenever iter returns OrderedDict.BREAK, or after the last element.   // 113
  forEach: function (iter) {                                                     // 114
    var self = this;                                                             // 115
    var i = 0;                                                                   // 116
    var elt = self._first;                                                       // 117
    while (elt !== null) {                                                       // 118
      var b = iter(elt.value, elt.key, i);                                       // 119
      if (b === OrderedDict.BREAK)                                               // 120
        return;                                                                  // 121
      elt = elt.next;                                                            // 122
      i++;                                                                       // 123
    }                                                                            // 124
  },                                                                             // 125
  first: function () {                                                           // 126
    var self = this;                                                             // 127
    if (self.empty())                                                            // 128
      return undefined;                                                          // 129
    return self._first.key;                                                      // 130
  },                                                                             // 131
  firstValue: function () {                                                      // 132
    var self = this;                                                             // 133
    if (self.empty())                                                            // 134
      return undefined;                                                          // 135
    return self._first.value;                                                    // 136
  },                                                                             // 137
  last: function () {                                                            // 138
    var self = this;                                                             // 139
    if (self.empty())                                                            // 140
      return undefined;                                                          // 141
    return self._last.key;                                                       // 142
  },                                                                             // 143
  lastValue: function () {                                                       // 144
    var self = this;                                                             // 145
    if (self.empty())                                                            // 146
      return undefined;                                                          // 147
    return self._last.value;                                                     // 148
  },                                                                             // 149
  prev: function (key) {                                                         // 150
    var self = this;                                                             // 151
    if (self.has(key)) {                                                         // 152
      var elt = self._dict[self._k(key)];                                        // 153
      if (elt.prev)                                                              // 154
        return elt.prev.key;                                                     // 155
    }                                                                            // 156
    return null;                                                                 // 157
  },                                                                             // 158
  next: function (key) {                                                         // 159
    var self = this;                                                             // 160
    if (self.has(key)) {                                                         // 161
      var elt = self._dict[self._k(key)];                                        // 162
      if (elt.next)                                                              // 163
        return elt.next.key;                                                     // 164
    }                                                                            // 165
    return null;                                                                 // 166
  },                                                                             // 167
  moveBefore: function (key, before) {                                           // 168
    var self = this;                                                             // 169
    var elt = self._dict[self._k(key)];                                          // 170
    var eltBefore = before ? self._dict[self._k(before)] : null;                 // 171
    if (elt === undefined)                                                       // 172
      throw new Error("Item to move is not present");                            // 173
    if (eltBefore === undefined) {                                               // 174
      throw new Error("Could not find element to move this one before");         // 175
    }                                                                            // 176
    if (eltBefore === elt.next) // no moving necessary                           // 177
      return;                                                                    // 178
    // remove from its old place                                                 // 179
    self._linkEltOut(elt);                                                       // 180
    // patch into its new place                                                  // 181
    elt.next = eltBefore;                                                        // 182
    self._linkEltIn(elt);                                                        // 183
  },                                                                             // 184
  // Linear, sadly.                                                              // 185
  indexOf: function (key) {                                                      // 186
    var self = this;                                                             // 187
    var ret = null;                                                              // 188
    self.forEach(function (v, k, i) {                                            // 189
      if (self._k(k) === self._k(key)) {                                         // 190
        ret = i;                                                                 // 191
        return OrderedDict.BREAK;                                                // 192
      }                                                                          // 193
      return undefined;                                                          // 194
    });                                                                          // 195
    return ret;                                                                  // 196
  },                                                                             // 197
  _checkRep: function () {                                                       // 198
    var self = this;                                                             // 199
    _.each(self._dict, function (k, v) {                                         // 200
      if (v.next === v)                                                          // 201
        throw new Error("Next is a loop");                                       // 202
      if (v.prev === v)                                                          // 203
        throw new Error("Prev is a loop");                                       // 204
    });                                                                          // 205
  }                                                                              // 206
                                                                                 // 207
});                                                                              // 208
OrderedDict.BREAK = {"break": true};                                             // 209
                                                                                 // 210
///////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['ordered-dict'] = {
  OrderedDict: OrderedDict
};

})();

//# sourceMappingURL=bf8af2f26c8d96bf8b2e6b407d3ed69f23c2cd37.map


//--------- geojson-utils.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;

/* Package-scope variables */
var GeoJSON, module;

(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                         //
// packages/geojson-utils/pre.js                                                                           //
//                                                                                                         //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                           //
// Define an object named exports. This will cause geojson-utils.js to put `gju`                           // 1
// as a field on it, instead of in the global namespace.  See also post.js.                                // 2
module = {exports:{}};                                                                                     // 3
                                                                                                           // 4
                                                                                                           // 5
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                         //
// packages/geojson-utils/geojson-utils.js                                                                 //
//                                                                                                         //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                           //
(function () {                                                                                             // 1
  var gju = {};                                                                                            // 2
                                                                                                           // 3
  // Export the geojson object for **CommonJS**                                                            // 4
  if (typeof module !== 'undefined' && module.exports) {                                                   // 5
    module.exports = gju;                                                                                  // 6
  }                                                                                                        // 7
                                                                                                           // 8
  // adapted from http://www.kevlindev.com/gui/math/intersection/Intersection.js                           // 9
  gju.lineStringsIntersect = function (l1, l2) {                                                           // 10
    var intersects = [];                                                                                   // 11
    for (var i = 0; i <= l1.coordinates.length - 2; ++i) {                                                 // 12
      for (var j = 0; j <= l2.coordinates.length - 2; ++j) {                                               // 13
        var a1 = {                                                                                         // 14
          x: l1.coordinates[i][1],                                                                         // 15
          y: l1.coordinates[i][0]                                                                          // 16
        },                                                                                                 // 17
          a2 = {                                                                                           // 18
            x: l1.coordinates[i + 1][1],                                                                   // 19
            y: l1.coordinates[i + 1][0]                                                                    // 20
          },                                                                                               // 21
          b1 = {                                                                                           // 22
            x: l2.coordinates[j][1],                                                                       // 23
            y: l2.coordinates[j][0]                                                                        // 24
          },                                                                                               // 25
          b2 = {                                                                                           // 26
            x: l2.coordinates[j + 1][1],                                                                   // 27
            y: l2.coordinates[j + 1][0]                                                                    // 28
          },                                                                                               // 29
          ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),                            // 30
          ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),                            // 31
          u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);                             // 32
        if (u_b != 0) {                                                                                    // 33
          var ua = ua_t / u_b,                                                                             // 34
            ub = ub_t / u_b;                                                                               // 35
          if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {                                                  // 36
            intersects.push({                                                                              // 37
              'type': 'Point',                                                                             // 38
              'coordinates': [a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)]                        // 39
            });                                                                                            // 40
          }                                                                                                // 41
        }                                                                                                  // 42
      }                                                                                                    // 43
    }                                                                                                      // 44
    if (intersects.length == 0) intersects = false;                                                        // 45
    return intersects;                                                                                     // 46
  }                                                                                                        // 47
                                                                                                           // 48
  // Bounding Box                                                                                          // 49
                                                                                                           // 50
  function boundingBoxAroundPolyCoords (coords) {                                                          // 51
    var xAll = [], yAll = []                                                                               // 52
                                                                                                           // 53
    for (var i = 0; i < coords[0].length; i++) {                                                           // 54
      xAll.push(coords[0][i][1])                                                                           // 55
      yAll.push(coords[0][i][0])                                                                           // 56
    }                                                                                                      // 57
                                                                                                           // 58
    xAll = xAll.sort(function (a,b) { return a - b })                                                      // 59
    yAll = yAll.sort(function (a,b) { return a - b })                                                      // 60
                                                                                                           // 61
    return [ [xAll[0], yAll[0]], [xAll[xAll.length - 1], yAll[yAll.length - 1]] ]                          // 62
  }                                                                                                        // 63
                                                                                                           // 64
  gju.pointInBoundingBox = function (point, bounds) {                                                      // 65
    return !(point.coordinates[1] < bounds[0][0] || point.coordinates[1] > bounds[1][0] || point.coordinates[0] < bounds[0][1] || point.coordinates[0] > bounds[1][1]) 
  }                                                                                                        // 67
                                                                                                           // 68
  // Point in Polygon                                                                                      // 69
  // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html#Listing the Vertices           // 70
                                                                                                           // 71
  function pnpoly (x,y,coords) {                                                                           // 72
    var vert = [ [0,0] ]                                                                                   // 73
                                                                                                           // 74
    for (var i = 0; i < coords.length; i++) {                                                              // 75
      for (var j = 0; j < coords[i].length; j++) {                                                         // 76
        vert.push(coords[i][j])                                                                            // 77
      }                                                                                                    // 78
      vert.push([0,0])                                                                                     // 79
    }                                                                                                      // 80
                                                                                                           // 81
    var inside = false                                                                                     // 82
    for (var i = 0, j = vert.length - 1; i < vert.length; j = i++) {                                       // 83
      if (((vert[i][0] > y) != (vert[j][0] > y)) && (x < (vert[j][1] - vert[i][1]) * (y - vert[i][0]) / (vert[j][0] - vert[i][0]) + vert[i][1])) inside = !inside
    }                                                                                                      // 85
                                                                                                           // 86
    return inside                                                                                          // 87
  }                                                                                                        // 88
                                                                                                           // 89
  gju.pointInPolygon = function (p, poly) {                                                                // 90
    var coords = (poly.type == "Polygon") ? [ poly.coordinates ] : poly.coordinates                        // 91
                                                                                                           // 92
    var insideBox = false                                                                                  // 93
    for (var i = 0; i < coords.length; i++) {                                                              // 94
      if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[i]))) insideBox = true              // 95
    }                                                                                                      // 96
    if (!insideBox) return false                                                                           // 97
                                                                                                           // 98
    var insidePoly = false                                                                                 // 99
    for (var i = 0; i < coords.length; i++) {                                                              // 100
      if (pnpoly(p.coordinates[1], p.coordinates[0], coords[i])) insidePoly = true                         // 101
    }                                                                                                      // 102
                                                                                                           // 103
    return insidePoly                                                                                      // 104
  }                                                                                                        // 105
                                                                                                           // 106
  gju.numberToRadius = function (number) {                                                                 // 107
    return number * Math.PI / 180;                                                                         // 108
  }                                                                                                        // 109
                                                                                                           // 110
  gju.numberToDegree = function (number) {                                                                 // 111
    return number * 180 / Math.PI;                                                                         // 112
  }                                                                                                        // 113
                                                                                                           // 114
  // written with help from @tautologe                                                                     // 115
  gju.drawCircle = function (radiusInMeters, centerPoint, steps) {                                         // 116
    var center = [centerPoint.coordinates[1], centerPoint.coordinates[0]],                                 // 117
      dist = (radiusInMeters / 1000) / 6371,                                                               // 118
      // convert meters to radiant                                                                         // 119
      radCenter = [gju.numberToRadius(center[0]), gju.numberToRadius(center[1])],                          // 120
      steps = steps || 15,                                                                                 // 121
      // 15 sided circle                                                                                   // 122
      poly = [[center[0], center[1]]];                                                                     // 123
    for (var i = 0; i < steps; i++) {                                                                      // 124
      var brng = 2 * Math.PI * i / steps;                                                                  // 125
      var lat = Math.asin(Math.sin(radCenter[0]) * Math.cos(dist)                                          // 126
              + Math.cos(radCenter[0]) * Math.sin(dist) * Math.cos(brng));                                 // 127
      var lng = radCenter[1] + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(radCenter[0]),        // 128
                                          Math.cos(dist) - Math.sin(radCenter[0]) * Math.sin(lat));        // 129
      poly[i] = [];                                                                                        // 130
      poly[i][1] = gju.numberToDegree(lat);                                                                // 131
      poly[i][0] = gju.numberToDegree(lng);                                                                // 132
    }                                                                                                      // 133
    return {                                                                                               // 134
      "type": "Polygon",                                                                                   // 135
      "coordinates": [poly]                                                                                // 136
    };                                                                                                     // 137
  }                                                                                                        // 138
                                                                                                           // 139
  // assumes rectangle starts at lower left point                                                          // 140
  gju.rectangleCentroid = function (rectangle) {                                                           // 141
    var bbox = rectangle.coordinates[0];                                                                   // 142
    var xmin = bbox[0][0],                                                                                 // 143
      ymin = bbox[0][1],                                                                                   // 144
      xmax = bbox[2][0],                                                                                   // 145
      ymax = bbox[2][1];                                                                                   // 146
    var xwidth = xmax - xmin;                                                                              // 147
    var ywidth = ymax - ymin;                                                                              // 148
    return {                                                                                               // 149
      'type': 'Point',                                                                                     // 150
      'coordinates': [xmin + xwidth / 2, ymin + ywidth / 2]                                                // 151
    };                                                                                                     // 152
  }                                                                                                        // 153
                                                                                                           // 154
  // from http://www.movable-type.co.uk/scripts/latlong.html                                               // 155
  gju.pointDistance = function (pt1, pt2) {                                                                // 156
    var lon1 = pt1.coordinates[0],                                                                         // 157
      lat1 = pt1.coordinates[1],                                                                           // 158
      lon2 = pt2.coordinates[0],                                                                           // 159
      lat2 = pt2.coordinates[1],                                                                           // 160
      dLat = gju.numberToRadius(lat2 - lat1),                                                              // 161
      dLon = gju.numberToRadius(lon2 - lon1),                                                              // 162
      a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(gju.numberToRadius(lat1))                             // 163
        * Math.cos(gju.numberToRadius(lat2)) * Math.pow(Math.sin(dLon / 2), 2),                            // 164
      c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));                                                  // 165
    // Earth radius is 6371 km                                                                             // 166
    return (6371 * c) * 1000; // returns meters                                                            // 167
  },                                                                                                       // 168
                                                                                                           // 169
  // checks if geometry lies entirely within a circle                                                      // 170
  // works with Point, LineString, Polygon                                                                 // 171
  gju.geometryWithinRadius = function (geometry, center, radius) {                                         // 172
    if (geometry.type == 'Point') {                                                                        // 173
      return gju.pointDistance(geometry, center) <= radius;                                                // 174
    } else if (geometry.type == 'LineString' || geometry.type == 'Polygon') {                              // 175
      var point = {};                                                                                      // 176
      var coordinates;                                                                                     // 177
      if (geometry.type == 'Polygon') {                                                                    // 178
        // it's enough to check the exterior ring of the Polygon                                           // 179
        coordinates = geometry.coordinates[0];                                                             // 180
      } else {                                                                                             // 181
        coordinates = geometry.coordinates;                                                                // 182
      }                                                                                                    // 183
      for (var i in coordinates) {                                                                         // 184
        point.coordinates = coordinates[i];                                                                // 185
        if (gju.pointDistance(point, center) > radius) {                                                   // 186
          return false;                                                                                    // 187
        }                                                                                                  // 188
      }                                                                                                    // 189
    }                                                                                                      // 190
    return true;                                                                                           // 191
  }                                                                                                        // 192
                                                                                                           // 193
  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt                                   // 194
  gju.area = function (polygon) {                                                                          // 195
    var area = 0;                                                                                          // 196
    // TODO: polygon holes at coordinates[1]                                                               // 197
    var points = polygon.coordinates[0];                                                                   // 198
    var j = points.length - 1;                                                                             // 199
    var p1, p2;                                                                                            // 200
                                                                                                           // 201
    for (var i = 0; i < points.length; j = i++) {                                                          // 202
      var p1 = {                                                                                           // 203
        x: points[i][1],                                                                                   // 204
        y: points[i][0]                                                                                    // 205
      };                                                                                                   // 206
      var p2 = {                                                                                           // 207
        x: points[j][1],                                                                                   // 208
        y: points[j][0]                                                                                    // 209
      };                                                                                                   // 210
      area += p1.x * p2.y;                                                                                 // 211
      area -= p1.y * p2.x;                                                                                 // 212
    }                                                                                                      // 213
                                                                                                           // 214
    area /= 2;                                                                                             // 215
    return area;                                                                                           // 216
  },                                                                                                       // 217
                                                                                                           // 218
  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt                                   // 219
  gju.centroid = function (polygon) {                                                                      // 220
    var f, x = 0,                                                                                          // 221
      y = 0;                                                                                               // 222
    // TODO: polygon holes at coordinates[1]                                                               // 223
    var points = polygon.coordinates[0];                                                                   // 224
    var j = points.length - 1;                                                                             // 225
    var p1, p2;                                                                                            // 226
                                                                                                           // 227
    for (var i = 0; i < points.length; j = i++) {                                                          // 228
      var p1 = {                                                                                           // 229
        x: points[i][1],                                                                                   // 230
        y: points[i][0]                                                                                    // 231
      };                                                                                                   // 232
      var p2 = {                                                                                           // 233
        x: points[j][1],                                                                                   // 234
        y: points[j][0]                                                                                    // 235
      };                                                                                                   // 236
      f = p1.x * p2.y - p2.x * p1.y;                                                                       // 237
      x += (p1.x + p2.x) * f;                                                                              // 238
      y += (p1.y + p2.y) * f;                                                                              // 239
    }                                                                                                      // 240
                                                                                                           // 241
    f = gju.area(polygon) * 6;                                                                             // 242
    return {                                                                                               // 243
      'type': 'Point',                                                                                     // 244
      'coordinates': [y / f, x / f]                                                                        // 245
    };                                                                                                     // 246
  },                                                                                                       // 247
                                                                                                           // 248
  gju.simplify = function (source, kink) { /* source[] array of geojson points */                          // 249
    /* kink	in metres, kinks above this depth kept  */                                                     // 250
    /* kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments */ // 251
    kink = kink || 20;                                                                                     // 252
    source = source.map(function (o) {                                                                     // 253
      return {                                                                                             // 254
        lng: o.coordinates[0],                                                                             // 255
        lat: o.coordinates[1]                                                                              // 256
      }                                                                                                    // 257
    });                                                                                                    // 258
                                                                                                           // 259
    var n_source, n_stack, n_dest, start, end, i, sig;                                                     // 260
    var dev_sqr, max_dev_sqr, band_sqr;                                                                    // 261
    var x12, y12, d12, x13, y13, d13, x23, y23, d23;                                                       // 262
    var F = (Math.PI / 180.0) * 0.5;                                                                       // 263
    var index = new Array(); /* aray of indexes of source points to include in the reduced line */         // 264
    var sig_start = new Array(); /* indices of start & end of working section */                           // 265
    var sig_end = new Array();                                                                             // 266
                                                                                                           // 267
    /* check for simple cases */                                                                           // 268
                                                                                                           // 269
    if (source.length < 3) return (source); /* one or two points */                                        // 270
                                                                                                           // 271
    /* more complex case. initialize stack */                                                              // 272
                                                                                                           // 273
    n_source = source.length;                                                                              // 274
    band_sqr = kink * 360.0 / (2.0 * Math.PI * 6378137.0); /* Now in degrees */                            // 275
    band_sqr *= band_sqr;                                                                                  // 276
    n_dest = 0;                                                                                            // 277
    sig_start[0] = 0;                                                                                      // 278
    sig_end[0] = n_source - 1;                                                                             // 279
    n_stack = 1;                                                                                           // 280
                                                                                                           // 281
    /* while the stack is not empty  ... */                                                                // 282
    while (n_stack > 0) {                                                                                  // 283
                                                                                                           // 284
      /* ... pop the top-most entries off the stacks */                                                    // 285
                                                                                                           // 286
      start = sig_start[n_stack - 1];                                                                      // 287
      end = sig_end[n_stack - 1];                                                                          // 288
      n_stack--;                                                                                           // 289
                                                                                                           // 290
      if ((end - start) > 1) { /* any intermediate points ? */                                             // 291
                                                                                                           // 292
        /* ... yes, so find most deviant intermediate point to                                             // 293
        either side of line joining start & end points */                                                  // 294
                                                                                                           // 295
        x12 = (source[end].lng() - source[start].lng());                                                   // 296
        y12 = (source[end].lat() - source[start].lat());                                                   // 297
        if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);                                            // 298
        x12 *= Math.cos(F * (source[end].lat() + source[start].lat())); /* use avg lat to reduce lng */    // 299
        d12 = (x12 * x12) + (y12 * y12);                                                                   // 300
                                                                                                           // 301
        for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {                               // 302
                                                                                                           // 303
          x13 = source[i].lng() - source[start].lng();                                                     // 304
          y13 = source[i].lat() - source[start].lat();                                                     // 305
          if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);                                          // 306
          x13 *= Math.cos(F * (source[i].lat() + source[start].lat()));                                    // 307
          d13 = (x13 * x13) + (y13 * y13);                                                                 // 308
                                                                                                           // 309
          x23 = source[i].lng() - source[end].lng();                                                       // 310
          y23 = source[i].lat() - source[end].lat();                                                       // 311
          if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);                                          // 312
          x23 *= Math.cos(F * (source[i].lat() + source[end].lat()));                                      // 313
          d23 = (x23 * x23) + (y23 * y23);                                                                 // 314
                                                                                                           // 315
          if (d13 >= (d12 + d23)) dev_sqr = d23;                                                           // 316
          else if (d23 >= (d12 + d13)) dev_sqr = d13;                                                      // 317
          else dev_sqr = (x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12) / d12; // solve triangle        // 318
          if (dev_sqr > max_dev_sqr) {                                                                     // 319
            sig = i;                                                                                       // 320
            max_dev_sqr = dev_sqr;                                                                         // 321
          }                                                                                                // 322
        }                                                                                                  // 323
                                                                                                           // 324
        if (max_dev_sqr < band_sqr) { /* is there a sig. intermediate point ? */                           // 325
          /* ... no, so transfer current start point */                                                    // 326
          index[n_dest] = start;                                                                           // 327
          n_dest++;                                                                                        // 328
        } else { /* ... yes, so push two sub-sections on stack for further processing */                   // 329
          n_stack++;                                                                                       // 330
          sig_start[n_stack - 1] = sig;                                                                    // 331
          sig_end[n_stack - 1] = end;                                                                      // 332
          n_stack++;                                                                                       // 333
          sig_start[n_stack - 1] = start;                                                                  // 334
          sig_end[n_stack - 1] = sig;                                                                      // 335
        }                                                                                                  // 336
      } else { /* ... no intermediate points, so transfer current start point */                           // 337
        index[n_dest] = start;                                                                             // 338
        n_dest++;                                                                                          // 339
      }                                                                                                    // 340
    }                                                                                                      // 341
                                                                                                           // 342
    /* transfer last point */                                                                              // 343
    index[n_dest] = n_source - 1;                                                                          // 344
    n_dest++;                                                                                              // 345
                                                                                                           // 346
    /* make return array */                                                                                // 347
    var r = new Array();                                                                                   // 348
    for (var i = 0; i < n_dest; i++)                                                                       // 349
      r.push(source[index[i]]);                                                                            // 350
                                                                                                           // 351
    return r.map(function (o) {                                                                            // 352
      return {                                                                                             // 353
        type: "Point",                                                                                     // 354
        coordinates: [o.lng, o.lat]                                                                        // 355
      }                                                                                                    // 356
    });                                                                                                    // 357
  }                                                                                                        // 358
                                                                                                           // 359
  // http://www.movable-type.co.uk/scripts/latlong.html#destPoint                                          // 360
  gju.destinationPoint = function (pt, brng, dist) {                                                       // 361
    dist = dist/6371;  // convert dist to angular distance in radians                                      // 362
    brng = gju.numberToRadius(brng);                                                                       // 363
                                                                                                           // 364
    var lat1 = gju.numberToRadius(pt.coordinates[0]);                                                      // 365
    var lon1 = gju.numberToRadius(pt.coordinates[1]);                                                      // 366
                                                                                                           // 367
    var lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist) +                                                  // 368
                          Math.cos(lat1)*Math.sin(dist)*Math.cos(brng) );                                  // 369
    var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(dist)*Math.cos(lat1),                             // 370
                                 Math.cos(dist)-Math.sin(lat1)*Math.sin(lat2));                            // 371
    lon2 = (lon2+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180Âº                          // 372
                                                                                                           // 373
    return {                                                                                               // 374
      'type': 'Point',                                                                                     // 375
      'coordinates': [gju.numberToDegree(lat2), gju.numberToDegree(lon2)]                                  // 376
    };                                                                                                     // 377
  };                                                                                                       // 378
                                                                                                           // 379
})();                                                                                                      // 380
                                                                                                           // 381
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                         //
// packages/geojson-utils/post.js                                                                          //
//                                                                                                         //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                           //
// This exports object was created in pre.js.  Now copy the `exports` object                               // 1
// from it into the package-scope variable `GeoJSON`, which will get exported.                             // 2
GeoJSON = module.exports;                                                                                  // 3
                                                                                                           // 4
                                                                                                           // 5
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['geojson-utils'] = {
  GeoJSON: GeoJSON
};

})();

//# sourceMappingURL=81b79d5cf96d00b4b7a28987debcffb665c17526.map


//--------- minimongo.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var JSON = Package.json.JSON;
var EJSON = Package.ejson.EJSON;
var OrderedDict = Package['ordered-dict'].OrderedDict;
var Deps = Package.deps.Deps;
var Random = Package.random.Random;
var GeoJSON = Package['geojson-utils'].GeoJSON;

/* Package-scope variables */
var LocalCollection, Minimongo, MinimongoTest, MinimongoError, isArray, isPlainObject, isIndexable, isOperatorObject, isNumericKey, makeLookupFunction, expandArraysInBranches, Sorter, projectionDetails, pathsToTree;

(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/minimongo.js                                                                    //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
// XXX type checking on selectors (graceful error if malformed)                                       // 1
                                                                                                      // 2
// LocalCollection: a set of documents that supports queries and modifiers.                           // 3
                                                                                                      // 4
// Cursor: a specification for a particular subset of documents, w/                                   // 5
// a defined order, limit, and offset.  creating a Cursor with LocalCollection.find(),                // 6
                                                                                                      // 7
// ObserveHandle: the return value of a live query.                                                   // 8
                                                                                                      // 9
LocalCollection = function (options) {                                                                // 10
  var self = this;                                                                                    // 11
  options = options || {};                                                                            // 12
                                                                                                      // 13
  self.name = options.name;                                                                           // 14
  // _id -> document (also containing id)                                                             // 15
  self._docs = new LocalCollection._IdMap;                                                            // 16
                                                                                                      // 17
  // When writing to this collection, we batch all observeChanges callbacks                           // 18
  // until the end of the write, and run them at this point. On the server, we                        // 19
  // use a single SynchronousQueue to do so, so that we never deliver callbacks                       // 20
  // out of order even if other writes occur during a yield. On the client, or                        // 21
  // on the server if we promise that our callbacks will never yield via an                           // 22
  // undocumented option, we use the simpler UnyieldingQueue.                                         // 23
  //                                                                                                  // 24
  // (What is the _observeCallbacksWillNeverYield option for? In some cases, it                       // 25
  // can be nice (on the server) to be able to write to a LocalCollection                             // 26
  // without yielding (eg, in a _noYieldsAllowed block). It's necessary to                            // 27
  // provide non-yielding allow callbacks in that case, but just doing that                           // 28
  // wouldn't be good enough if we always used SynchronousQueue on the server,                        // 29
  // since it tends to yield in order to run even non-yielding callbacks.)                            // 30
  var queueClass;                                                                                     // 31
  if (Meteor._SynchronousQueue && !options._observeCallbacksWillNeverYield) {                         // 32
    queueClass = Meteor._SynchronousQueue;                                                            // 33
  } else {                                                                                            // 34
    queueClass = Meteor._UnyieldingQueue;                                                             // 35
  }                                                                                                   // 36
  self._observeQueue = new queueClass();                                                              // 37
                                                                                                      // 38
  self.next_qid = 1; // live query id generator                                                       // 39
                                                                                                      // 40
  // qid -> live query object. keys:                                                                  // 41
  //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.                          // 42
  //  results: array (ordered) or object (unordered) of current results                               // 43
  //    (aliased with self._docs!)                                                                    // 44
  //  resultsSnapshot: snapshot of results. null if not paused.                                       // 45
  //  cursor: Cursor object for the query.                                                            // 46
  //  selector, sorter, (callbacks): functions                                                        // 47
  self.queries = {};                                                                                  // 48
                                                                                                      // 49
  // null if not saving originals; an IdMap from id to original document value                        // 50
  // if saving originals. See comments before saveOriginals().                                        // 51
  self._savedOriginals = null;                                                                        // 52
                                                                                                      // 53
  // True when observers are paused and we should not send callbacks.                                 // 54
  self.paused = false;                                                                                // 55
};                                                                                                    // 56
                                                                                                      // 57
Minimongo = {};                                                                                       // 58
                                                                                                      // 59
// Object exported only for unit testing.                                                             // 60
// Use it to export private functions to test in Tinytest.                                            // 61
MinimongoTest = {};                                                                                   // 62
                                                                                                      // 63
LocalCollection._applyChanges = function (doc, changeFields) {                                        // 64
  _.each(changeFields, function (value, key) {                                                        // 65
    if (value === undefined)                                                                          // 66
      delete doc[key];                                                                                // 67
    else                                                                                              // 68
      doc[key] = value;                                                                               // 69
  });                                                                                                 // 70
};                                                                                                    // 71
                                                                                                      // 72
MinimongoError = function (message) {                                                                 // 73
  var e = new Error(message);                                                                         // 74
  e.name = "MinimongoError";                                                                          // 75
  return e;                                                                                           // 76
};                                                                                                    // 77
                                                                                                      // 78
                                                                                                      // 79
// options may include sort, skip, limit, reactive                                                    // 80
// sort may be any of these forms:                                                                    // 81
//     {a: 1, b: -1}                                                                                  // 82
//     [["a", "asc"], ["b", "desc"]]                                                                  // 83
//     ["a", ["b", "desc"]]                                                                           // 84
//   (in the first form you're beholden to key enumeration order in                                   // 85
//   your javascript VM)                                                                              // 86
//                                                                                                    // 87
// reactive: if given, and false, don't register with Deps (default                                   // 88
// is true)                                                                                           // 89
//                                                                                                    // 90
// XXX possibly should support retrieving a subset of fields? and                                     // 91
// have it be a hint (ignored on the client, when not copying the                                     // 92
// doc?)                                                                                              // 93
//                                                                                                    // 94
// XXX sort does not yet support subkeys ('a.b') .. fix that!                                         // 95
// XXX add one more sort form: "key"                                                                  // 96
// XXX tests                                                                                          // 97
LocalCollection.prototype.find = function (selector, options) {                                       // 98
  // default syntax for everything is to omit the selector argument.                                  // 99
  // but if selector is explicitly passed in as false or undefined, we                                // 100
  // want a selector that matches nothing.                                                            // 101
  if (arguments.length === 0)                                                                         // 102
    selector = {};                                                                                    // 103
                                                                                                      // 104
  return new LocalCollection.Cursor(this, selector, options);                                         // 105
};                                                                                                    // 106
                                                                                                      // 107
// don't call this ctor directly.  use LocalCollection.find().                                        // 108
LocalCollection.Cursor = function (collection, selector, options) {                                   // 109
  var self = this;                                                                                    // 110
  if (!options) options = {};                                                                         // 111
                                                                                                      // 112
  this.collection = collection;                                                                       // 113
                                                                                                      // 114
  if (LocalCollection._selectorIsId(selector)) {                                                      // 115
    // stash for fast path                                                                            // 116
    self._selectorId = selector;                                                                      // 117
    self.matcher = new Minimongo.Matcher(selector, self);                                             // 118
    self.sorter = undefined;                                                                          // 119
  } else {                                                                                            // 120
    self._selectorId = undefined;                                                                     // 121
    self.matcher = new Minimongo.Matcher(selector, self);                                             // 122
    self.sorter = (self.matcher.hasGeoQuery() || options.sort) ?                                      // 123
      new Sorter(options.sort || []) : null;                                                          // 124
  }                                                                                                   // 125
  self.skip = options.skip;                                                                           // 126
  self.limit = options.limit;                                                                         // 127
  self.fields = options.fields;                                                                       // 128
                                                                                                      // 129
  if (self.fields)                                                                                    // 130
    self.projectionFn = LocalCollection._compileProjection(self.fields);                              // 131
                                                                                                      // 132
  self._transform = LocalCollection.wrapTransform(options.transform);                                 // 133
                                                                                                      // 134
  // db_objects is an array of the objects that match the cursor. (It's always                        // 135
  // an array, never an IdMap: LocalCollection.Cursor is always ordered.)                             // 136
  self.db_objects = null;                                                                             // 137
  self.cursor_pos = 0;                                                                                // 138
                                                                                                      // 139
  // by default, queries register w/ Deps when it is available.                                       // 140
  if (typeof Deps !== "undefined")                                                                    // 141
    self.reactive = (options.reactive === undefined) ? true : options.reactive;                       // 142
};                                                                                                    // 143
                                                                                                      // 144
LocalCollection.Cursor.prototype.rewind = function () {                                               // 145
  var self = this;                                                                                    // 146
  self.db_objects = null;                                                                             // 147
  self.cursor_pos = 0;                                                                                // 148
};                                                                                                    // 149
                                                                                                      // 150
LocalCollection.prototype.findOne = function (selector, options) {                                    // 151
  if (arguments.length === 0)                                                                         // 152
    selector = {};                                                                                    // 153
                                                                                                      // 154
  // NOTE: by setting limit 1 here, we end up using very inefficient                                  // 155
  // code that recomputes the whole query on each update. The upside is                               // 156
  // that when you reactively depend on a findOne you only get                                        // 157
  // invalidated when the found object changes, not any object in the                                 // 158
  // collection. Most findOne will be by id, which has a fast path, so                                // 159
  // this might not be a big deal. In most cases, invalidation causes                                 // 160
  // the called to re-query anyway, so this should be a net performance                               // 161
  // improvement.                                                                                     // 162
  options = options || {};                                                                            // 163
  options.limit = 1;                                                                                  // 164
                                                                                                      // 165
  return this.find(selector, options).fetch()[0];                                                     // 166
};                                                                                                    // 167
                                                                                                      // 168
LocalCollection.Cursor.prototype.forEach = function (callback, thisArg) {                             // 169
  var self = this;                                                                                    // 170
                                                                                                      // 171
  if (self.db_objects === null)                                                                       // 172
    self.db_objects = self._getRawObjects({ordered: true});                                           // 173
                                                                                                      // 174
  if (self.reactive)                                                                                  // 175
    self._depend({                                                                                    // 176
      addedBefore: true,                                                                              // 177
      removed: true,                                                                                  // 178
      changed: true,                                                                                  // 179
      movedBefore: true});                                                                            // 180
                                                                                                      // 181
  while (self.cursor_pos < self.db_objects.length) {                                                  // 182
    var elt = EJSON.clone(self.db_objects[self.cursor_pos]);                                          // 183
    if (self.projectionFn)                                                                            // 184
      elt = self.projectionFn(elt);                                                                   // 185
    if (self._transform)                                                                              // 186
      elt = self._transform(elt);                                                                     // 187
    callback.call(thisArg, elt, self.cursor_pos, self);                                               // 188
    ++self.cursor_pos;                                                                                // 189
  }                                                                                                   // 190
};                                                                                                    // 191
                                                                                                      // 192
LocalCollection.Cursor.prototype.getTransform = function () {                                         // 193
  return this._transform;                                                                             // 194
};                                                                                                    // 195
                                                                                                      // 196
LocalCollection.Cursor.prototype.map = function (callback, thisArg) {                                 // 197
  var self = this;                                                                                    // 198
  var res = [];                                                                                       // 199
  self.forEach(function (doc, index) {                                                                // 200
    res.push(callback.call(thisArg, doc, index, self));                                               // 201
  });                                                                                                 // 202
  return res;                                                                                         // 203
};                                                                                                    // 204
                                                                                                      // 205
LocalCollection.Cursor.prototype.fetch = function () {                                                // 206
  var self = this;                                                                                    // 207
  var res = [];                                                                                       // 208
  self.forEach(function (doc) {                                                                       // 209
    res.push(doc);                                                                                    // 210
  });                                                                                                 // 211
  return res;                                                                                         // 212
};                                                                                                    // 213
                                                                                                      // 214
LocalCollection.Cursor.prototype.count = function () {                                                // 215
  var self = this;                                                                                    // 216
                                                                                                      // 217
  if (self.reactive)                                                                                  // 218
    self._depend({added: true, removed: true},                                                        // 219
                 true /* allow the observe to be unordered */);                                       // 220
                                                                                                      // 221
  if (self.db_objects === null)                                                                       // 222
    self.db_objects = self._getRawObjects({ordered: true});                                           // 223
                                                                                                      // 224
  return self.db_objects.length;                                                                      // 225
};                                                                                                    // 226
                                                                                                      // 227
LocalCollection.Cursor.prototype._publishCursor = function (sub) {                                    // 228
  var self = this;                                                                                    // 229
  if (! self.collection.name)                                                                         // 230
    throw new Error("Can't publish a cursor from a collection without a name.");                      // 231
  var collection = self.collection.name;                                                              // 232
                                                                                                      // 233
  // XXX minimongo should not depend on mongo-livedata!                                               // 234
  return Meteor.Collection._publishCursor(self, sub, collection);                                     // 235
};                                                                                                    // 236
                                                                                                      // 237
LocalCollection._observeChangesCallbacksAreOrdered = function (callbacks) {                           // 238
  if (callbacks.added && callbacks.addedBefore)                                                       // 239
    throw new Error("Please specify only one of added() and addedBefore()");                          // 240
  return !!(callbacks.addedBefore || callbacks.movedBefore);                                          // 241
};                                                                                                    // 242
                                                                                                      // 243
LocalCollection._observeCallbacksAreOrdered = function (callbacks) {                                  // 244
  if (callbacks.addedAt && callbacks.added)                                                           // 245
    throw new Error("Please specify only one of added() and addedAt()");                              // 246
  if (callbacks.changedAt && callbacks.changed)                                                       // 247
    throw new Error("Please specify only one of changed() and changedAt()");                          // 248
  if (callbacks.removed && callbacks.removedAt)                                                       // 249
    throw new Error("Please specify only one of removed() and removedAt()");                          // 250
                                                                                                      // 251
  return !!(callbacks.addedAt || callbacks.movedTo || callbacks.changedAt                             // 252
            || callbacks.removedAt);                                                                  // 253
};                                                                                                    // 254
                                                                                                      // 255
// the handle that comes back from observe.                                                           // 256
LocalCollection.ObserveHandle = function () {};                                                       // 257
                                                                                                      // 258
// options to contain:                                                                                // 259
//  * callbacks for observe():                                                                        // 260
//    - addedAt (document, atIndex)                                                                   // 261
//    - added (document)                                                                              // 262
//    - changedAt (newDocument, oldDocument, atIndex)                                                 // 263
//    - changed (newDocument, oldDocument)                                                            // 264
//    - removedAt (document, atIndex)                                                                 // 265
//    - removed (document)                                                                            // 266
//    - movedTo (document, oldIndex, newIndex)                                                        // 267
//                                                                                                    // 268
// attributes available on returned query handle:                                                     // 269
//  * stop(): end updates                                                                             // 270
//  * collection: the collection this query is querying                                               // 271
//                                                                                                    // 272
// iff x is a returned query handle, (x instanceof                                                    // 273
// LocalCollection.ObserveHandle) is true                                                             // 274
//                                                                                                    // 275
// initial results delivered through added callback                                                   // 276
// XXX maybe callbacks should take a list of objects, to expose transactions?                         // 277
// XXX maybe support field limiting (to limit what you're notified on)                                // 278
                                                                                                      // 279
_.extend(LocalCollection.Cursor.prototype, {                                                          // 280
  observe: function (options) {                                                                       // 281
    var self = this;                                                                                  // 282
    return LocalCollection._observeFromObserveChanges(self, options);                                 // 283
  },                                                                                                  // 284
  observeChanges: function (options) {                                                                // 285
    var self = this;                                                                                  // 286
                                                                                                      // 287
    var ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);                        // 288
                                                                                                      // 289
    // there are several places that assume you aren't combining skip/limit with                      // 290
    // unordered observe.  eg, update's EJSON.clone, and the "there are several"                      // 291
    // comment in _modifyAndNotify                                                                    // 292
    // XXX allow skip/limit with unordered observe                                                    // 293
    if (!options._allow_unordered && !ordered && (self.skip || self.limit))                           // 294
      throw new Error("must use ordered observe with skip or limit");                                 // 295
                                                                                                      // 296
    if (self.fields && (self.fields._id === 0 || self.fields._id === false))                          // 297
      throw Error("You may not observe a cursor with {fields: {_id: 0}}");                            // 298
                                                                                                      // 299
    var query = {                                                                                     // 300
      matcher: self.matcher, // not fast pathed                                                       // 301
      sorter: ordered && self.sorter,                                                                 // 302
      distances: (                                                                                    // 303
        self.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap),                         // 304
      resultsSnapshot: null,                                                                          // 305
      ordered: ordered,                                                                               // 306
      cursor: self,                                                                                   // 307
      projectionFn: self.projectionFn                                                                 // 308
    };                                                                                                // 309
    var qid;                                                                                          // 310
                                                                                                      // 311
    // Non-reactive queries call added[Before] and then never call anything                           // 312
    // else.                                                                                          // 313
    if (self.reactive) {                                                                              // 314
      qid = self.collection.next_qid++;                                                               // 315
      self.collection.queries[qid] = query;                                                           // 316
    }                                                                                                 // 317
    query.results = self._getRawObjects({                                                             // 318
      ordered: ordered, distances: query.distances});                                                 // 319
    if (self.collection.paused)                                                                       // 320
      query.resultsSnapshot = (ordered ? [] : new LocalCollection._IdMap);                            // 321
                                                                                                      // 322
    // wrap callbacks we were passed. callbacks only fire when not paused and                         // 323
    // are never undefined                                                                            // 324
    // Filters out blacklisted fields according to cursor's projection.                               // 325
    // XXX wrong place for this?                                                                      // 326
                                                                                                      // 327
    // furthermore, callbacks enqueue until the operation we're working on is                         // 328
    // done.                                                                                          // 329
    var wrapCallback = function (f, fieldsIndex, ignoreEmptyFields) {                                 // 330
      if (!f)                                                                                         // 331
        return function () {};                                                                        // 332
      return function (/*args*/) {                                                                    // 333
        var context = this;                                                                           // 334
        var args = arguments;                                                                         // 335
                                                                                                      // 336
        if (self.collection.paused)                                                                   // 337
          return;                                                                                     // 338
                                                                                                      // 339
        if (fieldsIndex !== undefined && self.projectionFn) {                                         // 340
          args[fieldsIndex] = self.projectionFn(args[fieldsIndex]);                                   // 341
          if (ignoreEmptyFields && _.isEmpty(args[fieldsIndex]))                                      // 342
            return;                                                                                   // 343
        }                                                                                             // 344
                                                                                                      // 345
        self.collection._observeQueue.queueTask(function () {                                         // 346
          f.apply(context, args);                                                                     // 347
        });                                                                                           // 348
      };                                                                                              // 349
    };                                                                                                // 350
    query.added = wrapCallback(options.added, 1);                                                     // 351
    query.changed = wrapCallback(options.changed, 1, true);                                           // 352
    query.removed = wrapCallback(options.removed);                                                    // 353
    if (ordered) {                                                                                    // 354
      query.addedBefore = wrapCallback(options.addedBefore, 1);                                       // 355
      query.movedBefore = wrapCallback(options.movedBefore);                                          // 356
    }                                                                                                 // 357
                                                                                                      // 358
    if (!options._suppress_initial && !self.collection.paused) {                                      // 359
      // XXX unify ordered and unordered interface                                                    // 360
      var each = ordered                                                                              // 361
            ? _.bind(_.each, null, query.results)                                                     // 362
            : _.bind(query.results.forEach, query.results);                                           // 363
      each(function (doc) {                                                                           // 364
        var fields = EJSON.clone(doc);                                                                // 365
                                                                                                      // 366
        delete fields._id;                                                                            // 367
        if (ordered)                                                                                  // 368
          query.addedBefore(doc._id, fields, null);                                                   // 369
        query.added(doc._id, fields);                                                                 // 370
      });                                                                                             // 371
    }                                                                                                 // 372
                                                                                                      // 373
    var handle = new LocalCollection.ObserveHandle;                                                   // 374
    _.extend(handle, {                                                                                // 375
      collection: self.collection,                                                                    // 376
      stop: function () {                                                                             // 377
        if (self.reactive)                                                                            // 378
          delete self.collection.queries[qid];                                                        // 379
      }                                                                                               // 380
    });                                                                                               // 381
                                                                                                      // 382
    if (self.reactive && Deps.active) {                                                               // 383
      // XXX in many cases, the same observe will be recreated when                                   // 384
      // the current autorun is rerun.  we could save work by                                         // 385
      // letting it linger across rerun and potentially get                                           // 386
      // repurposed if the same observe is performed, using logic                                     // 387
      // similar to that of Meteor.subscribe.                                                         // 388
      Deps.onInvalidate(function () {                                                                 // 389
        handle.stop();                                                                                // 390
      });                                                                                             // 391
    }                                                                                                 // 392
    // run the observe callbacks resulting from the initial contents                                  // 393
    // before we leave the observe.                                                                   // 394
    self.collection._observeQueue.drain();                                                            // 395
                                                                                                      // 396
    return handle;                                                                                    // 397
  }                                                                                                   // 398
});                                                                                                   // 399
                                                                                                      // 400
// Returns a collection of matching objects, but doesn't deep copy them.                              // 401
//                                                                                                    // 402
// If ordered is set, returns a sorted array, respecting sorter, skip, and limit                      // 403
// properties of the query.  if sorter is falsey, no sort -- you get the natural                      // 404
// order.                                                                                             // 405
//                                                                                                    // 406
// If ordered is not set, returns an object mapping from ID to doc (sorter, skip                      // 407
// and limit should not be set).                                                                      // 408
//                                                                                                    // 409
// If ordered is set and this cursor is a $near geoquery, then this function                          // 410
// will use an _IdMap to track each distance from the $near argument point in                         // 411
// order to use it as a sort key. If an _IdMap is passed in the 'distances'                           // 412
// argument, this function will clear it and use it for this purpose (otherwise                       // 413
// it will just create its own _IdMap). The observeChanges implementation uses                        // 414
// this to remember the distances after this function returns.                                        // 415
LocalCollection.Cursor.prototype._getRawObjects = function (options) {                                // 416
  var self = this;                                                                                    // 417
  options = options || {};                                                                            // 418
                                                                                                      // 419
  // XXX use OrderedDict instead of array, and make IdMap and OrderedDict                             // 420
  // compatible                                                                                       // 421
  var results = options.ordered ? [] : new LocalCollection._IdMap;                                    // 422
                                                                                                      // 423
  // fast path for single ID value                                                                    // 424
  if (self._selectorId !== undefined) {                                                               // 425
    // If you have non-zero skip and ask for a single id, you get                                     // 426
    // nothing. This is so it matches the behavior of the '{_id: foo}'                                // 427
    // path.                                                                                          // 428
    if (self.skip)                                                                                    // 429
      return results;                                                                                 // 430
                                                                                                      // 431
    var selectedDoc = self.collection._docs.get(self._selectorId);                                    // 432
    if (selectedDoc) {                                                                                // 433
      if (options.ordered)                                                                            // 434
        results.push(selectedDoc);                                                                    // 435
      else                                                                                            // 436
        results.set(self._selectorId, selectedDoc);                                                   // 437
    }                                                                                                 // 438
    return results;                                                                                   // 439
  }                                                                                                   // 440
                                                                                                      // 441
  // slow path for arbitrary selector, sort, skip, limit                                              // 442
                                                                                                      // 443
  // in the observeChanges case, distances is actually part of the "query" (ie,                       // 444
  // live results set) object.  in other cases, distances is only used inside                         // 445
  // this function.                                                                                   // 446
  var distances;                                                                                      // 447
  if (self.matcher.hasGeoQuery() && options.ordered) {                                                // 448
    if (options.distances) {                                                                          // 449
      distances = options.distances;                                                                  // 450
      distances.clear();                                                                              // 451
    } else {                                                                                          // 452
      distances = new LocalCollection._IdMap();                                                       // 453
    }                                                                                                 // 454
  }                                                                                                   // 455
                                                                                                      // 456
  self.collection._docs.forEach(function (doc, id) {                                                  // 457
    var matchResult = self.matcher.documentMatches(doc);                                              // 458
    if (matchResult.result) {                                                                         // 459
      if (options.ordered) {                                                                          // 460
        results.push(doc);                                                                            // 461
        if (distances && matchResult.distance !== undefined)                                          // 462
          distances.set(id, matchResult.distance);                                                    // 463
      } else {                                                                                        // 464
        results.set(id, doc);                                                                         // 465
      }                                                                                               // 466
    }                                                                                                 // 467
    // Fast path for limited unsorted queries.                                                        // 468
    // XXX 'length' check here seems wrong for ordered                                                // 469
    if (self.limit && !self.skip && !self.sorter &&                                                   // 470
        results.length === self.limit)                                                                // 471
      return false;  // break                                                                         // 472
    return true;  // continue                                                                         // 473
  });                                                                                                 // 474
                                                                                                      // 475
  if (!options.ordered)                                                                               // 476
    return results;                                                                                   // 477
                                                                                                      // 478
  if (self.sorter) {                                                                                  // 479
    var comparator = self.sorter.getComparator({distances: distances});                               // 480
    results.sort(comparator);                                                                         // 481
  }                                                                                                   // 482
                                                                                                      // 483
  var idx_start = self.skip || 0;                                                                     // 484
  var idx_end = self.limit ? (self.limit + idx_start) : results.length;                               // 485
  return results.slice(idx_start, idx_end);                                                           // 486
};                                                                                                    // 487
                                                                                                      // 488
// XXX Maybe we need a version of observe that just calls a callback if                               // 489
// anything changed.                                                                                  // 490
LocalCollection.Cursor.prototype._depend = function (changers, _allow_unordered) {                    // 491
  var self = this;                                                                                    // 492
                                                                                                      // 493
  if (Deps.active) {                                                                                  // 494
    var v = new Deps.Dependency;                                                                      // 495
    v.depend();                                                                                       // 496
    var notifyChange = _.bind(v.changed, v);                                                          // 497
                                                                                                      // 498
    var options = {                                                                                   // 499
      _suppress_initial: true,                                                                        // 500
      _allow_unordered: _allow_unordered                                                              // 501
    };                                                                                                // 502
    _.each(['added', 'changed', 'removed', 'addedBefore', 'movedBefore'],                             // 503
           function (fnName) {                                                                        // 504
             if (changers[fnName])                                                                    // 505
               options[fnName] = notifyChange;                                                        // 506
           });                                                                                        // 507
                                                                                                      // 508
    // observeChanges will stop() when this computation is invalidated                                // 509
    self.observeChanges(options);                                                                     // 510
  }                                                                                                   // 511
};                                                                                                    // 512
                                                                                                      // 513
// XXX enforce rule that field names can't start with '$' or contain '.'                              // 514
// (real mongodb does in fact enforce this)                                                           // 515
// XXX possibly enforce that 'undefined' does not appear (we assume                                   // 516
// this in our handling of null and $exists)                                                          // 517
LocalCollection.prototype.insert = function (doc, callback) {                                         // 518
  var self = this;                                                                                    // 519
  doc = EJSON.clone(doc);                                                                             // 520
                                                                                                      // 521
  if (!_.has(doc, '_id')) {                                                                           // 522
    // if you really want to use ObjectIDs, set this global.                                          // 523
    // Meteor.Collection specifies its own ids and does not use this code.                            // 524
    doc._id = LocalCollection._useOID ? new LocalCollection._ObjectID()                               // 525
                                      : Random.id();                                                  // 526
  }                                                                                                   // 527
  var id = doc._id;                                                                                   // 528
                                                                                                      // 529
  if (self._docs.has(id))                                                                             // 530
    throw MinimongoError("Duplicate _id '" + id + "'");                                               // 531
                                                                                                      // 532
  self._saveOriginal(id, undefined);                                                                  // 533
  self._docs.set(id, doc);                                                                            // 534
                                                                                                      // 535
  var queriesToRecompute = [];                                                                        // 536
  // trigger live queries that match                                                                  // 537
  for (var qid in self.queries) {                                                                     // 538
    var query = self.queries[qid];                                                                    // 539
    var matchResult = query.matcher.documentMatches(doc);                                             // 540
    if (matchResult.result) {                                                                         // 541
      if (query.distances && matchResult.distance !== undefined)                                      // 542
        query.distances.set(id, matchResult.distance);                                                // 543
      if (query.cursor.skip || query.cursor.limit)                                                    // 544
        queriesToRecompute.push(qid);                                                                 // 545
      else                                                                                            // 546
        LocalCollection._insertInResults(query, doc);                                                 // 547
    }                                                                                                 // 548
  }                                                                                                   // 549
                                                                                                      // 550
  _.each(queriesToRecompute, function (qid) {                                                         // 551
    if (self.queries[qid])                                                                            // 552
      LocalCollection._recomputeResults(self.queries[qid]);                                           // 553
  });                                                                                                 // 554
  self._observeQueue.drain();                                                                         // 555
                                                                                                      // 556
  // Defer because the caller likely doesn't expect the callback to be run                            // 557
  // immediately.                                                                                     // 558
  if (callback)                                                                                       // 559
    Meteor.defer(function () {                                                                        // 560
      callback(null, id);                                                                             // 561
    });                                                                                               // 562
  return id;                                                                                          // 563
};                                                                                                    // 564
                                                                                                      // 565
// Iterates over a subset of documents that could match selector; calls                               // 566
// f(doc, id) on each of them.  Specifically, if selector specifies                                   // 567
// specific _id's, it only looks at those.  doc is *not* cloned: it is the                            // 568
// same object that is in _docs.                                                                      // 569
LocalCollection.prototype._eachPossiblyMatchingDoc = function (selector, f) {                         // 570
  var self = this;                                                                                    // 571
  var specificIds = LocalCollection._idsMatchedBySelector(selector);                                  // 572
  if (specificIds) {                                                                                  // 573
    for (var i = 0; i < specificIds.length; ++i) {                                                    // 574
      var id = specificIds[i];                                                                        // 575
      var doc = self._docs.get(id);                                                                   // 576
      if (doc) {                                                                                      // 577
        var breakIfFalse = f(doc, id);                                                                // 578
        if (breakIfFalse === false)                                                                   // 579
          break;                                                                                      // 580
      }                                                                                               // 581
    }                                                                                                 // 582
  } else {                                                                                            // 583
    self._docs.forEach(f);                                                                            // 584
  }                                                                                                   // 585
};                                                                                                    // 586
                                                                                                      // 587
LocalCollection.prototype.remove = function (selector, callback) {                                    // 588
  var self = this;                                                                                    // 589
                                                                                                      // 590
  // Easy special case: if we're not calling observeChanges callbacks and we're                       // 591
  // not saving originals and we got asked to remove everything, then just empty                      // 592
  // everything directly.                                                                             // 593
  if (self.paused && !self._savedOriginals && EJSON.equals(selector, {})) {                           // 594
    var result = self._docs.size();                                                                   // 595
    self._docs.clear();                                                                               // 596
    _.each(self.queries, function (query) {                                                           // 597
      if (query.ordered) {                                                                            // 598
        query.results = [];                                                                           // 599
      } else {                                                                                        // 600
        query.results.clear();                                                                        // 601
      }                                                                                               // 602
    });                                                                                               // 603
    if (callback) {                                                                                   // 604
      Meteor.defer(function () {                                                                      // 605
        callback(null, result);                                                                       // 606
      });                                                                                             // 607
    }                                                                                                 // 608
    return result;                                                                                    // 609
  }                                                                                                   // 610
                                                                                                      // 611
  var matcher = new Minimongo.Matcher(selector, self);                                                // 612
  var remove = [];                                                                                    // 613
  self._eachPossiblyMatchingDoc(selector, function (doc, id) {                                        // 614
    if (matcher.documentMatches(doc).result)                                                          // 615
      remove.push(id);                                                                                // 616
  });                                                                                                 // 617
                                                                                                      // 618
  var queriesToRecompute = [];                                                                        // 619
  var queryRemove = [];                                                                               // 620
  for (var i = 0; i < remove.length; i++) {                                                           // 621
    var removeId = remove[i];                                                                         // 622
    var removeDoc = self._docs.get(removeId);                                                         // 623
    _.each(self.queries, function (query, qid) {                                                      // 624
      if (query.matcher.documentMatches(removeDoc).result) {                                          // 625
        if (query.cursor.skip || query.cursor.limit)                                                  // 626
          queriesToRecompute.push(qid);                                                               // 627
        else                                                                                          // 628
          queryRemove.push({qid: qid, doc: removeDoc});                                               // 629
      }                                                                                               // 630
    });                                                                                               // 631
    self._saveOriginal(removeId, removeDoc);                                                          // 632
    self._docs.remove(removeId);                                                                      // 633
  }                                                                                                   // 634
                                                                                                      // 635
  // run live query callbacks _after_ we've removed the documents.                                    // 636
  _.each(queryRemove, function (remove) {                                                             // 637
    var query = self.queries[remove.qid];                                                             // 638
    if (query) {                                                                                      // 639
      query.distances && query.distances.remove(remove.doc._id);                                      // 640
      LocalCollection._removeFromResults(query, remove.doc);                                          // 641
    }                                                                                                 // 642
  });                                                                                                 // 643
  _.each(queriesToRecompute, function (qid) {                                                         // 644
    var query = self.queries[qid];                                                                    // 645
    if (query)                                                                                        // 646
      LocalCollection._recomputeResults(query);                                                       // 647
  });                                                                                                 // 648
  self._observeQueue.drain();                                                                         // 649
  result = remove.length;                                                                             // 650
  if (callback)                                                                                       // 651
    Meteor.defer(function () {                                                                        // 652
      callback(null, result);                                                                         // 653
    });                                                                                               // 654
  return result;                                                                                      // 655
};                                                                                                    // 656
                                                                                                      // 657
// XXX atomicity: if multi is true, and one modification fails, do                                    // 658
// we rollback the whole operation, or what?                                                          // 659
LocalCollection.prototype.update = function (selector, mod, options, callback) {                      // 660
  var self = this;                                                                                    // 661
  if (! callback && options instanceof Function) {                                                    // 662
    callback = options;                                                                               // 663
    options = null;                                                                                   // 664
  }                                                                                                   // 665
  if (!options) options = {};                                                                         // 666
                                                                                                      // 667
  var matcher = new Minimongo.Matcher(selector, self);                                                // 668
                                                                                                      // 669
  // Save the original results of any query that we might need to                                     // 670
  // _recomputeResults on, because _modifyAndNotify will mutate the objects in                        // 671
  // it. (We don't need to save the original results of paused queries because                        // 672
  // they already have a resultsSnapshot and we won't be diffing in                                   // 673
  // _recomputeResults.)                                                                              // 674
  var qidToOriginalResults = {};                                                                      // 675
  _.each(self.queries, function (query, qid) {                                                        // 676
    // XXX for now, skip/limit implies ordered observe, so query.results is                           // 677
    // always an array                                                                                // 678
    if ((query.cursor.skip || query.cursor.limit) && !query.paused)                                   // 679
      qidToOriginalResults[qid] = EJSON.clone(query.results);                                         // 680
  });                                                                                                 // 681
  var recomputeQids = {};                                                                             // 682
                                                                                                      // 683
  var updateCount = 0;                                                                                // 684
                                                                                                      // 685
  self._eachPossiblyMatchingDoc(selector, function (doc, id) {                                        // 686
    var queryResult = matcher.documentMatches(doc);                                                   // 687
    if (queryResult.result) {                                                                         // 688
      // XXX Should we save the original even if mod ends up being a no-op?                           // 689
      self._saveOriginal(id, doc);                                                                    // 690
      self._modifyAndNotify(doc, mod, recomputeQids, queryResult.arrayIndex);                         // 691
      ++updateCount;                                                                                  // 692
      if (!options.multi)                                                                             // 693
        return false;  // break                                                                       // 694
    }                                                                                                 // 695
    return true;                                                                                      // 696
  });                                                                                                 // 697
                                                                                                      // 698
  _.each(recomputeQids, function (dummy, qid) {                                                       // 699
    var query = self.queries[qid];                                                                    // 700
    if (query)                                                                                        // 701
      LocalCollection._recomputeResults(query,                                                        // 702
                                        qidToOriginalResults[qid]);                                   // 703
  });                                                                                                 // 704
  self._observeQueue.drain();                                                                         // 705
                                                                                                      // 706
  // If we are doing an upsert, and we didn't modify any documents yet, then                          // 707
  // it's time to do an insert. Figure out what document we are inserting, and                        // 708
  // generate an id for it.                                                                           // 709
  var insertedId;                                                                                     // 710
  if (updateCount === 0 && options.upsert) {                                                          // 711
    var newDoc = LocalCollection._removeDollarOperators(selector);                                    // 712
    LocalCollection._modify(newDoc, mod, {isInsert: true});                                           // 713
    if (! newDoc._id && options.insertedId)                                                           // 714
      newDoc._id = options.insertedId;                                                                // 715
    insertedId = self.insert(newDoc);                                                                 // 716
    updateCount = 1;                                                                                  // 717
  }                                                                                                   // 718
                                                                                                      // 719
  // Return the number of affected documents, or in the upsert case, an object                        // 720
  // containing the number of affected docs and the id of the doc that was                            // 721
  // inserted, if any.                                                                                // 722
  var result;                                                                                         // 723
  if (options._returnObject) {                                                                        // 724
    result = {                                                                                        // 725
      numberAffected: updateCount                                                                     // 726
    };                                                                                                // 727
    if (insertedId !== undefined)                                                                     // 728
      result.insertedId = insertedId;                                                                 // 729
  } else {                                                                                            // 730
    result = updateCount;                                                                             // 731
  }                                                                                                   // 732
                                                                                                      // 733
  if (callback)                                                                                       // 734
    Meteor.defer(function () {                                                                        // 735
      callback(null, result);                                                                         // 736
    });                                                                                               // 737
  return result;                                                                                      // 738
};                                                                                                    // 739
                                                                                                      // 740
// A convenience wrapper on update. LocalCollection.upsert(sel, mod) is                               // 741
// equivalent to LocalCollection.update(sel, mod, { upsert: true, _returnObject:                      // 742
// true }).                                                                                           // 743
LocalCollection.prototype.upsert = function (selector, mod, options, callback) {                      // 744
  var self = this;                                                                                    // 745
  if (! callback && typeof options === "function") {                                                  // 746
    callback = options;                                                                               // 747
    options = {};                                                                                     // 748
  }                                                                                                   // 749
  return self.update(selector, mod, _.extend({}, options, {                                           // 750
    upsert: true,                                                                                     // 751
    _returnObject: true                                                                               // 752
  }), callback);                                                                                      // 753
};                                                                                                    // 754
                                                                                                      // 755
LocalCollection.prototype._modifyAndNotify = function (                                               // 756
    doc, mod, recomputeQids, arrayIndex) {                                                            // 757
  var self = this;                                                                                    // 758
                                                                                                      // 759
  var matched_before = {};                                                                            // 760
  for (var qid in self.queries) {                                                                     // 761
    var query = self.queries[qid];                                                                    // 762
    if (query.ordered) {                                                                              // 763
      matched_before[qid] = query.matcher.documentMatches(doc).result;                                // 764
    } else {                                                                                          // 765
      // Because we don't support skip or limit (yet) in unordered queries, we                        // 766
      // can just do a direct lookup.                                                                 // 767
      matched_before[qid] = query.results.has(doc._id);                                               // 768
    }                                                                                                 // 769
  }                                                                                                   // 770
                                                                                                      // 771
  var old_doc = EJSON.clone(doc);                                                                     // 772
                                                                                                      // 773
  LocalCollection._modify(doc, mod, {arrayIndex: arrayIndex});                                        // 774
                                                                                                      // 775
  for (qid in self.queries) {                                                                         // 776
    query = self.queries[qid];                                                                        // 777
    var before = matched_before[qid];                                                                 // 778
    var afterMatch = query.matcher.documentMatches(doc);                                              // 779
    var after = afterMatch.result;                                                                    // 780
    if (after && query.distances && afterMatch.distance !== undefined)                                // 781
      query.distances.set(doc._id, afterMatch.distance);                                              // 782
                                                                                                      // 783
    if (query.cursor.skip || query.cursor.limit) {                                                    // 784
      // We need to recompute any query where the doc may have been in the                            // 785
      // cursor's window either before or after the update. (Note that if skip                        // 786
      // or limit is set, "before" and "after" being true do not necessarily                          // 787
      // mean that the document is in the cursor's output after skip/limit is                         // 788
      // applied... but if they are false, then the document definitely is NOT                        // 789
      // in the output. So it's safe to skip recompute if neither before or                           // 790
      // after are true.)                                                                             // 791
      if (before || after)                                                                            // 792
        recomputeQids[qid] = true;                                                                    // 793
    } else if (before && !after) {                                                                    // 794
      LocalCollection._removeFromResults(query, doc);                                                 // 795
    } else if (!before && after) {                                                                    // 796
      LocalCollection._insertInResults(query, doc);                                                   // 797
    } else if (before && after) {                                                                     // 798
      LocalCollection._updateInResults(query, doc, old_doc);                                          // 799
    }                                                                                                 // 800
  }                                                                                                   // 801
};                                                                                                    // 802
                                                                                                      // 803
// XXX the sorted-query logic below is laughably inefficient. we'll                                   // 804
// need to come up with a better datastructure for this.                                              // 805
//                                                                                                    // 806
// XXX the logic for observing with a skip or a limit is even more                                    // 807
// laughably inefficient. we recompute the whole results every time!                                  // 808
                                                                                                      // 809
LocalCollection._insertInResults = function (query, doc) {                                            // 810
  var fields = EJSON.clone(doc);                                                                      // 811
  delete fields._id;                                                                                  // 812
  if (query.ordered) {                                                                                // 813
    if (!query.sorter) {                                                                              // 814
      query.addedBefore(doc._id, fields, null);                                                       // 815
      query.results.push(doc);                                                                        // 816
    } else {                                                                                          // 817
      var i = LocalCollection._insertInSortedList(                                                    // 818
        query.sorter.getComparator({distances: query.distances}),                                     // 819
        query.results, doc);                                                                          // 820
      var next = query.results[i+1];                                                                  // 821
      if (next)                                                                                       // 822
        next = next._id;                                                                              // 823
      else                                                                                            // 824
        next = null;                                                                                  // 825
      query.addedBefore(doc._id, fields, next);                                                       // 826
    }                                                                                                 // 827
    query.added(doc._id, fields);                                                                     // 828
  } else {                                                                                            // 829
    query.added(doc._id, fields);                                                                     // 830
    query.results.set(doc._id, doc);                                                                  // 831
  }                                                                                                   // 832
};                                                                                                    // 833
                                                                                                      // 834
LocalCollection._removeFromResults = function (query, doc) {                                          // 835
  if (query.ordered) {                                                                                // 836
    var i = LocalCollection._findInOrderedResults(query, doc);                                        // 837
    query.removed(doc._id);                                                                           // 838
    query.results.splice(i, 1);                                                                       // 839
  } else {                                                                                            // 840
    var id = doc._id;  // in case callback mutates doc                                                // 841
    query.removed(doc._id);                                                                           // 842
    query.results.remove(id);                                                                         // 843
  }                                                                                                   // 844
};                                                                                                    // 845
                                                                                                      // 846
LocalCollection._updateInResults = function (query, doc, old_doc) {                                   // 847
  if (!EJSON.equals(doc._id, old_doc._id))                                                            // 848
    throw new Error("Can't change a doc's _id while updating");                                       // 849
  var changedFields = LocalCollection._makeChangedFields(doc, old_doc);                               // 850
  if (!query.ordered) {                                                                               // 851
    if (!_.isEmpty(changedFields)) {                                                                  // 852
      query.changed(doc._id, changedFields);                                                          // 853
      query.results.set(doc._id, doc);                                                                // 854
    }                                                                                                 // 855
    return;                                                                                           // 856
  }                                                                                                   // 857
                                                                                                      // 858
  var orig_idx = LocalCollection._findInOrderedResults(query, doc);                                   // 859
                                                                                                      // 860
  if (!_.isEmpty(changedFields))                                                                      // 861
    query.changed(doc._id, changedFields);                                                            // 862
  if (!query.sorter)                                                                                  // 863
    return;                                                                                           // 864
                                                                                                      // 865
  // just take it out and put it back in again, and see if the index                                  // 866
  // changes                                                                                          // 867
  query.results.splice(orig_idx, 1);                                                                  // 868
  var new_idx = LocalCollection._insertInSortedList(                                                  // 869
    query.sorter.getComparator({distances: query.distances}),                                         // 870
    query.results, doc);                                                                              // 871
  if (orig_idx !== new_idx) {                                                                         // 872
    var next = query.results[new_idx+1];                                                              // 873
    if (next)                                                                                         // 874
      next = next._id;                                                                                // 875
    else                                                                                              // 876
      next = null;                                                                                    // 877
    query.movedBefore && query.movedBefore(doc._id, next);                                            // 878
  }                                                                                                   // 879
};                                                                                                    // 880
                                                                                                      // 881
// Recomputes the results of a query and runs observe callbacks for the                               // 882
// difference between the previous results and the current results (unless                            // 883
// paused). Used for skip/limit queries.                                                              // 884
//                                                                                                    // 885
// When this is used by insert or remove, it can just use query.results for the                       // 886
// old results (and there's no need to pass in oldResults), because these                             // 887
// operations don't mutate the documents in the collection. Update needs to pass                      // 888
// in an oldResults which was deep-copied before the modifier was applied.                            // 889
LocalCollection._recomputeResults = function (query, oldResults) {                                    // 890
  if (!oldResults)                                                                                    // 891
    oldResults = query.results;                                                                       // 892
  if (query.distances)                                                                                // 893
    query.distances.clear();                                                                          // 894
  query.results = query.cursor._getRawObjects({                                                       // 895
    ordered: query.ordered, distances: query.distances});                                             // 896
                                                                                                      // 897
  if (!query.paused) {                                                                                // 898
    LocalCollection._diffQueryChanges(                                                                // 899
      query.ordered, oldResults, query.results, query);                                               // 900
  }                                                                                                   // 901
};                                                                                                    // 902
                                                                                                      // 903
                                                                                                      // 904
LocalCollection._findInOrderedResults = function (query, doc) {                                       // 905
  if (!query.ordered)                                                                                 // 906
    throw new Error("Can't call _findInOrderedResults on unordered query");                           // 907
  for (var i = 0; i < query.results.length; i++)                                                      // 908
    if (query.results[i] === doc)                                                                     // 909
      return i;                                                                                       // 910
  throw Error("object missing from query");                                                           // 911
};                                                                                                    // 912
                                                                                                      // 913
// This binary search puts a value between any equal values, and the first                            // 914
// lesser value.                                                                                      // 915
LocalCollection._binarySearch = function (cmp, array, value) {                                        // 916
  var first = 0, rangeLength = array.length;                                                          // 917
                                                                                                      // 918
  while (rangeLength > 0) {                                                                           // 919
    var halfRange = Math.floor(rangeLength/2);                                                        // 920
    if (cmp(value, array[first + halfRange]) >= 0) {                                                  // 921
      first += halfRange + 1;                                                                         // 922
      rangeLength -= halfRange + 1;                                                                   // 923
    } else {                                                                                          // 924
      rangeLength = halfRange;                                                                        // 925
    }                                                                                                 // 926
  }                                                                                                   // 927
  return first;                                                                                       // 928
};                                                                                                    // 929
                                                                                                      // 930
LocalCollection._insertInSortedList = function (cmp, array, value) {                                  // 931
  if (array.length === 0) {                                                                           // 932
    array.push(value);                                                                                // 933
    return 0;                                                                                         // 934
  }                                                                                                   // 935
                                                                                                      // 936
  var idx = LocalCollection._binarySearch(cmp, array, value);                                         // 937
  array.splice(idx, 0, value);                                                                        // 938
  return idx;                                                                                         // 939
};                                                                                                    // 940
                                                                                                      // 941
// To track what documents are affected by a piece of code, call saveOriginals()                      // 942
// before it and retrieveOriginals() after it. retrieveOriginals returns an                           // 943
// object whose keys are the ids of the documents that were affected since the                        // 944
// call to saveOriginals(), and the values are equal to the document's contents                       // 945
// at the time of saveOriginals. (In the case of an inserted document, undefined                      // 946
// is the value.) You must alternate between calls to saveOriginals() and                             // 947
// retrieveOriginals().                                                                               // 948
LocalCollection.prototype.saveOriginals = function () {                                               // 949
  var self = this;                                                                                    // 950
  if (self._savedOriginals)                                                                           // 951
    throw new Error("Called saveOriginals twice without retrieveOriginals");                          // 952
  self._savedOriginals = new LocalCollection._IdMap;                                                  // 953
};                                                                                                    // 954
LocalCollection.prototype.retrieveOriginals = function () {                                           // 955
  var self = this;                                                                                    // 956
  if (!self._savedOriginals)                                                                          // 957
    throw new Error("Called retrieveOriginals without saveOriginals");                                // 958
                                                                                                      // 959
  var originals = self._savedOriginals;                                                               // 960
  self._savedOriginals = null;                                                                        // 961
  return originals;                                                                                   // 962
};                                                                                                    // 963
                                                                                                      // 964
LocalCollection.prototype._saveOriginal = function (id, doc) {                                        // 965
  var self = this;                                                                                    // 966
  // Are we even trying to save originals?                                                            // 967
  if (!self._savedOriginals)                                                                          // 968
    return;                                                                                           // 969
  // Have we previously mutated the original (and so 'doc' is not actually                            // 970
  // original)?  (Note the 'has' check rather than truth: we store undefined                          // 971
  // here for inserted docs!)                                                                         // 972
  if (self._savedOriginals.has(id))                                                                   // 973
    return;                                                                                           // 974
  self._savedOriginals.set(id, EJSON.clone(doc));                                                     // 975
};                                                                                                    // 976
                                                                                                      // 977
// Pause the observers. No callbacks from observers will fire until                                   // 978
// 'resumeObservers' is called.                                                                       // 979
LocalCollection.prototype.pauseObservers = function () {                                              // 980
  // No-op if already paused.                                                                         // 981
  if (this.paused)                                                                                    // 982
    return;                                                                                           // 983
                                                                                                      // 984
  // Set the 'paused' flag such that new observer messages don't fire.                                // 985
  this.paused = true;                                                                                 // 986
                                                                                                      // 987
  // Take a snapshot of the query results for each query.                                             // 988
  for (var qid in this.queries) {                                                                     // 989
    var query = this.queries[qid];                                                                    // 990
                                                                                                      // 991
    query.resultsSnapshot = EJSON.clone(query.results);                                               // 992
  }                                                                                                   // 993
};                                                                                                    // 994
                                                                                                      // 995
// Resume the observers. Observers immediately receive change                                         // 996
// notifications to bring them to the current state of the                                            // 997
// database. Note that this is not just replaying all the changes that                                // 998
// happened during the pause, it is a smarter 'coalesced' diff.                                       // 999
LocalCollection.prototype.resumeObservers = function () {                                             // 1000
  var self = this;                                                                                    // 1001
  // No-op if not paused.                                                                             // 1002
  if (!this.paused)                                                                                   // 1003
    return;                                                                                           // 1004
                                                                                                      // 1005
  // Unset the 'paused' flag. Make sure to do this first, otherwise                                   // 1006
  // observer methods won't actually fire when we trigger them.                                       // 1007
  this.paused = false;                                                                                // 1008
                                                                                                      // 1009
  for (var qid in this.queries) {                                                                     // 1010
    var query = self.queries[qid];                                                                    // 1011
    // Diff the current results against the snapshot and send to observers.                           // 1012
    // pass the query object for its observer callbacks.                                              // 1013
    LocalCollection._diffQueryChanges(                                                                // 1014
      query.ordered, query.resultsSnapshot, query.results, query);                                    // 1015
    query.resultsSnapshot = null;                                                                     // 1016
  }                                                                                                   // 1017
  self._observeQueue.drain();                                                                         // 1018
};                                                                                                    // 1019
                                                                                                      // 1020
                                                                                                      // 1021
// NB: used by livedata                                                                               // 1022
LocalCollection._idStringify = function (id) {                                                        // 1023
  if (id instanceof LocalCollection._ObjectID) {                                                      // 1024
    return id.valueOf();                                                                              // 1025
  } else if (typeof id === 'string') {                                                                // 1026
    if (id === "") {                                                                                  // 1027
      return id;                                                                                      // 1028
    } else if (id.substr(0, 1) === "-" || // escape previously dashed strings                         // 1029
               id.substr(0, 1) === "~" || // escape escaped numbers, true, false                      // 1030
               LocalCollection._looksLikeObjectID(id) || // escape object-id-form strings             // 1031
               id.substr(0, 1) === '{') { // escape object-form strings, for maybe implementing later // 1032
      return "-" + id;                                                                                // 1033
    } else {                                                                                          // 1034
      return id; // other strings go through unchanged.                                               // 1035
    }                                                                                                 // 1036
  } else if (id === undefined) {                                                                      // 1037
    return '-';                                                                                       // 1038
  } else if (typeof id === 'object' && id !== null) {                                                 // 1039
    throw new Error("Meteor does not currently support objects other than ObjectID as ids");          // 1040
  } else { // Numbers, true, false, null                                                              // 1041
    return "~" + JSON.stringify(id);                                                                  // 1042
  }                                                                                                   // 1043
};                                                                                                    // 1044
                                                                                                      // 1045
                                                                                                      // 1046
// NB: used by livedata                                                                               // 1047
LocalCollection._idParse = function (id) {                                                            // 1048
  if (id === "") {                                                                                    // 1049
    return id;                                                                                        // 1050
  } else if (id === '-') {                                                                            // 1051
    return undefined;                                                                                 // 1052
  } else if (id.substr(0, 1) === '-') {                                                               // 1053
    return id.substr(1);                                                                              // 1054
  } else if (id.substr(0, 1) === '~') {                                                               // 1055
    return JSON.parse(id.substr(1));                                                                  // 1056
  } else if (LocalCollection._looksLikeObjectID(id)) {                                                // 1057
    return new LocalCollection._ObjectID(id);                                                         // 1058
  } else {                                                                                            // 1059
    return id;                                                                                        // 1060
  }                                                                                                   // 1061
};                                                                                                    // 1062
                                                                                                      // 1063
LocalCollection._makeChangedFields = function (newDoc, oldDoc) {                                      // 1064
  var fields = {};                                                                                    // 1065
  LocalCollection._diffObjects(oldDoc, newDoc, {                                                      // 1066
    leftOnly: function (key, value) {                                                                 // 1067
      fields[key] = undefined;                                                                        // 1068
    },                                                                                                // 1069
    rightOnly: function (key, value) {                                                                // 1070
      fields[key] = value;                                                                            // 1071
    },                                                                                                // 1072
    both: function (key, leftValue, rightValue) {                                                     // 1073
      if (!EJSON.equals(leftValue, rightValue))                                                       // 1074
        fields[key] = rightValue;                                                                     // 1075
    }                                                                                                 // 1076
  });                                                                                                 // 1077
  return fields;                                                                                      // 1078
};                                                                                                    // 1079
                                                                                                      // 1080
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/wrap_transform.js                                                               //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
// Wrap a transform function to return objects that have the _id field                                // 1
// of the untransformed document. This ensures that subsystems such as                                // 2
// the observe-sequence package that call `observe` can keep track of                                 // 3
// the documents identities.                                                                          // 4
//                                                                                                    // 5
// - Require that it returns objects                                                                  // 6
// - If the return value has an _id field, verify that it matches the                                 // 7
//   original _id field                                                                               // 8
// - If the return value doesn't have an _id field, add it back.                                      // 9
LocalCollection.wrapTransform = function (transform) {                                                // 10
  if (!transform)                                                                                     // 11
    return null;                                                                                      // 12
                                                                                                      // 13
  return function (doc) {                                                                             // 14
    if (!_.has(doc, '_id')) {                                                                         // 15
      // XXX do we ever have a transform on the oplog's collection? because that                      // 16
      // collection has no _id.                                                                       // 17
      throw new Error("can only transform documents with _id");                                       // 18
    }                                                                                                 // 19
                                                                                                      // 20
    var id = doc._id;                                                                                 // 21
    // XXX consider making deps a weak dependency and checking Package.deps here                      // 22
    var transformed = Deps.nonreactive(function () {                                                  // 23
      return transform(doc);                                                                          // 24
    });                                                                                               // 25
                                                                                                      // 26
    if (!isPlainObject(transformed)) {                                                                // 27
      throw new Error("transform must return object");                                                // 28
    }                                                                                                 // 29
                                                                                                      // 30
    if (_.has(transformed, '_id')) {                                                                  // 31
      if (!EJSON.equals(transformed._id, id)) {                                                       // 32
        throw new Error("transformed document can't have different _id");                             // 33
      }                                                                                               // 34
    } else {                                                                                          // 35
      transformed._id = id;                                                                           // 36
    }                                                                                                 // 37
    return transformed;                                                                               // 38
  };                                                                                                  // 39
};                                                                                                    // 40
                                                                                                      // 41
                                                                                                      // 42
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/helpers.js                                                                      //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
// Like _.isArray, but doesn't regard polyfilled Uint8Arrays on old browsers as                       // 1
// arrays.                                                                                            // 2
// XXX maybe this should be EJSON.isArray                                                             // 3
isArray = function (x) {                                                                              // 4
  return _.isArray(x) && !EJSON.isBinary(x);                                                          // 5
};                                                                                                    // 6
                                                                                                      // 7
// XXX maybe this should be EJSON.isObject, though EJSON doesn't know about                           // 8
// RegExp                                                                                             // 9
// XXX note that _type(undefined) === 3!!!!                                                           // 10
isPlainObject = function (x) {                                                                        // 11
  return x && LocalCollection._f._type(x) === 3;                                                      // 12
};                                                                                                    // 13
                                                                                                      // 14
isIndexable = function (x) {                                                                          // 15
  return isArray(x) || isPlainObject(x);                                                              // 16
};                                                                                                    // 17
                                                                                                      // 18
isOperatorObject = function (valueSelector) {                                                         // 19
  if (!isPlainObject(valueSelector))                                                                  // 20
    return false;                                                                                     // 21
                                                                                                      // 22
  var theseAreOperators = undefined;                                                                  // 23
  _.each(valueSelector, function (value, selKey) {                                                    // 24
    var thisIsOperator = selKey.substr(0, 1) === '$';                                                 // 25
    if (theseAreOperators === undefined) {                                                            // 26
      theseAreOperators = thisIsOperator;                                                             // 27
    } else if (theseAreOperators !== thisIsOperator) {                                                // 28
      throw new Error("Inconsistent operator: " + valueSelector);                                     // 29
    }                                                                                                 // 30
  });                                                                                                 // 31
  return !!theseAreOperators;  // {} has no operators                                                 // 32
};                                                                                                    // 33
                                                                                                      // 34
                                                                                                      // 35
// string can be converted to integer                                                                 // 36
isNumericKey = function (s) {                                                                         // 37
  return /^[0-9]+$/.test(s);                                                                          // 38
};                                                                                                    // 39
                                                                                                      // 40
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/selector.js                                                                     //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
// The minimongo selector compiler!                                                                   // 1
                                                                                                      // 2
// Terminology:                                                                                       // 3
//  - a "selector" is the EJSON object representing a selector                                        // 4
//  - a "matcher" is its compiled form (whether a full Minimongo.Matcher                              // 5
//    object or one of the component lambdas that matches parts of it)                                // 6
//  - a "result object" is an object with a "result" field and maybe                                  // 7
//    distance and arrayIndex.                                                                        // 8
//  - a "branched value" is an object with a "value" field and maybe                                  // 9
//    "dontIterate" and "arrayIndex".                                                                 // 10
//  - a "document" is a top-level object that can be stored in a collection.                          // 11
//  - a "lookup function" is a function that takes in a document and returns                          // 12
//    an array of "branched values".                                                                  // 13
//  - a "branched matcher" maps from an array of branched values to a result                          // 14
//    object.                                                                                         // 15
//  - an "element matcher" maps from a single value to a bool.                                        // 16
                                                                                                      // 17
// Main entry point.                                                                                  // 18
//   var matcher = new Minimongo.Matcher({a: {$gt: 5}});                                              // 19
//   if (matcher.documentMatches({a: 7})) ...                                                         // 20
Minimongo.Matcher = function (selector) {                                                             // 21
  var self = this;                                                                                    // 22
  // A set (object mapping string -> *) of all of the document paths looked                           // 23
  // at by the selector. Also includes the empty string if it may look at any                         // 24
  // path (eg, $where).                                                                               // 25
  self._paths = {};                                                                                   // 26
  // Set to true if compilation finds a $near.                                                        // 27
  self._hasGeoQuery = false;                                                                          // 28
  // Set to true if compilation finds a $where.                                                       // 29
  self._hasWhere = false;                                                                             // 30
  // Set to false if compilation finds anything other than a simple equality or                       // 31
  // one or more of '$gt', '$gte', '$lt', '$lte', '$ne', '$in', '$nin' used with                      // 32
  // scalars as operands.                                                                             // 33
  self._isSimple = true;                                                                              // 34
  // Set to a dummy document which always matches this Matcher. Or set to null                        // 35
  // if such document is too hard to find.                                                            // 36
  self._matchingDocument = undefined;                                                                 // 37
  // A clone of the original selector. Used by canBecomeTrueByModifier.                               // 38
  self._selector = null;                                                                              // 39
  self._docMatcher = self._compileSelector(selector);                                                 // 40
};                                                                                                    // 41
                                                                                                      // 42
_.extend(Minimongo.Matcher.prototype, {                                                               // 43
  documentMatches: function (doc) {                                                                   // 44
    return this._docMatcher(doc);                                                                     // 45
  },                                                                                                  // 46
  hasGeoQuery: function () {                                                                          // 47
    return this._hasGeoQuery;                                                                         // 48
  },                                                                                                  // 49
  hasWhere: function () {                                                                             // 50
    return this._hasWhere;                                                                            // 51
  },                                                                                                  // 52
  isSimple: function () {                                                                             // 53
    return this._isSimple;                                                                            // 54
  },                                                                                                  // 55
                                                                                                      // 56
  // Given a selector, return a function that takes one argument, a                                   // 57
  // document. It returns a result object.                                                            // 58
  _compileSelector: function (selector) {                                                             // 59
    var self = this;                                                                                  // 60
    // you can pass a literal function instead of a selector                                          // 61
    if (selector instanceof Function) {                                                               // 62
      self._isSimple = false;                                                                         // 63
      self._selector = selector;                                                                      // 64
      self._recordPathUsed('');                                                                       // 65
      return function (doc) {                                                                         // 66
        return {result: !!selector.call(doc)};                                                        // 67
      };                                                                                              // 68
    }                                                                                                 // 69
                                                                                                      // 70
    // shorthand -- scalars match _id                                                                 // 71
    if (LocalCollection._selectorIsId(selector)) {                                                    // 72
      self._selector = {_id: selector};                                                               // 73
      self._recordPathUsed('_id');                                                                    // 74
      return function (doc) {                                                                         // 75
        return {result: EJSON.equals(doc._id, selector)};                                             // 76
      };                                                                                              // 77
    }                                                                                                 // 78
                                                                                                      // 79
    // protect against dangerous selectors.  falsey and {_id: falsey} are both                        // 80
    // likely programmer error, and not what you want, particularly for                               // 81
    // destructive operations.                                                                        // 82
    if (!selector || (('_id' in selector) && !selector._id)) {                                        // 83
      self._isSimple = false;                                                                         // 84
      return nothingMatcher;                                                                          // 85
    }                                                                                                 // 86
                                                                                                      // 87
    // Top level can't be an array or true or binary.                                                 // 88
    if (typeof(selector) === 'boolean' || isArray(selector) ||                                        // 89
        EJSON.isBinary(selector))                                                                     // 90
      throw new Error("Invalid selector: " + selector);                                               // 91
                                                                                                      // 92
    self._selector = EJSON.clone(selector);                                                           // 93
    return compileDocumentSelector(selector, self, {isRoot: true});                                   // 94
  },                                                                                                  // 95
  _recordPathUsed: function (path) {                                                                  // 96
    this._paths[path] = true;                                                                         // 97
  },                                                                                                  // 98
  // Returns a list of key paths the given selector is looking for. It includes                       // 99
  // the empty string if there is a $where.                                                           // 100
  _getPaths: function () {                                                                            // 101
    return _.keys(this._paths);                                                                       // 102
  }                                                                                                   // 103
});                                                                                                   // 104
                                                                                                      // 105
                                                                                                      // 106
// Takes in a selector that could match a full document (eg, the original                             // 107
// selector). Returns a function mapping document->result object.                                     // 108
//                                                                                                    // 109
// matcher is the Matcher object we are compiling.                                                    // 110
//                                                                                                    // 111
// If this is the root document selector (ie, not wrapped in $and or the like),                       // 112
// then isRoot is true. (This is used by $near.)                                                      // 113
var compileDocumentSelector = function (docSelector, matcher, options) {                              // 114
  options = options || {};                                                                            // 115
  var docMatchers = [];                                                                               // 116
  _.each(docSelector, function (subSelector, key) {                                                   // 117
    if (key.substr(0, 1) === '$') {                                                                   // 118
      // Outer operators are either logical operators (they recurse back into                         // 119
      // this function), or $where.                                                                   // 120
      if (!_.has(LOGICAL_OPERATORS, key))                                                             // 121
        throw new Error("Unrecognized logical operator: " + key);                                     // 122
      matcher._isSimple = false;                                                                      // 123
      docMatchers.push(LOGICAL_OPERATORS[key](subSelector, matcher,                                   // 124
                                              options.inElemMatch));                                  // 125
    } else {                                                                                          // 126
      // Record this path, but only if we aren't in an elemMatcher, since in an                       // 127
      // elemMatch this is a path inside an object in an array, not in the doc                        // 128
      // root.                                                                                        // 129
      if (!options.inElemMatch)                                                                       // 130
        matcher._recordPathUsed(key);                                                                 // 131
      var lookUpByIndex = makeLookupFunction(key);                                                    // 132
      var valueMatcher =                                                                              // 133
        compileValueSelector(subSelector, matcher, options.isRoot);                                   // 134
      docMatchers.push(function (doc) {                                                               // 135
        var branchValues = lookUpByIndex(doc);                                                        // 136
        return valueMatcher(branchValues);                                                            // 137
      });                                                                                             // 138
    }                                                                                                 // 139
  });                                                                                                 // 140
                                                                                                      // 141
  return andDocumentMatchers(docMatchers);                                                            // 142
};                                                                                                    // 143
                                                                                                      // 144
// Takes in a selector that could match a key-indexed value in a document; eg,                        // 145
// {$gt: 5, $lt: 9}, or a regular expression, or any non-expression object (to                        // 146
// indicate equality).  Returns a branched matcher: a function mapping                                // 147
// [branched value]->result object.                                                                   // 148
var compileValueSelector = function (valueSelector, matcher, isRoot) {                                // 149
  if (valueSelector instanceof RegExp) {                                                              // 150
    matcher._isSimple = false;                                                                        // 151
    return convertElementMatcherToBranchedMatcher(                                                    // 152
      regexpElementMatcher(valueSelector));                                                           // 153
  } else if (isOperatorObject(valueSelector)) {                                                       // 154
    return operatorBranchedMatcher(valueSelector, matcher, isRoot);                                   // 155
  } else {                                                                                            // 156
    return convertElementMatcherToBranchedMatcher(                                                    // 157
      equalityElementMatcher(valueSelector));                                                         // 158
  }                                                                                                   // 159
};                                                                                                    // 160
                                                                                                      // 161
// Given an element matcher (which evaluates a single value), returns a branched                      // 162
// value (which evaluates the element matcher on all the branches and returns a                       // 163
// more structured return value possibly including arrayIndex).                                       // 164
var convertElementMatcherToBranchedMatcher = function (                                               // 165
    elementMatcher, options) {                                                                        // 166
  options = options || {};                                                                            // 167
  return function (branches) {                                                                        // 168
    var expanded = branches;                                                                          // 169
    if (!options.dontExpandLeafArrays) {                                                              // 170
      expanded = expandArraysInBranches(                                                              // 171
        branches, options.dontIncludeLeafArrays);                                                     // 172
    }                                                                                                 // 173
    var ret = {};                                                                                     // 174
    ret.result = _.any(expanded, function (element) {                                                 // 175
      var matched = elementMatcher(element.value);                                                    // 176
                                                                                                      // 177
      // Special case for $elemMatch: it means "true, and use this arrayIndex if                      // 178
      // I didn't already have one".                                                                  // 179
      if (typeof matched === 'number') {                                                              // 180
        if (element.arrayIndex === undefined)                                                         // 181
          element.arrayIndex = matched;                                                               // 182
        matched = true;                                                                               // 183
      }                                                                                               // 184
                                                                                                      // 185
      // If some element matched, and it's tagged with an array index, include                        // 186
      // that index in our result object.                                                             // 187
      if (matched && element.arrayIndex !== undefined)                                                // 188
        ret.arrayIndex = element.arrayIndex;                                                          // 189
                                                                                                      // 190
      return matched;                                                                                 // 191
    });                                                                                               // 192
    return ret;                                                                                       // 193
  };                                                                                                  // 194
};                                                                                                    // 195
                                                                                                      // 196
// Takes a RegExp object and returns an element matcher.                                              // 197
var regexpElementMatcher = function (regexp) {                                                        // 198
  return function (value) {                                                                           // 199
    if (value instanceof RegExp) {                                                                    // 200
      // Comparing two regexps means seeing if the regexps are identical                              // 201
      // (really!). Underscore knows how.                                                             // 202
      return _.isEqual(value, regexp);                                                                // 203
    }                                                                                                 // 204
    // Regexps only work against strings.                                                             // 205
    if (typeof value !== 'string')                                                                    // 206
      return false;                                                                                   // 207
    return regexp.test(value);                                                                        // 208
  };                                                                                                  // 209
};                                                                                                    // 210
                                                                                                      // 211
// Takes something that is not an operator object and returns an element matcher                      // 212
// for equality with that thing.                                                                      // 213
var equalityElementMatcher = function (elementSelector) {                                             // 214
  if (isOperatorObject(elementSelector))                                                              // 215
    throw Error("Can't create equalityValueSelector for operator object");                            // 216
                                                                                                      // 217
  // Special-case: null and undefined are equal (if you got undefined in there                        // 218
  // somewhere, or if you got it due to some branch being non-existent in the                         // 219
  // weird special case), even though they aren't with EJSON.equals.                                  // 220
  if (elementSelector == null) {  // undefined or null                                                // 221
    return function (value) {                                                                         // 222
      return value == null;  // undefined or null                                                     // 223
    };                                                                                                // 224
  }                                                                                                   // 225
                                                                                                      // 226
  return function (value) {                                                                           // 227
    return LocalCollection._f._equal(elementSelector, value);                                         // 228
  };                                                                                                  // 229
};                                                                                                    // 230
                                                                                                      // 231
// Takes an operator object (an object with $ keys) and returns a branched                            // 232
// matcher for it.                                                                                    // 233
var operatorBranchedMatcher = function (valueSelector, matcher, isRoot) {                             // 234
  // Each valueSelector works separately on the various branches.  So one                             // 235
  // operator can match one branch and another can match another branch.  This                        // 236
  // is OK.                                                                                           // 237
                                                                                                      // 238
  var operatorMatchers = [];                                                                          // 239
  _.each(valueSelector, function (operand, operator) {                                                // 240
    // XXX we should actually implement $eq, which is new in 2.6                                      // 241
    var simpleRange = _.contains(['$lt', '$lte', '$gt', '$gte'], operator) &&                         // 242
      _.isNumber(operand);                                                                            // 243
    var simpleInequality = operator === '$ne' && !_.isObject(operand);                                // 244
    var simpleInclusion = _.contains(['$in', '$nin'], operator) &&                                    // 245
      _.isArray(operand) && !_.any(operand, _.isObject);                                              // 246
                                                                                                      // 247
    if (! (operator === '$eq' || simpleRange ||                                                       // 248
           simpleInclusion || simpleInequality)) {                                                    // 249
      matcher._isSimple = false;                                                                      // 250
    }                                                                                                 // 251
                                                                                                      // 252
    if (_.has(VALUE_OPERATORS, operator)) {                                                           // 253
      operatorMatchers.push(                                                                          // 254
        VALUE_OPERATORS[operator](operand, valueSelector, matcher, isRoot));                          // 255
    } else if (_.has(ELEMENT_OPERATORS, operator)) {                                                  // 256
      var options = ELEMENT_OPERATORS[operator];                                                      // 257
      if (typeof options === 'function')                                                              // 258
        options = {compileElementSelector: options};                                                  // 259
      operatorMatchers.push(                                                                          // 260
        convertElementMatcherToBranchedMatcher(                                                       // 261
          options.compileElementSelector(                                                             // 262
            operand, valueSelector, matcher),                                                         // 263
          options));                                                                                  // 264
    } else {                                                                                          // 265
      throw new Error("Unrecognized operator: " + operator);                                          // 266
    }                                                                                                 // 267
  });                                                                                                 // 268
                                                                                                      // 269
  return andBranchedMatchers(operatorMatchers);                                                       // 270
};                                                                                                    // 271
                                                                                                      // 272
var compileArrayOfDocumentSelectors = function (                                                      // 273
    selectors, matcher, inElemMatch) {                                                                // 274
  if (!isArray(selectors) || _.isEmpty(selectors))                                                    // 275
    throw Error("$and/$or/$nor must be nonempty array");                                              // 276
  return _.map(selectors, function (subSelector) {                                                    // 277
    if (!isPlainObject(subSelector))                                                                  // 278
      throw Error("$or/$and/$nor entries need to be full objects");                                   // 279
    return compileDocumentSelector(                                                                   // 280
      subSelector, matcher, {inElemMatch: inElemMatch});                                              // 281
  });                                                                                                 // 282
};                                                                                                    // 283
                                                                                                      // 284
// Operators that appear at the top level of a document selector.                                     // 285
var LOGICAL_OPERATORS = {                                                                             // 286
  $and: function (subSelector, matcher, inElemMatch) {                                                // 287
    var matchers = compileArrayOfDocumentSelectors(                                                   // 288
      subSelector, matcher, inElemMatch);                                                             // 289
    return andDocumentMatchers(matchers);                                                             // 290
  },                                                                                                  // 291
                                                                                                      // 292
  $or: function (subSelector, matcher, inElemMatch) {                                                 // 293
    var matchers = compileArrayOfDocumentSelectors(                                                   // 294
      subSelector, matcher, inElemMatch);                                                             // 295
                                                                                                      // 296
    // Special case: if there is only one matcher, use it directly, *preserving*                      // 297
    // any arrayIndex it returns.                                                                     // 298
    if (matchers.length === 1)                                                                        // 299
      return matchers[0];                                                                             // 300
                                                                                                      // 301
    return function (doc) {                                                                           // 302
      var result = _.any(matchers, function (f) {                                                     // 303
        return f(doc).result;                                                                         // 304
      });                                                                                             // 305
      // $or does NOT set arrayIndex when it has multiple                                             // 306
      // sub-expressions. (Tested against MongoDB.)                                                   // 307
      return {result: result};                                                                        // 308
    };                                                                                                // 309
  },                                                                                                  // 310
                                                                                                      // 311
  $nor: function (subSelector, matcher, inElemMatch) {                                                // 312
    var matchers = compileArrayOfDocumentSelectors(                                                   // 313
      subSelector, matcher, inElemMatch);                                                             // 314
    return function (doc) {                                                                           // 315
      var result = _.all(matchers, function (f) {                                                     // 316
        return !f(doc).result;                                                                        // 317
      });                                                                                             // 318
      // Never set arrayIndex, because we only match if nothing in particular                         // 319
      // "matched" (and because this is consistent with MongoDB).                                     // 320
      return {result: result};                                                                        // 321
    };                                                                                                // 322
  },                                                                                                  // 323
                                                                                                      // 324
  $where: function (selectorValue, matcher) {                                                         // 325
    // Record that *any* path may be used.                                                            // 326
    matcher._recordPathUsed('');                                                                      // 327
    matcher._hasWhere = true;                                                                         // 328
    if (!(selectorValue instanceof Function)) {                                                       // 329
      // XXX MongoDB seems to have more complex logic to decide where or or not                       // 330
      // to add "return"; not sure exactly what it is.                                                // 331
      selectorValue = Function("obj", "return " + selectorValue);                                     // 332
    }                                                                                                 // 333
    return function (doc) {                                                                           // 334
      // We make the document available as both `this` and `obj`.                                     // 335
      // XXX not sure what we should do if this throws                                                // 336
      return {result: selectorValue.call(doc, doc)};                                                  // 337
    };                                                                                                // 338
  },                                                                                                  // 339
                                                                                                      // 340
  // This is just used as a comment in the query (in MongoDB, it also ends up in                      // 341
  // query logs); it has no effect on the actual selection.                                           // 342
  $comment: function () {                                                                             // 343
    return function () {                                                                              // 344
      return {result: true};                                                                          // 345
    };                                                                                                // 346
  }                                                                                                   // 347
};                                                                                                    // 348
                                                                                                      // 349
// Returns a branched matcher that matches iff the given matcher does not.                            // 350
// Note that this implicitly "deMorganizes" the wrapped function.  ie, it                             // 351
// means that ALL branch values need to fail to match innerBranchedMatcher.                           // 352
var invertBranchedMatcher = function (branchedMatcher) {                                              // 353
  return function (branchValues) {                                                                    // 354
    var invertMe = branchedMatcher(branchValues);                                                     // 355
    // We explicitly choose to strip arrayIndex here: it doesn't make sense to                        // 356
    // say "update the array element that does not match something", at least                         // 357
    // in mongo-land.                                                                                 // 358
    return {result: !invertMe.result};                                                                // 359
  };                                                                                                  // 360
};                                                                                                    // 361
                                                                                                      // 362
// Operators that (unlike LOGICAL_OPERATORS) pertain to individual paths in a                         // 363
// document, but (unlike ELEMENT_OPERATORS) do not have a simple definition as                        // 364
// "match each branched value independently and combine with                                          // 365
// convertElementMatcherToBranchedMatcher".                                                           // 366
var VALUE_OPERATORS = {                                                                               // 367
  $not: function (operand, valueSelector, matcher) {                                                  // 368
    return invertBranchedMatcher(compileValueSelector(operand, matcher));                             // 369
  },                                                                                                  // 370
  $ne: function (operand) {                                                                           // 371
    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(                              // 372
      equalityElementMatcher(operand)));                                                              // 373
  },                                                                                                  // 374
  $nin: function (operand) {                                                                          // 375
    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(                              // 376
      ELEMENT_OPERATORS.$in(operand)));                                                               // 377
  },                                                                                                  // 378
  $exists: function (operand) {                                                                       // 379
    var exists = convertElementMatcherToBranchedMatcher(function (value) {                            // 380
      return value !== undefined;                                                                     // 381
    });                                                                                               // 382
    return operand ? exists : invertBranchedMatcher(exists);                                          // 383
  },                                                                                                  // 384
  // $options just provides options for $regex; its logic is inside $regex                            // 385
  $options: function (operand, valueSelector) {                                                       // 386
    if (!valueSelector.$regex)                                                                        // 387
      throw Error("$options needs a $regex");                                                         // 388
    return everythingMatcher;                                                                         // 389
  },                                                                                                  // 390
  // $maxDistance is basically an argument to $near                                                   // 391
  $maxDistance: function (operand, valueSelector) {                                                   // 392
    if (!valueSelector.$near)                                                                         // 393
      throw Error("$maxDistance needs a $near");                                                      // 394
    return everythingMatcher;                                                                         // 395
  },                                                                                                  // 396
  $all: function (operand, valueSelector, matcher) {                                                  // 397
    if (!isArray(operand))                                                                            // 398
      throw Error("$all requires array");                                                             // 399
    // Not sure why, but this seems to be what MongoDB does.                                          // 400
    if (_.isEmpty(operand))                                                                           // 401
      return nothingMatcher;                                                                          // 402
                                                                                                      // 403
    var branchedMatchers = [];                                                                        // 404
    _.each(operand, function (criterion) {                                                            // 405
      // XXX handle $all/$elemMatch combination                                                       // 406
      if (isOperatorObject(criterion))                                                                // 407
        throw Error("no $ expressions in $all");                                                      // 408
      // This is always a regexp or equality selector.                                                // 409
      branchedMatchers.push(compileValueSelector(criterion, matcher));                                // 410
    });                                                                                               // 411
    // andBranchedMatchers does NOT require all selectors to return true on the                       // 412
    // SAME branch.                                                                                   // 413
    return andBranchedMatchers(branchedMatchers);                                                     // 414
  },                                                                                                  // 415
  $near: function (operand, valueSelector, matcher, isRoot) {                                         // 416
    if (!isRoot)                                                                                      // 417
      throw Error("$near can't be inside another $ operator");                                        // 418
    matcher._hasGeoQuery = true;                                                                      // 419
                                                                                                      // 420
    // There are two kinds of geodata in MongoDB: coordinate pairs and                                // 421
    // GeoJSON. They use different distance metrics, too. GeoJSON queries are                         // 422
    // marked with a $geometry property.                                                              // 423
                                                                                                      // 424
    var maxDistance, point, distance;                                                                 // 425
    if (isPlainObject(operand) && _.has(operand, '$geometry')) {                                      // 426
      // GeoJSON "2dsphere" mode.                                                                     // 427
      maxDistance = operand.$maxDistance;                                                             // 428
      point = operand.$geometry;                                                                      // 429
      distance = function (value) {                                                                   // 430
        // XXX: for now, we don't calculate the actual distance between, say,                         // 431
        // polygon and circle. If people care about this use-case it will get                         // 432
        // a priority.                                                                                // 433
        if (!value || !value.type)                                                                    // 434
          return null;                                                                                // 435
        if (value.type === "Point") {                                                                 // 436
          return GeoJSON.pointDistance(point, value);                                                 // 437
        } else {                                                                                      // 438
          return GeoJSON.geometryWithinRadius(value, point, maxDistance)                              // 439
            ? 0 : maxDistance + 1;                                                                    // 440
        }                                                                                             // 441
      };                                                                                              // 442
    } else {                                                                                          // 443
      maxDistance = valueSelector.$maxDistance;                                                       // 444
      if (!isArray(operand) && !isPlainObject(operand))                                               // 445
        throw Error("$near argument must be coordinate pair or GeoJSON");                             // 446
      point = pointToArray(operand);                                                                  // 447
      distance = function (value) {                                                                   // 448
        if (!isArray(value) && !isPlainObject(value))                                                 // 449
          return null;                                                                                // 450
        return distanceCoordinatePairs(point, value);                                                 // 451
      };                                                                                              // 452
    }                                                                                                 // 453
                                                                                                      // 454
    return function (branchedValues) {                                                                // 455
      // There might be multiple points in the document that match the given                          // 456
      // field. Only one of them needs to be within $maxDistance, but we need to                      // 457
      // evaluate all of them and use the nearest one for the implicit sort                           // 458
      // specifier. (That's why we can't just use ELEMENT_OPERATORS here.)                            // 459
      //                                                                                              // 460
      // Note: This differs from MongoDB's implementation, where a document will                      // 461
      // actually show up *multiple times* in the result set, with one entry for                      // 462
      // each within-$maxDistance branching point.                                                    // 463
      branchedValues = expandArraysInBranches(branchedValues);                                        // 464
      var result = {result: false};                                                                   // 465
      _.each(branchedValues, function (branch) {                                                      // 466
        var curDistance = distance(branch.value);                                                     // 467
        // Skip branches that aren't real points or are too far away.                                 // 468
        if (curDistance === null || curDistance > maxDistance)                                        // 469
          return;                                                                                     // 470
        // Skip anything that's a tie.                                                                // 471
        if (result.distance !== undefined && result.distance <= curDistance)                          // 472
          return;                                                                                     // 473
        result.result = true;                                                                         // 474
        result.distance = curDistance;                                                                // 475
        if (branch.arrayIndex === undefined)                                                          // 476
          delete result.arrayIndex;                                                                   // 477
        else                                                                                          // 478
          result.arrayIndex = branch.arrayIndex;                                                      // 479
      });                                                                                             // 480
      return result;                                                                                  // 481
    };                                                                                                // 482
  }                                                                                                   // 483
};                                                                                                    // 484
                                                                                                      // 485
// Helpers for $near.                                                                                 // 486
var distanceCoordinatePairs = function (a, b) {                                                       // 487
  a = pointToArray(a);                                                                                // 488
  b = pointToArray(b);                                                                                // 489
  var x = a[0] - b[0];                                                                                // 490
  var y = a[1] - b[1];                                                                                // 491
  if (_.isNaN(x) || _.isNaN(y))                                                                       // 492
    return null;                                                                                      // 493
  return Math.sqrt(x * x + y * y);                                                                    // 494
};                                                                                                    // 495
// Makes sure we get 2 elements array and assume the first one to be x and                            // 496
// the second one to y no matter what user passes.                                                    // 497
// In case user passes { lon: x, lat: y } returns [x, y]                                              // 498
var pointToArray = function (point) {                                                                 // 499
  return _.map(point, _.identity);                                                                    // 500
};                                                                                                    // 501
                                                                                                      // 502
// Helper for $lt/$gt/$lte/$gte.                                                                      // 503
var makeInequality = function (cmpValueComparator) {                                                  // 504
  return function (operand) {                                                                         // 505
    // Arrays never compare false with non-arrays for any inequality.                                 // 506
    if (isArray(operand)) {                                                                           // 507
      return function () {                                                                            // 508
        return false;                                                                                 // 509
      };                                                                                              // 510
    }                                                                                                 // 511
                                                                                                      // 512
    // Special case: consider undefined and null the same (so true with                               // 513
    // $gte/$lte).                                                                                    // 514
    if (operand === undefined)                                                                        // 515
      operand = null;                                                                                 // 516
                                                                                                      // 517
    var operandType = LocalCollection._f._type(operand);                                              // 518
                                                                                                      // 519
    return function (value) {                                                                         // 520
      if (value === undefined)                                                                        // 521
        value = null;                                                                                 // 522
      // Comparisons are never true among things of different type (except null                       // 523
      // vs undefined).                                                                               // 524
      if (LocalCollection._f._type(value) !== operandType)                                            // 525
        return false;                                                                                 // 526
      return cmpValueComparator(LocalCollection._f._cmp(value, operand));                             // 527
    };                                                                                                // 528
  };                                                                                                  // 529
};                                                                                                    // 530
                                                                                                      // 531
// Each element selector is a function with args:                                                     // 532
//  - operand - the "right hand side" of the operator                                                 // 533
//  - valueSelector - the "context" for the operator (so that $regex can find                         // 534
//    $options)                                                                                       // 535
// Or is an object with an compileElementSelector field (the above) and optional                      // 536
// flags dontExpandLeafArrays and dontIncludeLeafArrays which control if                              // 537
// expandArraysInBranches is called and if it takes an optional argument.                             // 538
//                                                                                                    // 539
// An element selector compiler returns a function mapping a single value to                          // 540
// bool.                                                                                              // 541
var ELEMENT_OPERATORS = {                                                                             // 542
  $lt: makeInequality(function (cmpValue) {                                                           // 543
    return cmpValue < 0;                                                                              // 544
  }),                                                                                                 // 545
  $gt: makeInequality(function (cmpValue) {                                                           // 546
    return cmpValue > 0;                                                                              // 547
  }),                                                                                                 // 548
  $lte: makeInequality(function (cmpValue) {                                                          // 549
    return cmpValue <= 0;                                                                             // 550
  }),                                                                                                 // 551
  $gte: makeInequality(function (cmpValue) {                                                          // 552
    return cmpValue >= 0;                                                                             // 553
  }),                                                                                                 // 554
  $mod: function (operand) {                                                                          // 555
    if (!(isArray(operand) && operand.length === 2                                                    // 556
          && typeof(operand[0]) === 'number'                                                          // 557
          && typeof(operand[1]) === 'number')) {                                                      // 558
      throw Error("argument to $mod must be an array of two numbers");                                // 559
    }                                                                                                 // 560
    // XXX could require to be ints or round or something                                             // 561
    var divisor = operand[0];                                                                         // 562
    var remainder = operand[1];                                                                       // 563
    return function (value) {                                                                         // 564
      return typeof value === 'number' && value % divisor === remainder;                              // 565
    };                                                                                                // 566
  },                                                                                                  // 567
  $in: function (operand) {                                                                           // 568
    if (!isArray(operand))                                                                            // 569
      throw Error("$in needs an array");                                                              // 570
                                                                                                      // 571
    var elementMatchers = [];                                                                         // 572
    _.each(operand, function (option) {                                                               // 573
      if (option instanceof RegExp)                                                                   // 574
        elementMatchers.push(regexpElementMatcher(option));                                           // 575
      else if (isOperatorObject(option))                                                              // 576
        throw Error("cannot nest $ under $in");                                                       // 577
      else                                                                                            // 578
        elementMatchers.push(equalityElementMatcher(option));                                         // 579
    });                                                                                               // 580
                                                                                                      // 581
    return function (value) {                                                                         // 582
      // Allow {a: {$in: [null]}} to match when 'a' does not exist.                                   // 583
      if (value === undefined)                                                                        // 584
        value = null;                                                                                 // 585
      return _.any(elementMatchers, function (e) {                                                    // 586
        return e(value);                                                                              // 587
      });                                                                                             // 588
    };                                                                                                // 589
  },                                                                                                  // 590
  $size: {                                                                                            // 591
    // {a: [[5, 5]]} must match {a: {$size: 1}} but not {a: {$size: 2}}, so we                        // 592
    // don't want to consider the element [5,5] in the leaf array [[5,5]] as a                        // 593
    // possible value.                                                                                // 594
    dontExpandLeafArrays: true,                                                                       // 595
    compileElementSelector: function (operand) {                                                      // 596
      if (typeof operand === 'string') {                                                              // 597
        // Don't ask me why, but by experimentation, this seems to be what Mongo                      // 598
        // does.                                                                                      // 599
        operand = 0;                                                                                  // 600
      } else if (typeof operand !== 'number') {                                                       // 601
        throw Error("$size needs a number");                                                          // 602
      }                                                                                               // 603
      return function (value) {                                                                       // 604
        return isArray(value) && value.length === operand;                                            // 605
      };                                                                                              // 606
    }                                                                                                 // 607
  },                                                                                                  // 608
  $type: {                                                                                            // 609
    // {a: [5]} must not match {a: {$type: 4}} (4 means array), but it should                         // 610
    // match {a: {$type: 1}} (1 means number), and {a: [[5]]} must match {$a:                         // 611
    // {$type: 4}}. Thus, when we see a leaf array, we *should* expand it but                         // 612
    // should *not* include it itself.                                                                // 613
    dontIncludeLeafArrays: true,                                                                      // 614
    compileElementSelector: function (operand) {                                                      // 615
      if (typeof operand !== 'number')                                                                // 616
        throw Error("$type needs a number");                                                          // 617
      return function (value) {                                                                       // 618
        return value !== undefined                                                                    // 619
          && LocalCollection._f._type(value) === operand;                                             // 620
      };                                                                                              // 621
    }                                                                                                 // 622
  },                                                                                                  // 623
  $regex: function (operand, valueSelector) {                                                         // 624
    if (!(typeof operand === 'string' || operand instanceof RegExp))                                  // 625
      throw Error("$regex has to be a string or RegExp");                                             // 626
                                                                                                      // 627
    var regexp;                                                                                       // 628
    if (valueSelector.$options !== undefined) {                                                       // 629
      // Options passed in $options (even the empty string) always overrides                          // 630
      // options in the RegExp object itself. (See also                                               // 631
      // Meteor.Collection._rewriteSelector.)                                                         // 632
                                                                                                      // 633
      // Be clear that we only support the JS-supported options, not extended                         // 634
      // ones (eg, Mongo supports x and s). Ideally we would implement x and s                        // 635
      // by transforming the regexp, but not today...                                                 // 636
      if (/[^gim]/.test(valueSelector.$options))                                                      // 637
        throw new Error("Only the i, m, and g regexp options are supported");                         // 638
                                                                                                      // 639
      var regexSource = operand instanceof RegExp ? operand.source : operand;                         // 640
      regexp = new RegExp(regexSource, valueSelector.$options);                                       // 641
    } else if (operand instanceof RegExp) {                                                           // 642
      regexp = operand;                                                                               // 643
    } else {                                                                                          // 644
      regexp = new RegExp(operand);                                                                   // 645
    }                                                                                                 // 646
    return regexpElementMatcher(regexp);                                                              // 647
  },                                                                                                  // 648
  $elemMatch: {                                                                                       // 649
    dontExpandLeafArrays: true,                                                                       // 650
    compileElementSelector: function (operand, valueSelector, matcher) {                              // 651
      if (!isPlainObject(operand))                                                                    // 652
        throw Error("$elemMatch need an object");                                                     // 653
                                                                                                      // 654
      var subMatcher, isDocMatcher;                                                                   // 655
      if (isOperatorObject(operand)) {                                                                // 656
        subMatcher = compileValueSelector(operand, matcher);                                          // 657
        isDocMatcher = false;                                                                         // 658
      } else {                                                                                        // 659
        // This is NOT the same as compileValueSelector(operand), and not just                        // 660
        // because of the slightly different calling convention.                                      // 661
        // {$elemMatch: {x: 3}} means "an element has a field x:3", not                               // 662
        // "consists only of a field x:3". Also, regexps and sub-$ are allowed.                       // 663
        subMatcher = compileDocumentSelector(operand, matcher,                                        // 664
                                             {inElemMatch: true});                                    // 665
        isDocMatcher = true;                                                                          // 666
      }                                                                                               // 667
                                                                                                      // 668
      return function (value) {                                                                       // 669
        if (!isArray(value))                                                                          // 670
          return false;                                                                               // 671
        for (var i = 0; i < value.length; ++i) {                                                      // 672
          var arrayElement = value[i];                                                                // 673
          var arg;                                                                                    // 674
          if (isDocMatcher) {                                                                         // 675
            // We can only match {$elemMatch: {b: 3}} against objects.                                // 676
            // (We can also match against arrays, if there's numeric indices,                         // 677
            // eg {$elemMatch: {'0.b': 3}} or {$elemMatch: {0: 3}}.)                                  // 678
            if (!isPlainObject(arrayElement) && !isArray(arrayElement))                               // 679
              return false;                                                                           // 680
            arg = arrayElement;                                                                       // 681
          } else {                                                                                    // 682
            // dontIterate ensures that {a: {$elemMatch: {$gt: 5}}} matches                           // 683
            // {a: [8]} but not {a: [[8]]}                                                            // 684
            arg = [{value: arrayElement, dontIterate: true}];                                         // 685
          }                                                                                           // 686
          // XXX support $near in $elemMatch by propagating $distance?                                // 687
          if (subMatcher(arg).result)                                                                 // 688
            return i;   // specially understood to mean "use my arrayIndex"                           // 689
        }                                                                                             // 690
        return false;                                                                                 // 691
      };                                                                                              // 692
    }                                                                                                 // 693
  }                                                                                                   // 694
};                                                                                                    // 695
                                                                                                      // 696
// makeLookupFunction(key) returns a lookup function.                                                 // 697
//                                                                                                    // 698
// A lookup function takes in a document and returns an array of matching                             // 699
// branches.  If no arrays are found while looking up the key, this array will                        // 700
// have exactly one branches (possibly 'undefined', if some segment of the key                        // 701
// was not found).                                                                                    // 702
//                                                                                                    // 703
// If arrays are found in the middle, this can have more than one element, since                      // 704
// we "branch". When we "branch", if there are more key segments to look up,                          // 705
// then we only pursue branches that are plain objects (not arrays or scalars).                       // 706
// This means we can actually end up with no branches!                                                // 707
//                                                                                                    // 708
// We do *NOT* branch on arrays that are found at the end (ie, at the last                            // 709
// dotted member of the key). We just return that array; if you want to                               // 710
// effectively "branch" over the array's values, post-process the lookup                              // 711
// function with expandArraysInBranches.                                                              // 712
//                                                                                                    // 713
// Each branch is an object with keys:                                                                // 714
//  - value: the value at the branch                                                                  // 715
//  - dontIterate: an optional bool; if true, it means that 'value' is an array                       // 716
//    that expandArraysInBranches should NOT expand. This specifically happens                        // 717
//    when there is a numeric index in the key, and ensures the                                       // 718
//    perhaps-surprising MongoDB behavior where {'a.0': 5} does NOT                                   // 719
//    match {a: [[5]]}.                                                                               // 720
//  - arrayIndex: if any array indexing was done during lookup (either                                // 721
//    due to explicit numeric indices or implicit branching), this will                               // 722
//    be the FIRST (outermost) array index used; it is undefined or absent                            // 723
//    if no array index is used. (Make sure to check its value vs undefined,                          // 724
//    not just for truth, since '0' is a legit array index!) This is used                             // 725
//    to implement the '$' modifier feature.                                                          // 726
//                                                                                                    // 727
// At the top level, you may only pass in a plain object or arraym.                                   // 728
//                                                                                                    // 729
// See the text 'minimongo - lookup' for some examples of what lookup functions                       // 730
// return.                                                                                            // 731
makeLookupFunction = function (key) {                                                                 // 732
  var parts = key.split('.');                                                                         // 733
  var firstPart = parts.length ? parts[0] : '';                                                       // 734
  var firstPartIsNumeric = isNumericKey(firstPart);                                                   // 735
  var lookupRest;                                                                                     // 736
  if (parts.length > 1) {                                                                             // 737
    lookupRest = makeLookupFunction(parts.slice(1).join('.'));                                        // 738
  }                                                                                                   // 739
                                                                                                      // 740
  var elideUnnecessaryFields = function (retVal) {                                                    // 741
    if (!retVal.dontIterate)                                                                          // 742
      delete retVal.dontIterate;                                                                      // 743
    if (retVal.arrayIndex === undefined)                                                              // 744
      delete retVal.arrayIndex;                                                                       // 745
    return retVal;                                                                                    // 746
  };                                                                                                  // 747
                                                                                                      // 748
  // Doc will always be a plain object or an array.                                                   // 749
  // apply an explicit numeric index, an array.                                                       // 750
  return function (doc, firstArrayIndex) {                                                            // 751
    if (isArray(doc)) {                                                                               // 752
      // If we're being asked to do an invalid lookup into an array (non-integer                      // 753
      // or out-of-bounds), return no results (which is different from returning                      // 754
      // a single undefined result, in that `null` equality checks won't match).                      // 755
      if (!(firstPartIsNumeric && firstPart < doc.length))                                            // 756
        return [];                                                                                    // 757
                                                                                                      // 758
      // If this is the first array index we've seen, remember the index.                             // 759
      // (Mongo doesn't support multiple uses of '$', at least not in 2.5.                            // 760
      if (firstArrayIndex === undefined)                                                              // 761
        firstArrayIndex = +firstPart;                                                                 // 762
    }                                                                                                 // 763
                                                                                                      // 764
    // Do our first lookup.                                                                           // 765
    var firstLevel = doc[firstPart];                                                                  // 766
                                                                                                      // 767
    // If there is no deeper to dig, return what we found.                                            // 768
    //                                                                                                // 769
    // If what we found is an array, most value selectors will choose to treat                        // 770
    // the elements of the array as matchable values in their own right, but                          // 771
    // that's done outside of the lookup function. (Exceptions to this are $size                      // 772
    // and stuff relating to $elemMatch.  eg, {a: {$size: 2}} does not match {a:                      // 773
    // [[1, 2]]}.)                                                                                    // 774
    //                                                                                                // 775
    // That said, if we just did an *explicit* array lookup (on doc) to find                          // 776
    // firstLevel, and firstLevel is an array too, we do NOT want value                               // 777
    // selectors to iterate over it.  eg, {'a.0': 5} does not match {a: [[5]]}.                       // 778
    // So in that case, we mark the return value as "don't iterate".                                  // 779
    if (!lookupRest) {                                                                                // 780
      return [elideUnnecessaryFields({                                                                // 781
        value: firstLevel,                                                                            // 782
        dontIterate: isArray(doc) && isArray(firstLevel),                                             // 783
        arrayIndex: firstArrayIndex})];                                                               // 784
    }                                                                                                 // 785
                                                                                                      // 786
    // We need to dig deeper.  But if we can't, because what we've found is not                       // 787
    // an array or plain object, we're done. If we just did a numeric index into                      // 788
    // an array, we return nothing here (this is a change in Mongo 2.5 from                           // 789
    // Mongo 2.4, where {'a.0.b': null} stopped matching {a: [5]}). Otherwise,                        // 790
    // return a single `undefined` (which can, for example, match via equality                        // 791
    // with `null`).                                                                                  // 792
    if (!isIndexable(firstLevel)) {                                                                   // 793
      if (isArray(doc))                                                                               // 794
        return [];                                                                                    // 795
      return [elideUnnecessaryFields({value: undefined,                                               // 796
                                      arrayIndex: firstArrayIndex})];                                 // 797
    }                                                                                                 // 798
                                                                                                      // 799
    var result = [];                                                                                  // 800
    var appendToResult = function (more) {                                                            // 801
      Array.prototype.push.apply(result, more);                                                       // 802
    };                                                                                                // 803
                                                                                                      // 804
    // Dig deeper: look up the rest of the parts on whatever we've found.                             // 805
    // (lookupRest is smart enough to not try to do invalid lookups into                              // 806
    // firstLevel if it's an array.)                                                                  // 807
    appendToResult(lookupRest(firstLevel, firstArrayIndex));                                          // 808
                                                                                                      // 809
    // If we found an array, then in *addition* to potentially treating the next                      // 810
    // part as a literal integer lookup, we should also "branch": try to do look                      // 811
    // up the rest of the parts on each array element in parallel.                                    // 812
    //                                                                                                // 813
    // In this case, we *only* dig deeper into array elements that are plain                          // 814
    // objects. (Recall that we only got this far if we have further to dig.)                         // 815
    // This makes sense: we certainly don't dig deeper into non-indexable                             // 816
    // objects. And it would be weird to dig into an array: it's simpler to have                      // 817
    // a rule that explicit integer indexes only apply to an outer array, not to                      // 818
    // an array you find after a branching search.                                                    // 819
    if (isArray(firstLevel)) {                                                                        // 820
      _.each(firstLevel, function (branch, arrayIndex) {                                              // 821
        if (isPlainObject(branch)) {                                                                  // 822
          appendToResult(lookupRest(                                                                  // 823
            branch,                                                                                   // 824
            firstArrayIndex === undefined ? arrayIndex : firstArrayIndex));                           // 825
        }                                                                                             // 826
      });                                                                                             // 827
    }                                                                                                 // 828
                                                                                                      // 829
    return result;                                                                                    // 830
  };                                                                                                  // 831
};                                                                                                    // 832
MinimongoTest.makeLookupFunction = makeLookupFunction;                                                // 833
                                                                                                      // 834
expandArraysInBranches = function (branches, skipTheArrays) {                                         // 835
  var branchesOut = [];                                                                               // 836
  _.each(branches, function (branch) {                                                                // 837
    var thisIsArray = isArray(branch.value);                                                          // 838
    // We include the branch itself, *UNLESS* we it's an array that we're going                       // 839
    // to iterate and we're told to skip arrays.  (That's right, we include some                      // 840
    // arrays even skipTheArrays is true: these are arrays that were found via                        // 841
    // explicit numerical indices.)                                                                   // 842
    if (!(skipTheArrays && thisIsArray && !branch.dontIterate)) {                                     // 843
      branchesOut.push({                                                                              // 844
        value: branch.value,                                                                          // 845
        arrayIndex: branch.arrayIndex                                                                 // 846
      });                                                                                             // 847
    }                                                                                                 // 848
    if (thisIsArray && !branch.dontIterate) {                                                         // 849
      _.each(branch.value, function (leaf, i) {                                                       // 850
        branchesOut.push({                                                                            // 851
          value: leaf,                                                                                // 852
          // arrayIndex always defaults to the outermost array, but if we didn't                      // 853
          // need to use an array to get to this branch, we mark the index we                         // 854
          // just used as the arrayIndex.                                                             // 855
          arrayIndex: branch.arrayIndex === undefined ? i : branch.arrayIndex                         // 856
        });                                                                                           // 857
      });                                                                                             // 858
    }                                                                                                 // 859
  });                                                                                                 // 860
  return branchesOut;                                                                                 // 861
};                                                                                                    // 862
                                                                                                      // 863
var nothingMatcher = function (docOrBranchedValues) {                                                 // 864
  return {result: false};                                                                             // 865
};                                                                                                    // 866
                                                                                                      // 867
var everythingMatcher = function (docOrBranchedValues) {                                              // 868
  return {result: true};                                                                              // 869
};                                                                                                    // 870
                                                                                                      // 871
                                                                                                      // 872
// NB: We are cheating and using this function to implement "AND" for both                            // 873
// "document matchers" and "branched matchers". They both return result objects                       // 874
// but the argument is different: for the former it's a whole doc, whereas for                        // 875
// the latter it's an array of "branched values".                                                     // 876
var andSomeMatchers = function (subMatchers) {                                                        // 877
  if (subMatchers.length === 0)                                                                       // 878
    return everythingMatcher;                                                                         // 879
  if (subMatchers.length === 1)                                                                       // 880
    return subMatchers[0];                                                                            // 881
                                                                                                      // 882
  return function (docOrBranches) {                                                                   // 883
    // XXX arrayIndex!                                                                                // 884
    var ret = {};                                                                                     // 885
    ret.result = _.all(subMatchers, function (f) {                                                    // 886
      var subResult = f(docOrBranches);                                                               // 887
      // Copy a 'distance' number out of the first sub-matcher that has                               // 888
      // one. Yes, this means that if there are multiple $near fields in a                            // 889
      // query, something arbitrary happens; this appears to be consistent with                       // 890
      // Mongo.                                                                                       // 891
      if (subResult.result && subResult.distance !== undefined                                        // 892
          && ret.distance === undefined) {                                                            // 893
        ret.distance = subResult.distance;                                                            // 894
      }                                                                                               // 895
      // Similarly, propagate arrayIndex from sub-matchers... but to match                            // 896
      // MongoDB behavior, this time the *last* sub-matcher with an arrayIndex                        // 897
      // wins.                                                                                        // 898
      if (subResult.result && subResult.arrayIndex !== undefined) {                                   // 899
        ret.arrayIndex = subResult.arrayIndex;                                                        // 900
      }                                                                                               // 901
      return subResult.result;                                                                        // 902
    });                                                                                               // 903
                                                                                                      // 904
    // If we didn't actually match, forget any extra metadata we came up with.                        // 905
    if (!ret.result) {                                                                                // 906
      delete ret.distance;                                                                            // 907
      delete ret.arrayIndex;                                                                          // 908
    }                                                                                                 // 909
    return ret;                                                                                       // 910
  };                                                                                                  // 911
};                                                                                                    // 912
                                                                                                      // 913
var andDocumentMatchers = andSomeMatchers;                                                            // 914
var andBranchedMatchers = andSomeMatchers;                                                            // 915
                                                                                                      // 916
                                                                                                      // 917
// helpers used by compiled selector code                                                             // 918
LocalCollection._f = {                                                                                // 919
  // XXX for _all and _in, consider building 'inquery' at compile time..                              // 920
                                                                                                      // 921
  _type: function (v) {                                                                               // 922
    if (typeof v === "number")                                                                        // 923
      return 1;                                                                                       // 924
    if (typeof v === "string")                                                                        // 925
      return 2;                                                                                       // 926
    if (typeof v === "boolean")                                                                       // 927
      return 8;                                                                                       // 928
    if (isArray(v))                                                                                   // 929
      return 4;                                                                                       // 930
    if (v === null)                                                                                   // 931
      return 10;                                                                                      // 932
    if (v instanceof RegExp)                                                                          // 933
      // note that typeof(/x/) === "object"                                                           // 934
      return 11;                                                                                      // 935
    if (typeof v === "function")                                                                      // 936
      return 13;                                                                                      // 937
    if (v instanceof Date)                                                                            // 938
      return 9;                                                                                       // 939
    if (EJSON.isBinary(v))                                                                            // 940
      return 5;                                                                                       // 941
    if (v instanceof LocalCollection._ObjectID)                                                       // 942
      return 7;                                                                                       // 943
    return 3; // object                                                                               // 944
                                                                                                      // 945
    // XXX support some/all of these:                                                                 // 946
    // 14, symbol                                                                                     // 947
    // 15, javascript code with scope                                                                 // 948
    // 16, 18: 32-bit/64-bit integer                                                                  // 949
    // 17, timestamp                                                                                  // 950
    // 255, minkey                                                                                    // 951
    // 127, maxkey                                                                                    // 952
  },                                                                                                  // 953
                                                                                                      // 954
  // deep equality test: use for literal document and array matches                                   // 955
  _equal: function (a, b) {                                                                           // 956
    return EJSON.equals(a, b, {keyOrderSensitive: true});                                             // 957
  },                                                                                                  // 958
                                                                                                      // 959
  // maps a type code to a value that can be used to sort values of                                   // 960
  // different types                                                                                  // 961
  _typeorder: function (t) {                                                                          // 962
    // http://www.mongodb.org/display/DOCS/What+is+the+Compare+Order+for+BSON+Types                   // 963
    // XXX what is the correct sort position for Javascript code?                                     // 964
    // ('100' in the matrix below)                                                                    // 965
    // XXX minkey/maxkey                                                                              // 966
    return [-1,  // (not a type)                                                                      // 967
            1,   // number                                                                            // 968
            2,   // string                                                                            // 969
            3,   // object                                                                            // 970
            4,   // array                                                                             // 971
            5,   // binary                                                                            // 972
            -1,  // deprecated                                                                        // 973
            6,   // ObjectID                                                                          // 974
            7,   // bool                                                                              // 975
            8,   // Date                                                                              // 976
            0,   // null                                                                              // 977
            9,   // RegExp                                                                            // 978
            -1,  // deprecated                                                                        // 979
            100, // JS code                                                                           // 980
            2,   // deprecated (symbol)                                                               // 981
            100, // JS code                                                                           // 982
            1,   // 32-bit int                                                                        // 983
            8,   // Mongo timestamp                                                                   // 984
            1    // 64-bit int                                                                        // 985
           ][t];                                                                                      // 986
  },                                                                                                  // 987
                                                                                                      // 988
  // compare two values of unknown type according to BSON ordering                                    // 989
  // semantics. (as an extension, consider 'undefined' to be less than                                // 990
  // any other value.) return negative if a is less, positive if b is                                 // 991
  // less, or 0 if equal                                                                              // 992
  _cmp: function (a, b) {                                                                             // 993
    if (a === undefined)                                                                              // 994
      return b === undefined ? 0 : -1;                                                                // 995
    if (b === undefined)                                                                              // 996
      return 1;                                                                                       // 997
    var ta = LocalCollection._f._type(a);                                                             // 998
    var tb = LocalCollection._f._type(b);                                                             // 999
    var oa = LocalCollection._f._typeorder(ta);                                                       // 1000
    var ob = LocalCollection._f._typeorder(tb);                                                       // 1001
    if (oa !== ob)                                                                                    // 1002
      return oa < ob ? -1 : 1;                                                                        // 1003
    if (ta !== tb)                                                                                    // 1004
      // XXX need to implement this if we implement Symbol or integers, or                            // 1005
      // Timestamp                                                                                    // 1006
      throw Error("Missing type coercion logic in _cmp");                                             // 1007
    if (ta === 7) { // ObjectID                                                                       // 1008
      // Convert to string.                                                                           // 1009
      ta = tb = 2;                                                                                    // 1010
      a = a.toHexString();                                                                            // 1011
      b = b.toHexString();                                                                            // 1012
    }                                                                                                 // 1013
    if (ta === 9) { // Date                                                                           // 1014
      // Convert to millis.                                                                           // 1015
      ta = tb = 1;                                                                                    // 1016
      a = a.getTime();                                                                                // 1017
      b = b.getTime();                                                                                // 1018
    }                                                                                                 // 1019
                                                                                                      // 1020
    if (ta === 1) // double                                                                           // 1021
      return a - b;                                                                                   // 1022
    if (tb === 2) // string                                                                           // 1023
      return a < b ? -1 : (a === b ? 0 : 1);                                                          // 1024
    if (ta === 3) { // Object                                                                         // 1025
      // this could be much more efficient in the expected case ...                                   // 1026
      var to_array = function (obj) {                                                                 // 1027
        var ret = [];                                                                                 // 1028
        for (var key in obj) {                                                                        // 1029
          ret.push(key);                                                                              // 1030
          ret.push(obj[key]);                                                                         // 1031
        }                                                                                             // 1032
        return ret;                                                                                   // 1033
      };                                                                                              // 1034
      return LocalCollection._f._cmp(to_array(a), to_array(b));                                       // 1035
    }                                                                                                 // 1036
    if (ta === 4) { // Array                                                                          // 1037
      for (var i = 0; ; i++) {                                                                        // 1038
        if (i === a.length)                                                                           // 1039
          return (i === b.length) ? 0 : -1;                                                           // 1040
        if (i === b.length)                                                                           // 1041
          return 1;                                                                                   // 1042
        var s = LocalCollection._f._cmp(a[i], b[i]);                                                  // 1043
        if (s !== 0)                                                                                  // 1044
          return s;                                                                                   // 1045
      }                                                                                               // 1046
    }                                                                                                 // 1047
    if (ta === 5) { // binary                                                                         // 1048
      // Surprisingly, a small binary blob is always less than a large one in                         // 1049
      // Mongo.                                                                                       // 1050
      if (a.length !== b.length)                                                                      // 1051
        return a.length - b.length;                                                                   // 1052
      for (i = 0; i < a.length; i++) {                                                                // 1053
        if (a[i] < b[i])                                                                              // 1054
          return -1;                                                                                  // 1055
        if (a[i] > b[i])                                                                              // 1056
          return 1;                                                                                   // 1057
      }                                                                                               // 1058
      return 0;                                                                                       // 1059
    }                                                                                                 // 1060
    if (ta === 8) { // boolean                                                                        // 1061
      if (a) return b ? 0 : 1;                                                                        // 1062
      return b ? -1 : 0;                                                                              // 1063
    }                                                                                                 // 1064
    if (ta === 10) // null                                                                            // 1065
      return 0;                                                                                       // 1066
    if (ta === 11) // regexp                                                                          // 1067
      throw Error("Sorting not supported on regular expression"); // XXX                              // 1068
    // 13: javascript code                                                                            // 1069
    // 14: symbol                                                                                     // 1070
    // 15: javascript code with scope                                                                 // 1071
    // 16: 32-bit integer                                                                             // 1072
    // 17: timestamp                                                                                  // 1073
    // 18: 64-bit integer                                                                             // 1074
    // 255: minkey                                                                                    // 1075
    // 127: maxkey                                                                                    // 1076
    if (ta === 13) // javascript code                                                                 // 1077
      throw Error("Sorting not supported on Javascript code"); // XXX                                 // 1078
    throw Error("Unknown type to sort");                                                              // 1079
  }                                                                                                   // 1080
};                                                                                                    // 1081
                                                                                                      // 1082
// Oddball function used by upsert.                                                                   // 1083
LocalCollection._removeDollarOperators = function (selector) {                                        // 1084
  var selectorDoc = {};                                                                               // 1085
  for (var k in selector)                                                                             // 1086
    if (k.substr(0, 1) !== '$')                                                                       // 1087
      selectorDoc[k] = selector[k];                                                                   // 1088
  return selectorDoc;                                                                                 // 1089
};                                                                                                    // 1090
                                                                                                      // 1091
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/sort.js                                                                         //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
// Give a sort spec, which can be in any of these forms:                                              // 1
//   {"key1": 1, "key2": -1}                                                                          // 2
//   [["key1", "asc"], ["key2", "desc"]]                                                              // 3
//   ["key1", ["key2", "desc"]]                                                                       // 4
//                                                                                                    // 5
// (.. with the first form being dependent on the key enumeration                                     // 6
// behavior of your javascript VM, which usually does what you mean in                                // 7
// this case if the key names don't look like integers ..)                                            // 8
//                                                                                                    // 9
// return a function that takes two objects, and returns -1 if the                                    // 10
// first object comes first in order, 1 if the second object comes                                    // 11
// first, or 0 if neither object comes before the other.                                              // 12
                                                                                                      // 13
Sorter = function (spec) {                                                                            // 14
  var self = this;                                                                                    // 15
                                                                                                      // 16
  var sortSpecParts = [];                                                                             // 17
                                                                                                      // 18
  if (spec instanceof Array) {                                                                        // 19
    for (var i = 0; i < spec.length; i++) {                                                           // 20
      if (typeof spec[i] === "string") {                                                              // 21
        sortSpecParts.push({                                                                          // 22
          lookup: makeLookupFunction(spec[i]),                                                        // 23
          ascending: true                                                                             // 24
        });                                                                                           // 25
      } else {                                                                                        // 26
        sortSpecParts.push({                                                                          // 27
          lookup: makeLookupFunction(spec[i][0]),                                                     // 28
          ascending: spec[i][1] !== "desc"                                                            // 29
        });                                                                                           // 30
      }                                                                                               // 31
    }                                                                                                 // 32
  } else if (typeof spec === "object") {                                                              // 33
    for (var key in spec) {                                                                           // 34
      sortSpecParts.push({                                                                            // 35
        lookup: makeLookupFunction(key),                                                              // 36
        ascending: spec[key] >= 0                                                                     // 37
      });                                                                                             // 38
    }                                                                                                 // 39
  } else {                                                                                            // 40
    throw Error("Bad sort specification: ", JSON.stringify(spec));                                    // 41
  }                                                                                                   // 42
                                                                                                      // 43
  // reduceValue takes in all the possible values for the sort key along various                      // 44
  // branches, and returns the min or max value (according to the bool                                // 45
  // findMin). Each value can itself be an array, and we look at its values                           // 46
  // too. (ie, we do a single level of flattening on branchValues, then find the                      // 47
  // min/max.)                                                                                        // 48
  //                                                                                                  // 49
  // XXX This is actually wrong! In fact, the whole attempt to compile sort                           // 50
  //     functions independently of selectors is wrong. In MongoDB, if you have                       // 51
  //     documents {_id: 'x', a: [1, 10]} and {_id: 'y', a: [5, 15]}, then                            // 52
  //     C.find({}, {sort: {a: 1}}) puts x before y (1 comes before 5).  But                          // 53
  //     C.find({a: {$gt: 3}}, {sort: {a: 1}}) puts y before x (1 does not match                      // 54
  //     the selector, and 5 comes before 10).                                                        // 55
  //                                                                                                  // 56
  //     The way this works is pretty subtle!  For example, if the documents are                      // 57
  //     instead {_id: 'x', a: [{x: 1}, {x: 10}]}) and                                                // 58
  //             {_id: 'y', a: [{x: 5}, {x: 15}]}),                                                   // 59
  //     then C.find({'a.x': {$gt: 3}}, {sort: {'a.x': 1}}) and                                       // 60
  //          C.find({a: {$elemMatch: {x: {$gt: 3}}}}, {sort: {'a.x': 1}})                            // 61
  //     both follow this rule (y before x).  ie, you do have to apply this                           // 62
  //     through $elemMatch.                                                                          // 63
  var reduceValue = function (branchValues, findMin) {                                                // 64
    // Expand any leaf arrays that we find, and ignore those arrays themselves.                       // 65
    branchValues = expandArraysInBranches(branchValues, true);                                        // 66
    var reduced = undefined;                                                                          // 67
    var first = true;                                                                                 // 68
    // Iterate over all the values found in all the branches, and if a value is                       // 69
    // an array itself, iterate over the values in the array separately.                              // 70
    _.each(branchValues, function (branchValue) {                                                     // 71
      if (first) {                                                                                    // 72
        reduced = branchValue.value;                                                                  // 73
        first = false;                                                                                // 74
      } else {                                                                                        // 75
        // Compare the value we found to the value we found so far, saving it                         // 76
        // if it's less (for an ascending sort) or more (for a descending                             // 77
        // sort).                                                                                     // 78
        var cmp = LocalCollection._f._cmp(reduced, branchValue.value);                                // 79
        if ((findMin && cmp > 0) || (!findMin && cmp < 0))                                            // 80
          reduced = branchValue.value;                                                                // 81
      }                                                                                               // 82
    });                                                                                               // 83
    return reduced;                                                                                   // 84
  };                                                                                                  // 85
                                                                                                      // 86
  var comparators = _.map(sortSpecParts, function (specPart) {                                        // 87
    return function (a, b) {                                                                          // 88
      var aValue = reduceValue(specPart.lookup(a), specPart.ascending);                               // 89
      var bValue = reduceValue(specPart.lookup(b), specPart.ascending);                               // 90
      var compare = LocalCollection._f._cmp(aValue, bValue);                                          // 91
      return specPart.ascending ? compare : -compare;                                                 // 92
    };                                                                                                // 93
  });                                                                                                 // 94
                                                                                                      // 95
  self._baseComparator = composeComparators(comparators);                                             // 96
};                                                                                                    // 97
                                                                                                      // 98
Sorter.prototype.getComparator = function (options) {                                                 // 99
  var self = this;                                                                                    // 100
                                                                                                      // 101
  // If we have no distances, just use the comparator from the source                                 // 102
  // specification (which defaults to "everything is equal".                                          // 103
  if (!options || !options.distances) {                                                               // 104
    return self._baseComparator;                                                                      // 105
  }                                                                                                   // 106
                                                                                                      // 107
  var distances = options.distances;                                                                  // 108
                                                                                                      // 109
  // Return a comparator which first tries the sort specification, and if that                        // 110
  // says "it's equal", breaks ties using $near distances.                                            // 111
  return composeComparators([self._baseComparator, function (a, b) {                                  // 112
    if (!distances.has(a._id))                                                                        // 113
      throw Error("Missing distance for " + a._id);                                                   // 114
    if (!distances.has(b._id))                                                                        // 115
      throw Error("Missing distance for " + b._id);                                                   // 116
    return distances.get(a._id) - distances.get(b._id);                                               // 117
  }]);                                                                                                // 118
};                                                                                                    // 119
                                                                                                      // 120
MinimongoTest.Sorter = Sorter;                                                                        // 121
                                                                                                      // 122
// Given an array of comparators                                                                      // 123
// (functions (a,b)->(negative or positive or zero)), returns a single                                // 124
// comparator which uses each comparator in order and returns the first                               // 125
// non-zero value.                                                                                    // 126
var composeComparators = function (comparatorArray) {                                                 // 127
  return function (a, b) {                                                                            // 128
    for (var i = 0; i < comparatorArray.length; ++i) {                                                // 129
      var compare = comparatorArray[i](a, b);                                                         // 130
      if (compare !== 0)                                                                              // 131
        return compare;                                                                               // 132
    }                                                                                                 // 133
    return 0;                                                                                         // 134
  };                                                                                                  // 135
};                                                                                                    // 136
                                                                                                      // 137
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/projection.js                                                                   //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
// Knows how to compile a fields projection to a predicate function.                                  // 1
// @returns - Function: a closure that filters out an object according to the                         // 2
//            fields projection rules:                                                                // 3
//            @param obj - Object: MongoDB-styled document                                            // 4
//            @returns - Object: a document with the fields filtered out                              // 5
//                       according to projection rules. Doesn't retain subfields                      // 6
//                       of passed argument.                                                          // 7
LocalCollection._compileProjection = function (fields) {                                              // 8
  LocalCollection._checkSupportedProjection(fields);                                                  // 9
                                                                                                      // 10
  var _idProjection = _.isUndefined(fields._id) ? true : fields._id;                                  // 11
  var details = projectionDetails(fields);                                                            // 12
                                                                                                      // 13
  // returns transformed doc according to ruleTree                                                    // 14
  var transform = function (doc, ruleTree) {                                                          // 15
    // Special case for "sets"                                                                        // 16
    if (_.isArray(doc))                                                                               // 17
      return _.map(doc, function (subdoc) { return transform(subdoc, ruleTree); });                   // 18
                                                                                                      // 19
    var res = details.including ? {} : EJSON.clone(doc);                                              // 20
    _.each(ruleTree, function (rule, key) {                                                           // 21
      if (!_.has(doc, key))                                                                           // 22
        return;                                                                                       // 23
      if (_.isObject(rule)) {                                                                         // 24
        // For sub-objects/subsets we branch                                                          // 25
        if (_.isObject(doc[key]))                                                                     // 26
          res[key] = transform(doc[key], rule);                                                       // 27
        // Otherwise we don't even touch this subfield                                                // 28
      } else if (details.including)                                                                   // 29
        res[key] = EJSON.clone(doc[key]);                                                             // 30
      else                                                                                            // 31
        delete res[key];                                                                              // 32
    });                                                                                               // 33
                                                                                                      // 34
    return res;                                                                                       // 35
  };                                                                                                  // 36
                                                                                                      // 37
  return function (obj) {                                                                             // 38
    var res = transform(obj, details.tree);                                                           // 39
                                                                                                      // 40
    if (_idProjection && _.has(obj, '_id'))                                                           // 41
      res._id = obj._id;                                                                              // 42
    if (!_idProjection && _.has(res, '_id'))                                                          // 43
      delete res._id;                                                                                 // 44
    return res;                                                                                       // 45
  };                                                                                                  // 46
};                                                                                                    // 47
                                                                                                      // 48
// Traverses the keys of passed projection and constructs a tree where all                            // 49
// leaves are either all True or all False                                                            // 50
// @returns Object:                                                                                   // 51
//  - tree - Object - tree representation of keys involved in projection                              // 52
//  (exception for '_id' as it is a special case handled separately)                                  // 53
//  - including - Boolean - "take only certain fields" type of projection                             // 54
projectionDetails = function (fields) {                                                               // 55
  // Find the non-_id keys (_id is handled specially because it is included unless                    // 56
  // explicitly excluded). Sort the keys, so that our code to detect overlaps                         // 57
  // like 'foo' and 'foo.bar' can assume that 'foo' comes first.                                      // 58
  var fieldsKeys = _.keys(fields).sort();                                                             // 59
                                                                                                      // 60
  // If there are other rules other than '_id', treat '_id' differently in a                          // 61
  // separate case. If '_id' is the only rule, use it to understand if it is                          // 62
  // including/excluding projection.                                                                  // 63
  if (fieldsKeys.length > 0 && !(fieldsKeys.length === 1 && fieldsKeys[0] === '_id'))                 // 64
    fieldsKeys = _.reject(fieldsKeys, function (key) { return key === '_id'; });                      // 65
                                                                                                      // 66
  var including = null; // Unknown                                                                    // 67
                                                                                                      // 68
  _.each(fieldsKeys, function (keyPath) {                                                             // 69
    var rule = !!fields[keyPath];                                                                     // 70
    if (including === null)                                                                           // 71
      including = rule;                                                                               // 72
    if (including !== rule)                                                                           // 73
      // This error message is copies from MongoDB shell                                              // 74
      throw MinimongoError("You cannot currently mix including and excluding fields.");               // 75
  });                                                                                                 // 76
                                                                                                      // 77
                                                                                                      // 78
  var projectionRulesTree = pathsToTree(                                                              // 79
    fieldsKeys,                                                                                       // 80
    function (path) { return including; },                                                            // 81
    function (node, path, fullPath) {                                                                 // 82
      // Check passed projection fields' keys: If you have two rules such as                          // 83
      // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If                           // 84
      // that happens, there is a probability you are doing something wrong,                          // 85
      // framework should notify you about such mistake earlier on cursor                             // 86
      // compilation step than later during runtime.  Note, that real mongo                           // 87
      // doesn't do anything about it and the later rule appears in projection                        // 88
      // project, more priority it takes.                                                             // 89
      //                                                                                              // 90
      // Example, assume following in mongo shell:                                                    // 91
      // > db.coll.insert({ a: { b: 23, c: 44 } })                                                    // 92
      // > db.coll.find({}, { 'a': 1, 'a.b': 1 })                                                     // 93
      // { "_id" : ObjectId("520bfe456024608e8ef24af3"), "a" : { "b" : 23 } }                         // 94
      // > db.coll.find({}, { 'a.b': 1, 'a': 1 })                                                     // 95
      // { "_id" : ObjectId("520bfe456024608e8ef24af3"), "a" : { "b" : 23, "c" : 44 } }               // 96
      //                                                                                              // 97
      // Note, how second time the return set of keys is different.                                   // 98
                                                                                                      // 99
      var currentPath = fullPath;                                                                     // 100
      var anotherPath = path;                                                                         // 101
      throw MinimongoError("both " + currentPath + " and " + anotherPath +                            // 102
                           " found in fields option, using both of them may trigger " +               // 103
                           "unexpected behavior. Did you mean to use only one of them?");             // 104
    });                                                                                               // 105
                                                                                                      // 106
  return {                                                                                            // 107
    tree: projectionRulesTree,                                                                        // 108
    including: including                                                                              // 109
  };                                                                                                  // 110
};                                                                                                    // 111
                                                                                                      // 112
// paths - Array: list of mongo style paths                                                           // 113
// newLeafFn - Function: of form function(path) should return a scalar value to                       // 114
//                       put into list created for that path                                          // 115
// conflictFn - Function: of form function(node, path, fullPath) is called                            // 116
//                        when building a tree path for 'fullPath' node on                            // 117
//                        'path' was already a leaf with a value. Must return a                       // 118
//                        conflict resolution.                                                        // 119
// initial tree - Optional Object: starting tree.                                                     // 120
// @returns - Object: tree represented as a set of nested objects                                     // 121
pathsToTree = function (paths, newLeafFn, conflictFn, tree) {                                         // 122
  tree = tree || {};                                                                                  // 123
  _.each(paths, function (keyPath) {                                                                  // 124
    var treePos = tree;                                                                               // 125
    var pathArr = keyPath.split('.');                                                                 // 126
                                                                                                      // 127
    // use _.all just for iteration with break                                                        // 128
    var success = _.all(pathArr.slice(0, -1), function (key, idx) {                                   // 129
      if (!_.has(treePos, key))                                                                       // 130
        treePos[key] = {};                                                                            // 131
      else if (!_.isObject(treePos[key])) {                                                           // 132
        treePos[key] = conflictFn(treePos[key],                                                       // 133
                                  pathArr.slice(0, idx + 1).join('.'),                                // 134
                                  keyPath);                                                           // 135
        // break out of loop if we are failing for this path                                          // 136
        if (!_.isObject(treePos[key]))                                                                // 137
          return false;                                                                               // 138
      }                                                                                               // 139
                                                                                                      // 140
      treePos = treePos[key];                                                                         // 141
      return true;                                                                                    // 142
    });                                                                                               // 143
                                                                                                      // 144
    if (success) {                                                                                    // 145
      var lastKey = _.last(pathArr);                                                                  // 146
      if (!_.has(treePos, lastKey))                                                                   // 147
        treePos[lastKey] = newLeafFn(keyPath);                                                        // 148
      else                                                                                            // 149
        treePos[lastKey] = conflictFn(treePos[lastKey], keyPath, keyPath);                            // 150
    }                                                                                                 // 151
  });                                                                                                 // 152
                                                                                                      // 153
  return tree;                                                                                        // 154
};                                                                                                    // 155
                                                                                                      // 156
LocalCollection._checkSupportedProjection = function (fields) {                                       // 157
  if (!_.isObject(fields) || _.isArray(fields))                                                       // 158
    throw MinimongoError("fields option must be an object");                                          // 159
                                                                                                      // 160
  _.each(fields, function (val, keyPath) {                                                            // 161
    if (_.contains(keyPath.split('.'), '$'))                                                          // 162
      throw MinimongoError("Minimongo doesn't support $ operator in projections yet.");               // 163
    if (_.indexOf([1, 0, true, false], val) === -1)                                                   // 164
      throw MinimongoError("Projection values should be one of 1, 0, true, or false");                // 165
  });                                                                                                 // 166
};                                                                                                    // 167
                                                                                                      // 168
                                                                                                      // 169
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/modify.js                                                                       //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
// XXX need a strategy for passing the binding of $ into this                                         // 1
// function, from the compiled selector                                                               // 2
//                                                                                                    // 3
// maybe just {key.up.to.just.before.dollarsign: array_index}                                         // 4
//                                                                                                    // 5
// XXX atomicity: if one modification fails, do we roll back the whole                                // 6
// change?                                                                                            // 7
//                                                                                                    // 8
// options:                                                                                           // 9
//   - isInsert is set when _modify is being called to compute the document to                        // 10
//     insert as part of an upsert operation. We use this primarily to figure                         // 11
//     out when to set the fields in $setOnInsert, if present.                                        // 12
LocalCollection._modify = function (doc, mod, options) {                                              // 13
  options = options || {};                                                                            // 14
  if (!isPlainObject(mod))                                                                            // 15
    throw MinimongoError("Modifier must be an object");                                               // 16
  var isModifier = isOperatorObject(mod);                                                             // 17
                                                                                                      // 18
  var newDoc;                                                                                         // 19
                                                                                                      // 20
  if (!isModifier) {                                                                                  // 21
    if (mod._id && !EJSON.equals(doc._id, mod._id))                                                   // 22
      throw MinimongoError("Cannot change the _id of a document");                                    // 23
                                                                                                      // 24
    // replace the whole document                                                                     // 25
    for (var k in mod) {                                                                              // 26
      if (/\./.test(k))                                                                               // 27
        throw MinimongoError(                                                                         // 28
          "When replacing document, field name may not contain '.'");                                 // 29
    }                                                                                                 // 30
    newDoc = mod;                                                                                     // 31
  } else {                                                                                            // 32
    // apply modifiers to the doc.                                                                    // 33
    newDoc = EJSON.clone(doc);                                                                        // 34
                                                                                                      // 35
    _.each(mod, function (operand, op) {                                                              // 36
      var modFunc = MODIFIERS[op];                                                                    // 37
      // Treat $setOnInsert as $set if this is an insert.                                             // 38
      if (options.isInsert && op === '$setOnInsert')                                                  // 39
        modFunc = MODIFIERS['$set'];                                                                  // 40
      if (!modFunc)                                                                                   // 41
        throw MinimongoError("Invalid modifier specified " + op);                                     // 42
      _.each(operand, function (arg, keypath) {                                                       // 43
        // XXX mongo doesn't allow mod field names to end in a period,                                // 44
        // but I don't see why.. it allows '' as a key, as does JS                                    // 45
        if (keypath.length && keypath[keypath.length-1] === '.')                                      // 46
          throw MinimongoError(                                                                       // 47
            "Invalid mod field name, may not end in a period");                                       // 48
                                                                                                      // 49
        var keyparts = keypath.split('.');                                                            // 50
        var noCreate = _.has(NO_CREATE_MODIFIERS, op);                                                // 51
        var forbidArray = (op === "$rename");                                                         // 52
        var target = findModTarget(newDoc, keyparts, {                                                // 53
          noCreate: NO_CREATE_MODIFIERS[op],                                                          // 54
          forbidArray: (op === "$rename"),                                                            // 55
          arrayIndex: options.arrayIndex                                                              // 56
        });                                                                                           // 57
        var field = keyparts.pop();                                                                   // 58
        modFunc(target, field, arg, keypath, newDoc);                                                 // 59
      });                                                                                             // 60
    });                                                                                               // 61
  }                                                                                                   // 62
                                                                                                      // 63
  // move new document into place.                                                                    // 64
  _.each(_.keys(doc), function (k) {                                                                  // 65
    // Note: this used to be for (var k in doc) however, this does not                                // 66
    // work right in Opera. Deleting from a doc while iterating over it                               // 67
    // would sometimes cause opera to skip some keys.                                                 // 68
                                                                                                      // 69
    // isInsert: if we're constructing a document to insert (via upsert)                              // 70
    // and we're in replacement mode, not modify mode, DON'T take the                                 // 71
    // _id from the query.  This matches mongo's behavior.                                            // 72
    if (k !== '_id' || options.isInsert)                                                              // 73
      delete doc[k];                                                                                  // 74
  });                                                                                                 // 75
  _.each(newDoc, function (v, k) {                                                                    // 76
    doc[k] = v;                                                                                       // 77
  });                                                                                                 // 78
};                                                                                                    // 79
                                                                                                      // 80
// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],                                // 81
// and then you would operate on the 'e' property of the returned                                     // 82
// object.                                                                                            // 83
//                                                                                                    // 84
// if options.noCreate is falsey, creates intermediate levels of                                      // 85
// structure as necessary, like mkdir -p (and raises an exception if                                  // 86
// that would mean giving a non-numeric property to an array.) if                                     // 87
// options.noCreate is true, return undefined instead.                                                // 88
//                                                                                                    // 89
// may modify the last element of keyparts to signal to the caller that it needs                      // 90
// to use a different value to index into the returned object (for example,                           // 91
// ['a', '01'] -> ['a', 1]).                                                                          // 92
//                                                                                                    // 93
// if forbidArray is true, return null if the keypath goes through an array.                          // 94
//                                                                                                    // 95
// if options.arrayIndex is defined, use this for the (first) '$' in the path.                        // 96
var findModTarget = function (doc, keyparts, options) {                                               // 97
  options = options || {};                                                                            // 98
  var usedArrayIndex = false;                                                                         // 99
  for (var i = 0; i < keyparts.length; i++) {                                                         // 100
    var last = (i === keyparts.length - 1);                                                           // 101
    var keypart = keyparts[i];                                                                        // 102
    var indexable = isIndexable(doc);                                                                 // 103
    if (!indexable) {                                                                                 // 104
      if (options.noCreate)                                                                           // 105
        return undefined;                                                                             // 106
      var e = MinimongoError(                                                                         // 107
        "cannot use the part '" + keypart + "' to traverse " + doc);                                  // 108
      e.setPropertyError = true;                                                                      // 109
      throw e;                                                                                        // 110
    }                                                                                                 // 111
    if (doc instanceof Array) {                                                                       // 112
      if (options.forbidArray)                                                                        // 113
        return null;                                                                                  // 114
      if (keypart === '$') {                                                                          // 115
        if (usedArrayIndex)                                                                           // 116
          throw MinimongoError("Too many positional (i.e. '$') elements");                            // 117
        if (options.arrayIndex === undefined) {                                                       // 118
          throw MinimongoError("The positional operator did not find the " +                          // 119
                               "match needed from the query");                                        // 120
        }                                                                                             // 121
        keypart = options.arrayIndex;                                                                 // 122
        usedArrayIndex = true;                                                                        // 123
      } else if (isNumericKey(keypart)) {                                                             // 124
        keypart = parseInt(keypart);                                                                  // 125
      } else {                                                                                        // 126
        if (options.noCreate)                                                                         // 127
          return undefined;                                                                           // 128
        throw MinimongoError(                                                                         // 129
          "can't append to array using string field name ["                                           // 130
                    + keypart + "]");                                                                 // 131
      }                                                                                               // 132
      if (last)                                                                                       // 133
        // handle 'a.01'                                                                              // 134
        keyparts[i] = keypart;                                                                        // 135
      if (options.noCreate && keypart >= doc.length)                                                  // 136
        return undefined;                                                                             // 137
      while (doc.length < keypart)                                                                    // 138
        doc.push(null);                                                                               // 139
      if (!last) {                                                                                    // 140
        if (doc.length === keypart)                                                                   // 141
          doc.push({});                                                                               // 142
        else if (typeof doc[keypart] !== "object")                                                    // 143
          throw MinimongoError("can't modify field '" + keyparts[i + 1] +                             // 144
                      "' of list value " + JSON.stringify(doc[keypart]));                             // 145
      }                                                                                               // 146
    } else {                                                                                          // 147
      if (keypart.length && keypart.substr(0, 1) === '$')                                             // 148
        throw MinimongoError("can't set field named " + keypart);                                     // 149
      if (!(keypart in doc)) {                                                                        // 150
        if (options.noCreate)                                                                         // 151
          return undefined;                                                                           // 152
        if (!last)                                                                                    // 153
          doc[keypart] = {};                                                                          // 154
      }                                                                                               // 155
    }                                                                                                 // 156
                                                                                                      // 157
    if (last)                                                                                         // 158
      return doc;                                                                                     // 159
    doc = doc[keypart];                                                                               // 160
  }                                                                                                   // 161
                                                                                                      // 162
  // notreached                                                                                       // 163
};                                                                                                    // 164
                                                                                                      // 165
var NO_CREATE_MODIFIERS = {                                                                           // 166
  $unset: true,                                                                                       // 167
  $pop: true,                                                                                         // 168
  $rename: true,                                                                                      // 169
  $pull: true,                                                                                        // 170
  $pullAll: true                                                                                      // 171
};                                                                                                    // 172
                                                                                                      // 173
var MODIFIERS = {                                                                                     // 174
  $inc: function (target, field, arg) {                                                               // 175
    if (typeof arg !== "number")                                                                      // 176
      throw MinimongoError("Modifier $inc allowed for numbers only");                                 // 177
    if (field in target) {                                                                            // 178
      if (typeof target[field] !== "number")                                                          // 179
        throw MinimongoError("Cannot apply $inc modifier to non-number");                             // 180
      target[field] += arg;                                                                           // 181
    } else {                                                                                          // 182
      target[field] = arg;                                                                            // 183
    }                                                                                                 // 184
  },                                                                                                  // 185
  $set: function (target, field, arg) {                                                               // 186
    if (!_.isObject(target)) { // not an array or an object                                           // 187
      var e = MinimongoError("Cannot set property on non-object field");                              // 188
      e.setPropertyError = true;                                                                      // 189
      throw e;                                                                                        // 190
    }                                                                                                 // 191
    if (target === null) {                                                                            // 192
      var e = MinimongoError("Cannot set property on null");                                          // 193
      e.setPropertyError = true;                                                                      // 194
      throw e;                                                                                        // 195
    }                                                                                                 // 196
    if (field === '_id' && !EJSON.equals(arg, target._id))                                            // 197
      throw MinimongoError("Cannot change the _id of a document");                                    // 198
                                                                                                      // 199
    target[field] = EJSON.clone(arg);                                                                 // 200
  },                                                                                                  // 201
  $setOnInsert: function (target, field, arg) {                                                       // 202
    // converted to `$set` in `_modify`                                                               // 203
  },                                                                                                  // 204
  $unset: function (target, field, arg) {                                                             // 205
    if (target !== undefined) {                                                                       // 206
      if (target instanceof Array) {                                                                  // 207
        if (field in target)                                                                          // 208
          target[field] = null;                                                                       // 209
      } else                                                                                          // 210
        delete target[field];                                                                         // 211
    }                                                                                                 // 212
  },                                                                                                  // 213
  $push: function (target, field, arg) {                                                              // 214
    if (target[field] === undefined)                                                                  // 215
      target[field] = [];                                                                             // 216
    if (!(target[field] instanceof Array))                                                            // 217
      throw MinimongoError("Cannot apply $push modifier to non-array");                               // 218
                                                                                                      // 219
    if (!(arg && arg.$each)) {                                                                        // 220
      // Simple mode: not $each                                                                       // 221
      target[field].push(EJSON.clone(arg));                                                           // 222
      return;                                                                                         // 223
    }                                                                                                 // 224
                                                                                                      // 225
    // Fancy mode: $each (and maybe $slice and $sort)                                                 // 226
    var toPush = arg.$each;                                                                           // 227
    if (!(toPush instanceof Array))                                                                   // 228
      throw MinimongoError("$each must be an array");                                                 // 229
                                                                                                      // 230
    // Parse $slice.                                                                                  // 231
    var slice = undefined;                                                                            // 232
    if ('$slice' in arg) {                                                                            // 233
      if (typeof arg.$slice !== "number")                                                             // 234
        throw MinimongoError("$slice must be a numeric value");                                       // 235
      // XXX should check to make sure integer                                                        // 236
      if (arg.$slice > 0)                                                                             // 237
        throw MinimongoError("$slice in $push must be zero or negative");                             // 238
      slice = arg.$slice;                                                                             // 239
    }                                                                                                 // 240
                                                                                                      // 241
    // Parse $sort.                                                                                   // 242
    var sortFunction = undefined;                                                                     // 243
    if (arg.$sort) {                                                                                  // 244
      if (slice === undefined)                                                                        // 245
        throw MinimongoError("$sort requires $slice to be present");                                  // 246
      // XXX this allows us to use a $sort whose value is an array, but that's                        // 247
      // actually an extension of the Node driver, so it won't work                                   // 248
      // server-side. Could be confusing!                                                             // 249
      // XXX is it correct that we don't do geo-stuff here?                                           // 250
      sortFunction = new Sorter(arg.$sort).getComparator();                                           // 251
      for (var i = 0; i < toPush.length; i++) {                                                       // 252
        if (LocalCollection._f._type(toPush[i]) !== 3) {                                              // 253
          throw MinimongoError("$push like modifiers using $sort " +                                  // 254
                      "require all elements to be objects");                                          // 255
        }                                                                                             // 256
      }                                                                                               // 257
    }                                                                                                 // 258
                                                                                                      // 259
    // Actually push.                                                                                 // 260
    for (var j = 0; j < toPush.length; j++)                                                           // 261
      target[field].push(EJSON.clone(toPush[j]));                                                     // 262
                                                                                                      // 263
    // Actually sort.                                                                                 // 264
    if (sortFunction)                                                                                 // 265
      target[field].sort(sortFunction);                                                               // 266
                                                                                                      // 267
    // Actually slice.                                                                                // 268
    if (slice !== undefined) {                                                                        // 269
      if (slice === 0)                                                                                // 270
        target[field] = [];  // differs from Array.slice!                                             // 271
      else                                                                                            // 272
        target[field] = target[field].slice(slice);                                                   // 273
    }                                                                                                 // 274
  },                                                                                                  // 275
  $pushAll: function (target, field, arg) {                                                           // 276
    if (!(typeof arg === "object" && arg instanceof Array))                                           // 277
      throw MinimongoError("Modifier $pushAll/pullAll allowed for arrays only");                      // 278
    var x = target[field];                                                                            // 279
    if (x === undefined)                                                                              // 280
      target[field] = arg;                                                                            // 281
    else if (!(x instanceof Array))                                                                   // 282
      throw MinimongoError("Cannot apply $pushAll modifier to non-array");                            // 283
    else {                                                                                            // 284
      for (var i = 0; i < arg.length; i++)                                                            // 285
        x.push(arg[i]);                                                                               // 286
    }                                                                                                 // 287
  },                                                                                                  // 288
  $addToSet: function (target, field, arg) {                                                          // 289
    var x = target[field];                                                                            // 290
    if (x === undefined)                                                                              // 291
      target[field] = [arg];                                                                          // 292
    else if (!(x instanceof Array))                                                                   // 293
      throw MinimongoError("Cannot apply $addToSet modifier to non-array");                           // 294
    else {                                                                                            // 295
      var isEach = false;                                                                             // 296
      if (typeof arg === "object") {                                                                  // 297
        for (var k in arg) {                                                                          // 298
          if (k === "$each")                                                                          // 299
            isEach = true;                                                                            // 300
          break;                                                                                      // 301
        }                                                                                             // 302
      }                                                                                               // 303
      var values = isEach ? arg["$each"] : [arg];                                                     // 304
      _.each(values, function (value) {                                                               // 305
        for (var i = 0; i < x.length; i++)                                                            // 306
          if (LocalCollection._f._equal(value, x[i]))                                                 // 307
            return;                                                                                   // 308
        x.push(EJSON.clone(value));                                                                   // 309
      });                                                                                             // 310
    }                                                                                                 // 311
  },                                                                                                  // 312
  $pop: function (target, field, arg) {                                                               // 313
    if (target === undefined)                                                                         // 314
      return;                                                                                         // 315
    var x = target[field];                                                                            // 316
    if (x === undefined)                                                                              // 317
      return;                                                                                         // 318
    else if (!(x instanceof Array))                                                                   // 319
      throw MinimongoError("Cannot apply $pop modifier to non-array");                                // 320
    else {                                                                                            // 321
      if (typeof arg === 'number' && arg < 0)                                                         // 322
        x.splice(0, 1);                                                                               // 323
      else                                                                                            // 324
        x.pop();                                                                                      // 325
    }                                                                                                 // 326
  },                                                                                                  // 327
  $pull: function (target, field, arg) {                                                              // 328
    if (target === undefined)                                                                         // 329
      return;                                                                                         // 330
    var x = target[field];                                                                            // 331
    if (x === undefined)                                                                              // 332
      return;                                                                                         // 333
    else if (!(x instanceof Array))                                                                   // 334
      throw MinimongoError("Cannot apply $pull/pullAll modifier to non-array");                       // 335
    else {                                                                                            // 336
      var out = [];                                                                                   // 337
      if (typeof arg === "object" && !(arg instanceof Array)) {                                       // 338
        // XXX would be much nicer to compile this once, rather than                                  // 339
        // for each document we modify.. but usually we're not                                        // 340
        // modifying that many documents, so we'll let it slide for                                   // 341
        // now                                                                                        // 342
                                                                                                      // 343
        // XXX Minimongo.Matcher isn't up for the job, because we need                                // 344
        // to permit stuff like {$pull: {a: {$gt: 4}}}.. something                                    // 345
        // like {$gt: 4} is not normally a complete selector.                                         // 346
        // same issue as $elemMatch possibly?                                                         // 347
        var matcher = new Minimongo.Matcher(arg);                                                     // 348
        for (var i = 0; i < x.length; i++)                                                            // 349
          if (!matcher.documentMatches(x[i]).result)                                                  // 350
            out.push(x[i]);                                                                           // 351
      } else {                                                                                        // 352
        for (var i = 0; i < x.length; i++)                                                            // 353
          if (!LocalCollection._f._equal(x[i], arg))                                                  // 354
            out.push(x[i]);                                                                           // 355
      }                                                                                               // 356
      target[field] = out;                                                                            // 357
    }                                                                                                 // 358
  },                                                                                                  // 359
  $pullAll: function (target, field, arg) {                                                           // 360
    if (!(typeof arg === "object" && arg instanceof Array))                                           // 361
      throw MinimongoError("Modifier $pushAll/pullAll allowed for arrays only");                      // 362
    if (target === undefined)                                                                         // 363
      return;                                                                                         // 364
    var x = target[field];                                                                            // 365
    if (x === undefined)                                                                              // 366
      return;                                                                                         // 367
    else if (!(x instanceof Array))                                                                   // 368
      throw MinimongoError("Cannot apply $pull/pullAll modifier to non-array");                       // 369
    else {                                                                                            // 370
      var out = [];                                                                                   // 371
      for (var i = 0; i < x.length; i++) {                                                            // 372
        var exclude = false;                                                                          // 373
        for (var j = 0; j < arg.length; j++) {                                                        // 374
          if (LocalCollection._f._equal(x[i], arg[j])) {                                              // 375
            exclude = true;                                                                           // 376
            break;                                                                                    // 377
          }                                                                                           // 378
        }                                                                                             // 379
        if (!exclude)                                                                                 // 380
          out.push(x[i]);                                                                             // 381
      }                                                                                               // 382
      target[field] = out;                                                                            // 383
    }                                                                                                 // 384
  },                                                                                                  // 385
  $rename: function (target, field, arg, keypath, doc) {                                              // 386
    if (keypath === arg)                                                                              // 387
      // no idea why mongo has this restriction..                                                     // 388
      throw MinimongoError("$rename source must differ from target");                                 // 389
    if (target === null)                                                                              // 390
      throw MinimongoError("$rename source field invalid");                                           // 391
    if (typeof arg !== "string")                                                                      // 392
      throw MinimongoError("$rename target must be a string");                                        // 393
    if (target === undefined)                                                                         // 394
      return;                                                                                         // 395
    var v = target[field];                                                                            // 396
    delete target[field];                                                                             // 397
                                                                                                      // 398
    var keyparts = arg.split('.');                                                                    // 399
    var target2 = findModTarget(doc, keyparts, {forbidArray: true});                                  // 400
    if (target2 === null)                                                                             // 401
      throw MinimongoError("$rename target field invalid");                                           // 402
    var field2 = keyparts.pop();                                                                      // 403
    target2[field2] = v;                                                                              // 404
  },                                                                                                  // 405
  $bit: function (target, field, arg) {                                                               // 406
    // XXX mongo only supports $bit on integers, and we only support                                  // 407
    // native javascript numbers (doubles) so far, so we can't support $bit                           // 408
    throw MinimongoError("$bit is not supported");                                                    // 409
  }                                                                                                   // 410
};                                                                                                    // 411
                                                                                                      // 412
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/diff.js                                                                         //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
                                                                                                      // 1
// ordered: bool.                                                                                     // 2
// old_results and new_results: collections of documents.                                             // 3
//    if ordered, they are arrays.                                                                    // 4
//    if unordered, they are IdMaps                                                                   // 5
LocalCollection._diffQueryChanges = function (ordered, oldResults, newResults,                        // 6
                                       observer) {                                                    // 7
  if (ordered)                                                                                        // 8
    LocalCollection._diffQueryOrderedChanges(                                                         // 9
      oldResults, newResults, observer);                                                              // 10
  else                                                                                                // 11
    LocalCollection._diffQueryUnorderedChanges(                                                       // 12
      oldResults, newResults, observer);                                                              // 13
};                                                                                                    // 14
                                                                                                      // 15
LocalCollection._diffQueryUnorderedChanges = function (oldResults, newResults,                        // 16
                                                       observer) {                                    // 17
  if (observer.movedBefore) {                                                                         // 18
    throw new Error("_diffQueryUnordered called with a movedBefore observer!");                       // 19
  }                                                                                                   // 20
                                                                                                      // 21
  newResults.forEach(function (newDoc, id) {                                                          // 22
    var oldDoc = oldResults.get(id);                                                                  // 23
    if (oldDoc) {                                                                                     // 24
      if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {                                        // 25
        observer.changed(                                                                             // 26
          id, LocalCollection._makeChangedFields(newDoc, oldDoc));                                    // 27
      }                                                                                               // 28
    } else if (observer.added) {                                                                      // 29
      var fields = EJSON.clone(newDoc);                                                               // 30
      delete fields._id;                                                                              // 31
      observer.added(newDoc._id, fields);                                                             // 32
    }                                                                                                 // 33
  });                                                                                                 // 34
                                                                                                      // 35
  if (observer.removed) {                                                                             // 36
    oldResults.forEach(function (oldDoc, id) {                                                        // 37
      if (!newResults.has(id))                                                                        // 38
        observer.removed(id);                                                                         // 39
    });                                                                                               // 40
  }                                                                                                   // 41
};                                                                                                    // 42
                                                                                                      // 43
                                                                                                      // 44
LocalCollection._diffQueryOrderedChanges = function (old_results, new_results, observer) {            // 45
                                                                                                      // 46
  var new_presence_of_id = {};                                                                        // 47
  _.each(new_results, function (doc) {                                                                // 48
    if (new_presence_of_id[doc._id])                                                                  // 49
      Meteor._debug("Duplicate _id in new_results");                                                  // 50
    new_presence_of_id[doc._id] = true;                                                               // 51
  });                                                                                                 // 52
                                                                                                      // 53
  var old_index_of_id = {};                                                                           // 54
  _.each(old_results, function (doc, i) {                                                             // 55
    if (doc._id in old_index_of_id)                                                                   // 56
      Meteor._debug("Duplicate _id in old_results");                                                  // 57
    old_index_of_id[doc._id] = i;                                                                     // 58
  });                                                                                                 // 59
                                                                                                      // 60
  // ALGORITHM:                                                                                       // 61
  //                                                                                                  // 62
  // To determine which docs should be considered "moved" (and which                                  // 63
  // merely change position because of other docs moving) we run                                      // 64
  // a "longest common subsequence" (LCS) algorithm.  The LCS of the                                  // 65
  // old doc IDs and the new doc IDs gives the docs that should NOT be                                // 66
  // considered moved.                                                                                // 67
                                                                                                      // 68
  // To actually call the appropriate callbacks to get from the old state to the                      // 69
  // new state:                                                                                       // 70
                                                                                                      // 71
  // First, we call removed() on all the items that only appear in the old                            // 72
  // state.                                                                                           // 73
                                                                                                      // 74
  // Then, once we have the items that should not move, we walk through the new                       // 75
  // results array group-by-group, where a "group" is a set of items that have                        // 76
  // moved, anchored on the end by an item that should not move.  One by one, we                      // 77
  // move each of those elements into place "before" the anchoring end-of-group                       // 78
  // item, and fire changed events on them if necessary.  Then we fire a changed                      // 79
  // event on the anchor, and move on to the next group.  There is always at                          // 80
  // least one group; the last group is anchored by a virtual "null" id at the                        // 81
  // end.                                                                                             // 82
                                                                                                      // 83
  // Asymptotically: O(N k) where k is number of ops, or potentially                                  // 84
  // O(N log N) if inner loop of LCS were made to be binary search.                                   // 85
                                                                                                      // 86
                                                                                                      // 87
  //////// LCS (longest common sequence, with respect to _id)                                         // 88
  // (see Wikipedia article on Longest Increasing Subsequence,                                        // 89
  // where the LIS is taken of the sequence of old indices of the                                     // 90
  // docs in new_results)                                                                             // 91
  //                                                                                                  // 92
  // unmoved: the output of the algorithm; members of the LCS,                                        // 93
  // in the form of indices into new_results                                                          // 94
  var unmoved = [];                                                                                   // 95
  // max_seq_len: length of LCS found so far                                                          // 96
  var max_seq_len = 0;                                                                                // 97
  // seq_ends[i]: the index into new_results of the last doc in a                                     // 98
  // common subsequence of length of i+1 <= max_seq_len                                               // 99
  var N = new_results.length;                                                                         // 100
  var seq_ends = new Array(N);                                                                        // 101
  // ptrs:  the common subsequence ending with new_results[n] extends                                 // 102
  // a common subsequence ending with new_results[ptr[n]], unless                                     // 103
  // ptr[n] is -1.                                                                                    // 104
  var ptrs = new Array(N);                                                                            // 105
  // virtual sequence of old indices of new results                                                   // 106
  var old_idx_seq = function(i_new) {                                                                 // 107
    return old_index_of_id[new_results[i_new]._id];                                                   // 108
  };                                                                                                  // 109
  // for each item in new_results, use it to extend a common subsequence                              // 110
  // of length j <= max_seq_len                                                                       // 111
  for(var i=0; i<N; i++) {                                                                            // 112
    if (old_index_of_id[new_results[i]._id] !== undefined) {                                          // 113
      var j = max_seq_len;                                                                            // 114
      // this inner loop would traditionally be a binary search,                                      // 115
      // but scanning backwards we will likely find a subseq to extend                                // 116
      // pretty soon, bounded for example by the total number of ops.                                 // 117
      // If this were to be changed to a binary search, we'd still want                               // 118
      // to scan backwards a bit as an optimization.                                                  // 119
      while (j > 0) {                                                                                 // 120
        if (old_idx_seq(seq_ends[j-1]) < old_idx_seq(i))                                              // 121
          break;                                                                                      // 122
        j--;                                                                                          // 123
      }                                                                                               // 124
                                                                                                      // 125
      ptrs[i] = (j === 0 ? -1 : seq_ends[j-1]);                                                       // 126
      seq_ends[j] = i;                                                                                // 127
      if (j+1 > max_seq_len)                                                                          // 128
        max_seq_len = j+1;                                                                            // 129
    }                                                                                                 // 130
  }                                                                                                   // 131
                                                                                                      // 132
  // pull out the LCS/LIS into unmoved                                                                // 133
  var idx = (max_seq_len === 0 ? -1 : seq_ends[max_seq_len-1]);                                       // 134
  while (idx >= 0) {                                                                                  // 135
    unmoved.push(idx);                                                                                // 136
    idx = ptrs[idx];                                                                                  // 137
  }                                                                                                   // 138
  // the unmoved item list is built backwards, so fix that                                            // 139
  unmoved.reverse();                                                                                  // 140
                                                                                                      // 141
  // the last group is always anchored by the end of the result list, which is                        // 142
  // an id of "null"                                                                                  // 143
  unmoved.push(new_results.length);                                                                   // 144
                                                                                                      // 145
  _.each(old_results, function (doc) {                                                                // 146
    if (!new_presence_of_id[doc._id])                                                                 // 147
      observer.removed && observer.removed(doc._id);                                                  // 148
  });                                                                                                 // 149
  // for each group of things in the new_results that is anchored by an unmoved                       // 150
  // element, iterate through the things before it.                                                   // 151
  var startOfGroup = 0;                                                                               // 152
  _.each(unmoved, function (endOfGroup) {                                                             // 153
    var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;                       // 154
    var oldDoc;                                                                                       // 155
    var newDoc;                                                                                       // 156
    var fields;                                                                                       // 157
    for (var i = startOfGroup; i < endOfGroup; i++) {                                                 // 158
      newDoc = new_results[i];                                                                        // 159
      if (!_.has(old_index_of_id, newDoc._id)) {                                                      // 160
        fields = EJSON.clone(newDoc);                                                                 // 161
        delete fields._id;                                                                            // 162
        observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);                    // 163
        observer.added && observer.added(newDoc._id, fields);                                         // 164
      } else {                                                                                        // 165
        // moved                                                                                      // 166
        oldDoc = old_results[old_index_of_id[newDoc._id]];                                            // 167
        fields = LocalCollection._makeChangedFields(newDoc, oldDoc);                                  // 168
        if (!_.isEmpty(fields)) {                                                                     // 169
          observer.changed && observer.changed(newDoc._id, fields);                                   // 170
        }                                                                                             // 171
        observer.movedBefore && observer.movedBefore(newDoc._id, groupId);                            // 172
      }                                                                                               // 173
    }                                                                                                 // 174
    if (groupId) {                                                                                    // 175
      newDoc = new_results[endOfGroup];                                                               // 176
      oldDoc = old_results[old_index_of_id[newDoc._id]];                                              // 177
      fields = LocalCollection._makeChangedFields(newDoc, oldDoc);                                    // 178
      if (!_.isEmpty(fields)) {                                                                       // 179
        observer.changed && observer.changed(newDoc._id, fields);                                     // 180
      }                                                                                               // 181
    }                                                                                                 // 182
    startOfGroup = endOfGroup+1;                                                                      // 183
  });                                                                                                 // 184
                                                                                                      // 185
                                                                                                      // 186
};                                                                                                    // 187
                                                                                                      // 188
                                                                                                      // 189
// General helper for diff-ing two objects.                                                           // 190
// callbacks is an object like so:                                                                    // 191
// { leftOnly: function (key, leftValue) {...},                                                       // 192
//   rightOnly: function (key, rightValue) {...},                                                     // 193
//   both: function (key, leftValue, rightValue) {...},                                               // 194
// }                                                                                                  // 195
LocalCollection._diffObjects = function (left, right, callbacks) {                                    // 196
  _.each(left, function (leftValue, key) {                                                            // 197
    if (_.has(right, key))                                                                            // 198
      callbacks.both && callbacks.both(key, leftValue, right[key]);                                   // 199
    else                                                                                              // 200
      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);                                       // 201
  });                                                                                                 // 202
  if (callbacks.rightOnly) {                                                                          // 203
    _.each(right, function(rightValue, key) {                                                         // 204
      if (!_.has(left, key))                                                                          // 205
        callbacks.rightOnly(key, rightValue);                                                         // 206
    });                                                                                               // 207
  }                                                                                                   // 208
};                                                                                                    // 209
                                                                                                      // 210
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/id_map.js                                                                       //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
LocalCollection._IdMap = function () {                                                                // 1
  var self = this;                                                                                    // 2
  self._map = {};                                                                                     // 3
};                                                                                                    // 4
                                                                                                      // 5
// Some of these methods are designed to match methods on OrderedDict, since                          // 6
// (eg) ObserveMultiplex and _CachingChangeObserver use them interchangeably.                         // 7
// (Conceivably, this should be replaced with "UnorderedDict" with a specific                         // 8
// set of methods that overlap between the two.)                                                      // 9
                                                                                                      // 10
_.extend(LocalCollection._IdMap.prototype, {                                                          // 11
  get: function (id) {                                                                                // 12
    var self = this;                                                                                  // 13
    var key = LocalCollection._idStringify(id);                                                       // 14
    return self._map[key];                                                                            // 15
  },                                                                                                  // 16
  set: function (id, value) {                                                                         // 17
    var self = this;                                                                                  // 18
    var key = LocalCollection._idStringify(id);                                                       // 19
    self._map[key] = value;                                                                           // 20
  },                                                                                                  // 21
  remove: function (id) {                                                                             // 22
    var self = this;                                                                                  // 23
    var key = LocalCollection._idStringify(id);                                                       // 24
    delete self._map[key];                                                                            // 25
  },                                                                                                  // 26
  has: function (id) {                                                                                // 27
    var self = this;                                                                                  // 28
    var key = LocalCollection._idStringify(id);                                                       // 29
    return _.has(self._map, key);                                                                     // 30
  },                                                                                                  // 31
  empty: function () {                                                                                // 32
    var self = this;                                                                                  // 33
    return _.isEmpty(self._map);                                                                      // 34
  },                                                                                                  // 35
  clear: function () {                                                                                // 36
    var self = this;                                                                                  // 37
    self._map = {};                                                                                   // 38
  },                                                                                                  // 39
  // Iterates over the items in the map. Return `false` to break the loop.                            // 40
  forEach: function (iterator) {                                                                      // 41
    var self = this;                                                                                  // 42
    // don't use _.each, because we can't break out of it.                                            // 43
    var keys = _.keys(self._map);                                                                     // 44
    for (var i = 0; i < keys.length; i++) {                                                           // 45
      var breakIfFalse = iterator.call(null, self._map[keys[i]],                                      // 46
                                       LocalCollection._idParse(keys[i]));                            // 47
      if (breakIfFalse === false)                                                                     // 48
        return;                                                                                       // 49
    }                                                                                                 // 50
  },                                                                                                  // 51
  size: function () {                                                                                 // 52
    var self = this;                                                                                  // 53
    return _.size(self._map);                                                                         // 54
  },                                                                                                  // 55
  setDefault: function (id, def) {                                                                    // 56
    var self = this;                                                                                  // 57
    var key = LocalCollection._idStringify(id);                                                       // 58
    if (_.has(self._map, key))                                                                        // 59
      return self._map[key];                                                                          // 60
    self._map[key] = def;                                                                             // 61
    return def;                                                                                       // 62
  },                                                                                                  // 63
  // Assumes that values are EJSON-cloneable, and that we don't need to clone                         // 64
  // IDs (ie, that nobody is going to mutate an ObjectId).                                            // 65
  clone: function () {                                                                                // 66
    var self = this;                                                                                  // 67
    var clone = new LocalCollection._IdMap;                                                           // 68
    self.forEach(function (value, id) {                                                               // 69
      clone.set(id, EJSON.clone(value));                                                              // 70
      });                                                                                             // 71
    return clone;                                                                                     // 72
  }                                                                                                   // 73
});                                                                                                   // 74
                                                                                                      // 75
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/observe.js                                                                      //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
// XXX maybe move these into another ObserveHelpers package or something                              // 1
                                                                                                      // 2
// _CachingChangeObserver is an object which receives observeChanges callbacks                        // 3
// and keeps a cache of the current cursor state up to date in self.docs. Users                       // 4
// of this class should read the docs field but not modify it. You should pass                        // 5
// the "applyChange" field as the callbacks to the underlying observeChanges                          // 6
// call. Optionally, you can specify your own observeChanges callbacks which are                      // 7
// invoked immediately before the docs field is updated; this object is made                          // 8
// available as `this` to those callbacks.                                                            // 9
LocalCollection._CachingChangeObserver = function (options) {                                         // 10
  var self = this;                                                                                    // 11
  options = options || {};                                                                            // 12
                                                                                                      // 13
  var orderedFromCallbacks = options.callbacks &&                                                     // 14
        LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks);                        // 15
  if (_.has(options, 'ordered')) {                                                                    // 16
    self.ordered = options.ordered;                                                                   // 17
    if (options.callbacks && options.ordered !== orderedFromCallbacks)                                // 18
      throw Error("ordered option doesn't match callbacks");                                          // 19
  } else if (options.callbacks) {                                                                     // 20
    self.ordered = orderedFromCallbacks;                                                              // 21
  } else {                                                                                            // 22
    throw Error("must provide ordered or callbacks");                                                 // 23
  }                                                                                                   // 24
  var callbacks = options.callbacks || {};                                                            // 25
                                                                                                      // 26
  if (self.ordered) {                                                                                 // 27
    self.docs = new OrderedDict(LocalCollection._idStringify);                                        // 28
    self.applyChange = {                                                                              // 29
      addedBefore: function (id, fields, before) {                                                    // 30
        var doc = EJSON.clone(fields);                                                                // 31
        doc._id = id;                                                                                 // 32
        callbacks.addedBefore && callbacks.addedBefore.call(                                          // 33
          self, id, fields, before);                                                                  // 34
        // This line triggers if we provide added with movedBefore.                                   // 35
        callbacks.added && callbacks.added.call(self, id, fields);                                    // 36
        // XXX could `before` be a falsy ID?  Technically                                             // 37
        // idStringify seems to allow for them -- though                                              // 38
        // OrderedDict won't call stringify on a falsy arg.                                           // 39
        self.docs.putBefore(id, doc, before || null);                                                 // 40
      },                                                                                              // 41
      movedBefore: function (id, before) {                                                            // 42
        var doc = self.docs.get(id);                                                                  // 43
        callbacks.movedBefore && callbacks.movedBefore.call(self, id, before);                        // 44
        self.docs.moveBefore(id, before || null);                                                     // 45
      }                                                                                               // 46
    };                                                                                                // 47
  } else {                                                                                            // 48
    self.docs = new LocalCollection._IdMap;                                                           // 49
    self.applyChange = {                                                                              // 50
      added: function (id, fields) {                                                                  // 51
        var doc = EJSON.clone(fields);                                                                // 52
        callbacks.added && callbacks.added.call(self, id, fields);                                    // 53
        doc._id = id;                                                                                 // 54
        self.docs.set(id,  doc);                                                                      // 55
      }                                                                                               // 56
    };                                                                                                // 57
  }                                                                                                   // 58
                                                                                                      // 59
  // The methods in _IdMap and OrderedDict used by these callbacks are                                // 60
  // identical.                                                                                       // 61
  self.applyChange.changed = function (id, fields) {                                                  // 62
    var doc = self.docs.get(id);                                                                      // 63
    if (!doc)                                                                                         // 64
      throw new Error("Unknown id for changed: " + id);                                               // 65
    callbacks.changed && callbacks.changed.call(                                                      // 66
      self, id, EJSON.clone(fields));                                                                 // 67
    LocalCollection._applyChanges(doc, fields);                                                       // 68
  };                                                                                                  // 69
  self.applyChange.removed = function (id) {                                                          // 70
    callbacks.removed && callbacks.removed.call(self, id);                                            // 71
    self.docs.remove(id);                                                                             // 72
  };                                                                                                  // 73
};                                                                                                    // 74
                                                                                                      // 75
LocalCollection._observeFromObserveChanges = function (cursor, observeCallbacks) {                    // 76
  var transform = cursor.getTransform() || function (doc) {return doc;};                              // 77
  var suppressed = !!observeCallbacks._suppress_initial;                                              // 78
                                                                                                      // 79
  var observeChangesCallbacks;                                                                        // 80
  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {                                // 81
    // The "_no_indices" option sets all index arguments to -1 and skips the                          // 82
    // linear scans required to generate them.  This lets observers that don't                        // 83
    // need absolute indices benefit from the other features of this API --                           // 84
    // relative order, transforms, and applyChanges -- without the speed hit.                         // 85
    var indices = !observeCallbacks._no_indices;                                                      // 86
    observeChangesCallbacks = {                                                                       // 87
      addedBefore: function (id, fields, before) {                                                    // 88
        var self = this;                                                                              // 89
        if (suppressed || !(observeCallbacks.addedAt || observeCallbacks.added))                      // 90
          return;                                                                                     // 91
        var doc = transform(_.extend(fields, {_id: id}));                                             // 92
        if (observeCallbacks.addedAt) {                                                               // 93
          var index = indices                                                                         // 94
                ? (before ? self.docs.indexOf(before) : self.docs.size()) : -1;                       // 95
          observeCallbacks.addedAt(doc, index, before);                                               // 96
        } else {                                                                                      // 97
          observeCallbacks.added(doc);                                                                // 98
        }                                                                                             // 99
      },                                                                                              // 100
      changed: function (id, fields) {                                                                // 101
        var self = this;                                                                              // 102
        if (!(observeCallbacks.changedAt || observeCallbacks.changed))                                // 103
          return;                                                                                     // 104
        var doc = EJSON.clone(self.docs.get(id));                                                     // 105
        if (!doc)                                                                                     // 106
          throw new Error("Unknown id for changed: " + id);                                           // 107
        var oldDoc = transform(EJSON.clone(doc));                                                     // 108
        LocalCollection._applyChanges(doc, fields);                                                   // 109
        doc = transform(doc);                                                                         // 110
        if (observeCallbacks.changedAt) {                                                             // 111
          var index = indices ? self.docs.indexOf(id) : -1;                                           // 112
          observeCallbacks.changedAt(doc, oldDoc, index);                                             // 113
        } else {                                                                                      // 114
          observeCallbacks.changed(doc, oldDoc);                                                      // 115
        }                                                                                             // 116
      },                                                                                              // 117
      movedBefore: function (id, before) {                                                            // 118
        var self = this;                                                                              // 119
        if (!observeCallbacks.movedTo)                                                                // 120
          return;                                                                                     // 121
        var from = indices ? self.docs.indexOf(id) : -1;                                              // 122
                                                                                                      // 123
        var to = indices                                                                              // 124
              ? (before ? self.docs.indexOf(before) : self.docs.size()) : -1;                         // 125
        // When not moving backwards, adjust for the fact that removing the                           // 126
        // document slides everything back one slot.                                                  // 127
        if (to > from)                                                                                // 128
          --to;                                                                                       // 129
        observeCallbacks.movedTo(transform(EJSON.clone(self.docs.get(id))),                           // 130
                                 from, to, before || null);                                           // 131
      },                                                                                              // 132
      removed: function (id) {                                                                        // 133
        var self = this;                                                                              // 134
        if (!(observeCallbacks.removedAt || observeCallbacks.removed))                                // 135
          return;                                                                                     // 136
        // technically maybe there should be an EJSON.clone here, but it's about                      // 137
        // to be removed from self.docs!                                                              // 138
        var doc = transform(self.docs.get(id));                                                       // 139
        if (observeCallbacks.removedAt) {                                                             // 140
          var index = indices ? self.docs.indexOf(id) : -1;                                           // 141
          observeCallbacks.removedAt(doc, index);                                                     // 142
        } else {                                                                                      // 143
          observeCallbacks.removed(doc);                                                              // 144
        }                                                                                             // 145
      }                                                                                               // 146
    };                                                                                                // 147
  } else {                                                                                            // 148
    observeChangesCallbacks = {                                                                       // 149
      added: function (id, fields) {                                                                  // 150
        if (!suppressed && observeCallbacks.added) {                                                  // 151
          var doc = _.extend(fields, {_id:  id});                                                     // 152
          observeCallbacks.added(transform(doc));                                                     // 153
        }                                                                                             // 154
      },                                                                                              // 155
      changed: function (id, fields) {                                                                // 156
        var self = this;                                                                              // 157
        if (observeCallbacks.changed) {                                                               // 158
          var oldDoc = self.docs.get(id);                                                             // 159
          var doc = EJSON.clone(oldDoc);                                                              // 160
          LocalCollection._applyChanges(doc, fields);                                                 // 161
          observeCallbacks.changed(transform(doc), transform(oldDoc));                                // 162
        }                                                                                             // 163
      },                                                                                              // 164
      removed: function (id) {                                                                        // 165
        var self = this;                                                                              // 166
        if (observeCallbacks.removed) {                                                               // 167
          observeCallbacks.removed(transform(self.docs.get(id)));                                     // 168
        }                                                                                             // 169
      }                                                                                               // 170
    };                                                                                                // 171
  }                                                                                                   // 172
                                                                                                      // 173
  var changeObserver = new LocalCollection._CachingChangeObserver(                                    // 174
    {callbacks: observeChangesCallbacks});                                                            // 175
  var handle = cursor.observeChanges(changeObserver.applyChange);                                     // 176
  suppressed = false;                                                                                 // 177
                                                                                                      // 178
  if (changeObserver.ordered) {                                                                       // 179
    // Fetches the current list of documents, in order, as an array.  Can be                          // 180
    // called at any time.  Internal API assumed by the `observe-sequence`                            // 181
    // package (used by Meteor UI for `#each` blocks).  Only defined on ordered                       // 182
    // observes (those that listen on `addedAt` or similar).  Continues to work                       // 183
    // after `stop()` is called on the handle.                                                        // 184
    //                                                                                                // 185
    // Because we already materialize the full OrderedDict of all documents, it                       // 186
    // seems nice to provide access to the view rather than making the data                           // 187
    // consumer reconstitute it.  This gives the consumer a shot at doing                             // 188
    // something smart with the feed like proxying it, since firing callbacks                         // 189
    // like `changed` and `movedTo` basically requires omniscience (knowing old                       // 190
    // and new documents, old and new indices, and the correct value for                              // 191
    // `before`).                                                                                     // 192
    //                                                                                                // 193
    // NOTE: If called from an observe callback for a certain change, the result                      // 194
    // is *not* guaranteed to be a snapshot of the cursor up to that                                  // 195
    // change. This is because the callbacks are invoked before updating docs.                        // 196
    handle._fetch = function () {                                                                     // 197
      var docsArray = [];                                                                             // 198
      changeObserver.docs.forEach(function (doc) {                                                    // 199
        docsArray.push(transform(EJSON.clone(doc)));                                                  // 200
      });                                                                                             // 201
      return docsArray;                                                                               // 202
    };                                                                                                // 203
  }                                                                                                   // 204
                                                                                                      // 205
  return handle;                                                                                      // 206
};                                                                                                    // 207
                                                                                                      // 208
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/objectid.js                                                                     //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
LocalCollection._looksLikeObjectID = function (str) {                                                 // 1
  return str.length === 24 && str.match(/^[0-9a-f]*$/);                                               // 2
};                                                                                                    // 3
                                                                                                      // 4
LocalCollection._ObjectID = function (hexString) {                                                    // 5
  //random-based impl of Mongo ObjectID                                                               // 6
  var self = this;                                                                                    // 7
  if (hexString) {                                                                                    // 8
    hexString = hexString.toLowerCase();                                                              // 9
    if (!LocalCollection._looksLikeObjectID(hexString)) {                                             // 10
      throw new Error("Invalid hexadecimal string for creating an ObjectID");                         // 11
    }                                                                                                 // 12
    // meant to work with _.isEqual(), which relies on structural equality                            // 13
    self._str = hexString;                                                                            // 14
  } else {                                                                                            // 15
    self._str = Random.hexString(24);                                                                 // 16
  }                                                                                                   // 17
};                                                                                                    // 18
                                                                                                      // 19
LocalCollection._ObjectID.prototype.toString = function () {                                          // 20
  var self = this;                                                                                    // 21
  return "ObjectID(\"" + self._str + "\")";                                                           // 22
};                                                                                                    // 23
                                                                                                      // 24
LocalCollection._ObjectID.prototype.equals = function (other) {                                       // 25
  var self = this;                                                                                    // 26
  return other instanceof LocalCollection._ObjectID &&                                                // 27
    self.valueOf() === other.valueOf();                                                               // 28
};                                                                                                    // 29
                                                                                                      // 30
LocalCollection._ObjectID.prototype.clone = function () {                                             // 31
  var self = this;                                                                                    // 32
  return new LocalCollection._ObjectID(self._str);                                                    // 33
};                                                                                                    // 34
                                                                                                      // 35
LocalCollection._ObjectID.prototype.typeName = function() {                                           // 36
  return "oid";                                                                                       // 37
};                                                                                                    // 38
                                                                                                      // 39
LocalCollection._ObjectID.prototype.getTimestamp = function() {                                       // 40
  var self = this;                                                                                    // 41
  return parseInt(self._str.substr(0, 8), 16);                                                        // 42
};                                                                                                    // 43
                                                                                                      // 44
LocalCollection._ObjectID.prototype.valueOf =                                                         // 45
    LocalCollection._ObjectID.prototype.toJSONValue =                                                 // 46
    LocalCollection._ObjectID.prototype.toHexString =                                                 // 47
    function () { return this._str; };                                                                // 48
                                                                                                      // 49
// Is this selector just shorthand for lookup by _id?                                                 // 50
LocalCollection._selectorIsId = function (selector) {                                                 // 51
  return (typeof selector === "string") ||                                                            // 52
    (typeof selector === "number") ||                                                                 // 53
    selector instanceof LocalCollection._ObjectID;                                                    // 54
};                                                                                                    // 55
                                                                                                      // 56
// Is the selector just lookup by _id (shorthand or not)?                                             // 57
LocalCollection._selectorIsIdPerhapsAsObject = function (selector) {                                  // 58
  return LocalCollection._selectorIsId(selector) ||                                                   // 59
    (selector && typeof selector === "object" &&                                                      // 60
     selector._id && LocalCollection._selectorIsId(selector._id) &&                                   // 61
     _.size(selector) === 1);                                                                         // 62
};                                                                                                    // 63
                                                                                                      // 64
// If this is a selector which explicitly constrains the match by ID to a finite                      // 65
// number of documents, returns a list of their IDs.  Otherwise returns                               // 66
// null. Note that the selector may have other restrictions so it may not even                        // 67
// match those document!  We care about $in and $and since those are generated                        // 68
// access-controlled update and remove.                                                               // 69
LocalCollection._idsMatchedBySelector = function (selector) {                                         // 70
  // Is the selector just an ID?                                                                      // 71
  if (LocalCollection._selectorIsId(selector))                                                        // 72
    return [selector];                                                                                // 73
  if (!selector)                                                                                      // 74
    return null;                                                                                      // 75
                                                                                                      // 76
  // Do we have an _id clause?                                                                        // 77
  if (_.has(selector, '_id')) {                                                                       // 78
    // Is the _id clause just an ID?                                                                  // 79
    if (LocalCollection._selectorIsId(selector._id))                                                  // 80
      return [selector._id];                                                                          // 81
    // Is the _id clause {_id: {$in: ["x", "y", "z"]}}?                                               // 82
    if (selector._id && selector._id.$in                                                              // 83
        && _.isArray(selector._id.$in)                                                                // 84
        && !_.isEmpty(selector._id.$in)                                                               // 85
        && _.all(selector._id.$in, LocalCollection._selectorIsId)) {                                  // 86
      return selector._id.$in;                                                                        // 87
    }                                                                                                 // 88
    return null;                                                                                      // 89
  }                                                                                                   // 90
                                                                                                      // 91
  // If this is a top-level $and, and any of the clauses constrain their                              // 92
  // documents, then the whole selector is constrained by any one clause's                            // 93
  // constraint. (Well, by their intersection, but that seems unlikely.)                              // 94
  if (selector.$and && _.isArray(selector.$and)) {                                                    // 95
    for (var i = 0; i < selector.$and.length; ++i) {                                                  // 96
      var subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);                           // 97
      if (subIds)                                                                                     // 98
        return subIds;                                                                                // 99
    }                                                                                                 // 100
  }                                                                                                   // 101
                                                                                                      // 102
  return null;                                                                                        // 103
};                                                                                                    // 104
                                                                                                      // 105
EJSON.addType("oid",  function (str) {                                                                // 106
  return new LocalCollection._ObjectID(str);                                                          // 107
});                                                                                                   // 108
                                                                                                      // 109
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.minimongo = {
  LocalCollection: LocalCollection,
  Minimongo: Minimongo,
  MinimongoTest: MinimongoTest
};

})();

//# sourceMappingURL=cc3ce9a489c69badc41095301076ba2a65f7ee32.map


//--------- standard-app-packages.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var Reload = Package.reload.Reload;



/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['standard-app-packages'] = {};

})();

//# sourceMappingURL=601dc02c741b437bbe8be03773a37f7d896a88e7.map


//--------- webapp.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;

/* Package-scope variables */
var WebApp;

(function () {

///////////////////////////////////////////////////////////////////////
//                                                                   //
// packages/webapp/webapp_client.js                                  //
//                                                                   //
///////////////////////////////////////////////////////////////////////
                                                                     //
WebApp = {                                                           // 1
                                                                     // 2
  _isCssLoaded: function () {                                        // 3
    return _.find(document.styleSheets, function (sheet) {           // 4
      if (sheet.cssText && !sheet.cssRules) // IE8                   // 5
        return sheet.cssText.match(/_meteor_detect_css/);            // 6
      return _.find(sheet.cssRules, function (rule) {                // 7
        return rule.selectorText === '._meteor_detect_css';          // 8
      });                                                            // 9
    });                                                              // 10
  }                                                                  // 11
};                                                                   // 12
                                                                     // 13
///////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.webapp = {
  WebApp: WebApp
};

})();

//# sourceMappingURL=87383e62e7a152277571ae1a71f7f8198ebd7a8a.map


//--------- reactive-dict.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var Deps = Package.deps.Deps;
var EJSON = Package.ejson.EJSON;

/* Package-scope variables */
var ReactiveDict;

(function () {

//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
// packages/reactive-dict/reactive-dict.js                                              //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////
                                                                                        //
// XXX come up with a serialization method which canonicalizes object key               // 1
// order, which would allow us to use objects as values for equals.                     // 2
var stringify = function (value) {                                                      // 3
  if (value === undefined)                                                              // 4
    return 'undefined';                                                                 // 5
  return EJSON.stringify(value);                                                        // 6
};                                                                                      // 7
var parse = function (serialized) {                                                     // 8
  if (serialized === undefined || serialized === 'undefined')                           // 9
    return undefined;                                                                   // 10
  return EJSON.parse(serialized);                                                       // 11
};                                                                                      // 12
                                                                                        // 13
// migrationData, if present, should be data previously returned from                   // 14
// getMigrationData()                                                                   // 15
ReactiveDict = function (migrationData) {                                               // 16
  this.keys = migrationData || {}; // key -> value                                      // 17
  this.keyDeps = {}; // key -> Dependency                                               // 18
  this.keyValueDeps = {}; // key -> Dependency                                          // 19
};                                                                                      // 20
                                                                                        // 21
_.extend(ReactiveDict.prototype, {                                                      // 22
  set: function (key, value) {                                                          // 23
    var self = this;                                                                    // 24
                                                                                        // 25
    value = stringify(value);                                                           // 26
                                                                                        // 27
    var oldSerializedValue = 'undefined';                                               // 28
    if (_.has(self.keys, key)) oldSerializedValue = self.keys[key];                     // 29
    if (value === oldSerializedValue)                                                   // 30
      return;                                                                           // 31
    self.keys[key] = value;                                                             // 32
                                                                                        // 33
    var changed = function (v) {                                                        // 34
      v && v.changed();                                                                 // 35
    };                                                                                  // 36
                                                                                        // 37
    changed(self.keyDeps[key]);                                                         // 38
    if (self.keyValueDeps[key]) {                                                       // 39
      changed(self.keyValueDeps[key][oldSerializedValue]);                              // 40
      changed(self.keyValueDeps[key][value]);                                           // 41
    }                                                                                   // 42
  },                                                                                    // 43
                                                                                        // 44
  setDefault: function (key, value) {                                                   // 45
    var self = this;                                                                    // 46
    // for now, explicitly check for undefined, since there is no                       // 47
    // ReactiveDict.clear().  Later we might have a ReactiveDict.clear(), in which case // 48
    // we should check if it has the key.                                               // 49
    if (self.keys[key] === undefined) {                                                 // 50
      self.set(key, value);                                                             // 51
    }                                                                                   // 52
  },                                                                                    // 53
                                                                                        // 54
  get: function (key) {                                                                 // 55
    var self = this;                                                                    // 56
    self._ensureKey(key);                                                               // 57
    self.keyDeps[key].depend();                                                         // 58
    return parse(self.keys[key]);                                                       // 59
  },                                                                                    // 60
                                                                                        // 61
  equals: function (key, value) {                                                       // 62
    var self = this;                                                                    // 63
                                                                                        // 64
    // XXX hardcoded awareness of the 'mongo-livedata' package is not ideal             // 65
    var ObjectID = Package['mongo-livedata'] && Meteor.Collection.ObjectID;             // 66
                                                                                        // 67
    // We don't allow objects (or arrays that might include objects) for                // 68
    // .equals, because JSON.stringify doesn't canonicalize object key                  // 69
    // order. (We can make equals have the right return value by parsing the            // 70
    // current value and using EJSON.equals, but we won't have a canonical              // 71
    // element of keyValueDeps[key] to store the dependency.) You can still use         // 72
    // "EJSON.equals(reactiveDict.get(key), value)".                                    // 73
    //                                                                                  // 74
    // XXX we could allow arrays as long as we recursively check that there             // 75
    // are no objects                                                                   // 76
    if (typeof value !== 'string' &&                                                    // 77
        typeof value !== 'number' &&                                                    // 78
        typeof value !== 'boolean' &&                                                   // 79
        typeof value !== 'undefined' &&                                                 // 80
        !(value instanceof Date) &&                                                     // 81
        !(ObjectID && value instanceof ObjectID) &&                                     // 82
        value !== null)                                                                 // 83
      throw new Error("ReactiveDict.equals: value must be scalar");                     // 84
    var serializedValue = stringify(value);                                             // 85
                                                                                        // 86
    if (Deps.active) {                                                                  // 87
      self._ensureKey(key);                                                             // 88
                                                                                        // 89
      if (! _.has(self.keyValueDeps[key], serializedValue))                             // 90
        self.keyValueDeps[key][serializedValue] = new Deps.Dependency;                  // 91
                                                                                        // 92
      var isNew = self.keyValueDeps[key][serializedValue].depend();                     // 93
      if (isNew) {                                                                      // 94
        Deps.onInvalidate(function () {                                                 // 95
          // clean up [key][serializedValue] if it's now empty, so we don't             // 96
          // use O(n) memory for n = values seen ever                                   // 97
          if (! self.keyValueDeps[key][serializedValue].hasDependents())                // 98
            delete self.keyValueDeps[key][serializedValue];                             // 99
        });                                                                             // 100
      }                                                                                 // 101
    }                                                                                   // 102
                                                                                        // 103
    var oldValue = undefined;                                                           // 104
    if (_.has(self.keys, key)) oldValue = parse(self.keys[key]);                        // 105
    return EJSON.equals(oldValue, value);                                               // 106
  },                                                                                    // 107
                                                                                        // 108
  _ensureKey: function (key) {                                                          // 109
    var self = this;                                                                    // 110
    if (!(key in self.keyDeps)) {                                                       // 111
      self.keyDeps[key] = new Deps.Dependency;                                          // 112
      self.keyValueDeps[key] = {};                                                      // 113
    }                                                                                   // 114
  },                                                                                    // 115
                                                                                        // 116
  // Get a JSON value that can be passed to the constructor to                          // 117
  // create a new ReactiveDict with the same contents as this one                       // 118
  getMigrationData: function () {                                                       // 119
    // XXX sanitize and make sure it's JSONible?                                        // 120
    return this.keys;                                                                   // 121
  }                                                                                     // 122
});                                                                                     // 123
                                                                                        // 124
//////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['reactive-dict'] = {
  ReactiveDict: ReactiveDict
};

})();

//# sourceMappingURL=22667928acc72f619ce81e7ac1e35def1ba9e0ae.map


//--------- session.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var ReactiveDict = Package['reactive-dict'].ReactiveDict;
var EJSON = Package.ejson.EJSON;

/* Package-scope variables */
var Session;

(function () {

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// packages/session/session.js                                         //
//                                                                     //
/////////////////////////////////////////////////////////////////////////
                                                                       //
var migratedKeys = {};                                                 // 1
if (Package.reload) {                                                  // 2
  var migrationData = Package.reload.Reload._migrationData('session'); // 3
  if (migrationData && migrationData.keys) {                           // 4
    migratedKeys = migrationData.keys;                                 // 5
  }                                                                    // 6
}                                                                      // 7
                                                                       // 8
Session = new ReactiveDict(migratedKeys);                              // 9
                                                                       // 10
if (Package.reload) {                                                  // 11
  Package.reload.Reload._onMigrate('session', function () {            // 12
    return [true, {keys: Session.keys}];                               // 13
  });                                                                  // 14
}                                                                      // 15
                                                                       // 16
/////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.session = {
  Session: Session
};

})();

//# sourceMappingURL=5bcd2d86431dc10d5f4be0910cb6567342e1aaf6.map


//--------- jquery.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;

/* Package-scope variables */
var $, jQuery;

(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/jquery/jquery.js                                                                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*!                                                                                                                    // 1
 * jQuery JavaScript Library v1.10.2                                                                                   // 2
 * http://jquery.com/                                                                                                  // 3
 *                                                                                                                     // 4
 * Includes Sizzle.js                                                                                                  // 5
 * http://sizzlejs.com/                                                                                                // 6
 *                                                                                                                     // 7
 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors                                                 // 8
 * Released under the MIT license                                                                                      // 9
 * http://jquery.org/license                                                                                           // 10
 *                                                                                                                     // 11
 * Date: 2013-07-03T13:48Z                                                                                             // 12
 */                                                                                                                    // 13
(function( window, undefined ) {                                                                                       // 14
                                                                                                                       // 15
// Can't do this because several apps including ASP.NET trace                                                          // 16
// the stack via arguments.caller.callee and Firefox dies if                                                           // 17
// you try to trace through "use strict" call chains. (#13335)                                                         // 18
// Support: Firefox 18+                                                                                                // 19
//"use strict";                                                                                                        // 20
var                                                                                                                    // 21
	// The deferred used on DOM ready                                                                                     // 22
	readyList,                                                                                                            // 23
                                                                                                                       // 24
	// A central reference to the root jQuery(document)                                                                   // 25
	rootjQuery,                                                                                                           // 26
                                                                                                                       // 27
	// Support: IE<10                                                                                                     // 28
	// For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`                                              // 29
	core_strundefined = typeof undefined,                                                                                 // 30
                                                                                                                       // 31
	// Use the correct document accordingly with window argument (sandbox)                                                // 32
	location = window.location,                                                                                           // 33
	document = window.document,                                                                                           // 34
	docElem = document.documentElement,                                                                                   // 35
                                                                                                                       // 36
	// Map over jQuery in case of overwrite                                                                               // 37
	_jQuery = window.jQuery,                                                                                              // 38
                                                                                                                       // 39
	// Map over the $ in case of overwrite                                                                                // 40
	_$ = window.$,                                                                                                        // 41
                                                                                                                       // 42
	// [[Class]] -> type pairs                                                                                            // 43
	class2type = {},                                                                                                      // 44
                                                                                                                       // 45
	// List of deleted data cache ids, so we can reuse them                                                               // 46
	core_deletedIds = [],                                                                                                 // 47
                                                                                                                       // 48
	core_version = "1.10.2",                                                                                              // 49
                                                                                                                       // 50
	// Save a reference to some core methods                                                                              // 51
	core_concat = core_deletedIds.concat,                                                                                 // 52
	core_push = core_deletedIds.push,                                                                                     // 53
	core_slice = core_deletedIds.slice,                                                                                   // 54
	core_indexOf = core_deletedIds.indexOf,                                                                               // 55
	core_toString = class2type.toString,                                                                                  // 56
	core_hasOwn = class2type.hasOwnProperty,                                                                              // 57
	core_trim = core_version.trim,                                                                                        // 58
                                                                                                                       // 59
	// Define a local copy of jQuery                                                                                      // 60
	jQuery = function( selector, context ) {                                                                              // 61
		// The jQuery object is actually just the init constructor 'enhanced'                                                // 62
		return new jQuery.fn.init( selector, context, rootjQuery );                                                          // 63
	},                                                                                                                    // 64
                                                                                                                       // 65
	// Used for matching numbers                                                                                          // 66
	core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,                                                             // 67
                                                                                                                       // 68
	// Used for splitting on whitespace                                                                                   // 69
	core_rnotwhite = /\S+/g,                                                                                              // 70
                                                                                                                       // 71
	// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)                                          // 72
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,                                                                         // 73
                                                                                                                       // 74
	// A simple way to check for HTML strings                                                                             // 75
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)                                                   // 76
	// Strict HTML recognition (#11290: must start with <)                                                                // 77
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,                                                                   // 78
                                                                                                                       // 79
	// Match a standalone tag                                                                                             // 80
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,                                                                            // 81
                                                                                                                       // 82
	// JSON RegExp                                                                                                        // 83
	rvalidchars = /^[\],:{}\s]*$/,                                                                                        // 84
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,                                                                                // 85
	rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,                                                                  // 86
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,                                     // 87
                                                                                                                       // 88
	// Matches dashed string for camelizing                                                                               // 89
	rmsPrefix = /^-ms-/,                                                                                                  // 90
	rdashAlpha = /-([\da-z])/gi,                                                                                          // 91
                                                                                                                       // 92
	// Used by jQuery.camelCase as callback to replace()                                                                  // 93
	fcamelCase = function( all, letter ) {                                                                                // 94
		return letter.toUpperCase();                                                                                         // 95
	},                                                                                                                    // 96
                                                                                                                       // 97
	// The ready event handler                                                                                            // 98
	completed = function( event ) {                                                                                       // 99
                                                                                                                       // 100
		// readyState === "complete" is good enough for us to call the dom ready in oldIE                                    // 101
		if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {                    // 102
			detach();                                                                                                           // 103
			jQuery.ready();                                                                                                     // 104
		}                                                                                                                    // 105
	},                                                                                                                    // 106
	// Clean-up method for dom ready events                                                                               // 107
	detach = function() {                                                                                                 // 108
		if ( document.addEventListener ) {                                                                                   // 109
			document.removeEventListener( "DOMContentLoaded", completed, false );                                               // 110
			window.removeEventListener( "load", completed, false );                                                             // 111
                                                                                                                       // 112
		} else {                                                                                                             // 113
			document.detachEvent( "onreadystatechange", completed );                                                            // 114
			window.detachEvent( "onload", completed );                                                                          // 115
		}                                                                                                                    // 116
	};                                                                                                                    // 117
                                                                                                                       // 118
jQuery.fn = jQuery.prototype = {                                                                                       // 119
	// The current version of jQuery being used                                                                           // 120
	jquery: core_version,                                                                                                 // 121
                                                                                                                       // 122
	constructor: jQuery,                                                                                                  // 123
	init: function( selector, context, rootjQuery ) {                                                                     // 124
		var match, elem;                                                                                                     // 125
                                                                                                                       // 126
		// HANDLE: $(""), $(null), $(undefined), $(false)                                                                    // 127
		if ( !selector ) {                                                                                                   // 128
			return this;                                                                                                        // 129
		}                                                                                                                    // 130
                                                                                                                       // 131
		// Handle HTML strings                                                                                               // 132
		if ( typeof selector === "string" ) {                                                                                // 133
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {       // 134
				// Assume that strings that start and end with <> are HTML and skip the regex check                                // 135
				match = [ null, selector, null ];                                                                                  // 136
                                                                                                                       // 137
			} else {                                                                                                            // 138
				match = rquickExpr.exec( selector );                                                                               // 139
			}                                                                                                                   // 140
                                                                                                                       // 141
			// Match html or make sure no context is specified for #id                                                          // 142
			if ( match && (match[1] || !context) ) {                                                                            // 143
                                                                                                                       // 144
				// HANDLE: $(html) -> $(array)                                                                                     // 145
				if ( match[1] ) {                                                                                                  // 146
					context = context instanceof jQuery ? context[0] : context;                                                       // 147
                                                                                                                       // 148
					// scripts is true for back-compat                                                                                // 149
					jQuery.merge( this, jQuery.parseHTML(                                                                             // 150
						match[1],                                                                                                        // 151
						context && context.nodeType ? context.ownerDocument || context : document,                                       // 152
						true                                                                                                             // 153
					) );                                                                                                              // 154
                                                                                                                       // 155
					// HANDLE: $(html, props)                                                                                         // 156
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {                                           // 157
						for ( match in context ) {                                                                                       // 158
							// Properties of context are called as methods if possible                                                      // 159
							if ( jQuery.isFunction( this[ match ] ) ) {                                                                     // 160
								this[ match ]( context[ match ] );                                                                             // 161
                                                                                                                       // 162
							// ...and otherwise set as attributes                                                                           // 163
							} else {                                                                                                        // 164
								this.attr( match, context[ match ] );                                                                          // 165
							}                                                                                                               // 166
						}                                                                                                                // 167
					}                                                                                                                 // 168
                                                                                                                       // 169
					return this;                                                                                                      // 170
                                                                                                                       // 171
				// HANDLE: $(#id)                                                                                                  // 172
				} else {                                                                                                           // 173
					elem = document.getElementById( match[2] );                                                                       // 174
                                                                                                                       // 175
					// Check parentNode to catch when Blackberry 4.6 returns                                                          // 176
					// nodes that are no longer in the document #6963                                                                 // 177
					if ( elem && elem.parentNode ) {                                                                                  // 178
						// Handle the case where IE and Opera return items                                                               // 179
						// by name instead of ID                                                                                         // 180
						if ( elem.id !== match[2] ) {                                                                                    // 181
							return rootjQuery.find( selector );                                                                             // 182
						}                                                                                                                // 183
                                                                                                                       // 184
						// Otherwise, we inject the element directly into the jQuery object                                              // 185
						this.length = 1;                                                                                                 // 186
						this[0] = elem;                                                                                                  // 187
					}                                                                                                                 // 188
                                                                                                                       // 189
					this.context = document;                                                                                          // 190
					this.selector = selector;                                                                                         // 191
					return this;                                                                                                      // 192
				}                                                                                                                  // 193
                                                                                                                       // 194
			// HANDLE: $(expr, $(...))                                                                                          // 195
			} else if ( !context || context.jquery ) {                                                                          // 196
				return ( context || rootjQuery ).find( selector );                                                                 // 197
                                                                                                                       // 198
			// HANDLE: $(expr, context)                                                                                         // 199
			// (which is just equivalent to: $(context).find(expr)                                                              // 200
			} else {                                                                                                            // 201
				return this.constructor( context ).find( selector );                                                               // 202
			}                                                                                                                   // 203
                                                                                                                       // 204
		// HANDLE: $(DOMElement)                                                                                             // 205
		} else if ( selector.nodeType ) {                                                                                    // 206
			this.context = this[0] = selector;                                                                                  // 207
			this.length = 1;                                                                                                    // 208
			return this;                                                                                                        // 209
                                                                                                                       // 210
		// HANDLE: $(function)                                                                                               // 211
		// Shortcut for document ready                                                                                       // 212
		} else if ( jQuery.isFunction( selector ) ) {                                                                        // 213
			return rootjQuery.ready( selector );                                                                                // 214
		}                                                                                                                    // 215
                                                                                                                       // 216
		if ( selector.selector !== undefined ) {                                                                             // 217
			this.selector = selector.selector;                                                                                  // 218
			this.context = selector.context;                                                                                    // 219
		}                                                                                                                    // 220
                                                                                                                       // 221
		return jQuery.makeArray( selector, this );                                                                           // 222
	},                                                                                                                    // 223
                                                                                                                       // 224
	// Start with an empty selector                                                                                       // 225
	selector: "",                                                                                                         // 226
                                                                                                                       // 227
	// The default length of a jQuery object is 0                                                                         // 228
	length: 0,                                                                                                            // 229
                                                                                                                       // 230
	toArray: function() {                                                                                                 // 231
		return core_slice.call( this );                                                                                      // 232
	},                                                                                                                    // 233
                                                                                                                       // 234
	// Get the Nth element in the matched element set OR                                                                  // 235
	// Get the whole matched element set as a clean array                                                                 // 236
	get: function( num ) {                                                                                                // 237
		return num == null ?                                                                                                 // 238
                                                                                                                       // 239
			// Return a 'clean' array                                                                                           // 240
			this.toArray() :                                                                                                    // 241
                                                                                                                       // 242
			// Return just the object                                                                                           // 243
			( num < 0 ? this[ this.length + num ] : this[ num ] );                                                              // 244
	},                                                                                                                    // 245
                                                                                                                       // 246
	// Take an array of elements and push it onto the stack                                                               // 247
	// (returning the new matched element set)                                                                            // 248
	pushStack: function( elems ) {                                                                                        // 249
                                                                                                                       // 250
		// Build a new jQuery matched element set                                                                            // 251
		var ret = jQuery.merge( this.constructor(), elems );                                                                 // 252
                                                                                                                       // 253
		// Add the old object onto the stack (as a reference)                                                                // 254
		ret.prevObject = this;                                                                                               // 255
		ret.context = this.context;                                                                                          // 256
                                                                                                                       // 257
		// Return the newly-formed element set                                                                               // 258
		return ret;                                                                                                          // 259
	},                                                                                                                    // 260
                                                                                                                       // 261
	// Execute a callback for every element in the matched set.                                                           // 262
	// (You can seed the arguments with an array of args, but this is                                                     // 263
	// only used internally.)                                                                                             // 264
	each: function( callback, args ) {                                                                                    // 265
		return jQuery.each( this, callback, args );                                                                          // 266
	},                                                                                                                    // 267
                                                                                                                       // 268
	ready: function( fn ) {                                                                                               // 269
		// Add the callback                                                                                                  // 270
		jQuery.ready.promise().done( fn );                                                                                   // 271
                                                                                                                       // 272
		return this;                                                                                                         // 273
	},                                                                                                                    // 274
                                                                                                                       // 275
	slice: function() {                                                                                                   // 276
		return this.pushStack( core_slice.apply( this, arguments ) );                                                        // 277
	},                                                                                                                    // 278
                                                                                                                       // 279
	first: function() {                                                                                                   // 280
		return this.eq( 0 );                                                                                                 // 281
	},                                                                                                                    // 282
                                                                                                                       // 283
	last: function() {                                                                                                    // 284
		return this.eq( -1 );                                                                                                // 285
	},                                                                                                                    // 286
                                                                                                                       // 287
	eq: function( i ) {                                                                                                   // 288
		var len = this.length,                                                                                               // 289
			j = +i + ( i < 0 ? len : 0 );                                                                                       // 290
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );                                                       // 291
	},                                                                                                                    // 292
                                                                                                                       // 293
	map: function( callback ) {                                                                                           // 294
		return this.pushStack( jQuery.map(this, function( elem, i ) {                                                        // 295
			return callback.call( elem, i, elem );                                                                              // 296
		}));                                                                                                                 // 297
	},                                                                                                                    // 298
                                                                                                                       // 299
	end: function() {                                                                                                     // 300
		return this.prevObject || this.constructor(null);                                                                    // 301
	},                                                                                                                    // 302
                                                                                                                       // 303
	// For internal use only.                                                                                             // 304
	// Behaves like an Array's method, not like a jQuery method.                                                          // 305
	push: core_push,                                                                                                      // 306
	sort: [].sort,                                                                                                        // 307
	splice: [].splice                                                                                                     // 308
};                                                                                                                     // 309
                                                                                                                       // 310
// Give the init function the jQuery prototype for later instantiation                                                 // 311
jQuery.fn.init.prototype = jQuery.fn;                                                                                  // 312
                                                                                                                       // 313
jQuery.extend = jQuery.fn.extend = function() {                                                                        // 314
	var src, copyIsArray, copy, name, options, clone,                                                                     // 315
		target = arguments[0] || {},                                                                                         // 316
		i = 1,                                                                                                               // 317
		length = arguments.length,                                                                                           // 318
		deep = false;                                                                                                        // 319
                                                                                                                       // 320
	// Handle a deep copy situation                                                                                       // 321
	if ( typeof target === "boolean" ) {                                                                                  // 322
		deep = target;                                                                                                       // 323
		target = arguments[1] || {};                                                                                         // 324
		// skip the boolean and the target                                                                                   // 325
		i = 2;                                                                                                               // 326
	}                                                                                                                     // 327
                                                                                                                       // 328
	// Handle case when target is a string or something (possible in deep copy)                                           // 329
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {                                                     // 330
		target = {};                                                                                                         // 331
	}                                                                                                                     // 332
                                                                                                                       // 333
	// extend jQuery itself if only one argument is passed                                                                // 334
	if ( length === i ) {                                                                                                 // 335
		target = this;                                                                                                       // 336
		--i;                                                                                                                 // 337
	}                                                                                                                     // 338
                                                                                                                       // 339
	for ( ; i < length; i++ ) {                                                                                           // 340
		// Only deal with non-null/undefined values                                                                          // 341
		if ( (options = arguments[ i ]) != null ) {                                                                          // 342
			// Extend the base object                                                                                           // 343
			for ( name in options ) {                                                                                           // 344
				src = target[ name ];                                                                                              // 345
				copy = options[ name ];                                                                                            // 346
                                                                                                                       // 347
				// Prevent never-ending loop                                                                                       // 348
				if ( target === copy ) {                                                                                           // 349
					continue;                                                                                                         // 350
				}                                                                                                                  // 351
                                                                                                                       // 352
				// Recurse if we're merging plain objects or arrays                                                                // 353
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {                    // 354
					if ( copyIsArray ) {                                                                                              // 355
						copyIsArray = false;                                                                                             // 356
						clone = src && jQuery.isArray(src) ? src : [];                                                                   // 357
                                                                                                                       // 358
					} else {                                                                                                          // 359
						clone = src && jQuery.isPlainObject(src) ? src : {};                                                             // 360
					}                                                                                                                 // 361
                                                                                                                       // 362
					// Never move original objects, clone them                                                                        // 363
					target[ name ] = jQuery.extend( deep, clone, copy );                                                              // 364
                                                                                                                       // 365
				// Don't bring in undefined values                                                                                 // 366
				} else if ( copy !== undefined ) {                                                                                 // 367
					target[ name ] = copy;                                                                                            // 368
				}                                                                                                                  // 369
			}                                                                                                                   // 370
		}                                                                                                                    // 371
	}                                                                                                                     // 372
                                                                                                                       // 373
	// Return the modified object                                                                                         // 374
	return target;                                                                                                        // 375
};                                                                                                                     // 376
                                                                                                                       // 377
jQuery.extend({                                                                                                        // 378
	// Unique for each copy of jQuery on the page                                                                         // 379
	// Non-digits removed to match rinlinejQuery                                                                          // 380
	expando: "jQuery" + ( core_version + Math.random() ).replace( /\D/g, "" ),                                            // 381
                                                                                                                       // 382
	noConflict: function( deep ) {                                                                                        // 383
		if ( window.$ === jQuery ) {                                                                                         // 384
			window.$ = _$;                                                                                                      // 385
		}                                                                                                                    // 386
                                                                                                                       // 387
		if ( deep && window.jQuery === jQuery ) {                                                                            // 388
			window.jQuery = _jQuery;                                                                                            // 389
		}                                                                                                                    // 390
                                                                                                                       // 391
		return jQuery;                                                                                                       // 392
	},                                                                                                                    // 393
                                                                                                                       // 394
	// Is the DOM ready to be used? Set to true once it occurs.                                                           // 395
	isReady: false,                                                                                                       // 396
                                                                                                                       // 397
	// A counter to track how many items to wait for before                                                               // 398
	// the ready event fires. See #6781                                                                                   // 399
	readyWait: 1,                                                                                                         // 400
                                                                                                                       // 401
	// Hold (or release) the ready event                                                                                  // 402
	holdReady: function( hold ) {                                                                                         // 403
		if ( hold ) {                                                                                                        // 404
			jQuery.readyWait++;                                                                                                 // 405
		} else {                                                                                                             // 406
			jQuery.ready( true );                                                                                               // 407
		}                                                                                                                    // 408
	},                                                                                                                    // 409
                                                                                                                       // 410
	// Handle when the DOM is ready                                                                                       // 411
	ready: function( wait ) {                                                                                             // 412
                                                                                                                       // 413
		// Abort if there are pending holds or we're already ready                                                           // 414
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {                                                         // 415
			return;                                                                                                             // 416
		}                                                                                                                    // 417
                                                                                                                       // 418
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).                             // 419
		if ( !document.body ) {                                                                                              // 420
			return setTimeout( jQuery.ready );                                                                                  // 421
		}                                                                                                                    // 422
                                                                                                                       // 423
		// Remember that the DOM is ready                                                                                    // 424
		jQuery.isReady = true;                                                                                               // 425
                                                                                                                       // 426
		// If a normal DOM Ready event fired, decrement, and wait if need be                                                 // 427
		if ( wait !== true && --jQuery.readyWait > 0 ) {                                                                     // 428
			return;                                                                                                             // 429
		}                                                                                                                    // 430
                                                                                                                       // 431
		// If there are functions bound, to execute                                                                          // 432
		readyList.resolveWith( document, [ jQuery ] );                                                                       // 433
                                                                                                                       // 434
		// Trigger any bound ready events                                                                                    // 435
		if ( jQuery.fn.trigger ) {                                                                                           // 436
			jQuery( document ).trigger("ready").off("ready");                                                                   // 437
		}                                                                                                                    // 438
	},                                                                                                                    // 439
                                                                                                                       // 440
	// See test/unit/core.js for details concerning isFunction.                                                           // 441
	// Since version 1.3, DOM methods and functions like alert                                                            // 442
	// aren't supported. They return false on IE (#2968).                                                                 // 443
	isFunction: function( obj ) {                                                                                         // 444
		return jQuery.type(obj) === "function";                                                                              // 445
	},                                                                                                                    // 446
                                                                                                                       // 447
	isArray: Array.isArray || function( obj ) {                                                                           // 448
		return jQuery.type(obj) === "array";                                                                                 // 449
	},                                                                                                                    // 450
                                                                                                                       // 451
	isWindow: function( obj ) {                                                                                           // 452
		/* jshint eqeqeq: false */                                                                                           // 453
		return obj != null && obj == obj.window;                                                                             // 454
	},                                                                                                                    // 455
                                                                                                                       // 456
	isNumeric: function( obj ) {                                                                                          // 457
		return !isNaN( parseFloat(obj) ) && isFinite( obj );                                                                 // 458
	},                                                                                                                    // 459
                                                                                                                       // 460
	type: function( obj ) {                                                                                               // 461
		if ( obj == null ) {                                                                                                 // 462
			return String( obj );                                                                                               // 463
		}                                                                                                                    // 464
		return typeof obj === "object" || typeof obj === "function" ?                                                        // 465
			class2type[ core_toString.call(obj) ] || "object" :                                                                 // 466
			typeof obj;                                                                                                         // 467
	},                                                                                                                    // 468
                                                                                                                       // 469
	isPlainObject: function( obj ) {                                                                                      // 470
		var key;                                                                                                             // 471
                                                                                                                       // 472
		// Must be an Object.                                                                                                // 473
		// Because of IE, we also have to check the presence of the constructor property.                                    // 474
		// Make sure that DOM nodes and window objects don't pass through, as well                                           // 475
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {                             // 476
			return false;                                                                                                       // 477
		}                                                                                                                    // 478
                                                                                                                       // 479
		try {                                                                                                                // 480
			// Not own constructor property must be Object                                                                      // 481
			if ( obj.constructor &&                                                                                             // 482
				!core_hasOwn.call(obj, "constructor") &&                                                                           // 483
				!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {                                                  // 484
				return false;                                                                                                      // 485
			}                                                                                                                   // 486
		} catch ( e ) {                                                                                                      // 487
			// IE8,9 Will throw exceptions on certain host objects #9897                                                        // 488
			return false;                                                                                                       // 489
		}                                                                                                                    // 490
                                                                                                                       // 491
		// Support: IE<9                                                                                                     // 492
		// Handle iteration over inherited properties before own properties.                                                 // 493
		if ( jQuery.support.ownLast ) {                                                                                      // 494
			for ( key in obj ) {                                                                                                // 495
				return core_hasOwn.call( obj, key );                                                                               // 496
			}                                                                                                                   // 497
		}                                                                                                                    // 498
                                                                                                                       // 499
		// Own properties are enumerated firstly, so to speed up,                                                            // 500
		// if last one is own, then all properties are own.                                                                  // 501
		for ( key in obj ) {}                                                                                                // 502
                                                                                                                       // 503
		return key === undefined || core_hasOwn.call( obj, key );                                                            // 504
	},                                                                                                                    // 505
                                                                                                                       // 506
	isEmptyObject: function( obj ) {                                                                                      // 507
		var name;                                                                                                            // 508
		for ( name in obj ) {                                                                                                // 509
			return false;                                                                                                       // 510
		}                                                                                                                    // 511
		return true;                                                                                                         // 512
	},                                                                                                                    // 513
                                                                                                                       // 514
	error: function( msg ) {                                                                                              // 515
		throw new Error( msg );                                                                                              // 516
	},                                                                                                                    // 517
                                                                                                                       // 518
	// data: string of html                                                                                               // 519
	// context (optional): If specified, the fragment will be created in this context, defaults to document               // 520
	// keepScripts (optional): If true, will include scripts passed in the html string                                    // 521
	parseHTML: function( data, context, keepScripts ) {                                                                   // 522
		if ( !data || typeof data !== "string" ) {                                                                           // 523
			return null;                                                                                                        // 524
		}                                                                                                                    // 525
		if ( typeof context === "boolean" ) {                                                                                // 526
			keepScripts = context;                                                                                              // 527
			context = false;                                                                                                    // 528
		}                                                                                                                    // 529
		context = context || document;                                                                                       // 530
                                                                                                                       // 531
		var parsed = rsingleTag.exec( data ),                                                                                // 532
			scripts = !keepScripts && [];                                                                                       // 533
                                                                                                                       // 534
		// Single tag                                                                                                        // 535
		if ( parsed ) {                                                                                                      // 536
			return [ context.createElement( parsed[1] ) ];                                                                      // 537
		}                                                                                                                    // 538
                                                                                                                       // 539
		parsed = jQuery.buildFragment( [ data ], context, scripts );                                                         // 540
		if ( scripts ) {                                                                                                     // 541
			jQuery( scripts ).remove();                                                                                         // 542
		}                                                                                                                    // 543
		return jQuery.merge( [], parsed.childNodes );                                                                        // 544
	},                                                                                                                    // 545
                                                                                                                       // 546
	parseJSON: function( data ) {                                                                                         // 547
		// Attempt to parse using the native JSON parser first                                                               // 548
		if ( window.JSON && window.JSON.parse ) {                                                                            // 549
			return window.JSON.parse( data );                                                                                   // 550
		}                                                                                                                    // 551
                                                                                                                       // 552
		if ( data === null ) {                                                                                               // 553
			return data;                                                                                                        // 554
		}                                                                                                                    // 555
                                                                                                                       // 556
		if ( typeof data === "string" ) {                                                                                    // 557
                                                                                                                       // 558
			// Make sure leading/trailing whitespace is removed (IE can't handle it)                                            // 559
			data = jQuery.trim( data );                                                                                         // 560
                                                                                                                       // 561
			if ( data ) {                                                                                                       // 562
				// Make sure the incoming data is actual JSON                                                                      // 563
				// Logic borrowed from http://json.org/json2.js                                                                    // 564
				if ( rvalidchars.test( data.replace( rvalidescape, "@" )                                                           // 565
					.replace( rvalidtokens, "]" )                                                                                     // 566
					.replace( rvalidbraces, "")) ) {                                                                                  // 567
                                                                                                                       // 568
					return ( new Function( "return " + data ) )();                                                                    // 569
				}                                                                                                                  // 570
			}                                                                                                                   // 571
		}                                                                                                                    // 572
                                                                                                                       // 573
		jQuery.error( "Invalid JSON: " + data );                                                                             // 574
	},                                                                                                                    // 575
                                                                                                                       // 576
	// Cross-browser xml parsing                                                                                          // 577
	parseXML: function( data ) {                                                                                          // 578
		var xml, tmp;                                                                                                        // 579
		if ( !data || typeof data !== "string" ) {                                                                           // 580
			return null;                                                                                                        // 581
		}                                                                                                                    // 582
		try {                                                                                                                // 583
			if ( window.DOMParser ) { // Standard                                                                               // 584
				tmp = new DOMParser();                                                                                             // 585
				xml = tmp.parseFromString( data , "text/xml" );                                                                    // 586
			} else { // IE                                                                                                      // 587
				xml = new ActiveXObject( "Microsoft.XMLDOM" );                                                                     // 588
				xml.async = "false";                                                                                               // 589
				xml.loadXML( data );                                                                                               // 590
			}                                                                                                                   // 591
		} catch( e ) {                                                                                                       // 592
			xml = undefined;                                                                                                    // 593
		}                                                                                                                    // 594
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {                            // 595
			jQuery.error( "Invalid XML: " + data );                                                                             // 596
		}                                                                                                                    // 597
		return xml;                                                                                                          // 598
	},                                                                                                                    // 599
                                                                                                                       // 600
	noop: function() {},                                                                                                  // 601
                                                                                                                       // 602
	// Evaluates a script in a global context                                                                             // 603
	// Workarounds based on findings by Jim Driscoll                                                                      // 604
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context                            // 605
	globalEval: function( data ) {                                                                                        // 606
		if ( data && jQuery.trim( data ) ) {                                                                                 // 607
			// We use execScript on Internet Explorer                                                                           // 608
			// We use an anonymous function so that context is window                                                           // 609
			// rather than jQuery in Firefox                                                                                    // 610
			( window.execScript || function( data ) {                                                                           // 611
				window[ "eval" ].call( window, data );                                                                             // 612
			} )( data );                                                                                                        // 613
		}                                                                                                                    // 614
	},                                                                                                                    // 615
                                                                                                                       // 616
	// Convert dashed to camelCase; used by the css and data modules                                                      // 617
	// Microsoft forgot to hump their vendor prefix (#9572)                                                               // 618
	camelCase: function( string ) {                                                                                       // 619
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );                                         // 620
	},                                                                                                                    // 621
                                                                                                                       // 622
	nodeName: function( elem, name ) {                                                                                    // 623
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();                                          // 624
	},                                                                                                                    // 625
                                                                                                                       // 626
	// args is for internal usage only                                                                                    // 627
	each: function( obj, callback, args ) {                                                                               // 628
		var value,                                                                                                           // 629
			i = 0,                                                                                                              // 630
			length = obj.length,                                                                                                // 631
			isArray = isArraylike( obj );                                                                                       // 632
                                                                                                                       // 633
		if ( args ) {                                                                                                        // 634
			if ( isArray ) {                                                                                                    // 635
				for ( ; i < length; i++ ) {                                                                                        // 636
					value = callback.apply( obj[ i ], args );                                                                         // 637
                                                                                                                       // 638
					if ( value === false ) {                                                                                          // 639
						break;                                                                                                           // 640
					}                                                                                                                 // 641
				}                                                                                                                  // 642
			} else {                                                                                                            // 643
				for ( i in obj ) {                                                                                                 // 644
					value = callback.apply( obj[ i ], args );                                                                         // 645
                                                                                                                       // 646
					if ( value === false ) {                                                                                          // 647
						break;                                                                                                           // 648
					}                                                                                                                 // 649
				}                                                                                                                  // 650
			}                                                                                                                   // 651
                                                                                                                       // 652
		// A special, fast, case for the most common use of each                                                             // 653
		} else {                                                                                                             // 654
			if ( isArray ) {                                                                                                    // 655
				for ( ; i < length; i++ ) {                                                                                        // 656
					value = callback.call( obj[ i ], i, obj[ i ] );                                                                   // 657
                                                                                                                       // 658
					if ( value === false ) {                                                                                          // 659
						break;                                                                                                           // 660
					}                                                                                                                 // 661
				}                                                                                                                  // 662
			} else {                                                                                                            // 663
				for ( i in obj ) {                                                                                                 // 664
					value = callback.call( obj[ i ], i, obj[ i ] );                                                                   // 665
                                                                                                                       // 666
					if ( value === false ) {                                                                                          // 667
						break;                                                                                                           // 668
					}                                                                                                                 // 669
				}                                                                                                                  // 670
			}                                                                                                                   // 671
		}                                                                                                                    // 672
                                                                                                                       // 673
		return obj;                                                                                                          // 674
	},                                                                                                                    // 675
                                                                                                                       // 676
	// Use native String.trim function wherever possible                                                                  // 677
	trim: core_trim && !core_trim.call("\uFEFF\xA0") ?                                                                    // 678
		function( text ) {                                                                                                   // 679
			return text == null ?                                                                                               // 680
				"" :                                                                                                               // 681
				core_trim.call( text );                                                                                            // 682
		} :                                                                                                                  // 683
                                                                                                                       // 684
		// Otherwise use our own trimming functionality                                                                      // 685
		function( text ) {                                                                                                   // 686
			return text == null ?                                                                                               // 687
				"" :                                                                                                               // 688
				( text + "" ).replace( rtrim, "" );                                                                                // 689
		},                                                                                                                   // 690
                                                                                                                       // 691
	// results is for internal usage only                                                                                 // 692
	makeArray: function( arr, results ) {                                                                                 // 693
		var ret = results || [];                                                                                             // 694
                                                                                                                       // 695
		if ( arr != null ) {                                                                                                 // 696
			if ( isArraylike( Object(arr) ) ) {                                                                                 // 697
				jQuery.merge( ret,                                                                                                 // 698
					typeof arr === "string" ?                                                                                         // 699
					[ arr ] : arr                                                                                                     // 700
				);                                                                                                                 // 701
			} else {                                                                                                            // 702
				core_push.call( ret, arr );                                                                                        // 703
			}                                                                                                                   // 704
		}                                                                                                                    // 705
                                                                                                                       // 706
		return ret;                                                                                                          // 707
	},                                                                                                                    // 708
                                                                                                                       // 709
	inArray: function( elem, arr, i ) {                                                                                   // 710
		var len;                                                                                                             // 711
                                                                                                                       // 712
		if ( arr ) {                                                                                                         // 713
			if ( core_indexOf ) {                                                                                               // 714
				return core_indexOf.call( arr, elem, i );                                                                          // 715
			}                                                                                                                   // 716
                                                                                                                       // 717
			len = arr.length;                                                                                                   // 718
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;                                                                     // 719
                                                                                                                       // 720
			for ( ; i < len; i++ ) {                                                                                            // 721
				// Skip accessing in sparse arrays                                                                                 // 722
				if ( i in arr && arr[ i ] === elem ) {                                                                             // 723
					return i;                                                                                                         // 724
				}                                                                                                                  // 725
			}                                                                                                                   // 726
		}                                                                                                                    // 727
                                                                                                                       // 728
		return -1;                                                                                                           // 729
	},                                                                                                                    // 730
                                                                                                                       // 731
	merge: function( first, second ) {                                                                                    // 732
		var l = second.length,                                                                                               // 733
			i = first.length,                                                                                                   // 734
			j = 0;                                                                                                              // 735
                                                                                                                       // 736
		if ( typeof l === "number" ) {                                                                                       // 737
			for ( ; j < l; j++ ) {                                                                                              // 738
				first[ i++ ] = second[ j ];                                                                                        // 739
			}                                                                                                                   // 740
		} else {                                                                                                             // 741
			while ( second[j] !== undefined ) {                                                                                 // 742
				first[ i++ ] = second[ j++ ];                                                                                      // 743
			}                                                                                                                   // 744
		}                                                                                                                    // 745
                                                                                                                       // 746
		first.length = i;                                                                                                    // 747
                                                                                                                       // 748
		return first;                                                                                                        // 749
	},                                                                                                                    // 750
                                                                                                                       // 751
	grep: function( elems, callback, inv ) {                                                                              // 752
		var retVal,                                                                                                          // 753
			ret = [],                                                                                                           // 754
			i = 0,                                                                                                              // 755
			length = elems.length;                                                                                              // 756
		inv = !!inv;                                                                                                         // 757
                                                                                                                       // 758
		// Go through the array, only saving the items                                                                       // 759
		// that pass the validator function                                                                                  // 760
		for ( ; i < length; i++ ) {                                                                                          // 761
			retVal = !!callback( elems[ i ], i );                                                                               // 762
			if ( inv !== retVal ) {                                                                                             // 763
				ret.push( elems[ i ] );                                                                                            // 764
			}                                                                                                                   // 765
		}                                                                                                                    // 766
                                                                                                                       // 767
		return ret;                                                                                                          // 768
	},                                                                                                                    // 769
                                                                                                                       // 770
	// arg is for internal usage only                                                                                     // 771
	map: function( elems, callback, arg ) {                                                                               // 772
		var value,                                                                                                           // 773
			i = 0,                                                                                                              // 774
			length = elems.length,                                                                                              // 775
			isArray = isArraylike( elems ),                                                                                     // 776
			ret = [];                                                                                                           // 777
                                                                                                                       // 778
		// Go through the array, translating each of the items to their                                                      // 779
		if ( isArray ) {                                                                                                     // 780
			for ( ; i < length; i++ ) {                                                                                         // 781
				value = callback( elems[ i ], i, arg );                                                                            // 782
                                                                                                                       // 783
				if ( value != null ) {                                                                                             // 784
					ret[ ret.length ] = value;                                                                                        // 785
				}                                                                                                                  // 786
			}                                                                                                                   // 787
                                                                                                                       // 788
		// Go through every key on the object,                                                                               // 789
		} else {                                                                                                             // 790
			for ( i in elems ) {                                                                                                // 791
				value = callback( elems[ i ], i, arg );                                                                            // 792
                                                                                                                       // 793
				if ( value != null ) {                                                                                             // 794
					ret[ ret.length ] = value;                                                                                        // 795
				}                                                                                                                  // 796
			}                                                                                                                   // 797
		}                                                                                                                    // 798
                                                                                                                       // 799
		// Flatten any nested arrays                                                                                         // 800
		return core_concat.apply( [], ret );                                                                                 // 801
	},                                                                                                                    // 802
                                                                                                                       // 803
	// A global GUID counter for objects                                                                                  // 804
	guid: 1,                                                                                                              // 805
                                                                                                                       // 806
	// Bind a function to a context, optionally partially applying any                                                    // 807
	// arguments.                                                                                                         // 808
	proxy: function( fn, context ) {                                                                                      // 809
		var args, proxy, tmp;                                                                                                // 810
                                                                                                                       // 811
		if ( typeof context === "string" ) {                                                                                 // 812
			tmp = fn[ context ];                                                                                                // 813
			context = fn;                                                                                                       // 814
			fn = tmp;                                                                                                           // 815
		}                                                                                                                    // 816
                                                                                                                       // 817
		// Quick check to determine if target is callable, in the spec                                                       // 818
		// this throws a TypeError, but we will just return undefined.                                                       // 819
		if ( !jQuery.isFunction( fn ) ) {                                                                                    // 820
			return undefined;                                                                                                   // 821
		}                                                                                                                    // 822
                                                                                                                       // 823
		// Simulated bind                                                                                                    // 824
		args = core_slice.call( arguments, 2 );                                                                              // 825
		proxy = function() {                                                                                                 // 826
			return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );                                    // 827
		};                                                                                                                   // 828
                                                                                                                       // 829
		// Set the guid of unique handler to the same of original handler, so it can be removed                              // 830
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;                                                                     // 831
                                                                                                                       // 832
		return proxy;                                                                                                        // 833
	},                                                                                                                    // 834
                                                                                                                       // 835
	// Multifunctional method to get and set values of a collection                                                       // 836
	// The value/s can optionally be executed if it's a function                                                          // 837
	access: function( elems, fn, key, value, chainable, emptyGet, raw ) {                                                 // 838
		var i = 0,                                                                                                           // 839
			length = elems.length,                                                                                              // 840
			bulk = key == null;                                                                                                 // 841
                                                                                                                       // 842
		// Sets many values                                                                                                  // 843
		if ( jQuery.type( key ) === "object" ) {                                                                             // 844
			chainable = true;                                                                                                   // 845
			for ( i in key ) {                                                                                                  // 846
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );                                                        // 847
			}                                                                                                                   // 848
                                                                                                                       // 849
		// Sets one value                                                                                                    // 850
		} else if ( value !== undefined ) {                                                                                  // 851
			chainable = true;                                                                                                   // 852
                                                                                                                       // 853
			if ( !jQuery.isFunction( value ) ) {                                                                                // 854
				raw = true;                                                                                                        // 855
			}                                                                                                                   // 856
                                                                                                                       // 857
			if ( bulk ) {                                                                                                       // 858
				// Bulk operations run against the entire set                                                                      // 859
				if ( raw ) {                                                                                                       // 860
					fn.call( elems, value );                                                                                          // 861
					fn = null;                                                                                                        // 862
                                                                                                                       // 863
				// ...except when executing function values                                                                        // 864
				} else {                                                                                                           // 865
					bulk = fn;                                                                                                        // 866
					fn = function( elem, key, value ) {                                                                               // 867
						return bulk.call( jQuery( elem ), value );                                                                       // 868
					};                                                                                                                // 869
				}                                                                                                                  // 870
			}                                                                                                                   // 871
                                                                                                                       // 872
			if ( fn ) {                                                                                                         // 873
				for ( ; i < length; i++ ) {                                                                                        // 874
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );                                // 875
				}                                                                                                                  // 876
			}                                                                                                                   // 877
		}                                                                                                                    // 878
                                                                                                                       // 879
		return chainable ?                                                                                                   // 880
			elems :                                                                                                             // 881
                                                                                                                       // 882
			// Gets                                                                                                             // 883
			bulk ?                                                                                                              // 884
				fn.call( elems ) :                                                                                                 // 885
				length ? fn( elems[0], key ) : emptyGet;                                                                           // 886
	},                                                                                                                    // 887
                                                                                                                       // 888
	now: function() {                                                                                                     // 889
		return ( new Date() ).getTime();                                                                                     // 890
	},                                                                                                                    // 891
                                                                                                                       // 892
	// A method for quickly swapping in/out CSS properties to get correct calculations.                                   // 893
	// Note: this method belongs to the css module but it's needed here for the support module.                           // 894
	// If support gets modularized, this method should be moved back to the css module.                                   // 895
	swap: function( elem, options, callback, args ) {                                                                     // 896
		var ret, name,                                                                                                       // 897
			old = {};                                                                                                           // 898
                                                                                                                       // 899
		// Remember the old values, and insert the new ones                                                                  // 900
		for ( name in options ) {                                                                                            // 901
			old[ name ] = elem.style[ name ];                                                                                   // 902
			elem.style[ name ] = options[ name ];                                                                               // 903
		}                                                                                                                    // 904
                                                                                                                       // 905
		ret = callback.apply( elem, args || [] );                                                                            // 906
                                                                                                                       // 907
		// Revert the old values                                                                                             // 908
		for ( name in options ) {                                                                                            // 909
			elem.style[ name ] = old[ name ];                                                                                   // 910
		}                                                                                                                    // 911
                                                                                                                       // 912
		return ret;                                                                                                          // 913
	}                                                                                                                     // 914
});                                                                                                                    // 915
                                                                                                                       // 916
jQuery.ready.promise = function( obj ) {                                                                               // 917
	if ( !readyList ) {                                                                                                   // 918
                                                                                                                       // 919
		readyList = jQuery.Deferred();                                                                                       // 920
                                                                                                                       // 921
		// Catch cases where $(document).ready() is called after the browser event has already occurred.                     // 922
		// we once tried to use readyState "interactive" here, but it caused issues like the one                             // 923
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15                                         // 924
		if ( document.readyState === "complete" ) {                                                                          // 925
			// Handle it asynchronously to allow scripts the opportunity to delay ready                                         // 926
			setTimeout( jQuery.ready );                                                                                         // 927
                                                                                                                       // 928
		// Standards-based browsers support DOMContentLoaded                                                                 // 929
		} else if ( document.addEventListener ) {                                                                            // 930
			// Use the handy event callback                                                                                     // 931
			document.addEventListener( "DOMContentLoaded", completed, false );                                                  // 932
                                                                                                                       // 933
			// A fallback to window.onload, that will always work                                                               // 934
			window.addEventListener( "load", completed, false );                                                                // 935
                                                                                                                       // 936
		// If IE event model is used                                                                                         // 937
		} else {                                                                                                             // 938
			// Ensure firing before onload, maybe late but safe also for iframes                                                // 939
			document.attachEvent( "onreadystatechange", completed );                                                            // 940
                                                                                                                       // 941
			// A fallback to window.onload, that will always work                                                               // 942
			window.attachEvent( "onload", completed );                                                                          // 943
                                                                                                                       // 944
			// If IE and not a frame                                                                                            // 945
			// continually check to see if the document is ready                                                                // 946
			var top = false;                                                                                                    // 947
                                                                                                                       // 948
			try {                                                                                                               // 949
				top = window.frameElement == null && document.documentElement;                                                     // 950
			} catch(e) {}                                                                                                       // 951
                                                                                                                       // 952
			if ( top && top.doScroll ) {                                                                                        // 953
				(function doScrollCheck() {                                                                                        // 954
					if ( !jQuery.isReady ) {                                                                                          // 955
                                                                                                                       // 956
						try {                                                                                                            // 957
							// Use the trick by Diego Perini                                                                                // 958
							// http://javascript.nwbox.com/IEContentLoaded/                                                                 // 959
							top.doScroll("left");                                                                                           // 960
						} catch(e) {                                                                                                     // 961
							return setTimeout( doScrollCheck, 50 );                                                                         // 962
						}                                                                                                                // 963
                                                                                                                       // 964
						// detach all dom ready events                                                                                   // 965
						detach();                                                                                                        // 966
                                                                                                                       // 967
						// and execute any waiting functions                                                                             // 968
						jQuery.ready();                                                                                                  // 969
					}                                                                                                                 // 970
				})();                                                                                                              // 971
			}                                                                                                                   // 972
		}                                                                                                                    // 973
	}                                                                                                                     // 974
	return readyList.promise( obj );                                                                                      // 975
};                                                                                                                     // 976
                                                                                                                       // 977
// Populate the class2type map                                                                                         // 978
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {            // 979
	class2type[ "[object " + name + "]" ] = name.toLowerCase();                                                           // 980
});                                                                                                                    // 981
                                                                                                                       // 982
function isArraylike( obj ) {                                                                                          // 983
	var length = obj.length,                                                                                              // 984
		type = jQuery.type( obj );                                                                                           // 985
                                                                                                                       // 986
	if ( jQuery.isWindow( obj ) ) {                                                                                       // 987
		return false;                                                                                                        // 988
	}                                                                                                                     // 989
                                                                                                                       // 990
	if ( obj.nodeType === 1 && length ) {                                                                                 // 991
		return true;                                                                                                         // 992
	}                                                                                                                     // 993
                                                                                                                       // 994
	return type === "array" || type !== "function" &&                                                                     // 995
		( length === 0 ||                                                                                                    // 996
		typeof length === "number" && length > 0 && ( length - 1 ) in obj );                                                 // 997
}                                                                                                                      // 998
                                                                                                                       // 999
// All jQuery objects should point back to these                                                                       // 1000
rootjQuery = jQuery(document);                                                                                         // 1001
/*!                                                                                                                    // 1002
 * Sizzle CSS Selector Engine v1.10.2                                                                                  // 1003
 * http://sizzlejs.com/                                                                                                // 1004
 *                                                                                                                     // 1005
 * Copyright 2013 jQuery Foundation, Inc. and other contributors                                                       // 1006
 * Released under the MIT license                                                                                      // 1007
 * http://jquery.org/license                                                                                           // 1008
 *                                                                                                                     // 1009
 * Date: 2013-07-03                                                                                                    // 1010
 */                                                                                                                    // 1011
(function( window, undefined ) {                                                                                       // 1012
                                                                                                                       // 1013
var i,                                                                                                                 // 1014
	support,                                                                                                              // 1015
	cachedruns,                                                                                                           // 1016
	Expr,                                                                                                                 // 1017
	getText,                                                                                                              // 1018
	isXML,                                                                                                                // 1019
	compile,                                                                                                              // 1020
	outermostContext,                                                                                                     // 1021
	sortInput,                                                                                                            // 1022
                                                                                                                       // 1023
	// Local document vars                                                                                                // 1024
	setDocument,                                                                                                          // 1025
	document,                                                                                                             // 1026
	docElem,                                                                                                              // 1027
	documentIsHTML,                                                                                                       // 1028
	rbuggyQSA,                                                                                                            // 1029
	rbuggyMatches,                                                                                                        // 1030
	matches,                                                                                                              // 1031
	contains,                                                                                                             // 1032
                                                                                                                       // 1033
	// Instance-specific data                                                                                             // 1034
	expando = "sizzle" + -(new Date()),                                                                                   // 1035
	preferredDoc = window.document,                                                                                       // 1036
	dirruns = 0,                                                                                                          // 1037
	done = 0,                                                                                                             // 1038
	classCache = createCache(),                                                                                           // 1039
	tokenCache = createCache(),                                                                                           // 1040
	compilerCache = createCache(),                                                                                        // 1041
	hasDuplicate = false,                                                                                                 // 1042
	sortOrder = function( a, b ) {                                                                                        // 1043
		if ( a === b ) {                                                                                                     // 1044
			hasDuplicate = true;                                                                                                // 1045
			return 0;                                                                                                           // 1046
		}                                                                                                                    // 1047
		return 0;                                                                                                            // 1048
	},                                                                                                                    // 1049
                                                                                                                       // 1050
	// General-purpose constants                                                                                          // 1051
	strundefined = typeof undefined,                                                                                      // 1052
	MAX_NEGATIVE = 1 << 31,                                                                                               // 1053
                                                                                                                       // 1054
	// Instance methods                                                                                                   // 1055
	hasOwn = ({}).hasOwnProperty,                                                                                         // 1056
	arr = [],                                                                                                             // 1057
	pop = arr.pop,                                                                                                        // 1058
	push_native = arr.push,                                                                                               // 1059
	push = arr.push,                                                                                                      // 1060
	slice = arr.slice,                                                                                                    // 1061
	// Use a stripped-down indexOf if we can't use a native one                                                           // 1062
	indexOf = arr.indexOf || function( elem ) {                                                                           // 1063
		var i = 0,                                                                                                           // 1064
			len = this.length;                                                                                                  // 1065
		for ( ; i < len; i++ ) {                                                                                             // 1066
			if ( this[i] === elem ) {                                                                                           // 1067
				return i;                                                                                                          // 1068
			}                                                                                                                   // 1069
		}                                                                                                                    // 1070
		return -1;                                                                                                           // 1071
	},                                                                                                                    // 1072
                                                                                                                       // 1073
	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                                                                                                                       // 1075
	// Regular expressions                                                                                                // 1076
                                                                                                                       // 1077
	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace                                              // 1078
	whitespace = "[\\x20\\t\\r\\n\\f]",                                                                                   // 1079
	// http://www.w3.org/TR/css3-syntax/#characters                                                                       // 1080
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",                                                               // 1081
                                                                                                                       // 1082
	// Loosely modeled on CSS identifier characters                                                                       // 1083
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors              // 1084
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier                                        // 1085
	identifier = characterEncoding.replace( "w", "w#" ),                                                                  // 1086
                                                                                                                       // 1087
	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors                                           // 1088
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +                                       // 1089
		"*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",
                                                                                                                       // 1091
	// Prefer arguments quoted,                                                                                           // 1092
	//   then not containing pseudos/brackets,                                                                            // 1093
	//   then attribute selectors/non-parenthetical expressions,                                                          // 1094
	//   then anything else                                                                                               // 1095
	// These preferences are here to reduce the number of selectors                                                       // 1096
	//   needing tokenize in the PSEUDO preFilter                                                                         // 1097
	pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",
                                                                                                                       // 1099
	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter         // 1100
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),                      // 1101
                                                                                                                       // 1102
	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),                                                    // 1103
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),                     // 1104
                                                                                                                       // 1105
	rsibling = new RegExp( whitespace + "*[+~]" ),                                                                        // 1106
	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*)" + whitespace + "*\\]", "g" ),                       // 1107
                                                                                                                       // 1108
	rpseudo = new RegExp( pseudos ),                                                                                      // 1109
	ridentifier = new RegExp( "^" + identifier + "$" ),                                                                   // 1110
                                                                                                                       // 1111
	matchExpr = {                                                                                                         // 1112
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),                                                                 // 1113
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),                                                            // 1114
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),                                            // 1115
		"ATTR": new RegExp( "^" + attributes ),                                                                              // 1116
		"PSEUDO": new RegExp( "^" + pseudos ),                                                                               // 1117
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +                         // 1118
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +                                          // 1119
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),                                                                        // 1120
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),                                                                 // 1121
		// For use in libraries implementing .is()                                                                           // 1122
		// We use this for POS matching in `select`                                                                          // 1123
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +                  // 1124
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )                                            // 1125
	},                                                                                                                    // 1126
                                                                                                                       // 1127
	rnative = /^[^{]+\{\s*\[native \w/,                                                                                   // 1128
                                                                                                                       // 1129
	// Easily-parseable/retrievable ID or TAG or CLASS selectors                                                          // 1130
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,                                                                      // 1131
                                                                                                                       // 1132
	rinputs = /^(?:input|select|textarea|button)$/i,                                                                      // 1133
	rheader = /^h\d$/i,                                                                                                   // 1134
                                                                                                                       // 1135
	rescape = /'|\\/g,                                                                                                    // 1136
                                                                                                                       // 1137
	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters                                             // 1138
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),                      // 1139
	funescape = function( _, escaped, escapedWhitespace ) {                                                               // 1140
		var high = "0x" + escaped - 0x10000;                                                                                 // 1141
		// NaN means non-codepoint                                                                                           // 1142
		// Support: Firefox                                                                                                  // 1143
		// Workaround erroneous numeric interpretation of +"0x"                                                              // 1144
		return high !== high || escapedWhitespace ?                                                                          // 1145
			escaped :                                                                                                           // 1146
			// BMP codepoint                                                                                                    // 1147
			high < 0 ?                                                                                                          // 1148
				String.fromCharCode( high + 0x10000 ) :                                                                            // 1149
				// Supplemental Plane codepoint (surrogate pair)                                                                   // 1150
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );                                                 // 1151
	};                                                                                                                    // 1152
                                                                                                                       // 1153
// Optimize for push.apply( _, NodeList )                                                                              // 1154
try {                                                                                                                  // 1155
	push.apply(                                                                                                           // 1156
		(arr = slice.call( preferredDoc.childNodes )),                                                                       // 1157
		preferredDoc.childNodes                                                                                              // 1158
	);                                                                                                                    // 1159
	// Support: Android<4.0                                                                                               // 1160
	// Detect silently failing push.apply                                                                                 // 1161
	arr[ preferredDoc.childNodes.length ].nodeType;                                                                       // 1162
} catch ( e ) {                                                                                                        // 1163
	push = { apply: arr.length ?                                                                                          // 1164
                                                                                                                       // 1165
		// Leverage slice if possible                                                                                        // 1166
		function( target, els ) {                                                                                            // 1167
			push_native.apply( target, slice.call(els) );                                                                       // 1168
		} :                                                                                                                  // 1169
                                                                                                                       // 1170
		// Support: IE<9                                                                                                     // 1171
		// Otherwise append directly                                                                                         // 1172
		function( target, els ) {                                                                                            // 1173
			var j = target.length,                                                                                              // 1174
				i = 0;                                                                                                             // 1175
			// Can't trust NodeList.length                                                                                      // 1176
			while ( (target[j++] = els[i++]) ) {}                                                                               // 1177
			target.length = j - 1;                                                                                              // 1178
		}                                                                                                                    // 1179
	};                                                                                                                    // 1180
}                                                                                                                      // 1181
                                                                                                                       // 1182
function Sizzle( selector, context, results, seed ) {                                                                  // 1183
	var match, elem, m, nodeType,                                                                                         // 1184
		// QSA vars                                                                                                          // 1185
		i, groups, old, nid, newContext, newSelector;                                                                        // 1186
                                                                                                                       // 1187
	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {                                   // 1188
		setDocument( context );                                                                                              // 1189
	}                                                                                                                     // 1190
                                                                                                                       // 1191
	context = context || document;                                                                                        // 1192
	results = results || [];                                                                                              // 1193
                                                                                                                       // 1194
	if ( !selector || typeof selector !== "string" ) {                                                                    // 1195
		return results;                                                                                                      // 1196
	}                                                                                                                     // 1197
                                                                                                                       // 1198
	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {                                                        // 1199
		return [];                                                                                                           // 1200
	}                                                                                                                     // 1201
                                                                                                                       // 1202
	if ( documentIsHTML && !seed ) {                                                                                      // 1203
                                                                                                                       // 1204
		// Shortcuts                                                                                                         // 1205
		if ( (match = rquickExpr.exec( selector )) ) {                                                                       // 1206
			// Speed-up: Sizzle("#ID")                                                                                          // 1207
			if ( (m = match[1]) ) {                                                                                             // 1208
				if ( nodeType === 9 ) {                                                                                            // 1209
					elem = context.getElementById( m );                                                                               // 1210
					// Check parentNode to catch when Blackberry 4.6 returns                                                          // 1211
					// nodes that are no longer in the document #6963                                                                 // 1212
					if ( elem && elem.parentNode ) {                                                                                  // 1213
						// Handle the case where IE, Opera, and Webkit return items                                                      // 1214
						// by name instead of ID                                                                                         // 1215
						if ( elem.id === m ) {                                                                                           // 1216
							results.push( elem );                                                                                           // 1217
							return results;                                                                                                 // 1218
						}                                                                                                                // 1219
					} else {                                                                                                          // 1220
						return results;                                                                                                  // 1221
					}                                                                                                                 // 1222
				} else {                                                                                                           // 1223
					// Context is not a document                                                                                      // 1224
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&                               // 1225
						contains( context, elem ) && elem.id === m ) {                                                                   // 1226
						results.push( elem );                                                                                            // 1227
						return results;                                                                                                  // 1228
					}                                                                                                                 // 1229
				}                                                                                                                  // 1230
                                                                                                                       // 1231
			// Speed-up: Sizzle("TAG")                                                                                          // 1232
			} else if ( match[2] ) {                                                                                            // 1233
				push.apply( results, context.getElementsByTagName( selector ) );                                                   // 1234
				return results;                                                                                                    // 1235
                                                                                                                       // 1236
			// Speed-up: Sizzle(".CLASS")                                                                                       // 1237
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {                  // 1238
				push.apply( results, context.getElementsByClassName( m ) );                                                        // 1239
				return results;                                                                                                    // 1240
			}                                                                                                                   // 1241
		}                                                                                                                    // 1242
                                                                                                                       // 1243
		// QSA path                                                                                                          // 1244
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {                                                  // 1245
			nid = old = expando;                                                                                                // 1246
			newContext = context;                                                                                               // 1247
			newSelector = nodeType === 9 && selector;                                                                           // 1248
                                                                                                                       // 1249
			// qSA works strangely on Element-rooted queries                                                                    // 1250
			// We can work around this by specifying an extra ID on the root                                                    // 1251
			// and working up from there (Thanks to Andrew Dupont for the technique)                                            // 1252
			// IE 8 doesn't work on object elements                                                                             // 1253
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {                                              // 1254
				groups = tokenize( selector );                                                                                     // 1255
                                                                                                                       // 1256
				if ( (old = context.getAttribute("id")) ) {                                                                        // 1257
					nid = old.replace( rescape, "\\$&" );                                                                             // 1258
				} else {                                                                                                           // 1259
					context.setAttribute( "id", nid );                                                                                // 1260
				}                                                                                                                  // 1261
				nid = "[id='" + nid + "'] ";                                                                                       // 1262
                                                                                                                       // 1263
				i = groups.length;                                                                                                 // 1264
				while ( i-- ) {                                                                                                    // 1265
					groups[i] = nid + toSelector( groups[i] );                                                                        // 1266
				}                                                                                                                  // 1267
				newContext = rsibling.test( selector ) && context.parentNode || context;                                           // 1268
				newSelector = groups.join(",");                                                                                    // 1269
			}                                                                                                                   // 1270
                                                                                                                       // 1271
			if ( newSelector ) {                                                                                                // 1272
				try {                                                                                                              // 1273
					push.apply( results,                                                                                              // 1274
						newContext.querySelectorAll( newSelector )                                                                       // 1275
					);                                                                                                                // 1276
					return results;                                                                                                   // 1277
				} catch(qsaError) {                                                                                                // 1278
				} finally {                                                                                                        // 1279
					if ( !old ) {                                                                                                     // 1280
						context.removeAttribute("id");                                                                                   // 1281
					}                                                                                                                 // 1282
				}                                                                                                                  // 1283
			}                                                                                                                   // 1284
		}                                                                                                                    // 1285
	}                                                                                                                     // 1286
                                                                                                                       // 1287
	// All others                                                                                                         // 1288
	return select( selector.replace( rtrim, "$1" ), context, results, seed );                                             // 1289
}                                                                                                                      // 1290
                                                                                                                       // 1291
/**                                                                                                                    // 1292
 * Create key-value caches of limited size                                                                             // 1293
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with                         // 1294
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)                        // 1295
 *	deleting the oldest entry                                                                                           // 1296
 */                                                                                                                    // 1297
function createCache() {                                                                                               // 1298
	var keys = [];                                                                                                        // 1299
                                                                                                                       // 1300
	function cache( key, value ) {                                                                                        // 1301
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)                              // 1302
		if ( keys.push( key += " " ) > Expr.cacheLength ) {                                                                  // 1303
			// Only keep the most recent entries                                                                                // 1304
			delete cache[ keys.shift() ];                                                                                       // 1305
		}                                                                                                                    // 1306
		return (cache[ key ] = value);                                                                                       // 1307
	}                                                                                                                     // 1308
	return cache;                                                                                                         // 1309
}                                                                                                                      // 1310
                                                                                                                       // 1311
/**                                                                                                                    // 1312
 * Mark a function for special use by Sizzle                                                                           // 1313
 * @param {Function} fn The function to mark                                                                           // 1314
 */                                                                                                                    // 1315
function markFunction( fn ) {                                                                                          // 1316
	fn[ expando ] = true;                                                                                                 // 1317
	return fn;                                                                                                            // 1318
}                                                                                                                      // 1319
                                                                                                                       // 1320
/**                                                                                                                    // 1321
 * Support testing using an element                                                                                    // 1322
 * @param {Function} fn Passed the created div and expects a boolean result                                            // 1323
 */                                                                                                                    // 1324
function assert( fn ) {                                                                                                // 1325
	var div = document.createElement("div");                                                                              // 1326
                                                                                                                       // 1327
	try {                                                                                                                 // 1328
		return !!fn( div );                                                                                                  // 1329
	} catch (e) {                                                                                                         // 1330
		return false;                                                                                                        // 1331
	} finally {                                                                                                           // 1332
		// Remove from its parent by default                                                                                 // 1333
		if ( div.parentNode ) {                                                                                              // 1334
			div.parentNode.removeChild( div );                                                                                  // 1335
		}                                                                                                                    // 1336
		// release memory in IE                                                                                              // 1337
		div = null;                                                                                                          // 1338
	}                                                                                                                     // 1339
}                                                                                                                      // 1340
                                                                                                                       // 1341
/**                                                                                                                    // 1342
 * Adds the same handler for all of the specified attrs                                                                // 1343
 * @param {String} attrs Pipe-separated list of attributes                                                             // 1344
 * @param {Function} handler The method that will be applied                                                           // 1345
 */                                                                                                                    // 1346
function addHandle( attrs, handler ) {                                                                                 // 1347
	var arr = attrs.split("|"),                                                                                           // 1348
		i = attrs.length;                                                                                                    // 1349
                                                                                                                       // 1350
	while ( i-- ) {                                                                                                       // 1351
		Expr.attrHandle[ arr[i] ] = handler;                                                                                 // 1352
	}                                                                                                                     // 1353
}                                                                                                                      // 1354
                                                                                                                       // 1355
/**                                                                                                                    // 1356
 * Checks document order of two siblings                                                                               // 1357
 * @param {Element} a                                                                                                  // 1358
 * @param {Element} b                                                                                                  // 1359
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b                                // 1360
 */                                                                                                                    // 1361
function siblingCheck( a, b ) {                                                                                        // 1362
	var cur = b && a,                                                                                                     // 1363
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&                                                                // 1364
			( ~b.sourceIndex || MAX_NEGATIVE ) -                                                                                // 1365
			( ~a.sourceIndex || MAX_NEGATIVE );                                                                                 // 1366
                                                                                                                       // 1367
	// Use IE sourceIndex if available on both nodes                                                                      // 1368
	if ( diff ) {                                                                                                         // 1369
		return diff;                                                                                                         // 1370
	}                                                                                                                     // 1371
                                                                                                                       // 1372
	// Check if b follows a                                                                                               // 1373
	if ( cur ) {                                                                                                          // 1374
		while ( (cur = cur.nextSibling) ) {                                                                                  // 1375
			if ( cur === b ) {                                                                                                  // 1376
				return -1;                                                                                                         // 1377
			}                                                                                                                   // 1378
		}                                                                                                                    // 1379
	}                                                                                                                     // 1380
                                                                                                                       // 1381
	return a ? 1 : -1;                                                                                                    // 1382
}                                                                                                                      // 1383
                                                                                                                       // 1384
/**                                                                                                                    // 1385
 * Returns a function to use in pseudos for input types                                                                // 1386
 * @param {String} type                                                                                                // 1387
 */                                                                                                                    // 1388
function createInputPseudo( type ) {                                                                                   // 1389
	return function( elem ) {                                                                                             // 1390
		var name = elem.nodeName.toLowerCase();                                                                              // 1391
		return name === "input" && elem.type === type;                                                                       // 1392
	};                                                                                                                    // 1393
}                                                                                                                      // 1394
                                                                                                                       // 1395
/**                                                                                                                    // 1396
 * Returns a function to use in pseudos for buttons                                                                    // 1397
 * @param {String} type                                                                                                // 1398
 */                                                                                                                    // 1399
function createButtonPseudo( type ) {                                                                                  // 1400
	return function( elem ) {                                                                                             // 1401
		var name = elem.nodeName.toLowerCase();                                                                              // 1402
		return (name === "input" || name === "button") && elem.type === type;                                                // 1403
	};                                                                                                                    // 1404
}                                                                                                                      // 1405
                                                                                                                       // 1406
/**                                                                                                                    // 1407
 * Returns a function to use in pseudos for positionals                                                                // 1408
 * @param {Function} fn                                                                                                // 1409
 */                                                                                                                    // 1410
function createPositionalPseudo( fn ) {                                                                                // 1411
	return markFunction(function( argument ) {                                                                            // 1412
		argument = +argument;                                                                                                // 1413
		return markFunction(function( seed, matches ) {                                                                      // 1414
			var j,                                                                                                              // 1415
				matchIndexes = fn( [], seed.length, argument ),                                                                    // 1416
				i = matchIndexes.length;                                                                                           // 1417
                                                                                                                       // 1418
			// Match elements found at the specified indexes                                                                    // 1419
			while ( i-- ) {                                                                                                     // 1420
				if ( seed[ (j = matchIndexes[i]) ] ) {                                                                             // 1421
					seed[j] = !(matches[j] = seed[j]);                                                                                // 1422
				}                                                                                                                  // 1423
			}                                                                                                                   // 1424
		});                                                                                                                  // 1425
	});                                                                                                                   // 1426
}                                                                                                                      // 1427
                                                                                                                       // 1428
/**                                                                                                                    // 1429
 * Detect xml                                                                                                          // 1430
 * @param {Element|Object} elem An element or a document                                                               // 1431
 */                                                                                                                    // 1432
isXML = Sizzle.isXML = function( elem ) {                                                                              // 1433
	// documentElement is verified for cases where it doesn't yet exist                                                   // 1434
	// (such as loading iframes in IE - #4833)                                                                            // 1435
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;                                           // 1436
	return documentElement ? documentElement.nodeName !== "HTML" : false;                                                 // 1437
};                                                                                                                     // 1438
                                                                                                                       // 1439
// Expose support vars for convenience                                                                                 // 1440
support = Sizzle.support = {};                                                                                         // 1441
                                                                                                                       // 1442
/**                                                                                                                    // 1443
 * Sets document-related variables once based on the current document                                                  // 1444
 * @param {Element|Object} [doc] An element or document object to use to set the document                              // 1445
 * @returns {Object} Returns the current document                                                                      // 1446
 */                                                                                                                    // 1447
setDocument = Sizzle.setDocument = function( node ) {                                                                  // 1448
	var doc = node ? node.ownerDocument || node : preferredDoc,                                                           // 1449
		parent = doc.defaultView;                                                                                            // 1450
                                                                                                                       // 1451
	// If no document and documentElement is available, return                                                            // 1452
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {                                               // 1453
		return document;                                                                                                     // 1454
	}                                                                                                                     // 1455
                                                                                                                       // 1456
	// Set our document                                                                                                   // 1457
	document = doc;                                                                                                       // 1458
	docElem = doc.documentElement;                                                                                        // 1459
                                                                                                                       // 1460
	// Support tests                                                                                                      // 1461
	documentIsHTML = !isXML( doc );                                                                                       // 1462
                                                                                                                       // 1463
	// Support: IE>8                                                                                                      // 1464
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,                             // 1465
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936                      // 1466
	// IE6-8 do not support the defaultView property so parent will be undefined                                          // 1467
	if ( parent && parent.attachEvent && parent !== parent.top ) {                                                        // 1468
		parent.attachEvent( "onbeforeunload", function() {                                                                   // 1469
			setDocument();                                                                                                      // 1470
		});                                                                                                                  // 1471
	}                                                                                                                     // 1472
                                                                                                                       // 1473
	/* Attributes                                                                                                         // 1474
	---------------------------------------------------------------------- */                                             // 1475
                                                                                                                       // 1476
	// Support: IE<8                                                                                                      // 1477
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)                     // 1478
	support.attributes = assert(function( div ) {                                                                         // 1479
		div.className = "i";                                                                                                 // 1480
		return !div.getAttribute("className");                                                                               // 1481
	});                                                                                                                   // 1482
                                                                                                                       // 1483
	/* getElement(s)By*                                                                                                   // 1484
	---------------------------------------------------------------------- */                                             // 1485
                                                                                                                       // 1486
	// Check if getElementsByTagName("*") returns only elements                                                           // 1487
	support.getElementsByTagName = assert(function( div ) {                                                               // 1488
		div.appendChild( doc.createComment("") );                                                                            // 1489
		return !div.getElementsByTagName("*").length;                                                                        // 1490
	});                                                                                                                   // 1491
                                                                                                                       // 1492
	// Check if getElementsByClassName can be trusted                                                                     // 1493
	support.getElementsByClassName = assert(function( div ) {                                                             // 1494
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";                                                      // 1495
                                                                                                                       // 1496
		// Support: Safari<4                                                                                                 // 1497
		// Catch class over-caching                                                                                          // 1498
		div.firstChild.className = "i";                                                                                      // 1499
		// Support: Opera<10                                                                                                 // 1500
		// Catch gEBCN failure to find non-leading classes                                                                   // 1501
		return div.getElementsByClassName("i").length === 2;                                                                 // 1502
	});                                                                                                                   // 1503
                                                                                                                       // 1504
	// Support: IE<10                                                                                                     // 1505
	// Check if getElementById returns elements by name                                                                   // 1506
	// The broken getElementById methods don't pick up programatically-set names,                                         // 1507
	// so use a roundabout getElementsByName test                                                                         // 1508
	support.getById = assert(function( div ) {                                                                            // 1509
		docElem.appendChild( div ).id = expando;                                                                             // 1510
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;                                           // 1511
	});                                                                                                                   // 1512
                                                                                                                       // 1513
	// ID find and filter                                                                                                 // 1514
	if ( support.getById ) {                                                                                              // 1515
		Expr.find["ID"] = function( id, context ) {                                                                          // 1516
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {                                           // 1517
				var m = context.getElementById( id );                                                                              // 1518
				// Check parentNode to catch when Blackberry 4.6 returns                                                           // 1519
				// nodes that are no longer in the document #6963                                                                  // 1520
				return m && m.parentNode ? [m] : [];                                                                               // 1521
			}                                                                                                                   // 1522
		};                                                                                                                   // 1523
		Expr.filter["ID"] = function( id ) {                                                                                 // 1524
			var attrId = id.replace( runescape, funescape );                                                                    // 1525
			return function( elem ) {                                                                                           // 1526
				return elem.getAttribute("id") === attrId;                                                                         // 1527
			};                                                                                                                  // 1528
		};                                                                                                                   // 1529
	} else {                                                                                                              // 1530
		// Support: IE6/7                                                                                                    // 1531
		// getElementById is not reliable as a find shortcut                                                                 // 1532
		delete Expr.find["ID"];                                                                                              // 1533
                                                                                                                       // 1534
		Expr.filter["ID"] =  function( id ) {                                                                                // 1535
			var attrId = id.replace( runescape, funescape );                                                                    // 1536
			return function( elem ) {                                                                                           // 1537
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");                           // 1538
				return node && node.value === attrId;                                                                              // 1539
			};                                                                                                                  // 1540
		};                                                                                                                   // 1541
	}                                                                                                                     // 1542
                                                                                                                       // 1543
	// Tag                                                                                                                // 1544
	Expr.find["TAG"] = support.getElementsByTagName ?                                                                     // 1545
		function( tag, context ) {                                                                                           // 1546
			if ( typeof context.getElementsByTagName !== strundefined ) {                                                       // 1547
				return context.getElementsByTagName( tag );                                                                        // 1548
			}                                                                                                                   // 1549
		} :                                                                                                                  // 1550
		function( tag, context ) {                                                                                           // 1551
			var elem,                                                                                                           // 1552
				tmp = [],                                                                                                          // 1553
				i = 0,                                                                                                             // 1554
				results = context.getElementsByTagName( tag );                                                                     // 1555
                                                                                                                       // 1556
			// Filter out possible comments                                                                                     // 1557
			if ( tag === "*" ) {                                                                                                // 1558
				while ( (elem = results[i++]) ) {                                                                                  // 1559
					if ( elem.nodeType === 1 ) {                                                                                      // 1560
						tmp.push( elem );                                                                                                // 1561
					}                                                                                                                 // 1562
				}                                                                                                                  // 1563
                                                                                                                       // 1564
				return tmp;                                                                                                        // 1565
			}                                                                                                                   // 1566
			return results;                                                                                                     // 1567
		};                                                                                                                   // 1568
                                                                                                                       // 1569
	// Class                                                                                                              // 1570
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {                               // 1571
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {                                    // 1572
			return context.getElementsByClassName( className );                                                                 // 1573
		}                                                                                                                    // 1574
	};                                                                                                                    // 1575
                                                                                                                       // 1576
	/* QSA/matchesSelector                                                                                                // 1577
	---------------------------------------------------------------------- */                                             // 1578
                                                                                                                       // 1579
	// QSA and matchesSelector support                                                                                    // 1580
                                                                                                                       // 1581
	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)                                                  // 1582
	rbuggyMatches = [];                                                                                                   // 1583
                                                                                                                       // 1584
	// qSa(:focus) reports false when true (Chrome 21)                                                                    // 1585
	// We allow this because of a bug in IE8/9 that throws an error                                                       // 1586
	// whenever `document.activeElement` is accessed on an iframe                                                         // 1587
	// So, we allow :focus to pass through QSA all the time to avoid the IE error                                         // 1588
	// See http://bugs.jquery.com/ticket/13378                                                                            // 1589
	rbuggyQSA = [];                                                                                                       // 1590
                                                                                                                       // 1591
	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {                                                         // 1592
		// Build QSA regex                                                                                                   // 1593
		// Regex strategy adopted from Diego Perini                                                                          // 1594
		assert(function( div ) {                                                                                             // 1595
			// Select is set to empty string on purpose                                                                         // 1596
			// This is to test IE's treatment of not explicitly                                                                 // 1597
			// setting a boolean content attribute,                                                                             // 1598
			// since its presence should be enough                                                                              // 1599
			// http://bugs.jquery.com/ticket/12359                                                                              // 1600
			div.innerHTML = "<select><option selected=''></option></select>";                                                   // 1601
                                                                                                                       // 1602
			// Support: IE8                                                                                                     // 1603
			// Boolean attributes and "value" are not treated correctly                                                         // 1604
			if ( !div.querySelectorAll("[selected]").length ) {                                                                 // 1605
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );                                              // 1606
			}                                                                                                                   // 1607
                                                                                                                       // 1608
			// Webkit/Opera - :checked should return selected option elements                                                   // 1609
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked                                                   // 1610
			// IE8 throws error here and will not see later tests                                                               // 1611
			if ( !div.querySelectorAll(":checked").length ) {                                                                   // 1612
				rbuggyQSA.push(":checked");                                                                                        // 1613
			}                                                                                                                   // 1614
		});                                                                                                                  // 1615
                                                                                                                       // 1616
		assert(function( div ) {                                                                                             // 1617
                                                                                                                       // 1618
			// Support: Opera 10-12/IE8                                                                                         // 1619
			// ^= $= *= and empty values                                                                                        // 1620
			// Should not select anything                                                                                       // 1621
			// Support: Windows 8 Native Apps                                                                                   // 1622
			// The type attribute is restricted during .innerHTML assignment                                                    // 1623
			var input = doc.createElement("input");                                                                             // 1624
			input.setAttribute( "type", "hidden" );                                                                             // 1625
			div.appendChild( input ).setAttribute( "t", "" );                                                                   // 1626
                                                                                                                       // 1627
			if ( div.querySelectorAll("[t^='']").length ) {                                                                     // 1628
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );                                                          // 1629
			}                                                                                                                   // 1630
                                                                                                                       // 1631
			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)                              // 1632
			// IE8 throws error here and will not see later tests                                                               // 1633
			if ( !div.querySelectorAll(":enabled").length ) {                                                                   // 1634
				rbuggyQSA.push( ":enabled", ":disabled" );                                                                         // 1635
			}                                                                                                                   // 1636
                                                                                                                       // 1637
			// Opera 10-11 does not throw on post-comma invalid pseudos                                                         // 1638
			div.querySelectorAll("*,:x");                                                                                       // 1639
			rbuggyQSA.push(",.*:");                                                                                             // 1640
		});                                                                                                                  // 1641
	}                                                                                                                     // 1642
                                                                                                                       // 1643
	if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||                             // 1644
		docElem.mozMatchesSelector ||                                                                                        // 1645
		docElem.oMatchesSelector ||                                                                                          // 1646
		docElem.msMatchesSelector) )) ) {                                                                                    // 1647
                                                                                                                       // 1648
		assert(function( div ) {                                                                                             // 1649
			// Check to see if it's possible to do matchesSelector                                                              // 1650
			// on a disconnected node (IE 9)                                                                                    // 1651
			support.disconnectedMatch = matches.call( div, "div" );                                                             // 1652
                                                                                                                       // 1653
			// This should fail with an exception                                                                               // 1654
			// Gecko does not error, returns false instead                                                                      // 1655
			matches.call( div, "[s!='']:x" );                                                                                   // 1656
			rbuggyMatches.push( "!=", pseudos );                                                                                // 1657
		});                                                                                                                  // 1658
	}                                                                                                                     // 1659
                                                                                                                       // 1660
	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );                                                    // 1661
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );                                        // 1662
                                                                                                                       // 1663
	/* Contains                                                                                                           // 1664
	---------------------------------------------------------------------- */                                             // 1665
                                                                                                                       // 1666
	// Element contains another                                                                                           // 1667
	// Purposefully does not implement inclusive descendent                                                               // 1668
	// As in, an element does not contain itself                                                                          // 1669
	contains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?                                      // 1670
		function( a, b ) {                                                                                                   // 1671
			var adown = a.nodeType === 9 ? a.documentElement : a,                                                               // 1672
				bup = b && b.parentNode;                                                                                           // 1673
			return a === bup || !!( bup && bup.nodeType === 1 && (                                                              // 1674
				adown.contains ?                                                                                                   // 1675
					adown.contains( bup ) :                                                                                           // 1676
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16                                                // 1677
			));                                                                                                                 // 1678
		} :                                                                                                                  // 1679
		function( a, b ) {                                                                                                   // 1680
			if ( b ) {                                                                                                          // 1681
				while ( (b = b.parentNode) ) {                                                                                     // 1682
					if ( b === a ) {                                                                                                  // 1683
						return true;                                                                                                     // 1684
					}                                                                                                                 // 1685
				}                                                                                                                  // 1686
			}                                                                                                                   // 1687
			return false;                                                                                                       // 1688
		};                                                                                                                   // 1689
                                                                                                                       // 1690
	/* Sorting                                                                                                            // 1691
	---------------------------------------------------------------------- */                                             // 1692
                                                                                                                       // 1693
	// Document order sorting                                                                                             // 1694
	sortOrder = docElem.compareDocumentPosition ?                                                                         // 1695
	function( a, b ) {                                                                                                    // 1696
                                                                                                                       // 1697
		// Flag for duplicate removal                                                                                        // 1698
		if ( a === b ) {                                                                                                     // 1699
			hasDuplicate = true;                                                                                                // 1700
			return 0;                                                                                                           // 1701
		}                                                                                                                    // 1702
                                                                                                                       // 1703
		var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );              // 1704
                                                                                                                       // 1705
		if ( compare ) {                                                                                                     // 1706
			// Disconnected nodes                                                                                               // 1707
			if ( compare & 1 ||                                                                                                 // 1708
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {                                          // 1709
                                                                                                                       // 1710
				// Choose the first element that is related to our preferred document                                              // 1711
				if ( a === doc || contains(preferredDoc, a) ) {                                                                    // 1712
					return -1;                                                                                                        // 1713
				}                                                                                                                  // 1714
				if ( b === doc || contains(preferredDoc, b) ) {                                                                    // 1715
					return 1;                                                                                                         // 1716
				}                                                                                                                  // 1717
                                                                                                                       // 1718
				// Maintain original order                                                                                         // 1719
				return sortInput ?                                                                                                 // 1720
					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :                                                 // 1721
					0;                                                                                                                // 1722
			}                                                                                                                   // 1723
                                                                                                                       // 1724
			return compare & 4 ? -1 : 1;                                                                                        // 1725
		}                                                                                                                    // 1726
                                                                                                                       // 1727
		// Not directly comparable, sort on existence of method                                                              // 1728
		return a.compareDocumentPosition ? -1 : 1;                                                                           // 1729
	} :                                                                                                                   // 1730
	function( a, b ) {                                                                                                    // 1731
		var cur,                                                                                                             // 1732
			i = 0,                                                                                                              // 1733
			aup = a.parentNode,                                                                                                 // 1734
			bup = b.parentNode,                                                                                                 // 1735
			ap = [ a ],                                                                                                         // 1736
			bp = [ b ];                                                                                                         // 1737
                                                                                                                       // 1738
		// Exit early if the nodes are identical                                                                             // 1739
		if ( a === b ) {                                                                                                     // 1740
			hasDuplicate = true;                                                                                                // 1741
			return 0;                                                                                                           // 1742
                                                                                                                       // 1743
		// Parentless nodes are either documents or disconnected                                                             // 1744
		} else if ( !aup || !bup ) {                                                                                         // 1745
			return a === doc ? -1 :                                                                                             // 1746
				b === doc ? 1 :                                                                                                    // 1747
				aup ? -1 :                                                                                                         // 1748
				bup ? 1 :                                                                                                          // 1749
				sortInput ?                                                                                                        // 1750
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :                                                  // 1751
				0;                                                                                                                 // 1752
                                                                                                                       // 1753
		// If the nodes are siblings, we can do a quick check                                                                // 1754
		} else if ( aup === bup ) {                                                                                          // 1755
			return siblingCheck( a, b );                                                                                        // 1756
		}                                                                                                                    // 1757
                                                                                                                       // 1758
		// Otherwise we need full lists of their ancestors for comparison                                                    // 1759
		cur = a;                                                                                                             // 1760
		while ( (cur = cur.parentNode) ) {                                                                                   // 1761
			ap.unshift( cur );                                                                                                  // 1762
		}                                                                                                                    // 1763
		cur = b;                                                                                                             // 1764
		while ( (cur = cur.parentNode) ) {                                                                                   // 1765
			bp.unshift( cur );                                                                                                  // 1766
		}                                                                                                                    // 1767
                                                                                                                       // 1768
		// Walk down the tree looking for a discrepancy                                                                      // 1769
		while ( ap[i] === bp[i] ) {                                                                                          // 1770
			i++;                                                                                                                // 1771
		}                                                                                                                    // 1772
                                                                                                                       // 1773
		return i ?                                                                                                           // 1774
			// Do a sibling check if the nodes have a common ancestor                                                           // 1775
			siblingCheck( ap[i], bp[i] ) :                                                                                      // 1776
                                                                                                                       // 1777
			// Otherwise nodes in our document sort first                                                                       // 1778
			ap[i] === preferredDoc ? -1 :                                                                                       // 1779
			bp[i] === preferredDoc ? 1 :                                                                                        // 1780
			0;                                                                                                                  // 1781
	};                                                                                                                    // 1782
                                                                                                                       // 1783
	return doc;                                                                                                           // 1784
};                                                                                                                     // 1785
                                                                                                                       // 1786
Sizzle.matches = function( expr, elements ) {                                                                          // 1787
	return Sizzle( expr, null, null, elements );                                                                          // 1788
};                                                                                                                     // 1789
                                                                                                                       // 1790
Sizzle.matchesSelector = function( elem, expr ) {                                                                      // 1791
	// Set document vars if needed                                                                                        // 1792
	if ( ( elem.ownerDocument || elem ) !== document ) {                                                                  // 1793
		setDocument( elem );                                                                                                 // 1794
	}                                                                                                                     // 1795
                                                                                                                       // 1796
	// Make sure that attribute selectors are quoted                                                                      // 1797
	expr = expr.replace( rattributeQuotes, "='$1']" );                                                                    // 1798
                                                                                                                       // 1799
	if ( support.matchesSelector && documentIsHTML &&                                                                     // 1800
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&                                                                 // 1801
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {                                                                    // 1802
                                                                                                                       // 1803
		try {                                                                                                                // 1804
			var ret = matches.call( elem, expr );                                                                               // 1805
                                                                                                                       // 1806
			// IE 9's matchesSelector returns false on disconnected nodes                                                       // 1807
			if ( ret || support.disconnectedMatch ||                                                                            // 1808
					// As well, disconnected nodes are said to be in a document                                                       // 1809
					// fragment in IE 9                                                                                               // 1810
					elem.document && elem.document.nodeType !== 11 ) {                                                                // 1811
				return ret;                                                                                                        // 1812
			}                                                                                                                   // 1813
		} catch(e) {}                                                                                                        // 1814
	}                                                                                                                     // 1815
                                                                                                                       // 1816
	return Sizzle( expr, document, null, [elem] ).length > 0;                                                             // 1817
};                                                                                                                     // 1818
                                                                                                                       // 1819
Sizzle.contains = function( context, elem ) {                                                                          // 1820
	// Set document vars if needed                                                                                        // 1821
	if ( ( context.ownerDocument || context ) !== document ) {                                                            // 1822
		setDocument( context );                                                                                              // 1823
	}                                                                                                                     // 1824
	return contains( context, elem );                                                                                     // 1825
};                                                                                                                     // 1826
                                                                                                                       // 1827
Sizzle.attr = function( elem, name ) {                                                                                 // 1828
	// Set document vars if needed                                                                                        // 1829
	if ( ( elem.ownerDocument || elem ) !== document ) {                                                                  // 1830
		setDocument( elem );                                                                                                 // 1831
	}                                                                                                                     // 1832
                                                                                                                       // 1833
	var fn = Expr.attrHandle[ name.toLowerCase() ],                                                                       // 1834
		// Don't get fooled by Object.prototype properties (jQuery #13807)                                                   // 1835
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?                                                     // 1836
			fn( elem, name, !documentIsHTML ) :                                                                                 // 1837
			undefined;                                                                                                          // 1838
                                                                                                                       // 1839
	return val === undefined ?                                                                                            // 1840
		support.attributes || !documentIsHTML ?                                                                              // 1841
			elem.getAttribute( name ) :                                                                                         // 1842
			(val = elem.getAttributeNode(name)) && val.specified ?                                                              // 1843
				val.value :                                                                                                        // 1844
				null :                                                                                                             // 1845
		val;                                                                                                                 // 1846
};                                                                                                                     // 1847
                                                                                                                       // 1848
Sizzle.error = function( msg ) {                                                                                       // 1849
	throw new Error( "Syntax error, unrecognized expression: " + msg );                                                   // 1850
};                                                                                                                     // 1851
                                                                                                                       // 1852
/**                                                                                                                    // 1853
 * Document sorting and removing duplicates                                                                            // 1854
 * @param {ArrayLike} results                                                                                          // 1855
 */                                                                                                                    // 1856
Sizzle.uniqueSort = function( results ) {                                                                              // 1857
	var elem,                                                                                                             // 1858
		duplicates = [],                                                                                                     // 1859
		j = 0,                                                                                                               // 1860
		i = 0;                                                                                                               // 1861
                                                                                                                       // 1862
	// Unless we *know* we can detect duplicates, assume their presence                                                   // 1863
	hasDuplicate = !support.detectDuplicates;                                                                             // 1864
	sortInput = !support.sortStable && results.slice( 0 );                                                                // 1865
	results.sort( sortOrder );                                                                                            // 1866
                                                                                                                       // 1867
	if ( hasDuplicate ) {                                                                                                 // 1868
		while ( (elem = results[i++]) ) {                                                                                    // 1869
			if ( elem === results[ i ] ) {                                                                                      // 1870
				j = duplicates.push( i );                                                                                          // 1871
			}                                                                                                                   // 1872
		}                                                                                                                    // 1873
		while ( j-- ) {                                                                                                      // 1874
			results.splice( duplicates[ j ], 1 );                                                                               // 1875
		}                                                                                                                    // 1876
	}                                                                                                                     // 1877
                                                                                                                       // 1878
	return results;                                                                                                       // 1879
};                                                                                                                     // 1880
                                                                                                                       // 1881
/**                                                                                                                    // 1882
 * Utility function for retrieving the text value of an array of DOM nodes                                             // 1883
 * @param {Array|Element} elem                                                                                         // 1884
 */                                                                                                                    // 1885
getText = Sizzle.getText = function( elem ) {                                                                          // 1886
	var node,                                                                                                             // 1887
		ret = "",                                                                                                            // 1888
		i = 0,                                                                                                               // 1889
		nodeType = elem.nodeType;                                                                                            // 1890
                                                                                                                       // 1891
	if ( !nodeType ) {                                                                                                    // 1892
		// If no nodeType, this is expected to be an array                                                                   // 1893
		for ( ; (node = elem[i]); i++ ) {                                                                                    // 1894
			// Do not traverse comment nodes                                                                                    // 1895
			ret += getText( node );                                                                                             // 1896
		}                                                                                                                    // 1897
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {                                                   // 1898
		// Use textContent for elements                                                                                      // 1899
		// innerText usage removed for consistency of new lines (see #11153)                                                 // 1900
		if ( typeof elem.textContent === "string" ) {                                                                        // 1901
			return elem.textContent;                                                                                            // 1902
		} else {                                                                                                             // 1903
			// Traverse its children                                                                                            // 1904
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {                                                     // 1905
				ret += getText( elem );                                                                                            // 1906
			}                                                                                                                   // 1907
		}                                                                                                                    // 1908
	} else if ( nodeType === 3 || nodeType === 4 ) {                                                                      // 1909
		return elem.nodeValue;                                                                                               // 1910
	}                                                                                                                     // 1911
	// Do not include comment or processing instruction nodes                                                             // 1912
                                                                                                                       // 1913
	return ret;                                                                                                           // 1914
};                                                                                                                     // 1915
                                                                                                                       // 1916
Expr = Sizzle.selectors = {                                                                                            // 1917
                                                                                                                       // 1918
	// Can be adjusted by the user                                                                                        // 1919
	cacheLength: 50,                                                                                                      // 1920
                                                                                                                       // 1921
	createPseudo: markFunction,                                                                                           // 1922
                                                                                                                       // 1923
	match: matchExpr,                                                                                                     // 1924
                                                                                                                       // 1925
	attrHandle: {},                                                                                                       // 1926
                                                                                                                       // 1927
	find: {},                                                                                                             // 1928
                                                                                                                       // 1929
	relative: {                                                                                                           // 1930
		">": { dir: "parentNode", first: true },                                                                             // 1931
		" ": { dir: "parentNode" },                                                                                          // 1932
		"+": { dir: "previousSibling", first: true },                                                                        // 1933
		"~": { dir: "previousSibling" }                                                                                      // 1934
	},                                                                                                                    // 1935
                                                                                                                       // 1936
	preFilter: {                                                                                                          // 1937
		"ATTR": function( match ) {                                                                                          // 1938
			match[1] = match[1].replace( runescape, funescape );                                                                // 1939
                                                                                                                       // 1940
			// Move the given value to match[3] whether quoted or unquoted                                                      // 1941
			match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );                                          // 1942
                                                                                                                       // 1943
			if ( match[2] === "~=" ) {                                                                                          // 1944
				match[3] = " " + match[3] + " ";                                                                                   // 1945
			}                                                                                                                   // 1946
                                                                                                                       // 1947
			return match.slice( 0, 4 );                                                                                         // 1948
		},                                                                                                                   // 1949
                                                                                                                       // 1950
		"CHILD": function( match ) {                                                                                         // 1951
			/* matches from matchExpr["CHILD"]                                                                                  // 1952
				1 type (only|nth|...)                                                                                              // 1953
				2 what (child|of-type)                                                                                             // 1954
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)                                                                       // 1955
				4 xn-component of xn+y argument ([+-]?\d*n|)                                                                       // 1956
				5 sign of xn-component                                                                                             // 1957
				6 x of xn-component                                                                                                // 1958
				7 sign of y-component                                                                                              // 1959
				8 y of y-component                                                                                                 // 1960
			*/                                                                                                                  // 1961
			match[1] = match[1].toLowerCase();                                                                                  // 1962
                                                                                                                       // 1963
			if ( match[1].slice( 0, 3 ) === "nth" ) {                                                                           // 1964
				// nth-* requires argument                                                                                         // 1965
				if ( !match[3] ) {                                                                                                 // 1966
					Sizzle.error( match[0] );                                                                                         // 1967
				}                                                                                                                  // 1968
                                                                                                                       // 1969
				// numeric x and y parameters for Expr.filter.CHILD                                                                // 1970
				// remember that false/true cast respectively to 0/1                                                               // 1971
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );         // 1972
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );                                                     // 1973
                                                                                                                       // 1974
			// other types prohibit arguments                                                                                   // 1975
			} else if ( match[3] ) {                                                                                            // 1976
				Sizzle.error( match[0] );                                                                                          // 1977
			}                                                                                                                   // 1978
                                                                                                                       // 1979
			return match;                                                                                                       // 1980
		},                                                                                                                   // 1981
                                                                                                                       // 1982
		"PSEUDO": function( match ) {                                                                                        // 1983
			var excess,                                                                                                         // 1984
				unquoted = !match[5] && match[2];                                                                                  // 1985
                                                                                                                       // 1986
			if ( matchExpr["CHILD"].test( match[0] ) ) {                                                                        // 1987
				return null;                                                                                                       // 1988
			}                                                                                                                   // 1989
                                                                                                                       // 1990
			// Accept quoted arguments as-is                                                                                    // 1991
			if ( match[3] && match[4] !== undefined ) {                                                                         // 1992
				match[2] = match[4];                                                                                               // 1993
                                                                                                                       // 1994
			// Strip excess characters from unquoted arguments                                                                  // 1995
			} else if ( unquoted && rpseudo.test( unquoted ) &&                                                                 // 1996
				// Get excess from tokenize (recursively)                                                                          // 1997
				(excess = tokenize( unquoted, true )) &&                                                                           // 1998
				// advance to the next closing parenthesis                                                                         // 1999
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {                                 // 2000
                                                                                                                       // 2001
				// excess is a negative index                                                                                      // 2002
				match[0] = match[0].slice( 0, excess );                                                                            // 2003
				match[2] = unquoted.slice( 0, excess );                                                                            // 2004
			}                                                                                                                   // 2005
                                                                                                                       // 2006
			// Return only captures needed by the pseudo filter method (type and argument)                                      // 2007
			return match.slice( 0, 3 );                                                                                         // 2008
		}                                                                                                                    // 2009
	},                                                                                                                    // 2010
                                                                                                                       // 2011
	filter: {                                                                                                             // 2012
                                                                                                                       // 2013
		"TAG": function( nodeNameSelector ) {                                                                                // 2014
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();                                      // 2015
			return nodeNameSelector === "*" ?                                                                                   // 2016
				function() { return true; } :                                                                                      // 2017
				function( elem ) {                                                                                                 // 2018
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;                                                 // 2019
				};                                                                                                                 // 2020
		},                                                                                                                   // 2021
                                                                                                                       // 2022
		"CLASS": function( className ) {                                                                                     // 2023
			var pattern = classCache[ className + " " ];                                                                        // 2024
                                                                                                                       // 2025
			return pattern ||                                                                                                   // 2026
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&                       // 2027
				classCache( className, function( elem ) {                                                                          // 2028
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});                                                                                                                // 2030
		},                                                                                                                   // 2031
                                                                                                                       // 2032
		"ATTR": function( name, operator, check ) {                                                                          // 2033
			return function( elem ) {                                                                                           // 2034
				var result = Sizzle.attr( elem, name );                                                                            // 2035
                                                                                                                       // 2036
				if ( result == null ) {                                                                                            // 2037
					return operator === "!=";                                                                                         // 2038
				}                                                                                                                  // 2039
				if ( !operator ) {                                                                                                 // 2040
					return true;                                                                                                      // 2041
				}                                                                                                                  // 2042
                                                                                                                       // 2043
				result += "";                                                                                                      // 2044
                                                                                                                       // 2045
				return operator === "=" ? result === check :                                                                       // 2046
					operator === "!=" ? result !== check :                                                                            // 2047
					operator === "^=" ? check && result.indexOf( check ) === 0 :                                                      // 2048
					operator === "*=" ? check && result.indexOf( check ) > -1 :                                                       // 2049
					operator === "$=" ? check && result.slice( -check.length ) === check :                                            // 2050
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :                                                // 2051
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :                     // 2052
					false;                                                                                                            // 2053
			};                                                                                                                  // 2054
		},                                                                                                                   // 2055
                                                                                                                       // 2056
		"CHILD": function( type, what, argument, first, last ) {                                                             // 2057
			var simple = type.slice( 0, 3 ) !== "nth",                                                                          // 2058
				forward = type.slice( -4 ) !== "last",                                                                             // 2059
				ofType = what === "of-type";                                                                                       // 2060
                                                                                                                       // 2061
			return first === 1 && last === 0 ?                                                                                  // 2062
                                                                                                                       // 2063
				// Shortcut for :nth-*(n)                                                                                          // 2064
				function( elem ) {                                                                                                 // 2065
					return !!elem.parentNode;                                                                                         // 2066
				} :                                                                                                                // 2067
                                                                                                                       // 2068
				function( elem, context, xml ) {                                                                                   // 2069
					var cache, outerCache, node, diff, nodeIndex, start,                                                              // 2070
						dir = simple !== forward ? "nextSibling" : "previousSibling",                                                    // 2071
						parent = elem.parentNode,                                                                                        // 2072
						name = ofType && elem.nodeName.toLowerCase(),                                                                    // 2073
						useCache = !xml && !ofType;                                                                                      // 2074
                                                                                                                       // 2075
					if ( parent ) {                                                                                                   // 2076
                                                                                                                       // 2077
						// :(first|last|only)-(child|of-type)                                                                            // 2078
						if ( simple ) {                                                                                                  // 2079
							while ( dir ) {                                                                                                 // 2080
								node = elem;                                                                                                   // 2081
								while ( (node = node[ dir ]) ) {                                                                               // 2082
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {                                  // 2083
										return false;                                                                                                // 2084
									}                                                                                                             // 2085
								}                                                                                                              // 2086
								// Reverse direction for :only-* (if we haven't yet done so)                                                   // 2087
								start = dir = type === "only" && !start && "nextSibling";                                                      // 2088
							}                                                                                                               // 2089
							return true;                                                                                                    // 2090
						}                                                                                                                // 2091
                                                                                                                       // 2092
						start = [ forward ? parent.firstChild : parent.lastChild ];                                                      // 2093
                                                                                                                       // 2094
						// non-xml :nth-child(...) stores cache data on `parent`                                                         // 2095
						if ( forward && useCache ) {                                                                                     // 2096
							// Seek `elem` from a previously-cached index                                                                   // 2097
							outerCache = parent[ expando ] || (parent[ expando ] = {});                                                     // 2098
							cache = outerCache[ type ] || [];                                                                               // 2099
							nodeIndex = cache[0] === dirruns && cache[1];                                                                   // 2100
							diff = cache[0] === dirruns && cache[2];                                                                        // 2101
							node = nodeIndex && parent.childNodes[ nodeIndex ];                                                             // 2102
                                                                                                                       // 2103
							while ( (node = ++nodeIndex && node && node[ dir ] ||                                                           // 2104
                                                                                                                       // 2105
								// Fallback to seeking `elem` from the start                                                                   // 2106
								(diff = nodeIndex = 0) || start.pop()) ) {                                                                     // 2107
                                                                                                                       // 2108
								// When found, cache indexes on `parent` and break                                                             // 2109
								if ( node.nodeType === 1 && ++diff && node === elem ) {                                                        // 2110
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];                                                            // 2111
									break;                                                                                                        // 2112
								}                                                                                                              // 2113
							}                                                                                                               // 2114
                                                                                                                       // 2115
						// Use previously-cached element index if available                                                              // 2116
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];                                                                                                // 2118
                                                                                                                       // 2119
						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)                                      // 2120
						} else {                                                                                                         // 2121
							// Use the same loop as above to seek `elem` from the start                                                     // 2122
							while ( (node = ++nodeIndex && node && node[ dir ] ||                                                           // 2123
								(diff = nodeIndex = 0) || start.pop()) ) {                                                                     // 2124
                                                                                                                       // 2125
								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {                     // 2126
									// Cache the index of each encountered element                                                                // 2127
									if ( useCache ) {                                                                                             // 2128
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];                                     // 2129
									}                                                                                                             // 2130
                                                                                                                       // 2131
									if ( node === elem ) {                                                                                        // 2132
										break;                                                                                                       // 2133
									}                                                                                                             // 2134
								}                                                                                                              // 2135
							}                                                                                                               // 2136
						}                                                                                                                // 2137
                                                                                                                       // 2138
						// Incorporate the offset, then check against cycle size                                                         // 2139
						diff -= last;                                                                                                    // 2140
						return diff === first || ( diff % first === 0 && diff / first >= 0 );                                            // 2141
					}                                                                                                                 // 2142
				};                                                                                                                 // 2143
		},                                                                                                                   // 2144
                                                                                                                       // 2145
		"PSEUDO": function( pseudo, argument ) {                                                                             // 2146
			// pseudo-class names are case-insensitive                                                                          // 2147
			// http://www.w3.org/TR/selectors/#pseudo-classes                                                                   // 2148
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters                           // 2149
			// Remember that setFilters inherits from pseudos                                                                   // 2150
			var args,                                                                                                           // 2151
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||                                          // 2152
					Sizzle.error( "unsupported pseudo: " + pseudo );                                                                  // 2153
                                                                                                                       // 2154
			// The user may use createPseudo to indicate that                                                                   // 2155
			// arguments are needed to create the filter function                                                               // 2156
			// just as Sizzle does                                                                                              // 2157
			if ( fn[ expando ] ) {                                                                                              // 2158
				return fn( argument );                                                                                             // 2159
			}                                                                                                                   // 2160
                                                                                                                       // 2161
			// But maintain support for old signatures                                                                          // 2162
			if ( fn.length > 1 ) {                                                                                              // 2163
				args = [ pseudo, pseudo, "", argument ];                                                                           // 2164
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?                                                    // 2165
					markFunction(function( seed, matches ) {                                                                          // 2166
						var idx,                                                                                                         // 2167
							matched = fn( seed, argument ),                                                                                 // 2168
							i = matched.length;                                                                                             // 2169
						while ( i-- ) {                                                                                                  // 2170
							idx = indexOf.call( seed, matched[i] );                                                                         // 2171
							seed[ idx ] = !( matches[ idx ] = matched[i] );                                                                 // 2172
						}                                                                                                                // 2173
					}) :                                                                                                              // 2174
					function( elem ) {                                                                                                // 2175
						return fn( elem, 0, args );                                                                                      // 2176
					};                                                                                                                // 2177
			}                                                                                                                   // 2178
                                                                                                                       // 2179
			return fn;                                                                                                          // 2180
		}                                                                                                                    // 2181
	},                                                                                                                    // 2182
                                                                                                                       // 2183
	pseudos: {                                                                                                            // 2184
		// Potentially complex pseudos                                                                                       // 2185
		"not": markFunction(function( selector ) {                                                                           // 2186
			// Trim the selector passed to compile                                                                              // 2187
			// to avoid treating leading and trailing                                                                           // 2188
			// spaces as combinators                                                                                            // 2189
			var input = [],                                                                                                     // 2190
				results = [],                                                                                                      // 2191
				matcher = compile( selector.replace( rtrim, "$1" ) );                                                              // 2192
                                                                                                                       // 2193
			return matcher[ expando ] ?                                                                                         // 2194
				markFunction(function( seed, matches, context, xml ) {                                                             // 2195
					var elem,                                                                                                         // 2196
						unmatched = matcher( seed, null, xml, [] ),                                                                      // 2197
						i = seed.length;                                                                                                 // 2198
                                                                                                                       // 2199
					// Match elements unmatched by `matcher`                                                                          // 2200
					while ( i-- ) {                                                                                                   // 2201
						if ( (elem = unmatched[i]) ) {                                                                                   // 2202
							seed[i] = !(matches[i] = elem);                                                                                 // 2203
						}                                                                                                                // 2204
					}                                                                                                                 // 2205
				}) :                                                                                                               // 2206
				function( elem, context, xml ) {                                                                                   // 2207
					input[0] = elem;                                                                                                  // 2208
					matcher( input, null, xml, results );                                                                             // 2209
					return !results.pop();                                                                                            // 2210
				};                                                                                                                 // 2211
		}),                                                                                                                  // 2212
                                                                                                                       // 2213
		"has": markFunction(function( selector ) {                                                                           // 2214
			return function( elem ) {                                                                                           // 2215
				return Sizzle( selector, elem ).length > 0;                                                                        // 2216
			};                                                                                                                  // 2217
		}),                                                                                                                  // 2218
                                                                                                                       // 2219
		"contains": markFunction(function( text ) {                                                                          // 2220
			return function( elem ) {                                                                                           // 2221
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;                             // 2222
			};                                                                                                                  // 2223
		}),                                                                                                                  // 2224
                                                                                                                       // 2225
		// "Whether an element is represented by a :lang() selector                                                          // 2226
		// is based solely on the element's language value                                                                   // 2227
		// being equal to the identifier C,                                                                                  // 2228
		// or beginning with the identifier C immediately followed by "-".                                                   // 2229
		// The matching of C against the element's language value is performed case-insensitively.                           // 2230
		// The identifier C does not have to be a valid language name."                                                      // 2231
		// http://www.w3.org/TR/selectors/#lang-pseudo                                                                       // 2232
		"lang": markFunction( function( lang ) {                                                                             // 2233
			// lang value must be a valid identifier                                                                            // 2234
			if ( !ridentifier.test(lang || "") ) {                                                                              // 2235
				Sizzle.error( "unsupported lang: " + lang );                                                                       // 2236
			}                                                                                                                   // 2237
			lang = lang.replace( runescape, funescape ).toLowerCase();                                                          // 2238
			return function( elem ) {                                                                                           // 2239
				var elemLang;                                                                                                      // 2240
				do {                                                                                                               // 2241
					if ( (elemLang = documentIsHTML ?                                                                                 // 2242
						elem.lang :                                                                                                      // 2243
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {                                                  // 2244
                                                                                                                       // 2245
						elemLang = elemLang.toLowerCase();                                                                               // 2246
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;                                                // 2247
					}                                                                                                                 // 2248
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );                                                       // 2249
				return false;                                                                                                      // 2250
			};                                                                                                                  // 2251
		}),                                                                                                                  // 2252
                                                                                                                       // 2253
		// Miscellaneous                                                                                                     // 2254
		"target": function( elem ) {                                                                                         // 2255
			var hash = window.location && window.location.hash;                                                                 // 2256
			return hash && hash.slice( 1 ) === elem.id;                                                                         // 2257
		},                                                                                                                   // 2258
                                                                                                                       // 2259
		"root": function( elem ) {                                                                                           // 2260
			return elem === docElem;                                                                                            // 2261
		},                                                                                                                   // 2262
                                                                                                                       // 2263
		"focus": function( elem ) {                                                                                          // 2264
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},                                                                                                                   // 2266
                                                                                                                       // 2267
		// Boolean properties                                                                                                // 2268
		"enabled": function( elem ) {                                                                                        // 2269
			return elem.disabled === false;                                                                                     // 2270
		},                                                                                                                   // 2271
                                                                                                                       // 2272
		"disabled": function( elem ) {                                                                                       // 2273
			return elem.disabled === true;                                                                                      // 2274
		},                                                                                                                   // 2275
                                                                                                                       // 2276
		"checked": function( elem ) {                                                                                        // 2277
			// In CSS3, :checked should return both checked and selected elements                                               // 2278
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked                                                   // 2279
			var nodeName = elem.nodeName.toLowerCase();                                                                         // 2280
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);                      // 2281
		},                                                                                                                   // 2282
                                                                                                                       // 2283
		"selected": function( elem ) {                                                                                       // 2284
			// Accessing this property makes selected-by-default                                                                // 2285
			// options in Safari work properly                                                                                  // 2286
			if ( elem.parentNode ) {                                                                                            // 2287
				elem.parentNode.selectedIndex;                                                                                     // 2288
			}                                                                                                                   // 2289
                                                                                                                       // 2290
			return elem.selected === true;                                                                                      // 2291
		},                                                                                                                   // 2292
                                                                                                                       // 2293
		// Contents                                                                                                          // 2294
		"empty": function( elem ) {                                                                                          // 2295
			// http://www.w3.org/TR/selectors/#empty-pseudo                                                                     // 2296
			// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),                         // 2297
			//   not comment, processing instructions, or others                                                                // 2298
			// Thanks to Diego Perini for the nodeName shortcut                                                                 // 2299
			//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")                            // 2300
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {                                                     // 2301
				if ( elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4 ) {                                         // 2302
					return false;                                                                                                     // 2303
				}                                                                                                                  // 2304
			}                                                                                                                   // 2305
			return true;                                                                                                        // 2306
		},                                                                                                                   // 2307
                                                                                                                       // 2308
		"parent": function( elem ) {                                                                                         // 2309
			return !Expr.pseudos["empty"]( elem );                                                                              // 2310
		},                                                                                                                   // 2311
                                                                                                                       // 2312
		// Element/input types                                                                                               // 2313
		"header": function( elem ) {                                                                                         // 2314
			return rheader.test( elem.nodeName );                                                                               // 2315
		},                                                                                                                   // 2316
                                                                                                                       // 2317
		"input": function( elem ) {                                                                                          // 2318
			return rinputs.test( elem.nodeName );                                                                               // 2319
		},                                                                                                                   // 2320
                                                                                                                       // 2321
		"button": function( elem ) {                                                                                         // 2322
			var name = elem.nodeName.toLowerCase();                                                                             // 2323
			return name === "input" && elem.type === "button" || name === "button";                                             // 2324
		},                                                                                                                   // 2325
                                                                                                                       // 2326
		"text": function( elem ) {                                                                                           // 2327
			var attr;                                                                                                           // 2328
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)                                         // 2329
			// use getAttribute instead to test this case                                                                       // 2330
			return elem.nodeName.toLowerCase() === "input" &&                                                                   // 2331
				elem.type === "text" &&                                                                                            // 2332
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type );                                // 2333
		},                                                                                                                   // 2334
                                                                                                                       // 2335
		// Position-in-collection                                                                                            // 2336
		"first": createPositionalPseudo(function() {                                                                         // 2337
			return [ 0 ];                                                                                                       // 2338
		}),                                                                                                                  // 2339
                                                                                                                       // 2340
		"last": createPositionalPseudo(function( matchIndexes, length ) {                                                    // 2341
			return [ length - 1 ];                                                                                              // 2342
		}),                                                                                                                  // 2343
                                                                                                                       // 2344
		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {                                            // 2345
			return [ argument < 0 ? argument + length : argument ];                                                             // 2346
		}),                                                                                                                  // 2347
                                                                                                                       // 2348
		"even": createPositionalPseudo(function( matchIndexes, length ) {                                                    // 2349
			var i = 0;                                                                                                          // 2350
			for ( ; i < length; i += 2 ) {                                                                                      // 2351
				matchIndexes.push( i );                                                                                            // 2352
			}                                                                                                                   // 2353
			return matchIndexes;                                                                                                // 2354
		}),                                                                                                                  // 2355
                                                                                                                       // 2356
		"odd": createPositionalPseudo(function( matchIndexes, length ) {                                                     // 2357
			var i = 1;                                                                                                          // 2358
			for ( ; i < length; i += 2 ) {                                                                                      // 2359
				matchIndexes.push( i );                                                                                            // 2360
			}                                                                                                                   // 2361
			return matchIndexes;                                                                                                // 2362
		}),                                                                                                                  // 2363
                                                                                                                       // 2364
		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {                                            // 2365
			var i = argument < 0 ? argument + length : argument;                                                                // 2366
			for ( ; --i >= 0; ) {                                                                                               // 2367
				matchIndexes.push( i );                                                                                            // 2368
			}                                                                                                                   // 2369
			return matchIndexes;                                                                                                // 2370
		}),                                                                                                                  // 2371
                                                                                                                       // 2372
		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {                                            // 2373
			var i = argument < 0 ? argument + length : argument;                                                                // 2374
			for ( ; ++i < length; ) {                                                                                           // 2375
				matchIndexes.push( i );                                                                                            // 2376
			}                                                                                                                   // 2377
			return matchIndexes;                                                                                                // 2378
		})                                                                                                                   // 2379
	}                                                                                                                     // 2380
};                                                                                                                     // 2381
                                                                                                                       // 2382
Expr.pseudos["nth"] = Expr.pseudos["eq"];                                                                              // 2383
                                                                                                                       // 2384
// Add button/input type pseudos                                                                                       // 2385
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {                                // 2386
	Expr.pseudos[ i ] = createInputPseudo( i );                                                                           // 2387
}                                                                                                                      // 2388
for ( i in { submit: true, reset: true } ) {                                                                           // 2389
	Expr.pseudos[ i ] = createButtonPseudo( i );                                                                          // 2390
}                                                                                                                      // 2391
                                                                                                                       // 2392
// Easy API for creating new setFilters                                                                                // 2393
function setFilters() {}                                                                                               // 2394
setFilters.prototype = Expr.filters = Expr.pseudos;                                                                    // 2395
Expr.setFilters = new setFilters();                                                                                    // 2396
                                                                                                                       // 2397
function tokenize( selector, parseOnly ) {                                                                             // 2398
	var matched, match, tokens, type,                                                                                     // 2399
		soFar, groups, preFilters,                                                                                           // 2400
		cached = tokenCache[ selector + " " ];                                                                               // 2401
                                                                                                                       // 2402
	if ( cached ) {                                                                                                       // 2403
		return parseOnly ? 0 : cached.slice( 0 );                                                                            // 2404
	}                                                                                                                     // 2405
                                                                                                                       // 2406
	soFar = selector;                                                                                                     // 2407
	groups = [];                                                                                                          // 2408
	preFilters = Expr.preFilter;                                                                                          // 2409
                                                                                                                       // 2410
	while ( soFar ) {                                                                                                     // 2411
                                                                                                                       // 2412
		// Comma and first run                                                                                               // 2413
		if ( !matched || (match = rcomma.exec( soFar )) ) {                                                                  // 2414
			if ( match ) {                                                                                                      // 2415
				// Don't consume trailing commas as valid                                                                          // 2416
				soFar = soFar.slice( match[0].length ) || soFar;                                                                   // 2417
			}                                                                                                                   // 2418
			groups.push( tokens = [] );                                                                                         // 2419
		}                                                                                                                    // 2420
                                                                                                                       // 2421
		matched = false;                                                                                                     // 2422
                                                                                                                       // 2423
		// Combinators                                                                                                       // 2424
		if ( (match = rcombinators.exec( soFar )) ) {                                                                        // 2425
			matched = match.shift();                                                                                            // 2426
			tokens.push({                                                                                                       // 2427
				value: matched,                                                                                                    // 2428
				// Cast descendant combinators to space                                                                            // 2429
				type: match[0].replace( rtrim, " " )                                                                               // 2430
			});                                                                                                                 // 2431
			soFar = soFar.slice( matched.length );                                                                              // 2432
		}                                                                                                                    // 2433
                                                                                                                       // 2434
		// Filters                                                                                                           // 2435
		for ( type in Expr.filter ) {                                                                                        // 2436
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||                                           // 2437
				(match = preFilters[ type ]( match ))) ) {                                                                         // 2438
				matched = match.shift();                                                                                           // 2439
				tokens.push({                                                                                                      // 2440
					value: matched,                                                                                                   // 2441
					type: type,                                                                                                       // 2442
					matches: match                                                                                                    // 2443
				});                                                                                                                // 2444
				soFar = soFar.slice( matched.length );                                                                             // 2445
			}                                                                                                                   // 2446
		}                                                                                                                    // 2447
                                                                                                                       // 2448
		if ( !matched ) {                                                                                                    // 2449
			break;                                                                                                              // 2450
		}                                                                                                                    // 2451
	}                                                                                                                     // 2452
                                                                                                                       // 2453
	// Return the length of the invalid excess                                                                            // 2454
	// if we're just parsing                                                                                              // 2455
	// Otherwise, throw an error or return tokens                                                                         // 2456
	return parseOnly ?                                                                                                    // 2457
		soFar.length :                                                                                                       // 2458
		soFar ?                                                                                                              // 2459
			Sizzle.error( selector ) :                                                                                          // 2460
			// Cache the tokens                                                                                                 // 2461
			tokenCache( selector, groups ).slice( 0 );                                                                          // 2462
}                                                                                                                      // 2463
                                                                                                                       // 2464
function toSelector( tokens ) {                                                                                        // 2465
	var i = 0,                                                                                                            // 2466
		len = tokens.length,                                                                                                 // 2467
		selector = "";                                                                                                       // 2468
	for ( ; i < len; i++ ) {                                                                                              // 2469
		selector += tokens[i].value;                                                                                         // 2470
	}                                                                                                                     // 2471
	return selector;                                                                                                      // 2472
}                                                                                                                      // 2473
                                                                                                                       // 2474
function addCombinator( matcher, combinator, base ) {                                                                  // 2475
	var dir = combinator.dir,                                                                                             // 2476
		checkNonElements = base && dir === "parentNode",                                                                     // 2477
		doneName = done++;                                                                                                   // 2478
                                                                                                                       // 2479
	return combinator.first ?                                                                                             // 2480
		// Check against closest ancestor/preceding element                                                                  // 2481
		function( elem, context, xml ) {                                                                                     // 2482
			while ( (elem = elem[ dir ]) ) {                                                                                    // 2483
				if ( elem.nodeType === 1 || checkNonElements ) {                                                                   // 2484
					return matcher( elem, context, xml );                                                                             // 2485
				}                                                                                                                  // 2486
			}                                                                                                                   // 2487
		} :                                                                                                                  // 2488
                                                                                                                       // 2489
		// Check against all ancestor/preceding elements                                                                     // 2490
		function( elem, context, xml ) {                                                                                     // 2491
			var data, cache, outerCache,                                                                                        // 2492
				dirkey = dirruns + " " + doneName;                                                                                 // 2493
                                                                                                                       // 2494
			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching                                 // 2495
			if ( xml ) {                                                                                                        // 2496
				while ( (elem = elem[ dir ]) ) {                                                                                   // 2497
					if ( elem.nodeType === 1 || checkNonElements ) {                                                                  // 2498
						if ( matcher( elem, context, xml ) ) {                                                                           // 2499
							return true;                                                                                                    // 2500
						}                                                                                                                // 2501
					}                                                                                                                 // 2502
				}                                                                                                                  // 2503
			} else {                                                                                                            // 2504
				while ( (elem = elem[ dir ]) ) {                                                                                   // 2505
					if ( elem.nodeType === 1 || checkNonElements ) {                                                                  // 2506
						outerCache = elem[ expando ] || (elem[ expando ] = {});                                                          // 2507
						if ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {                                                      // 2508
							if ( (data = cache[1]) === true || data === cachedruns ) {                                                      // 2509
								return data === true;                                                                                          // 2510
							}                                                                                                               // 2511
						} else {                                                                                                         // 2512
							cache = outerCache[ dir ] = [ dirkey ];                                                                         // 2513
							cache[1] = matcher( elem, context, xml ) || cachedruns;                                                         // 2514
							if ( cache[1] === true ) {                                                                                      // 2515
								return true;                                                                                                   // 2516
							}                                                                                                               // 2517
						}                                                                                                                // 2518
					}                                                                                                                 // 2519
				}                                                                                                                  // 2520
			}                                                                                                                   // 2521
		};                                                                                                                   // 2522
}                                                                                                                      // 2523
                                                                                                                       // 2524
function elementMatcher( matchers ) {                                                                                  // 2525
	return matchers.length > 1 ?                                                                                          // 2526
		function( elem, context, xml ) {                                                                                     // 2527
			var i = matchers.length;                                                                                            // 2528
			while ( i-- ) {                                                                                                     // 2529
				if ( !matchers[i]( elem, context, xml ) ) {                                                                        // 2530
					return false;                                                                                                     // 2531
				}                                                                                                                  // 2532
			}                                                                                                                   // 2533
			return true;                                                                                                        // 2534
		} :                                                                                                                  // 2535
		matchers[0];                                                                                                         // 2536
}                                                                                                                      // 2537
                                                                                                                       // 2538
function condense( unmatched, map, filter, context, xml ) {                                                            // 2539
	var elem,                                                                                                             // 2540
		newUnmatched = [],                                                                                                   // 2541
		i = 0,                                                                                                               // 2542
		len = unmatched.length,                                                                                              // 2543
		mapped = map != null;                                                                                                // 2544
                                                                                                                       // 2545
	for ( ; i < len; i++ ) {                                                                                              // 2546
		if ( (elem = unmatched[i]) ) {                                                                                       // 2547
			if ( !filter || filter( elem, context, xml ) ) {                                                                    // 2548
				newUnmatched.push( elem );                                                                                         // 2549
				if ( mapped ) {                                                                                                    // 2550
					map.push( i );                                                                                                    // 2551
				}                                                                                                                  // 2552
			}                                                                                                                   // 2553
		}                                                                                                                    // 2554
	}                                                                                                                     // 2555
                                                                                                                       // 2556
	return newUnmatched;                                                                                                  // 2557
}                                                                                                                      // 2558
                                                                                                                       // 2559
function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {                            // 2560
	if ( postFilter && !postFilter[ expando ] ) {                                                                         // 2561
		postFilter = setMatcher( postFilter );                                                                               // 2562
	}                                                                                                                     // 2563
	if ( postFinder && !postFinder[ expando ] ) {                                                                         // 2564
		postFinder = setMatcher( postFinder, postSelector );                                                                 // 2565
	}                                                                                                                     // 2566
	return markFunction(function( seed, results, context, xml ) {                                                         // 2567
		var temp, i, elem,                                                                                                   // 2568
			preMap = [],                                                                                                        // 2569
			postMap = [],                                                                                                       // 2570
			preexisting = results.length,                                                                                       // 2571
                                                                                                                       // 2572
			// Get initial elements from seed or context                                                                        // 2573
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),                  // 2574
                                                                                                                       // 2575
			// Prefilter to get matcher input, preserving a map for seed-results synchronization                                // 2576
			matcherIn = preFilter && ( seed || !selector ) ?                                                                    // 2577
				condense( elems, preMap, preFilter, context, xml ) :                                                               // 2578
				elems,                                                                                                             // 2579
                                                                                                                       // 2580
			matcherOut = matcher ?                                                                                              // 2581
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,                       // 2582
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?                                                   // 2583
                                                                                                                       // 2584
					// ...intermediate processing is necessary                                                                        // 2585
					[] :                                                                                                              // 2586
                                                                                                                       // 2587
					// ...otherwise use results directly                                                                              // 2588
					results :                                                                                                         // 2589
				matcherIn;                                                                                                         // 2590
                                                                                                                       // 2591
		// Find primary matches                                                                                              // 2592
		if ( matcher ) {                                                                                                     // 2593
			matcher( matcherIn, matcherOut, context, xml );                                                                     // 2594
		}                                                                                                                    // 2595
                                                                                                                       // 2596
		// Apply postFilter                                                                                                  // 2597
		if ( postFilter ) {                                                                                                  // 2598
			temp = condense( matcherOut, postMap );                                                                             // 2599
			postFilter( temp, [], context, xml );                                                                               // 2600
                                                                                                                       // 2601
			// Un-match failing elements by moving them back to matcherIn                                                       // 2602
			i = temp.length;                                                                                                    // 2603
			while ( i-- ) {                                                                                                     // 2604
				if ( (elem = temp[i]) ) {                                                                                          // 2605
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);                                                     // 2606
				}                                                                                                                  // 2607
			}                                                                                                                   // 2608
		}                                                                                                                    // 2609
                                                                                                                       // 2610
		if ( seed ) {                                                                                                        // 2611
			if ( postFinder || preFilter ) {                                                                                    // 2612
				if ( postFinder ) {                                                                                                // 2613
					// Get the final matcherOut by condensing this intermediate into postFinder contexts                              // 2614
					temp = [];                                                                                                        // 2615
					i = matcherOut.length;                                                                                            // 2616
					while ( i-- ) {                                                                                                   // 2617
						if ( (elem = matcherOut[i]) ) {                                                                                  // 2618
							// Restore matcherIn since elem is not yet a final match                                                        // 2619
							temp.push( (matcherIn[i] = elem) );                                                                             // 2620
						}                                                                                                                // 2621
					}                                                                                                                 // 2622
					postFinder( null, (matcherOut = []), temp, xml );                                                                 // 2623
				}                                                                                                                  // 2624
                                                                                                                       // 2625
				// Move matched elements from seed to results to keep them synchronized                                            // 2626
				i = matcherOut.length;                                                                                             // 2627
				while ( i-- ) {                                                                                                    // 2628
					if ( (elem = matcherOut[i]) &&                                                                                    // 2629
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {                                            // 2630
                                                                                                                       // 2631
						seed[temp] = !(results[temp] = elem);                                                                            // 2632
					}                                                                                                                 // 2633
				}                                                                                                                  // 2634
			}                                                                                                                   // 2635
                                                                                                                       // 2636
		// Add elements to results, through postFinder if defined                                                            // 2637
		} else {                                                                                                             // 2638
			matcherOut = condense(                                                                                              // 2639
				matcherOut === results ?                                                                                           // 2640
					matcherOut.splice( preexisting, matcherOut.length ) :                                                             // 2641
					matcherOut                                                                                                        // 2642
			);                                                                                                                  // 2643
			if ( postFinder ) {                                                                                                 // 2644
				postFinder( null, results, matcherOut, xml );                                                                      // 2645
			} else {                                                                                                            // 2646
				push.apply( results, matcherOut );                                                                                 // 2647
			}                                                                                                                   // 2648
		}                                                                                                                    // 2649
	});                                                                                                                   // 2650
}                                                                                                                      // 2651
                                                                                                                       // 2652
function matcherFromTokens( tokens ) {                                                                                 // 2653
	var checkContext, matcher, j,                                                                                         // 2654
		len = tokens.length,                                                                                                 // 2655
		leadingRelative = Expr.relative[ tokens[0].type ],                                                                   // 2656
		implicitRelative = leadingRelative || Expr.relative[" "],                                                            // 2657
		i = leadingRelative ? 1 : 0,                                                                                         // 2658
                                                                                                                       // 2659
		// The foundational matcher ensures that elements are reachable from top-level context(s)                            // 2660
		matchContext = addCombinator( function( elem ) {                                                                     // 2661
			return elem === checkContext;                                                                                       // 2662
		}, implicitRelative, true ),                                                                                         // 2663
		matchAnyContext = addCombinator( function( elem ) {                                                                  // 2664
			return indexOf.call( checkContext, elem ) > -1;                                                                     // 2665
		}, implicitRelative, true ),                                                                                         // 2666
		matchers = [ function( elem, context, xml ) {                                                                        // 2667
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (                                         // 2668
				(checkContext = context).nodeType ?                                                                                // 2669
					matchContext( elem, context, xml ) :                                                                              // 2670
					matchAnyContext( elem, context, xml ) );                                                                          // 2671
		} ];                                                                                                                 // 2672
                                                                                                                       // 2673
	for ( ; i < len; i++ ) {                                                                                              // 2674
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {                                                                 // 2675
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];                                                  // 2676
		} else {                                                                                                             // 2677
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );                                           // 2678
                                                                                                                       // 2679
			// Return special upon seeing a positional matcher                                                                  // 2680
			if ( matcher[ expando ] ) {                                                                                         // 2681
				// Find the next relative operator (if any) for proper handling                                                    // 2682
				j = ++i;                                                                                                           // 2683
				for ( ; j < len; j++ ) {                                                                                           // 2684
					if ( Expr.relative[ tokens[j].type ] ) {                                                                          // 2685
						break;                                                                                                           // 2686
					}                                                                                                                 // 2687
				}                                                                                                                  // 2688
				return setMatcher(                                                                                                 // 2689
					i > 1 && elementMatcher( matchers ),                                                                              // 2690
					i > 1 && toSelector(                                                                                              // 2691
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`                        // 2692
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })                              // 2693
					).replace( rtrim, "$1" ),                                                                                         // 2694
					matcher,                                                                                                          // 2695
					i < j && matcherFromTokens( tokens.slice( i, j ) ),                                                               // 2696
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),                                                     // 2697
					j < len && toSelector( tokens )                                                                                   // 2698
				);                                                                                                                 // 2699
			}                                                                                                                   // 2700
			matchers.push( matcher );                                                                                           // 2701
		}                                                                                                                    // 2702
	}                                                                                                                     // 2703
                                                                                                                       // 2704
	return elementMatcher( matchers );                                                                                    // 2705
}                                                                                                                      // 2706
                                                                                                                       // 2707
function matcherFromGroupMatchers( elementMatchers, setMatchers ) {                                                    // 2708
	// A counter to specify which element is currently being matched                                                      // 2709
	var matcherCachedRuns = 0,                                                                                            // 2710
		bySet = setMatchers.length > 0,                                                                                      // 2711
		byElement = elementMatchers.length > 0,                                                                              // 2712
		superMatcher = function( seed, context, xml, results, expandContext ) {                                              // 2713
			var elem, j, matcher,                                                                                               // 2714
				setMatched = [],                                                                                                   // 2715
				matchedCount = 0,                                                                                                  // 2716
				i = "0",                                                                                                           // 2717
				unmatched = seed && [],                                                                                            // 2718
				outermost = expandContext != null,                                                                                 // 2719
				contextBackup = outermostContext,                                                                                  // 2720
				// We must always have either seed elements or context                                                             // 2721
				elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),              // 2722
				// Use integer dirruns iff this is the outermost matcher                                                           // 2723
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);                                     // 2724
                                                                                                                       // 2725
			if ( outermost ) {                                                                                                  // 2726
				outermostContext = context !== document && context;                                                                // 2727
				cachedruns = matcherCachedRuns;                                                                                    // 2728
			}                                                                                                                   // 2729
                                                                                                                       // 2730
			// Add elements passing elementMatchers directly to results                                                         // 2731
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below                                  // 2732
			for ( ; (elem = elems[i]) != null; i++ ) {                                                                          // 2733
				if ( byElement && elem ) {                                                                                         // 2734
					j = 0;                                                                                                            // 2735
					while ( (matcher = elementMatchers[j++]) ) {                                                                      // 2736
						if ( matcher( elem, context, xml ) ) {                                                                           // 2737
							results.push( elem );                                                                                           // 2738
							break;                                                                                                          // 2739
						}                                                                                                                // 2740
					}                                                                                                                 // 2741
					if ( outermost ) {                                                                                                // 2742
						dirruns = dirrunsUnique;                                                                                         // 2743
						cachedruns = ++matcherCachedRuns;                                                                                // 2744
					}                                                                                                                 // 2745
				}                                                                                                                  // 2746
                                                                                                                       // 2747
				// Track unmatched elements for set filters                                                                        // 2748
				if ( bySet ) {                                                                                                     // 2749
					// They will have gone through all possible matchers                                                              // 2750
					if ( (elem = !matcher && elem) ) {                                                                                // 2751
						matchedCount--;                                                                                                  // 2752
					}                                                                                                                 // 2753
                                                                                                                       // 2754
					// Lengthen the array for every element, matched or not                                                           // 2755
					if ( seed ) {                                                                                                     // 2756
						unmatched.push( elem );                                                                                          // 2757
					}                                                                                                                 // 2758
				}                                                                                                                  // 2759
			}                                                                                                                   // 2760
                                                                                                                       // 2761
			// Apply set filters to unmatched elements                                                                          // 2762
			matchedCount += i;                                                                                                  // 2763
			if ( bySet && i !== matchedCount ) {                                                                                // 2764
				j = 0;                                                                                                             // 2765
				while ( (matcher = setMatchers[j++]) ) {                                                                           // 2766
					matcher( unmatched, setMatched, context, xml );                                                                   // 2767
				}                                                                                                                  // 2768
                                                                                                                       // 2769
				if ( seed ) {                                                                                                      // 2770
					// Reintegrate element matches to eliminate the need for sorting                                                  // 2771
					if ( matchedCount > 0 ) {                                                                                         // 2772
						while ( i-- ) {                                                                                                  // 2773
							if ( !(unmatched[i] || setMatched[i]) ) {                                                                       // 2774
								setMatched[i] = pop.call( results );                                                                           // 2775
							}                                                                                                               // 2776
						}                                                                                                                // 2777
					}                                                                                                                 // 2778
                                                                                                                       // 2779
					// Discard index placeholder values to get only actual matches                                                    // 2780
					setMatched = condense( setMatched );                                                                              // 2781
				}                                                                                                                  // 2782
                                                                                                                       // 2783
				// Add matches to results                                                                                          // 2784
				push.apply( results, setMatched );                                                                                 // 2785
                                                                                                                       // 2786
				// Seedless set matches succeeding multiple successful matchers stipulate sorting                                  // 2787
				if ( outermost && !seed && setMatched.length > 0 &&                                                                // 2788
					( matchedCount + setMatchers.length ) > 1 ) {                                                                     // 2789
                                                                                                                       // 2790
					Sizzle.uniqueSort( results );                                                                                     // 2791
				}                                                                                                                  // 2792
			}                                                                                                                   // 2793
                                                                                                                       // 2794
			// Override manipulation of globals by nested matchers                                                              // 2795
			if ( outermost ) {                                                                                                  // 2796
				dirruns = dirrunsUnique;                                                                                           // 2797
				outermostContext = contextBackup;                                                                                  // 2798
			}                                                                                                                   // 2799
                                                                                                                       // 2800
			return unmatched;                                                                                                   // 2801
		};                                                                                                                   // 2802
                                                                                                                       // 2803
	return bySet ?                                                                                                        // 2804
		markFunction( superMatcher ) :                                                                                       // 2805
		superMatcher;                                                                                                        // 2806
}                                                                                                                      // 2807
                                                                                                                       // 2808
compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {                                       // 2809
	var i,                                                                                                                // 2810
		setMatchers = [],                                                                                                    // 2811
		elementMatchers = [],                                                                                                // 2812
		cached = compilerCache[ selector + " " ];                                                                            // 2813
                                                                                                                       // 2814
	if ( !cached ) {                                                                                                      // 2815
		// Generate a function of recursive functions that can be used to check each element                                 // 2816
		if ( !group ) {                                                                                                      // 2817
			group = tokenize( selector );                                                                                       // 2818
		}                                                                                                                    // 2819
		i = group.length;                                                                                                    // 2820
		while ( i-- ) {                                                                                                      // 2821
			cached = matcherFromTokens( group[i] );                                                                             // 2822
			if ( cached[ expando ] ) {                                                                                          // 2823
				setMatchers.push( cached );                                                                                        // 2824
			} else {                                                                                                            // 2825
				elementMatchers.push( cached );                                                                                    // 2826
			}                                                                                                                   // 2827
		}                                                                                                                    // 2828
                                                                                                                       // 2829
		// Cache the compiled function                                                                                       // 2830
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );                        // 2831
	}                                                                                                                     // 2832
	return cached;                                                                                                        // 2833
};                                                                                                                     // 2834
                                                                                                                       // 2835
function multipleContexts( selector, contexts, results ) {                                                             // 2836
	var i = 0,                                                                                                            // 2837
		len = contexts.length;                                                                                               // 2838
	for ( ; i < len; i++ ) {                                                                                              // 2839
		Sizzle( selector, contexts[i], results );                                                                            // 2840
	}                                                                                                                     // 2841
	return results;                                                                                                       // 2842
}                                                                                                                      // 2843
                                                                                                                       // 2844
function select( selector, context, results, seed ) {                                                                  // 2845
	var i, tokens, token, type, find,                                                                                     // 2846
		match = tokenize( selector );                                                                                        // 2847
                                                                                                                       // 2848
	if ( !seed ) {                                                                                                        // 2849
		// Try to minimize operations if there is only one group                                                             // 2850
		if ( match.length === 1 ) {                                                                                          // 2851
                                                                                                                       // 2852
			// Take a shortcut and set the context if the root selector is an ID                                                // 2853
			tokens = match[0] = match[0].slice( 0 );                                                                            // 2854
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&                                                      // 2855
					support.getById && context.nodeType === 9 && documentIsHTML &&                                                    // 2856
					Expr.relative[ tokens[1].type ] ) {                                                                               // 2857
                                                                                                                       // 2858
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];                 // 2859
				if ( !context ) {                                                                                                  // 2860
					return results;                                                                                                   // 2861
				}                                                                                                                  // 2862
				selector = selector.slice( tokens.shift().value.length );                                                          // 2863
			}                                                                                                                   // 2864
                                                                                                                       // 2865
			// Fetch a seed set for right-to-left matching                                                                      // 2866
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;                                                 // 2867
			while ( i-- ) {                                                                                                     // 2868
				token = tokens[i];                                                                                                 // 2869
                                                                                                                       // 2870
				// Abort if we hit a combinator                                                                                    // 2871
				if ( Expr.relative[ (type = token.type) ] ) {                                                                      // 2872
					break;                                                                                                            // 2873
				}                                                                                                                  // 2874
				if ( (find = Expr.find[ type ]) ) {                                                                                // 2875
					// Search, expanding context for leading sibling combinators                                                      // 2876
					if ( (seed = find(                                                                                                // 2877
						token.matches[0].replace( runescape, funescape ),                                                                // 2878
						rsibling.test( tokens[0].type ) && context.parentNode || context                                                 // 2879
					)) ) {                                                                                                            // 2880
                                                                                                                       // 2881
						// If seed is empty or no tokens remain, we can return early                                                     // 2882
						tokens.splice( i, 1 );                                                                                           // 2883
						selector = seed.length && toSelector( tokens );                                                                  // 2884
						if ( !selector ) {                                                                                               // 2885
							push.apply( results, seed );                                                                                    // 2886
							return results;                                                                                                 // 2887
						}                                                                                                                // 2888
                                                                                                                       // 2889
						break;                                                                                                           // 2890
					}                                                                                                                 // 2891
				}                                                                                                                  // 2892
			}                                                                                                                   // 2893
		}                                                                                                                    // 2894
	}                                                                                                                     // 2895
                                                                                                                       // 2896
	// Compile and execute a filtering function                                                                           // 2897
	// Provide `match` to avoid retokenization if we modified the selector above                                          // 2898
	compile( selector, match )(                                                                                           // 2899
		seed,                                                                                                                // 2900
		context,                                                                                                             // 2901
		!documentIsHTML,                                                                                                     // 2902
		results,                                                                                                             // 2903
		rsibling.test( selector )                                                                                            // 2904
	);                                                                                                                    // 2905
	return results;                                                                                                       // 2906
}                                                                                                                      // 2907
                                                                                                                       // 2908
// One-time assignments                                                                                                // 2909
                                                                                                                       // 2910
// Sort stability                                                                                                      // 2911
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;                                         // 2912
                                                                                                                       // 2913
// Support: Chrome<14                                                                                                  // 2914
// Always assume duplicates if they aren't passed to the comparison function                                           // 2915
support.detectDuplicates = hasDuplicate;                                                                               // 2916
                                                                                                                       // 2917
// Initialize against the default document                                                                             // 2918
setDocument();                                                                                                         // 2919
                                                                                                                       // 2920
// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)                                                // 2921
// Detached nodes confoundingly follow *each other*                                                                    // 2922
support.sortDetached = assert(function( div1 ) {                                                                       // 2923
	// Should return 1, but returns 4 (following)                                                                         // 2924
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;                                             // 2925
});                                                                                                                    // 2926
                                                                                                                       // 2927
// Support: IE<8                                                                                                       // 2928
// Prevent attribute/property "interpolation"                                                                          // 2929
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx                                                    // 2930
if ( !assert(function( div ) {                                                                                         // 2931
	div.innerHTML = "<a href='#'></a>";                                                                                   // 2932
	return div.firstChild.getAttribute("href") === "#" ;                                                                  // 2933
}) ) {                                                                                                                 // 2934
	addHandle( "type|href|height|width", function( elem, name, isXML ) {                                                  // 2935
		if ( !isXML ) {                                                                                                      // 2936
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );                                            // 2937
		}                                                                                                                    // 2938
	});                                                                                                                   // 2939
}                                                                                                                      // 2940
                                                                                                                       // 2941
// Support: IE<9                                                                                                       // 2942
// Use defaultValue in place of getAttribute("value")                                                                  // 2943
if ( !support.attributes || !assert(function( div ) {                                                                  // 2944
	div.innerHTML = "<input/>";                                                                                           // 2945
	div.firstChild.setAttribute( "value", "" );                                                                           // 2946
	return div.firstChild.getAttribute( "value" ) === "";                                                                 // 2947
}) ) {                                                                                                                 // 2948
	addHandle( "value", function( elem, name, isXML ) {                                                                   // 2949
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {                                                           // 2950
			return elem.defaultValue;                                                                                           // 2951
		}                                                                                                                    // 2952
	});                                                                                                                   // 2953
}                                                                                                                      // 2954
                                                                                                                       // 2955
// Support: IE<9                                                                                                       // 2956
// Use getAttributeNode to fetch booleans when getAttribute lies                                                       // 2957
if ( !assert(function( div ) {                                                                                         // 2958
	return div.getAttribute("disabled") == null;                                                                          // 2959
}) ) {                                                                                                                 // 2960
	addHandle( booleans, function( elem, name, isXML ) {                                                                  // 2961
		var val;                                                                                                             // 2962
		if ( !isXML ) {                                                                                                      // 2963
			return (val = elem.getAttributeNode( name )) && val.specified ?                                                     // 2964
				val.value :                                                                                                        // 2965
				elem[ name ] === true ? name.toLowerCase() : null;                                                                 // 2966
		}                                                                                                                    // 2967
	});                                                                                                                   // 2968
}                                                                                                                      // 2969
                                                                                                                       // 2970
jQuery.find = Sizzle;                                                                                                  // 2971
jQuery.expr = Sizzle.selectors;                                                                                        // 2972
jQuery.expr[":"] = jQuery.expr.pseudos;                                                                                // 2973
jQuery.unique = Sizzle.uniqueSort;                                                                                     // 2974
jQuery.text = Sizzle.getText;                                                                                          // 2975
jQuery.isXMLDoc = Sizzle.isXML;                                                                                        // 2976
jQuery.contains = Sizzle.contains;                                                                                     // 2977
                                                                                                                       // 2978
                                                                                                                       // 2979
})( window );                                                                                                          // 2980
// String to Object options format cache                                                                               // 2981
var optionsCache = {};                                                                                                 // 2982
                                                                                                                       // 2983
// Convert String-formatted options into Object-formatted ones and store in cache                                      // 2984
function createOptions( options ) {                                                                                    // 2985
	var object = optionsCache[ options ] = {};                                                                            // 2986
	jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {                                             // 2987
		object[ flag ] = true;                                                                                               // 2988
	});                                                                                                                   // 2989
	return object;                                                                                                        // 2990
}                                                                                                                      // 2991
                                                                                                                       // 2992
/*                                                                                                                     // 2993
 * Create a callback list using the following parameters:                                                              // 2994
 *                                                                                                                     // 2995
 *	options: an optional list of space-separated options that will change how                                           // 2996
 *			the callback list behaves or a more traditional option object                                                     // 2997
 *                                                                                                                     // 2998
 * By default a callback list will act like an event callback list and can be                                          // 2999
 * "fired" multiple times.                                                                                             // 3000
 *                                                                                                                     // 3001
 * Possible options:                                                                                                   // 3002
 *                                                                                                                     // 3003
 *	once:			will ensure the callback list can only be fired once (like a Deferred)                                      // 3004
 *                                                                                                                     // 3005
 *	memory:			will keep track of previous values and will call any callback added                                       // 3006
 *					after the list has been fired right away with the latest "memorized"                                            // 3007
 *					values (like a Deferred)                                                                                        // 3008
 *                                                                                                                     // 3009
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)                                  // 3010
 *                                                                                                                     // 3011
 *	stopOnFalse:	interrupt callings when a callback returns false                                                       // 3012
 *                                                                                                                     // 3013
 */                                                                                                                    // 3014
jQuery.Callbacks = function( options ) {                                                                               // 3015
                                                                                                                       // 3016
	// Convert options from String-formatted to Object-formatted if needed                                                // 3017
	// (we check in cache first)                                                                                          // 3018
	options = typeof options === "string" ?                                                                               // 3019
		( optionsCache[ options ] || createOptions( options ) ) :                                                            // 3020
		jQuery.extend( {}, options );                                                                                        // 3021
                                                                                                                       // 3022
	var // Flag to know if list is currently firing                                                                       // 3023
		firing,                                                                                                              // 3024
		// Last fire value (for non-forgettable lists)                                                                       // 3025
		memory,                                                                                                              // 3026
		// Flag to know if list was already fired                                                                            // 3027
		fired,                                                                                                               // 3028
		// End of the loop when firing                                                                                       // 3029
		firingLength,                                                                                                        // 3030
		// Index of currently firing callback (modified by remove if needed)                                                 // 3031
		firingIndex,                                                                                                         // 3032
		// First callback to fire (used internally by add and fireWith)                                                      // 3033
		firingStart,                                                                                                         // 3034
		// Actual callback list                                                                                              // 3035
		list = [],                                                                                                           // 3036
		// Stack of fire calls for repeatable lists                                                                          // 3037
		stack = !options.once && [],                                                                                         // 3038
		// Fire callbacks                                                                                                    // 3039
		fire = function( data ) {                                                                                            // 3040
			memory = options.memory && data;                                                                                    // 3041
			fired = true;                                                                                                       // 3042
			firingIndex = firingStart || 0;                                                                                     // 3043
			firingStart = 0;                                                                                                    // 3044
			firingLength = list.length;                                                                                         // 3045
			firing = true;                                                                                                      // 3046
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {                                                       // 3047
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {                        // 3048
					memory = false; // To prevent further calls using add                                                             // 3049
					break;                                                                                                            // 3050
				}                                                                                                                  // 3051
			}                                                                                                                   // 3052
			firing = false;                                                                                                     // 3053
			if ( list ) {                                                                                                       // 3054
				if ( stack ) {                                                                                                     // 3055
					if ( stack.length ) {                                                                                             // 3056
						fire( stack.shift() );                                                                                           // 3057
					}                                                                                                                 // 3058
				} else if ( memory ) {                                                                                             // 3059
					list = [];                                                                                                        // 3060
				} else {                                                                                                           // 3061
					self.disable();                                                                                                   // 3062
				}                                                                                                                  // 3063
			}                                                                                                                   // 3064
		},                                                                                                                   // 3065
		// Actual Callbacks object                                                                                           // 3066
		self = {                                                                                                             // 3067
			// Add a callback or a collection of callbacks to the list                                                          // 3068
			add: function() {                                                                                                   // 3069
				if ( list ) {                                                                                                      // 3070
					// First, we save the current length                                                                              // 3071
					var start = list.length;                                                                                          // 3072
					(function add( args ) {                                                                                           // 3073
						jQuery.each( args, function( _, arg ) {                                                                          // 3074
							var type = jQuery.type( arg );                                                                                  // 3075
							if ( type === "function" ) {                                                                                    // 3076
								if ( !options.unique || !self.has( arg ) ) {                                                                   // 3077
									list.push( arg );                                                                                             // 3078
								}                                                                                                              // 3079
							} else if ( arg && arg.length && type !== "string" ) {                                                          // 3080
								// Inspect recursively                                                                                         // 3081
								add( arg );                                                                                                    // 3082
							}                                                                                                               // 3083
						});                                                                                                              // 3084
					})( arguments );                                                                                                  // 3085
					// Do we need to add the callbacks to the                                                                         // 3086
					// current firing batch?                                                                                          // 3087
					if ( firing ) {                                                                                                   // 3088
						firingLength = list.length;                                                                                      // 3089
					// With memory, if we're not firing then                                                                          // 3090
					// we should call right away                                                                                      // 3091
					} else if ( memory ) {                                                                                            // 3092
						firingStart = start;                                                                                             // 3093
						fire( memory );                                                                                                  // 3094
					}                                                                                                                 // 3095
				}                                                                                                                  // 3096
				return this;                                                                                                       // 3097
			},                                                                                                                  // 3098
			// Remove a callback from the list                                                                                  // 3099
			remove: function() {                                                                                                // 3100
				if ( list ) {                                                                                                      // 3101
					jQuery.each( arguments, function( _, arg ) {                                                                      // 3102
						var index;                                                                                                       // 3103
						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {                                                   // 3104
							list.splice( index, 1 );                                                                                        // 3105
							// Handle firing indexes                                                                                        // 3106
							if ( firing ) {                                                                                                 // 3107
								if ( index <= firingLength ) {                                                                                 // 3108
									firingLength--;                                                                                               // 3109
								}                                                                                                              // 3110
								if ( index <= firingIndex ) {                                                                                  // 3111
									firingIndex--;                                                                                                // 3112
								}                                                                                                              // 3113
							}                                                                                                               // 3114
						}                                                                                                                // 3115
					});                                                                                                               // 3116
				}                                                                                                                  // 3117
				return this;                                                                                                       // 3118
			},                                                                                                                  // 3119
			// Check if a given callback is in the list.                                                                        // 3120
			// If no argument is given, return whether or not list has callbacks attached.                                      // 3121
			has: function( fn ) {                                                                                               // 3122
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );                                           // 3123
			},                                                                                                                  // 3124
			// Remove all callbacks from the list                                                                               // 3125
			empty: function() {                                                                                                 // 3126
				list = [];                                                                                                         // 3127
				firingLength = 0;                                                                                                  // 3128
				return this;                                                                                                       // 3129
			},                                                                                                                  // 3130
			// Have the list do nothing anymore                                                                                 // 3131
			disable: function() {                                                                                               // 3132
				list = stack = memory = undefined;                                                                                 // 3133
				return this;                                                                                                       // 3134
			},                                                                                                                  // 3135
			// Is it disabled?                                                                                                  // 3136
			disabled: function() {                                                                                              // 3137
				return !list;                                                                                                      // 3138
			},                                                                                                                  // 3139
			// Lock the list in its current state                                                                               // 3140
			lock: function() {                                                                                                  // 3141
				stack = undefined;                                                                                                 // 3142
				if ( !memory ) {                                                                                                   // 3143
					self.disable();                                                                                                   // 3144
				}                                                                                                                  // 3145
				return this;                                                                                                       // 3146
			},                                                                                                                  // 3147
			// Is it locked?                                                                                                    // 3148
			locked: function() {                                                                                                // 3149
				return !stack;                                                                                                     // 3150
			},                                                                                                                  // 3151
			// Call all callbacks with the given context and arguments                                                          // 3152
			fireWith: function( context, args ) {                                                                               // 3153
				if ( list && ( !fired || stack ) ) {                                                                               // 3154
					args = args || [];                                                                                                // 3155
					args = [ context, args.slice ? args.slice() : args ];                                                             // 3156
					if ( firing ) {                                                                                                   // 3157
						stack.push( args );                                                                                              // 3158
					} else {                                                                                                          // 3159
						fire( args );                                                                                                    // 3160
					}                                                                                                                 // 3161
				}                                                                                                                  // 3162
				return this;                                                                                                       // 3163
			},                                                                                                                  // 3164
			// Call all the callbacks with the given arguments                                                                  // 3165
			fire: function() {                                                                                                  // 3166
				self.fireWith( this, arguments );                                                                                  // 3167
				return this;                                                                                                       // 3168
			},                                                                                                                  // 3169
			// To know if the callbacks have already been called at least once                                                  // 3170
			fired: function() {                                                                                                 // 3171
				return !!fired;                                                                                                    // 3172
			}                                                                                                                   // 3173
		};                                                                                                                   // 3174
                                                                                                                       // 3175
	return self;                                                                                                          // 3176
};                                                                                                                     // 3177
jQuery.extend({                                                                                                        // 3178
                                                                                                                       // 3179
	Deferred: function( func ) {                                                                                          // 3180
		var tuples = [                                                                                                       // 3181
				// action, add listener, listener list, final state                                                                // 3182
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],                                                // 3183
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],                                                 // 3184
				[ "notify", "progress", jQuery.Callbacks("memory") ]                                                               // 3185
			],                                                                                                                  // 3186
			state = "pending",                                                                                                  // 3187
			promise = {                                                                                                         // 3188
				state: function() {                                                                                                // 3189
					return state;                                                                                                     // 3190
				},                                                                                                                 // 3191
				always: function() {                                                                                               // 3192
					deferred.done( arguments ).fail( arguments );                                                                     // 3193
					return this;                                                                                                      // 3194
				},                                                                                                                 // 3195
				then: function( /* fnDone, fnFail, fnProgress */ ) {                                                               // 3196
					var fns = arguments;                                                                                              // 3197
					return jQuery.Deferred(function( newDefer ) {                                                                     // 3198
						jQuery.each( tuples, function( i, tuple ) {                                                                      // 3199
							var action = tuple[ 0 ],                                                                                        // 3200
								fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];                                                                // 3201
							// deferred[ done | fail | progress ] for forwarding actions to newDefer                                        // 3202
							deferred[ tuple[1] ](function() {                                                                               // 3203
								var returned = fn && fn.apply( this, arguments );                                                              // 3204
								if ( returned && jQuery.isFunction( returned.promise ) ) {                                                     // 3205
									returned.promise()                                                                                            // 3206
										.done( newDefer.resolve )                                                                                    // 3207
										.fail( newDefer.reject )                                                                                     // 3208
										.progress( newDefer.notify );                                                                                // 3209
								} else {                                                                                                       // 3210
									newDefer[ action + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );   // 3211
								}                                                                                                              // 3212
							});                                                                                                             // 3213
						});                                                                                                              // 3214
						fns = null;                                                                                                      // 3215
					}).promise();                                                                                                     // 3216
				},                                                                                                                 // 3217
				// Get a promise for this deferred                                                                                 // 3218
				// If obj is provided, the promise aspect is added to the object                                                   // 3219
				promise: function( obj ) {                                                                                         // 3220
					return obj != null ? jQuery.extend( obj, promise ) : promise;                                                     // 3221
				}                                                                                                                  // 3222
			},                                                                                                                  // 3223
			deferred = {};                                                                                                      // 3224
                                                                                                                       // 3225
		// Keep pipe for back-compat                                                                                         // 3226
		promise.pipe = promise.then;                                                                                         // 3227
                                                                                                                       // 3228
		// Add list-specific methods                                                                                         // 3229
		jQuery.each( tuples, function( i, tuple ) {                                                                          // 3230
			var list = tuple[ 2 ],                                                                                              // 3231
				stateString = tuple[ 3 ];                                                                                          // 3232
                                                                                                                       // 3233
			// promise[ done | fail | progress ] = list.add                                                                     // 3234
			promise[ tuple[1] ] = list.add;                                                                                     // 3235
                                                                                                                       // 3236
			// Handle state                                                                                                     // 3237
			if ( stateString ) {                                                                                                // 3238
				list.add(function() {                                                                                              // 3239
					// state = [ resolved | rejected ]                                                                                // 3240
					state = stateString;                                                                                              // 3241
                                                                                                                       // 3242
				// [ reject_list | resolve_list ].disable; progress_list.lock                                                      // 3243
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );                                                          // 3244
			}                                                                                                                   // 3245
                                                                                                                       // 3246
			// deferred[ resolve | reject | notify ]                                                                            // 3247
			deferred[ tuple[0] ] = function() {                                                                                 // 3248
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );                                    // 3249
				return this;                                                                                                       // 3250
			};                                                                                                                  // 3251
			deferred[ tuple[0] + "With" ] = list.fireWith;                                                                      // 3252
		});                                                                                                                  // 3253
                                                                                                                       // 3254
		// Make the deferred a promise                                                                                       // 3255
		promise.promise( deferred );                                                                                         // 3256
                                                                                                                       // 3257
		// Call given func if any                                                                                            // 3258
		if ( func ) {                                                                                                        // 3259
			func.call( deferred, deferred );                                                                                    // 3260
		}                                                                                                                    // 3261
                                                                                                                       // 3262
		// All done!                                                                                                         // 3263
		return deferred;                                                                                                     // 3264
	},                                                                                                                    // 3265
                                                                                                                       // 3266
	// Deferred helper                                                                                                    // 3267
	when: function( subordinate /* , ..., subordinateN */ ) {                                                             // 3268
		var i = 0,                                                                                                           // 3269
			resolveValues = core_slice.call( arguments ),                                                                       // 3270
			length = resolveValues.length,                                                                                      // 3271
                                                                                                                       // 3272
			// the count of uncompleted subordinates                                                                            // 3273
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,               // 3274
                                                                                                                       // 3275
			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.                          // 3276
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),                                                       // 3277
                                                                                                                       // 3278
			// Update function for both resolve and progress values                                                             // 3279
			updateFunc = function( i, contexts, values ) {                                                                      // 3280
				return function( value ) {                                                                                         // 3281
					contexts[ i ] = this;                                                                                             // 3282
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;                                        // 3283
					if( values === progressValues ) {                                                                                 // 3284
						deferred.notifyWith( contexts, values );                                                                         // 3285
					} else if ( !( --remaining ) ) {                                                                                  // 3286
						deferred.resolveWith( contexts, values );                                                                        // 3287
					}                                                                                                                 // 3288
				};                                                                                                                 // 3289
			},                                                                                                                  // 3290
                                                                                                                       // 3291
			progressValues, progressContexts, resolveContexts;                                                                  // 3292
                                                                                                                       // 3293
		// add listeners to Deferred subordinates; treat others as resolved                                                  // 3294
		if ( length > 1 ) {                                                                                                  // 3295
			progressValues = new Array( length );                                                                               // 3296
			progressContexts = new Array( length );                                                                             // 3297
			resolveContexts = new Array( length );                                                                              // 3298
			for ( ; i < length; i++ ) {                                                                                         // 3299
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {                                     // 3300
					resolveValues[ i ].promise()                                                                                      // 3301
						.done( updateFunc( i, resolveContexts, resolveValues ) )                                                         // 3302
						.fail( deferred.reject )                                                                                         // 3303
						.progress( updateFunc( i, progressContexts, progressValues ) );                                                  // 3304
				} else {                                                                                                           // 3305
					--remaining;                                                                                                      // 3306
				}                                                                                                                  // 3307
			}                                                                                                                   // 3308
		}                                                                                                                    // 3309
                                                                                                                       // 3310
		// if we're not waiting on anything, resolve the master                                                              // 3311
		if ( !remaining ) {                                                                                                  // 3312
			deferred.resolveWith( resolveContexts, resolveValues );                                                             // 3313
		}                                                                                                                    // 3314
                                                                                                                       // 3315
		return deferred.promise();                                                                                           // 3316
	}                                                                                                                     // 3317
});                                                                                                                    // 3318
jQuery.support = (function( support ) {                                                                                // 3319
                                                                                                                       // 3320
	var all, a, input, select, fragment, opt, eventName, isSupported, i,                                                  // 3321
		div = document.createElement("div");                                                                                 // 3322
                                                                                                                       // 3323
	// Setup                                                                                                              // 3324
	div.setAttribute( "className", "t" );                                                                                 // 3325
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";                                 // 3326
                                                                                                                       // 3327
	// Finish early in limited (non-browser) environments                                                                 // 3328
	all = div.getElementsByTagName("*") || [];                                                                            // 3329
	a = div.getElementsByTagName("a")[ 0 ];                                                                               // 3330
	if ( !a || !a.style || !all.length ) {                                                                                // 3331
		return support;                                                                                                      // 3332
	}                                                                                                                     // 3333
                                                                                                                       // 3334
	// First batch of tests                                                                                               // 3335
	select = document.createElement("select");                                                                            // 3336
	opt = select.appendChild( document.createElement("option") );                                                         // 3337
	input = div.getElementsByTagName("input")[ 0 ];                                                                       // 3338
                                                                                                                       // 3339
	a.style.cssText = "top:1px;float:left;opacity:.5";                                                                    // 3340
                                                                                                                       // 3341
	// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)           // 3342
	support.getSetAttribute = div.className !== "t";                                                                      // 3343
                                                                                                                       // 3344
	// IE strips leading whitespace when .innerHTML is used                                                               // 3345
	support.leadingWhitespace = div.firstChild.nodeType === 3;                                                            // 3346
                                                                                                                       // 3347
	// Make sure that tbody elements aren't automatically inserted                                                        // 3348
	// IE will insert them into empty tables                                                                              // 3349
	support.tbody = !div.getElementsByTagName("tbody").length;                                                            // 3350
                                                                                                                       // 3351
	// Make sure that link elements get serialized correctly by innerHTML                                                 // 3352
	// This requires a wrapper element in IE                                                                              // 3353
	support.htmlSerialize = !!div.getElementsByTagName("link").length;                                                    // 3354
                                                                                                                       // 3355
	// Get the style information from getAttribute                                                                        // 3356
	// (IE uses .cssText instead)                                                                                         // 3357
	support.style = /top/.test( a.getAttribute("style") );                                                                // 3358
                                                                                                                       // 3359
	// Make sure that URLs aren't manipulated                                                                             // 3360
	// (IE normalizes it by default)                                                                                      // 3361
	support.hrefNormalized = a.getAttribute("href") === "/a";                                                             // 3362
                                                                                                                       // 3363
	// Make sure that element opacity exists                                                                              // 3364
	// (IE uses filter instead)                                                                                           // 3365
	// Use a regex to work around a WebKit issue. See #5145                                                               // 3366
	support.opacity = /^0.5/.test( a.style.opacity );                                                                     // 3367
                                                                                                                       // 3368
	// Verify style float existence                                                                                       // 3369
	// (IE uses styleFloat instead of cssFloat)                                                                           // 3370
	support.cssFloat = !!a.style.cssFloat;                                                                                // 3371
                                                                                                                       // 3372
	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)                                              // 3373
	support.checkOn = !!input.value;                                                                                      // 3374
                                                                                                                       // 3375
	// Make sure that a selected-by-default option has a working selected property.                                       // 3376
	// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)                                         // 3377
	support.optSelected = opt.selected;                                                                                   // 3378
                                                                                                                       // 3379
	// Tests for enctype support on a form (#6743)                                                                        // 3380
	support.enctype = !!document.createElement("form").enctype;                                                           // 3381
                                                                                                                       // 3382
	// Makes sure cloning an html5 element does not cause problems                                                        // 3383
	// Where outerHTML is undefined, this still works                                                                     // 3384
	support.html5Clone = document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>";                   // 3385
                                                                                                                       // 3386
	// Will be defined later                                                                                              // 3387
	support.inlineBlockNeedsLayout = false;                                                                               // 3388
	support.shrinkWrapBlocks = false;                                                                                     // 3389
	support.pixelPosition = false;                                                                                        // 3390
	support.deleteExpando = true;                                                                                         // 3391
	support.noCloneEvent = true;                                                                                          // 3392
	support.reliableMarginRight = true;                                                                                   // 3393
	support.boxSizingReliable = true;                                                                                     // 3394
                                                                                                                       // 3395
	// Make sure checked status is properly cloned                                                                        // 3396
	input.checked = true;                                                                                                 // 3397
	support.noCloneChecked = input.cloneNode( true ).checked;                                                             // 3398
                                                                                                                       // 3399
	// Make sure that the options inside disabled selects aren't marked as disabled                                       // 3400
	// (WebKit marks them as disabled)                                                                                    // 3401
	select.disabled = true;                                                                                               // 3402
	support.optDisabled = !opt.disabled;                                                                                  // 3403
                                                                                                                       // 3404
	// Support: IE<9                                                                                                      // 3405
	try {                                                                                                                 // 3406
		delete div.test;                                                                                                     // 3407
	} catch( e ) {                                                                                                        // 3408
		support.deleteExpando = false;                                                                                       // 3409
	}                                                                                                                     // 3410
                                                                                                                       // 3411
	// Check if we can trust getAttribute("value")                                                                        // 3412
	input = document.createElement("input");                                                                              // 3413
	input.setAttribute( "value", "" );                                                                                    // 3414
	support.input = input.getAttribute( "value" ) === "";                                                                 // 3415
                                                                                                                       // 3416
	// Check if an input maintains its value after becoming a radio                                                       // 3417
	input.value = "t";                                                                                                    // 3418
	input.setAttribute( "type", "radio" );                                                                                // 3419
	support.radioValue = input.value === "t";                                                                             // 3420
                                                                                                                       // 3421
	// #11217 - WebKit loses check when the name is after the checked attribute                                           // 3422
	input.setAttribute( "checked", "t" );                                                                                 // 3423
	input.setAttribute( "name", "t" );                                                                                    // 3424
                                                                                                                       // 3425
	fragment = document.createDocumentFragment();                                                                         // 3426
	fragment.appendChild( input );                                                                                        // 3427
                                                                                                                       // 3428
	// Check if a disconnected checkbox will retain its checked                                                           // 3429
	// value of true after appended to the DOM (IE6/7)                                                                    // 3430
	support.appendChecked = input.checked;                                                                                // 3431
                                                                                                                       // 3432
	// WebKit doesn't clone checked state correctly in fragments                                                          // 3433
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;                                  // 3434
                                                                                                                       // 3435
	// Support: IE<9                                                                                                      // 3436
	// Opera does not clone events (and typeof div.attachEvent === undefined).                                            // 3437
	// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()                                   // 3438
	if ( div.attachEvent ) {                                                                                              // 3439
		div.attachEvent( "onclick", function() {                                                                             // 3440
			support.noCloneEvent = false;                                                                                       // 3441
		});                                                                                                                  // 3442
                                                                                                                       // 3443
		div.cloneNode( true ).click();                                                                                       // 3444
	}                                                                                                                     // 3445
                                                                                                                       // 3446
	// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)                                        // 3447
	// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)                                         // 3448
	for ( i in { submit: true, change: true, focusin: true }) {                                                           // 3449
		div.setAttribute( eventName = "on" + i, "t" );                                                                       // 3450
                                                                                                                       // 3451
		support[ i + "Bubbles" ] = eventName in window || div.attributes[ eventName ].expando === false;                     // 3452
	}                                                                                                                     // 3453
                                                                                                                       // 3454
	div.style.backgroundClip = "content-box";                                                                             // 3455
	div.cloneNode( true ).style.backgroundClip = "";                                                                      // 3456
	support.clearCloneStyle = div.style.backgroundClip === "content-box";                                                 // 3457
                                                                                                                       // 3458
	// Support: IE<9                                                                                                      // 3459
	// Iteration over object's inherited properties before its own.                                                       // 3460
	for ( i in jQuery( support ) ) {                                                                                      // 3461
		break;                                                                                                               // 3462
	}                                                                                                                     // 3463
	support.ownLast = i !== "0";                                                                                          // 3464
                                                                                                                       // 3465
	// Run tests that need a body at doc ready                                                                            // 3466
	jQuery(function() {                                                                                                   // 3467
		var container, marginDiv, tds,                                                                                       // 3468
			divReset = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",
			body = document.getElementsByTagName("body")[0];                                                                    // 3470
                                                                                                                       // 3471
		if ( !body ) {                                                                                                       // 3472
			// Return for frameset docs that don't have a body                                                                  // 3473
			return;                                                                                                             // 3474
		}                                                                                                                    // 3475
                                                                                                                       // 3476
		container = document.createElement("div");                                                                           // 3477
		container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";           // 3478
                                                                                                                       // 3479
		body.appendChild( container ).appendChild( div );                                                                    // 3480
                                                                                                                       // 3481
		// Support: IE8                                                                                                      // 3482
		// Check if table cells still have offsetWidth/Height when they are set                                              // 3483
		// to display:none and there are still other visible table cells in a                                                // 3484
		// table row; if so, offsetWidth/Height are not reliable for use when                                                // 3485
		// determining if an element has been hidden directly using                                                          // 3486
		// display:none (it is still safe to use offsets if a parent element is                                              // 3487
		// hidden; don safety goggles and see bug #4512 for more information).                                               // 3488
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";                                                       // 3489
		tds = div.getElementsByTagName("td");                                                                                // 3490
		tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";                                                 // 3491
		isSupported = ( tds[ 0 ].offsetHeight === 0 );                                                                       // 3492
                                                                                                                       // 3493
		tds[ 0 ].style.display = "";                                                                                         // 3494
		tds[ 1 ].style.display = "none";                                                                                     // 3495
                                                                                                                       // 3496
		// Support: IE8                                                                                                      // 3497
		// Check if empty table cells still have offsetWidth/Height                                                          // 3498
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );                                      // 3499
                                                                                                                       // 3500
		// Check box-sizing and margin behavior.                                                                             // 3501
		div.innerHTML = "";                                                                                                  // 3502
		div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
                                                                                                                       // 3504
		// Workaround failing boxSizing test due to offsetWidth returning wrong value                                        // 3505
		// with some non-1 values of body zoom, ticket #13543                                                                // 3506
		jQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {                                          // 3507
			support.boxSizing = div.offsetWidth === 4;                                                                          // 3508
		});                                                                                                                  // 3509
                                                                                                                       // 3510
		// Use window.getComputedStyle because jsdom on node.js will break without it.                                       // 3511
		if ( window.getComputedStyle ) {                                                                                     // 3512
			support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";                                // 3513
			support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";           // 3514
                                                                                                                       // 3515
			// Check if div with explicit width and no margin-right incorrectly                                                 // 3516
			// gets computed margin-right based on width of container. (#3333)                                                  // 3517
			// Fails in WebKit before Feb 2011 nightlies                                                                        // 3518
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right                                         // 3519
			marginDiv = div.appendChild( document.createElement("div") );                                                       // 3520
			marginDiv.style.cssText = div.style.cssText = divReset;                                                             // 3521
			marginDiv.style.marginRight = marginDiv.style.width = "0";                                                          // 3522
			div.style.width = "1px";                                                                                            // 3523
                                                                                                                       // 3524
			support.reliableMarginRight =                                                                                       // 3525
				!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );                                   // 3526
		}                                                                                                                    // 3527
                                                                                                                       // 3528
		if ( typeof div.style.zoom !== core_strundefined ) {                                                                 // 3529
			// Support: IE<8                                                                                                    // 3530
			// Check if natively block-level elements act like inline-block                                                     // 3531
			// elements when setting their display to 'inline' and giving                                                       // 3532
			// them layout                                                                                                      // 3533
			div.innerHTML = "";                                                                                                 // 3534
			div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";                                       // 3535
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );                                                         // 3536
                                                                                                                       // 3537
			// Support: IE6                                                                                                     // 3538
			// Check if elements with layout shrink-wrap their children                                                         // 3539
			div.style.display = "block";                                                                                        // 3540
			div.innerHTML = "<div></div>";                                                                                      // 3541
			div.firstChild.style.width = "5px";                                                                                 // 3542
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );                                                               // 3543
                                                                                                                       // 3544
			if ( support.inlineBlockNeedsLayout ) {                                                                             // 3545
				// Prevent IE 6 from affecting layout for positioned elements #11048                                               // 3546
				// Prevent IE from shrinking the body in IE 7 mode #12869                                                          // 3547
				// Support: IE<8                                                                                                   // 3548
				body.style.zoom = 1;                                                                                               // 3549
			}                                                                                                                   // 3550
		}                                                                                                                    // 3551
                                                                                                                       // 3552
		body.removeChild( container );                                                                                       // 3553
                                                                                                                       // 3554
		// Null elements to avoid leaks in IE                                                                                // 3555
		container = div = tds = marginDiv = null;                                                                            // 3556
	});                                                                                                                   // 3557
                                                                                                                       // 3558
	// Null elements to avoid leaks in IE                                                                                 // 3559
	all = select = fragment = opt = a = input = null;                                                                     // 3560
                                                                                                                       // 3561
	return support;                                                                                                       // 3562
})({});                                                                                                                // 3563
                                                                                                                       // 3564
var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,                                                                           // 3565
	rmultiDash = /([A-Z])/g;                                                                                              // 3566
                                                                                                                       // 3567
function internalData( elem, name, data, pvt /* Internal Use Only */ ){                                                // 3568
	if ( !jQuery.acceptData( elem ) ) {                                                                                   // 3569
		return;                                                                                                              // 3570
	}                                                                                                                     // 3571
                                                                                                                       // 3572
	var ret, thisCache,                                                                                                   // 3573
		internalKey = jQuery.expando,                                                                                        // 3574
                                                                                                                       // 3575
		// We have to handle DOM nodes and JS objects differently because IE6-7                                              // 3576
		// can't GC object references properly across the DOM-JS boundary                                                    // 3577
		isNode = elem.nodeType,                                                                                              // 3578
                                                                                                                       // 3579
		// Only DOM nodes need the global jQuery cache; JS object data is                                                    // 3580
		// attached directly to the object so GC can occur automatically                                                     // 3581
		cache = isNode ? jQuery.cache : elem,                                                                                // 3582
                                                                                                                       // 3583
		// Only defining an ID for JS objects if its cache already exists allows                                             // 3584
		// the code to shortcut on the same path as a DOM node with no cache                                                 // 3585
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;                                              // 3586
                                                                                                                       // 3587
	// Avoid doing any more work than we need to when trying to get data on an                                            // 3588
	// object that has no data at all                                                                                     // 3589
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {           // 3590
		return;                                                                                                              // 3591
	}                                                                                                                     // 3592
                                                                                                                       // 3593
	if ( !id ) {                                                                                                          // 3594
		// Only DOM nodes need a new unique ID for each element since their data                                             // 3595
		// ends up in the global cache                                                                                       // 3596
		if ( isNode ) {                                                                                                      // 3597
			id = elem[ internalKey ] = core_deletedIds.pop() || jQuery.guid++;                                                  // 3598
		} else {                                                                                                             // 3599
			id = internalKey;                                                                                                   // 3600
		}                                                                                                                    // 3601
	}                                                                                                                     // 3602
                                                                                                                       // 3603
	if ( !cache[ id ] ) {                                                                                                 // 3604
		// Avoid exposing jQuery metadata on plain JS objects when the object                                                // 3605
		// is serialized using JSON.stringify                                                                                // 3606
		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };                                                                 // 3607
	}                                                                                                                     // 3608
                                                                                                                       // 3609
	// An object can be passed to jQuery.data instead of a key/value pair; this gets                                      // 3610
	// shallow copied over onto the existing cache                                                                        // 3611
	if ( typeof name === "object" || typeof name === "function" ) {                                                       // 3612
		if ( pvt ) {                                                                                                         // 3613
			cache[ id ] = jQuery.extend( cache[ id ], name );                                                                   // 3614
		} else {                                                                                                             // 3615
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );                                                         // 3616
		}                                                                                                                    // 3617
	}                                                                                                                     // 3618
                                                                                                                       // 3619
	thisCache = cache[ id ];                                                                                              // 3620
                                                                                                                       // 3621
	// jQuery data() is stored in a separate object inside the object's internal data                                     // 3622
	// cache in order to avoid key collisions between internal data and user-defined                                      // 3623
	// data.                                                                                                              // 3624
	if ( !pvt ) {                                                                                                         // 3625
		if ( !thisCache.data ) {                                                                                             // 3626
			thisCache.data = {};                                                                                                // 3627
		}                                                                                                                    // 3628
                                                                                                                       // 3629
		thisCache = thisCache.data;                                                                                          // 3630
	}                                                                                                                     // 3631
                                                                                                                       // 3632
	if ( data !== undefined ) {                                                                                           // 3633
		thisCache[ jQuery.camelCase( name ) ] = data;                                                                        // 3634
	}                                                                                                                     // 3635
                                                                                                                       // 3636
	// Check for both converted-to-camel and non-converted data property names                                            // 3637
	// If a data property was specified                                                                                   // 3638
	if ( typeof name === "string" ) {                                                                                     // 3639
                                                                                                                       // 3640
		// First Try to find as-is property data                                                                             // 3641
		ret = thisCache[ name ];                                                                                             // 3642
                                                                                                                       // 3643
		// Test for null|undefined property data                                                                             // 3644
		if ( ret == null ) {                                                                                                 // 3645
                                                                                                                       // 3646
			// Try to find the camelCased property                                                                              // 3647
			ret = thisCache[ jQuery.camelCase( name ) ];                                                                        // 3648
		}                                                                                                                    // 3649
	} else {                                                                                                              // 3650
		ret = thisCache;                                                                                                     // 3651
	}                                                                                                                     // 3652
                                                                                                                       // 3653
	return ret;                                                                                                           // 3654
}                                                                                                                      // 3655
                                                                                                                       // 3656
function internalRemoveData( elem, name, pvt ) {                                                                       // 3657
	if ( !jQuery.acceptData( elem ) ) {                                                                                   // 3658
		return;                                                                                                              // 3659
	}                                                                                                                     // 3660
                                                                                                                       // 3661
	var thisCache, i,                                                                                                     // 3662
		isNode = elem.nodeType,                                                                                              // 3663
                                                                                                                       // 3664
		// See jQuery.data for more information                                                                              // 3665
		cache = isNode ? jQuery.cache : elem,                                                                                // 3666
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;                                                               // 3667
                                                                                                                       // 3668
	// If there is already no cache entry for this object, there is no                                                    // 3669
	// purpose in continuing                                                                                              // 3670
	if ( !cache[ id ] ) {                                                                                                 // 3671
		return;                                                                                                              // 3672
	}                                                                                                                     // 3673
                                                                                                                       // 3674
	if ( name ) {                                                                                                         // 3675
                                                                                                                       // 3676
		thisCache = pvt ? cache[ id ] : cache[ id ].data;                                                                    // 3677
                                                                                                                       // 3678
		if ( thisCache ) {                                                                                                   // 3679
                                                                                                                       // 3680
			// Support array or space separated string names for data keys                                                      // 3681
			if ( !jQuery.isArray( name ) ) {                                                                                    // 3682
                                                                                                                       // 3683
				// try the string as a key before any manipulation                                                                 // 3684
				if ( name in thisCache ) {                                                                                         // 3685
					name = [ name ];                                                                                                  // 3686
				} else {                                                                                                           // 3687
                                                                                                                       // 3688
					// split the camel cased version by spaces unless a key with the spaces exists                                    // 3689
					name = jQuery.camelCase( name );                                                                                  // 3690
					if ( name in thisCache ) {                                                                                        // 3691
						name = [ name ];                                                                                                 // 3692
					} else {                                                                                                          // 3693
						name = name.split(" ");                                                                                          // 3694
					}                                                                                                                 // 3695
				}                                                                                                                  // 3696
			} else {                                                                                                            // 3697
				// If "name" is an array of keys...                                                                                // 3698
				// When data is initially created, via ("key", "val") signature,                                                   // 3699
				// keys will be converted to camelCase.                                                                            // 3700
				// Since there is no way to tell _how_ a key was added, remove                                                     // 3701
				// both plain key and camelCase key. #12786                                                                        // 3702
				// This will only penalize the array argument path.                                                                // 3703
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );                                                        // 3704
			}                                                                                                                   // 3705
                                                                                                                       // 3706
			i = name.length;                                                                                                    // 3707
			while ( i-- ) {                                                                                                     // 3708
				delete thisCache[ name[i] ];                                                                                       // 3709
			}                                                                                                                   // 3710
                                                                                                                       // 3711
			// If there is no data left in the cache, we want to continue                                                       // 3712
			// and let the cache object itself get destroyed                                                                    // 3713
			if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {                                     // 3714
				return;                                                                                                            // 3715
			}                                                                                                                   // 3716
		}                                                                                                                    // 3717
	}                                                                                                                     // 3718
                                                                                                                       // 3719
	// See jQuery.data for more information                                                                               // 3720
	if ( !pvt ) {                                                                                                         // 3721
		delete cache[ id ].data;                                                                                             // 3722
                                                                                                                       // 3723
		// Don't destroy the parent cache unless the internal data object                                                    // 3724
		// had been the only thing left in it                                                                                // 3725
		if ( !isEmptyDataObject( cache[ id ] ) ) {                                                                           // 3726
			return;                                                                                                             // 3727
		}                                                                                                                    // 3728
	}                                                                                                                     // 3729
                                                                                                                       // 3730
	// Destroy the cache                                                                                                  // 3731
	if ( isNode ) {                                                                                                       // 3732
		jQuery.cleanData( [ elem ], true );                                                                                  // 3733
                                                                                                                       // 3734
	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)                            // 3735
	/* jshint eqeqeq: false */                                                                                            // 3736
	} else if ( jQuery.support.deleteExpando || cache != cache.window ) {                                                 // 3737
		/* jshint eqeqeq: true */                                                                                            // 3738
		delete cache[ id ];                                                                                                  // 3739
                                                                                                                       // 3740
	// When all else fails, null                                                                                          // 3741
	} else {                                                                                                              // 3742
		cache[ id ] = null;                                                                                                  // 3743
	}                                                                                                                     // 3744
}                                                                                                                      // 3745
                                                                                                                       // 3746
jQuery.extend({                                                                                                        // 3747
	cache: {},                                                                                                            // 3748
                                                                                                                       // 3749
	// The following elements throw uncatchable exceptions if you                                                         // 3750
	// attempt to add expando properties to them.                                                                         // 3751
	noData: {                                                                                                             // 3752
		"applet": true,                                                                                                      // 3753
		"embed": true,                                                                                                       // 3754
		// Ban all objects except for Flash (which handle expandos)                                                          // 3755
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"                                                               // 3756
	},                                                                                                                    // 3757
                                                                                                                       // 3758
	hasData: function( elem ) {                                                                                           // 3759
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];                                // 3760
		return !!elem && !isEmptyDataObject( elem );                                                                         // 3761
	},                                                                                                                    // 3762
                                                                                                                       // 3763
	data: function( elem, name, data ) {                                                                                  // 3764
		return internalData( elem, name, data );                                                                             // 3765
	},                                                                                                                    // 3766
                                                                                                                       // 3767
	removeData: function( elem, name ) {                                                                                  // 3768
		return internalRemoveData( elem, name );                                                                             // 3769
	},                                                                                                                    // 3770
                                                                                                                       // 3771
	// For internal use only.                                                                                             // 3772
	_data: function( elem, name, data ) {                                                                                 // 3773
		return internalData( elem, name, data, true );                                                                       // 3774
	},                                                                                                                    // 3775
                                                                                                                       // 3776
	_removeData: function( elem, name ) {                                                                                 // 3777
		return internalRemoveData( elem, name, true );                                                                       // 3778
	},                                                                                                                    // 3779
                                                                                                                       // 3780
	// A method for determining if a DOM node can handle the data expando                                                 // 3781
	acceptData: function( elem ) {                                                                                        // 3782
		// Do not set data on non-element because it will not be cleared (#8335).                                            // 3783
		if ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {                                                 // 3784
			return false;                                                                                                       // 3785
		}                                                                                                                    // 3786
                                                                                                                       // 3787
		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];                                          // 3788
                                                                                                                       // 3789
		// nodes accept data unless otherwise specified; rejection can be conditional                                        // 3790
		return !noData || noData !== true && elem.getAttribute("classid") === noData;                                        // 3791
	}                                                                                                                     // 3792
});                                                                                                                    // 3793
                                                                                                                       // 3794
jQuery.fn.extend({                                                                                                     // 3795
	data: function( key, value ) {                                                                                        // 3796
		var attrs, name,                                                                                                     // 3797
			data = null,                                                                                                        // 3798
			i = 0,                                                                                                              // 3799
			elem = this[0];                                                                                                     // 3800
                                                                                                                       // 3801
		// Special expections of .data basically thwart jQuery.access,                                                       // 3802
		// so implement the relevant behavior ourselves                                                                      // 3803
                                                                                                                       // 3804
		// Gets all values                                                                                                   // 3805
		if ( key === undefined ) {                                                                                           // 3806
			if ( this.length ) {                                                                                                // 3807
				data = jQuery.data( elem );                                                                                        // 3808
                                                                                                                       // 3809
				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {                                               // 3810
					attrs = elem.attributes;                                                                                          // 3811
					for ( ; i < attrs.length; i++ ) {                                                                                 // 3812
						name = attrs[i].name;                                                                                            // 3813
                                                                                                                       // 3814
						if ( name.indexOf("data-") === 0 ) {                                                                             // 3815
							name = jQuery.camelCase( name.slice(5) );                                                                       // 3816
                                                                                                                       // 3817
							dataAttr( elem, name, data[ name ] );                                                                           // 3818
						}                                                                                                                // 3819
					}                                                                                                                 // 3820
					jQuery._data( elem, "parsedAttrs", true );                                                                        // 3821
				}                                                                                                                  // 3822
			}                                                                                                                   // 3823
                                                                                                                       // 3824
			return data;                                                                                                        // 3825
		}                                                                                                                    // 3826
                                                                                                                       // 3827
		// Sets multiple values                                                                                              // 3828
		if ( typeof key === "object" ) {                                                                                     // 3829
			return this.each(function() {                                                                                       // 3830
				jQuery.data( this, key );                                                                                          // 3831
			});                                                                                                                 // 3832
		}                                                                                                                    // 3833
                                                                                                                       // 3834
		return arguments.length > 1 ?                                                                                        // 3835
                                                                                                                       // 3836
			// Sets one value                                                                                                   // 3837
			this.each(function() {                                                                                              // 3838
				jQuery.data( this, key, value );                                                                                   // 3839
			}) :                                                                                                                // 3840
                                                                                                                       // 3841
			// Gets one value                                                                                                   // 3842
			// Try to fetch any internally stored data first                                                                    // 3843
			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;                                                      // 3844
	},                                                                                                                    // 3845
                                                                                                                       // 3846
	removeData: function( key ) {                                                                                         // 3847
		return this.each(function() {                                                                                        // 3848
			jQuery.removeData( this, key );                                                                                     // 3849
		});                                                                                                                  // 3850
	}                                                                                                                     // 3851
});                                                                                                                    // 3852
                                                                                                                       // 3853
function dataAttr( elem, key, data ) {                                                                                 // 3854
	// If nothing was found internally, try to fetch any                                                                  // 3855
	// data from the HTML5 data-* attribute                                                                               // 3856
	if ( data === undefined && elem.nodeType === 1 ) {                                                                    // 3857
                                                                                                                       // 3858
		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();                                                 // 3859
                                                                                                                       // 3860
		data = elem.getAttribute( name );                                                                                    // 3861
                                                                                                                       // 3862
		if ( typeof data === "string" ) {                                                                                    // 3863
			try {                                                                                                               // 3864
				data = data === "true" ? true :                                                                                    // 3865
					data === "false" ? false :                                                                                        // 3866
					data === "null" ? null :                                                                                          // 3867
					// Only convert to a number if it doesn't change the string                                                       // 3868
					+data + "" === data ? +data :                                                                                     // 3869
					rbrace.test( data ) ? jQuery.parseJSON( data ) :                                                                  // 3870
						data;                                                                                                            // 3871
			} catch( e ) {}                                                                                                     // 3872
                                                                                                                       // 3873
			// Make sure we set the data so it isn't changed later                                                              // 3874
			jQuery.data( elem, key, data );                                                                                     // 3875
                                                                                                                       // 3876
		} else {                                                                                                             // 3877
			data = undefined;                                                                                                   // 3878
		}                                                                                                                    // 3879
	}                                                                                                                     // 3880
                                                                                                                       // 3881
	return data;                                                                                                          // 3882
}                                                                                                                      // 3883
                                                                                                                       // 3884
// checks a cache object for emptiness                                                                                 // 3885
function isEmptyDataObject( obj ) {                                                                                    // 3886
	var name;                                                                                                             // 3887
	for ( name in obj ) {                                                                                                 // 3888
                                                                                                                       // 3889
		// if the public data object is empty, the private is still empty                                                    // 3890
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {                                                        // 3891
			continue;                                                                                                           // 3892
		}                                                                                                                    // 3893
		if ( name !== "toJSON" ) {                                                                                           // 3894
			return false;                                                                                                       // 3895
		}                                                                                                                    // 3896
	}                                                                                                                     // 3897
                                                                                                                       // 3898
	return true;                                                                                                          // 3899
}                                                                                                                      // 3900
jQuery.extend({                                                                                                        // 3901
	queue: function( elem, type, data ) {                                                                                 // 3902
		var queue;                                                                                                           // 3903
                                                                                                                       // 3904
		if ( elem ) {                                                                                                        // 3905
			type = ( type || "fx" ) + "queue";                                                                                  // 3906
			queue = jQuery._data( elem, type );                                                                                 // 3907
                                                                                                                       // 3908
			// Speed up dequeue by getting out quickly if this is just a lookup                                                 // 3909
			if ( data ) {                                                                                                       // 3910
				if ( !queue || jQuery.isArray(data) ) {                                                                            // 3911
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );                                                       // 3912
				} else {                                                                                                           // 3913
					queue.push( data );                                                                                               // 3914
				}                                                                                                                  // 3915
			}                                                                                                                   // 3916
			return queue || [];                                                                                                 // 3917
		}                                                                                                                    // 3918
	},                                                                                                                    // 3919
                                                                                                                       // 3920
	dequeue: function( elem, type ) {                                                                                     // 3921
		type = type || "fx";                                                                                                 // 3922
                                                                                                                       // 3923
		var queue = jQuery.queue( elem, type ),                                                                              // 3924
			startLength = queue.length,                                                                                         // 3925
			fn = queue.shift(),                                                                                                 // 3926
			hooks = jQuery._queueHooks( elem, type ),                                                                           // 3927
			next = function() {                                                                                                 // 3928
				jQuery.dequeue( elem, type );                                                                                      // 3929
			};                                                                                                                  // 3930
                                                                                                                       // 3931
		// If the fx queue is dequeued, always remove the progress sentinel                                                  // 3932
		if ( fn === "inprogress" ) {                                                                                         // 3933
			fn = queue.shift();                                                                                                 // 3934
			startLength--;                                                                                                      // 3935
		}                                                                                                                    // 3936
                                                                                                                       // 3937
		if ( fn ) {                                                                                                          // 3938
                                                                                                                       // 3939
			// Add a progress sentinel to prevent the fx queue from being                                                       // 3940
			// automatically dequeued                                                                                           // 3941
			if ( type === "fx" ) {                                                                                              // 3942
				queue.unshift( "inprogress" );                                                                                     // 3943
			}                                                                                                                   // 3944
                                                                                                                       // 3945
			// clear up the last queue stop function                                                                            // 3946
			delete hooks.stop;                                                                                                  // 3947
			fn.call( elem, next, hooks );                                                                                       // 3948
		}                                                                                                                    // 3949
                                                                                                                       // 3950
		if ( !startLength && hooks ) {                                                                                       // 3951
			hooks.empty.fire();                                                                                                 // 3952
		}                                                                                                                    // 3953
	},                                                                                                                    // 3954
                                                                                                                       // 3955
	// not intended for public consumption - generates a queueHooks object, or returns the current one                    // 3956
	_queueHooks: function( elem, type ) {                                                                                 // 3957
		var key = type + "queueHooks";                                                                                       // 3958
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {                                                       // 3959
			empty: jQuery.Callbacks("once memory").add(function() {                                                             // 3960
				jQuery._removeData( elem, type + "queue" );                                                                        // 3961
				jQuery._removeData( elem, key );                                                                                   // 3962
			})                                                                                                                  // 3963
		});                                                                                                                  // 3964
	}                                                                                                                     // 3965
});                                                                                                                    // 3966
                                                                                                                       // 3967
jQuery.fn.extend({                                                                                                     // 3968
	queue: function( type, data ) {                                                                                       // 3969
		var setter = 2;                                                                                                      // 3970
                                                                                                                       // 3971
		if ( typeof type !== "string" ) {                                                                                    // 3972
			data = type;                                                                                                        // 3973
			type = "fx";                                                                                                        // 3974
			setter--;                                                                                                           // 3975
		}                                                                                                                    // 3976
                                                                                                                       // 3977
		if ( arguments.length < setter ) {                                                                                   // 3978
			return jQuery.queue( this[0], type );                                                                               // 3979
		}                                                                                                                    // 3980
                                                                                                                       // 3981
		return data === undefined ?                                                                                          // 3982
			this :                                                                                                              // 3983
			this.each(function() {                                                                                              // 3984
				var queue = jQuery.queue( this, type, data );                                                                      // 3985
                                                                                                                       // 3986
				// ensure a hooks for this queue                                                                                   // 3987
				jQuery._queueHooks( this, type );                                                                                  // 3988
                                                                                                                       // 3989
				if ( type === "fx" && queue[0] !== "inprogress" ) {                                                                // 3990
					jQuery.dequeue( this, type );                                                                                     // 3991
				}                                                                                                                  // 3992
			});                                                                                                                 // 3993
	},                                                                                                                    // 3994
	dequeue: function( type ) {                                                                                           // 3995
		return this.each(function() {                                                                                        // 3996
			jQuery.dequeue( this, type );                                                                                       // 3997
		});                                                                                                                  // 3998
	},                                                                                                                    // 3999
	// Based off of the plugin by Clint Helfers, with permission.                                                         // 4000
	// http://blindsignals.com/index.php/2009/07/jquery-delay/                                                            // 4001
	delay: function( time, type ) {                                                                                       // 4002
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;                                                          // 4003
		type = type || "fx";                                                                                                 // 4004
                                                                                                                       // 4005
		return this.queue( type, function( next, hooks ) {                                                                   // 4006
			var timeout = setTimeout( next, time );                                                                             // 4007
			hooks.stop = function() {                                                                                           // 4008
				clearTimeout( timeout );                                                                                           // 4009
			};                                                                                                                  // 4010
		});                                                                                                                  // 4011
	},                                                                                                                    // 4012
	clearQueue: function( type ) {                                                                                        // 4013
		return this.queue( type || "fx", [] );                                                                               // 4014
	},                                                                                                                    // 4015
	// Get a promise resolved when queues of a certain type                                                               // 4016
	// are emptied (fx is the type by default)                                                                            // 4017
	promise: function( type, obj ) {                                                                                      // 4018
		var tmp,                                                                                                             // 4019
			count = 1,                                                                                                          // 4020
			defer = jQuery.Deferred(),                                                                                          // 4021
			elements = this,                                                                                                    // 4022
			i = this.length,                                                                                                    // 4023
			resolve = function() {                                                                                              // 4024
				if ( !( --count ) ) {                                                                                              // 4025
					defer.resolveWith( elements, [ elements ] );                                                                      // 4026
				}                                                                                                                  // 4027
			};                                                                                                                  // 4028
                                                                                                                       // 4029
		if ( typeof type !== "string" ) {                                                                                    // 4030
			obj = type;                                                                                                         // 4031
			type = undefined;                                                                                                   // 4032
		}                                                                                                                    // 4033
		type = type || "fx";                                                                                                 // 4034
                                                                                                                       // 4035
		while( i-- ) {                                                                                                       // 4036
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );                                                           // 4037
			if ( tmp && tmp.empty ) {                                                                                           // 4038
				count++;                                                                                                           // 4039
				tmp.empty.add( resolve );                                                                                          // 4040
			}                                                                                                                   // 4041
		}                                                                                                                    // 4042
		resolve();                                                                                                           // 4043
		return defer.promise( obj );                                                                                         // 4044
	}                                                                                                                     // 4045
});                                                                                                                    // 4046
var nodeHook, boolHook,                                                                                                // 4047
	rclass = /[\t\r\n\f]/g,                                                                                               // 4048
	rreturn = /\r/g,                                                                                                      // 4049
	rfocusable = /^(?:input|select|textarea|button|object)$/i,                                                            // 4050
	rclickable = /^(?:a|area)$/i,                                                                                         // 4051
	ruseDefault = /^(?:checked|selected)$/i,                                                                              // 4052
	getSetAttribute = jQuery.support.getSetAttribute,                                                                     // 4053
	getSetInput = jQuery.support.input;                                                                                   // 4054
                                                                                                                       // 4055
jQuery.fn.extend({                                                                                                     // 4056
	attr: function( name, value ) {                                                                                       // 4057
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );                                        // 4058
	},                                                                                                                    // 4059
                                                                                                                       // 4060
	removeAttr: function( name ) {                                                                                        // 4061
		return this.each(function() {                                                                                        // 4062
			jQuery.removeAttr( this, name );                                                                                    // 4063
		});                                                                                                                  // 4064
	},                                                                                                                    // 4065
                                                                                                                       // 4066
	prop: function( name, value ) {                                                                                       // 4067
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );                                        // 4068
	},                                                                                                                    // 4069
                                                                                                                       // 4070
	removeProp: function( name ) {                                                                                        // 4071
		name = jQuery.propFix[ name ] || name;                                                                               // 4072
		return this.each(function() {                                                                                        // 4073
			// try/catch handles cases where IE balks (such as removing a property on window)                                   // 4074
			try {                                                                                                               // 4075
				this[ name ] = undefined;                                                                                          // 4076
				delete this[ name ];                                                                                               // 4077
			} catch( e ) {}                                                                                                     // 4078
		});                                                                                                                  // 4079
	},                                                                                                                    // 4080
                                                                                                                       // 4081
	addClass: function( value ) {                                                                                         // 4082
		var classes, elem, cur, clazz, j,                                                                                    // 4083
			i = 0,                                                                                                              // 4084
			len = this.length,                                                                                                  // 4085
			proceed = typeof value === "string" && value;                                                                       // 4086
                                                                                                                       // 4087
		if ( jQuery.isFunction( value ) ) {                                                                                  // 4088
			return this.each(function( j ) {                                                                                    // 4089
				jQuery( this ).addClass( value.call( this, j, this.className ) );                                                  // 4090
			});                                                                                                                 // 4091
		}                                                                                                                    // 4092
                                                                                                                       // 4093
		if ( proceed ) {                                                                                                     // 4094
			// The disjunction here is for better compressibility (see removeClass)                                             // 4095
			classes = ( value || "" ).match( core_rnotwhite ) || [];                                                            // 4096
                                                                                                                       // 4097
			for ( ; i < len; i++ ) {                                                                                            // 4098
				elem = this[ i ];                                                                                                  // 4099
				cur = elem.nodeType === 1 && ( elem.className ?                                                                    // 4100
					( " " + elem.className + " " ).replace( rclass, " " ) :                                                           // 4101
					" "                                                                                                               // 4102
				);                                                                                                                 // 4103
                                                                                                                       // 4104
				if ( cur ) {                                                                                                       // 4105
					j = 0;                                                                                                            // 4106
					while ( (clazz = classes[j++]) ) {                                                                                // 4107
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {                                                                    // 4108
							cur += clazz + " ";                                                                                             // 4109
						}                                                                                                                // 4110
					}                                                                                                                 // 4111
					elem.className = jQuery.trim( cur );                                                                              // 4112
                                                                                                                       // 4113
				}                                                                                                                  // 4114
			}                                                                                                                   // 4115
		}                                                                                                                    // 4116
                                                                                                                       // 4117
		return this;                                                                                                         // 4118
	},                                                                                                                    // 4119
                                                                                                                       // 4120
	removeClass: function( value ) {                                                                                      // 4121
		var classes, elem, cur, clazz, j,                                                                                    // 4122
			i = 0,                                                                                                              // 4123
			len = this.length,                                                                                                  // 4124
			proceed = arguments.length === 0 || typeof value === "string" && value;                                             // 4125
                                                                                                                       // 4126
		if ( jQuery.isFunction( value ) ) {                                                                                  // 4127
			return this.each(function( j ) {                                                                                    // 4128
				jQuery( this ).removeClass( value.call( this, j, this.className ) );                                               // 4129
			});                                                                                                                 // 4130
		}                                                                                                                    // 4131
		if ( proceed ) {                                                                                                     // 4132
			classes = ( value || "" ).match( core_rnotwhite ) || [];                                                            // 4133
                                                                                                                       // 4134
			for ( ; i < len; i++ ) {                                                                                            // 4135
				elem = this[ i ];                                                                                                  // 4136
				// This expression is here for better compressibility (see addClass)                                               // 4137
				cur = elem.nodeType === 1 && ( elem.className ?                                                                    // 4138
					( " " + elem.className + " " ).replace( rclass, " " ) :                                                           // 4139
					""                                                                                                                // 4140
				);                                                                                                                 // 4141
                                                                                                                       // 4142
				if ( cur ) {                                                                                                       // 4143
					j = 0;                                                                                                            // 4144
					while ( (clazz = classes[j++]) ) {                                                                                // 4145
						// Remove *all* instances                                                                                        // 4146
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {                                                                // 4147
							cur = cur.replace( " " + clazz + " ", " " );                                                                    // 4148
						}                                                                                                                // 4149
					}                                                                                                                 // 4150
					elem.className = value ? jQuery.trim( cur ) : "";                                                                 // 4151
				}                                                                                                                  // 4152
			}                                                                                                                   // 4153
		}                                                                                                                    // 4154
                                                                                                                       // 4155
		return this;                                                                                                         // 4156
	},                                                                                                                    // 4157
                                                                                                                       // 4158
	toggleClass: function( value, stateVal ) {                                                                            // 4159
		var type = typeof value;                                                                                             // 4160
                                                                                                                       // 4161
		if ( typeof stateVal === "boolean" && type === "string" ) {                                                          // 4162
			return stateVal ? this.addClass( value ) : this.removeClass( value );                                               // 4163
		}                                                                                                                    // 4164
                                                                                                                       // 4165
		if ( jQuery.isFunction( value ) ) {                                                                                  // 4166
			return this.each(function( i ) {                                                                                    // 4167
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );                             // 4168
			});                                                                                                                 // 4169
		}                                                                                                                    // 4170
                                                                                                                       // 4171
		return this.each(function() {                                                                                        // 4172
			if ( type === "string" ) {                                                                                          // 4173
				// toggle individual class names                                                                                   // 4174
				var className,                                                                                                     // 4175
					i = 0,                                                                                                            // 4176
					self = jQuery( this ),                                                                                            // 4177
					classNames = value.match( core_rnotwhite ) || [];                                                                 // 4178
                                                                                                                       // 4179
				while ( (className = classNames[ i++ ]) ) {                                                                        // 4180
					// check each className given, space separated list                                                               // 4181
					if ( self.hasClass( className ) ) {                                                                               // 4182
						self.removeClass( className );                                                                                   // 4183
					} else {                                                                                                          // 4184
						self.addClass( className );                                                                                      // 4185
					}                                                                                                                 // 4186
				}                                                                                                                  // 4187
                                                                                                                       // 4188
			// Toggle whole class name                                                                                          // 4189
			} else if ( type === core_strundefined || type === "boolean" ) {                                                    // 4190
				if ( this.className ) {                                                                                            // 4191
					// store className if set                                                                                         // 4192
					jQuery._data( this, "__className__", this.className );                                                            // 4193
				}                                                                                                                  // 4194
                                                                                                                       // 4195
				// If the element has a class name or if we're passed "false",                                                     // 4196
				// then remove the whole classname (if there was one, the above saved it).                                         // 4197
				// Otherwise bring back whatever was previously saved (if anything),                                               // 4198
				// falling back to the empty string if nothing was stored.                                                         // 4199
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";             // 4200
			}                                                                                                                   // 4201
		});                                                                                                                  // 4202
	},                                                                                                                    // 4203
                                                                                                                       // 4204
	hasClass: function( selector ) {                                                                                      // 4205
		var className = " " + selector + " ",                                                                                // 4206
			i = 0,                                                                                                              // 4207
			l = this.length;                                                                                                    // 4208
		for ( ; i < l; i++ ) {                                                                                               // 4209
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {   // 4210
				return true;                                                                                                       // 4211
			}                                                                                                                   // 4212
		}                                                                                                                    // 4213
                                                                                                                       // 4214
		return false;                                                                                                        // 4215
	},                                                                                                                    // 4216
                                                                                                                       // 4217
	val: function( value ) {                                                                                              // 4218
		var ret, hooks, isFunction,                                                                                          // 4219
			elem = this[0];                                                                                                     // 4220
                                                                                                                       // 4221
		if ( !arguments.length ) {                                                                                           // 4222
			if ( elem ) {                                                                                                       // 4223
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];                            // 4224
                                                                                                                       // 4225
				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {                               // 4226
					return ret;                                                                                                       // 4227
				}                                                                                                                  // 4228
                                                                                                                       // 4229
				ret = elem.value;                                                                                                  // 4230
                                                                                                                       // 4231
				return typeof ret === "string" ?                                                                                   // 4232
					// handle most common string cases                                                                                // 4233
					ret.replace(rreturn, "") :                                                                                        // 4234
					// handle cases where value is null/undef or number                                                               // 4235
					ret == null ? "" : ret;                                                                                           // 4236
			}                                                                                                                   // 4237
                                                                                                                       // 4238
			return;                                                                                                             // 4239
		}                                                                                                                    // 4240
                                                                                                                       // 4241
		isFunction = jQuery.isFunction( value );                                                                             // 4242
                                                                                                                       // 4243
		return this.each(function( i ) {                                                                                     // 4244
			var val;                                                                                                            // 4245
                                                                                                                       // 4246
			if ( this.nodeType !== 1 ) {                                                                                        // 4247
				return;                                                                                                            // 4248
			}                                                                                                                   // 4249
                                                                                                                       // 4250
			if ( isFunction ) {                                                                                                 // 4251
				val = value.call( this, i, jQuery( this ).val() );                                                                 // 4252
			} else {                                                                                                            // 4253
				val = value;                                                                                                       // 4254
			}                                                                                                                   // 4255
                                                                                                                       // 4256
			// Treat null/undefined as ""; convert numbers to string                                                            // 4257
			if ( val == null ) {                                                                                                // 4258
				val = "";                                                                                                          // 4259
			} else if ( typeof val === "number" ) {                                                                             // 4260
				val += "";                                                                                                         // 4261
			} else if ( jQuery.isArray( val ) ) {                                                                               // 4262
				val = jQuery.map(val, function ( value ) {                                                                         // 4263
					return value == null ? "" : value + "";                                                                           // 4264
				});                                                                                                                // 4265
			}                                                                                                                   // 4266
                                                                                                                       // 4267
			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];                             // 4268
                                                                                                                       // 4269
			// If set returns undefined, fall back to normal setting                                                            // 4270
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {                               // 4271
				this.value = val;                                                                                                  // 4272
			}                                                                                                                   // 4273
		});                                                                                                                  // 4274
	}                                                                                                                     // 4275
});                                                                                                                    // 4276
                                                                                                                       // 4277
jQuery.extend({                                                                                                        // 4278
	valHooks: {                                                                                                           // 4279
		option: {                                                                                                            // 4280
			get: function( elem ) {                                                                                             // 4281
				// Use proper attribute retrieval(#6932, #12072)                                                                   // 4282
				var val = jQuery.find.attr( elem, "value" );                                                                       // 4283
				return val != null ?                                                                                               // 4284
					val :                                                                                                             // 4285
					elem.text;                                                                                                        // 4286
			}                                                                                                                   // 4287
		},                                                                                                                   // 4288
		select: {                                                                                                            // 4289
			get: function( elem ) {                                                                                             // 4290
				var value, option,                                                                                                 // 4291
					options = elem.options,                                                                                           // 4292
					index = elem.selectedIndex,                                                                                       // 4293
					one = elem.type === "select-one" || index < 0,                                                                    // 4294
					values = one ? null : [],                                                                                         // 4295
					max = one ? index + 1 : options.length,                                                                           // 4296
					i = index < 0 ?                                                                                                   // 4297
						max :                                                                                                            // 4298
						one ? index : 0;                                                                                                 // 4299
                                                                                                                       // 4300
				// Loop through all the selected options                                                                           // 4301
				for ( ; i < max; i++ ) {                                                                                           // 4302
					option = options[ i ];                                                                                            // 4303
                                                                                                                       // 4304
					// oldIE doesn't update selected after form reset (#2551)                                                         // 4305
					if ( ( option.selected || i === index ) &&                                                                        // 4306
							// Don't return options that are disabled or in a disabled optgroup                                             // 4307
							( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&                 // 4308
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {                        // 4309
                                                                                                                       // 4310
						// Get the specific value for the option                                                                         // 4311
						value = jQuery( option ).val();                                                                                  // 4312
                                                                                                                       // 4313
						// We don't need an array for one selects                                                                        // 4314
						if ( one ) {                                                                                                     // 4315
							return value;                                                                                                   // 4316
						}                                                                                                                // 4317
                                                                                                                       // 4318
						// Multi-Selects return an array                                                                                 // 4319
						values.push( value );                                                                                            // 4320
					}                                                                                                                 // 4321
				}                                                                                                                  // 4322
                                                                                                                       // 4323
				return values;                                                                                                     // 4324
			},                                                                                                                  // 4325
                                                                                                                       // 4326
			set: function( elem, value ) {                                                                                      // 4327
				var optionSet, option,                                                                                             // 4328
					options = elem.options,                                                                                           // 4329
					values = jQuery.makeArray( value ),                                                                               // 4330
					i = options.length;                                                                                               // 4331
                                                                                                                       // 4332
				while ( i-- ) {                                                                                                    // 4333
					option = options[ i ];                                                                                            // 4334
					if ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {                                  // 4335
						optionSet = true;                                                                                                // 4336
					}                                                                                                                 // 4337
				}                                                                                                                  // 4338
                                                                                                                       // 4339
				// force browsers to behave consistently when non-matching value is set                                            // 4340
				if ( !optionSet ) {                                                                                                // 4341
					elem.selectedIndex = -1;                                                                                          // 4342
				}                                                                                                                  // 4343
				return values;                                                                                                     // 4344
			}                                                                                                                   // 4345
		}                                                                                                                    // 4346
	},                                                                                                                    // 4347
                                                                                                                       // 4348
	attr: function( elem, name, value ) {                                                                                 // 4349
		var hooks, ret,                                                                                                      // 4350
			nType = elem.nodeType;                                                                                              // 4351
                                                                                                                       // 4352
		// don't get/set attributes on text, comment and attribute nodes                                                     // 4353
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {                                                          // 4354
			return;                                                                                                             // 4355
		}                                                                                                                    // 4356
                                                                                                                       // 4357
		// Fallback to prop when attributes are not supported                                                                // 4358
		if ( typeof elem.getAttribute === core_strundefined ) {                                                              // 4359
			return jQuery.prop( elem, name, value );                                                                            // 4360
		}                                                                                                                    // 4361
                                                                                                                       // 4362
		// All attributes are lowercase                                                                                      // 4363
		// Grab necessary hook if one is defined                                                                             // 4364
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {                                                                     // 4365
			name = name.toLowerCase();                                                                                          // 4366
			hooks = jQuery.attrHooks[ name ] ||                                                                                 // 4367
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );                                                     // 4368
		}                                                                                                                    // 4369
                                                                                                                       // 4370
		if ( value !== undefined ) {                                                                                         // 4371
                                                                                                                       // 4372
			if ( value === null ) {                                                                                             // 4373
				jQuery.removeAttr( elem, name );                                                                                   // 4374
                                                                                                                       // 4375
			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {                     // 4376
				return ret;                                                                                                        // 4377
                                                                                                                       // 4378
			} else {                                                                                                            // 4379
				elem.setAttribute( name, value + "" );                                                                             // 4380
				return value;                                                                                                      // 4381
			}                                                                                                                   // 4382
                                                                                                                       // 4383
		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {                                  // 4384
			return ret;                                                                                                         // 4385
                                                                                                                       // 4386
		} else {                                                                                                             // 4387
			ret = jQuery.find.attr( elem, name );                                                                               // 4388
                                                                                                                       // 4389
			// Non-existent attributes return null, we normalize to undefined                                                   // 4390
			return ret == null ?                                                                                                // 4391
				undefined :                                                                                                        // 4392
				ret;                                                                                                               // 4393
		}                                                                                                                    // 4394
	},                                                                                                                    // 4395
                                                                                                                       // 4396
	removeAttr: function( elem, value ) {                                                                                 // 4397
		var name, propName,                                                                                                  // 4398
			i = 0,                                                                                                              // 4399
			attrNames = value && value.match( core_rnotwhite );                                                                 // 4400
                                                                                                                       // 4401
		if ( attrNames && elem.nodeType === 1 ) {                                                                            // 4402
			while ( (name = attrNames[i++]) ) {                                                                                 // 4403
				propName = jQuery.propFix[ name ] || name;                                                                         // 4404
                                                                                                                       // 4405
				// Boolean attributes get special treatment (#10870)                                                               // 4406
				if ( jQuery.expr.match.bool.test( name ) ) {                                                                       // 4407
					// Set corresponding property to false                                                                            // 4408
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {                                              // 4409
						elem[ propName ] = false;                                                                                        // 4410
					// Support: IE<9                                                                                                  // 4411
					// Also clear defaultChecked/defaultSelected (if appropriate)                                                     // 4412
					} else {                                                                                                          // 4413
						elem[ jQuery.camelCase( "default-" + name ) ] =                                                                  // 4414
							elem[ propName ] = false;                                                                                       // 4415
					}                                                                                                                 // 4416
                                                                                                                       // 4417
				// See #9699 for explanation of this approach (setting first, then removal)                                        // 4418
				} else {                                                                                                           // 4419
					jQuery.attr( elem, name, "" );                                                                                    // 4420
				}                                                                                                                  // 4421
                                                                                                                       // 4422
				elem.removeAttribute( getSetAttribute ? name : propName );                                                         // 4423
			}                                                                                                                   // 4424
		}                                                                                                                    // 4425
	},                                                                                                                    // 4426
                                                                                                                       // 4427
	attrHooks: {                                                                                                          // 4428
		type: {                                                                                                              // 4429
			set: function( elem, value ) {                                                                                      // 4430
				if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {                         // 4431
					// Setting the type on a radio button after the value resets the value in IE6-9                                   // 4432
					// Reset value to default in case type is set after value during creation                                         // 4433
					var val = elem.value;                                                                                             // 4434
					elem.setAttribute( "type", value );                                                                               // 4435
					if ( val ) {                                                                                                      // 4436
						elem.value = val;                                                                                                // 4437
					}                                                                                                                 // 4438
					return value;                                                                                                     // 4439
				}                                                                                                                  // 4440
			}                                                                                                                   // 4441
		}                                                                                                                    // 4442
	},                                                                                                                    // 4443
                                                                                                                       // 4444
	propFix: {                                                                                                            // 4445
		"for": "htmlFor",                                                                                                    // 4446
		"class": "className"                                                                                                 // 4447
	},                                                                                                                    // 4448
                                                                                                                       // 4449
	prop: function( elem, name, value ) {                                                                                 // 4450
		var ret, hooks, notxml,                                                                                              // 4451
			nType = elem.nodeType;                                                                                              // 4452
                                                                                                                       // 4453
		// don't get/set properties on text, comment and attribute nodes                                                     // 4454
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {                                                          // 4455
			return;                                                                                                             // 4456
		}                                                                                                                    // 4457
                                                                                                                       // 4458
		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );                                                                    // 4459
                                                                                                                       // 4460
		if ( notxml ) {                                                                                                      // 4461
			// Fix name and attach hooks                                                                                        // 4462
			name = jQuery.propFix[ name ] || name;                                                                              // 4463
			hooks = jQuery.propHooks[ name ];                                                                                   // 4464
		}                                                                                                                    // 4465
                                                                                                                       // 4466
		if ( value !== undefined ) {                                                                                         // 4467
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?                            // 4468
				ret :                                                                                                              // 4469
				( elem[ name ] = value );                                                                                          // 4470
                                                                                                                       // 4471
		} else {                                                                                                             // 4472
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?                                        // 4473
				ret :                                                                                                              // 4474
				elem[ name ];                                                                                                      // 4475
		}                                                                                                                    // 4476
	},                                                                                                                    // 4477
                                                                                                                       // 4478
	propHooks: {                                                                                                          // 4479
		tabIndex: {                                                                                                          // 4480
			get: function( elem ) {                                                                                             // 4481
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set                        // 4482
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/           // 4483
				// Use proper attribute retrieval(#12072)                                                                          // 4484
				var tabindex = jQuery.find.attr( elem, "tabindex" );                                                               // 4485
                                                                                                                       // 4486
				return tabindex ?                                                                                                  // 4487
					parseInt( tabindex, 10 ) :                                                                                        // 4488
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?                               // 4489
						0 :                                                                                                              // 4490
						-1;                                                                                                              // 4491
			}                                                                                                                   // 4492
		}                                                                                                                    // 4493
	}                                                                                                                     // 4494
});                                                                                                                    // 4495
                                                                                                                       // 4496
// Hooks for boolean attributes                                                                                        // 4497
boolHook = {                                                                                                           // 4498
	set: function( elem, value, name ) {                                                                                  // 4499
		if ( value === false ) {                                                                                             // 4500
			// Remove boolean attributes when set to false                                                                      // 4501
			jQuery.removeAttr( elem, name );                                                                                    // 4502
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {                                          // 4503
			// IE<8 needs the *property* name                                                                                   // 4504
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );                                      // 4505
                                                                                                                       // 4506
		// Use defaultChecked and defaultSelected for oldIE                                                                  // 4507
		} else {                                                                                                             // 4508
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;                                                // 4509
		}                                                                                                                    // 4510
                                                                                                                       // 4511
		return name;                                                                                                         // 4512
	}                                                                                                                     // 4513
};                                                                                                                     // 4514
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {                                      // 4515
	var getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;                                                      // 4516
                                                                                                                       // 4517
	jQuery.expr.attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?                        // 4518
		function( elem, name, isXML ) {                                                                                      // 4519
			var fn = jQuery.expr.attrHandle[ name ],                                                                            // 4520
				ret = isXML ?                                                                                                      // 4521
					undefined :                                                                                                       // 4522
					/* jshint eqeqeq: false */                                                                                        // 4523
					(jQuery.expr.attrHandle[ name ] = undefined) !=                                                                   // 4524
						getter( elem, name, isXML ) ?                                                                                    // 4525
                                                                                                                       // 4526
						name.toLowerCase() :                                                                                             // 4527
						null;                                                                                                            // 4528
			jQuery.expr.attrHandle[ name ] = fn;                                                                                // 4529
			return ret;                                                                                                         // 4530
		} :                                                                                                                  // 4531
		function( elem, name, isXML ) {                                                                                      // 4532
			return isXML ?                                                                                                      // 4533
				undefined :                                                                                                        // 4534
				elem[ jQuery.camelCase( "default-" + name ) ] ?                                                                    // 4535
					name.toLowerCase() :                                                                                              // 4536
					null;                                                                                                             // 4537
		};                                                                                                                   // 4538
});                                                                                                                    // 4539
                                                                                                                       // 4540
// fix oldIE attroperties                                                                                              // 4541
if ( !getSetInput || !getSetAttribute ) {                                                                              // 4542
	jQuery.attrHooks.value = {                                                                                            // 4543
		set: function( elem, value, name ) {                                                                                 // 4544
			if ( jQuery.nodeName( elem, "input" ) ) {                                                                           // 4545
				// Does not return so that setAttribute is also used                                                               // 4546
				elem.defaultValue = value;                                                                                         // 4547
			} else {                                                                                                            // 4548
				// Use nodeHook if defined (#1954); otherwise setAttribute is fine                                                 // 4549
				return nodeHook && nodeHook.set( elem, value, name );                                                              // 4550
			}                                                                                                                   // 4551
		}                                                                                                                    // 4552
	};                                                                                                                    // 4553
}                                                                                                                      // 4554
                                                                                                                       // 4555
// IE6/7 do not support getting/setting some attributes with get/setAttribute                                          // 4556
if ( !getSetAttribute ) {                                                                                              // 4557
                                                                                                                       // 4558
	// Use this for any attribute in IE6/7                                                                                // 4559
	// This fixes almost every IE6/7 issue                                                                                // 4560
	nodeHook = {                                                                                                          // 4561
		set: function( elem, value, name ) {                                                                                 // 4562
			// Set the existing or create a new attribute node                                                                  // 4563
			var ret = elem.getAttributeNode( name );                                                                            // 4564
			if ( !ret ) {                                                                                                       // 4565
				elem.setAttributeNode(                                                                                             // 4566
					(ret = elem.ownerDocument.createAttribute( name ))                                                                // 4567
				);                                                                                                                 // 4568
			}                                                                                                                   // 4569
                                                                                                                       // 4570
			ret.value = value += "";                                                                                            // 4571
                                                                                                                       // 4572
			// Break association with cloned elements by also using setAttribute (#9646)                                        // 4573
			return name === "value" || value === elem.getAttribute( name ) ?                                                    // 4574
				value :                                                                                                            // 4575
				undefined;                                                                                                         // 4576
		}                                                                                                                    // 4577
	};                                                                                                                    // 4578
	jQuery.expr.attrHandle.id = jQuery.expr.attrHandle.name = jQuery.expr.attrHandle.coords =                             // 4579
		// Some attributes are constructed with empty-string values when not defined                                         // 4580
		function( elem, name, isXML ) {                                                                                      // 4581
			var ret;                                                                                                            // 4582
			return isXML ?                                                                                                      // 4583
				undefined :                                                                                                        // 4584
				(ret = elem.getAttributeNode( name )) && ret.value !== "" ?                                                        // 4585
					ret.value :                                                                                                       // 4586
					null;                                                                                                             // 4587
		};                                                                                                                   // 4588
	jQuery.valHooks.button = {                                                                                            // 4589
		get: function( elem, name ) {                                                                                        // 4590
			var ret = elem.getAttributeNode( name );                                                                            // 4591
			return ret && ret.specified ?                                                                                       // 4592
				ret.value :                                                                                                        // 4593
				undefined;                                                                                                         // 4594
		},                                                                                                                   // 4595
		set: nodeHook.set                                                                                                    // 4596
	};                                                                                                                    // 4597
                                                                                                                       // 4598
	// Set contenteditable to false on removals(#10429)                                                                   // 4599
	// Setting to empty string throws an error as an invalid value                                                        // 4600
	jQuery.attrHooks.contenteditable = {                                                                                  // 4601
		set: function( elem, value, name ) {                                                                                 // 4602
			nodeHook.set( elem, value === "" ? false : value, name );                                                           // 4603
		}                                                                                                                    // 4604
	};                                                                                                                    // 4605
                                                                                                                       // 4606
	// Set width and height to auto instead of 0 on empty string( Bug #8150 )                                             // 4607
	// This is for removals                                                                                               // 4608
	jQuery.each([ "width", "height" ], function( i, name ) {                                                              // 4609
		jQuery.attrHooks[ name ] = {                                                                                         // 4610
			set: function( elem, value ) {                                                                                      // 4611
				if ( value === "" ) {                                                                                              // 4612
					elem.setAttribute( name, "auto" );                                                                                // 4613
					return value;                                                                                                     // 4614
				}                                                                                                                  // 4615
			}                                                                                                                   // 4616
		};                                                                                                                   // 4617
	});                                                                                                                   // 4618
}                                                                                                                      // 4619
                                                                                                                       // 4620
                                                                                                                       // 4621
// Some attributes require a special call on IE                                                                        // 4622
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx                                                    // 4623
if ( !jQuery.support.hrefNormalized ) {                                                                                // 4624
	// href/src property should get the full normalized URL (#10299/#12915)                                               // 4625
	jQuery.each([ "href", "src" ], function( i, name ) {                                                                  // 4626
		jQuery.propHooks[ name ] = {                                                                                         // 4627
			get: function( elem ) {                                                                                             // 4628
				return elem.getAttribute( name, 4 );                                                                               // 4629
			}                                                                                                                   // 4630
		};                                                                                                                   // 4631
	});                                                                                                                   // 4632
}                                                                                                                      // 4633
                                                                                                                       // 4634
if ( !jQuery.support.style ) {                                                                                         // 4635
	jQuery.attrHooks.style = {                                                                                            // 4636
		get: function( elem ) {                                                                                              // 4637
			// Return undefined in the case of empty string                                                                     // 4638
			// Note: IE uppercases css property names, but if we were to .toLowerCase()                                         // 4639
			// .cssText, that would destroy case senstitivity in URL's, like in "background"                                    // 4640
			return elem.style.cssText || undefined;                                                                             // 4641
		},                                                                                                                   // 4642
		set: function( elem, value ) {                                                                                       // 4643
			return ( elem.style.cssText = value + "" );                                                                         // 4644
		}                                                                                                                    // 4645
	};                                                                                                                    // 4646
}                                                                                                                      // 4647
                                                                                                                       // 4648
// Safari mis-reports the default selected property of an option                                                       // 4649
// Accessing the parent's selectedIndex property fixes it                                                              // 4650
if ( !jQuery.support.optSelected ) {                                                                                   // 4651
	jQuery.propHooks.selected = {                                                                                         // 4652
		get: function( elem ) {                                                                                              // 4653
			var parent = elem.parentNode;                                                                                       // 4654
                                                                                                                       // 4655
			if ( parent ) {                                                                                                     // 4656
				parent.selectedIndex;                                                                                              // 4657
                                                                                                                       // 4658
				// Make sure that it also works with optgroups, see #5701                                                          // 4659
				if ( parent.parentNode ) {                                                                                         // 4660
					parent.parentNode.selectedIndex;                                                                                  // 4661
				}                                                                                                                  // 4662
			}                                                                                                                   // 4663
			return null;                                                                                                        // 4664
		}                                                                                                                    // 4665
	};                                                                                                                    // 4666
}                                                                                                                      // 4667
                                                                                                                       // 4668
jQuery.each([                                                                                                          // 4669
	"tabIndex",                                                                                                           // 4670
	"readOnly",                                                                                                           // 4671
	"maxLength",                                                                                                          // 4672
	"cellSpacing",                                                                                                        // 4673
	"cellPadding",                                                                                                        // 4674
	"rowSpan",                                                                                                            // 4675
	"colSpan",                                                                                                            // 4676
	"useMap",                                                                                                             // 4677
	"frameBorder",                                                                                                        // 4678
	"contentEditable"                                                                                                     // 4679
], function() {                                                                                                        // 4680
	jQuery.propFix[ this.toLowerCase() ] = this;                                                                          // 4681
});                                                                                                                    // 4682
                                                                                                                       // 4683
// IE6/7 call enctype encoding                                                                                         // 4684
if ( !jQuery.support.enctype ) {                                                                                       // 4685
	jQuery.propFix.enctype = "encoding";                                                                                  // 4686
}                                                                                                                      // 4687
                                                                                                                       // 4688
// Radios and checkboxes getter/setter                                                                                 // 4689
jQuery.each([ "radio", "checkbox" ], function() {                                                                      // 4690
	jQuery.valHooks[ this ] = {                                                                                           // 4691
		set: function( elem, value ) {                                                                                       // 4692
			if ( jQuery.isArray( value ) ) {                                                                                    // 4693
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );                                        // 4694
			}                                                                                                                   // 4695
		}                                                                                                                    // 4696
	};                                                                                                                    // 4697
	if ( !jQuery.support.checkOn ) {                                                                                      // 4698
		jQuery.valHooks[ this ].get = function( elem ) {                                                                     // 4699
			// Support: Webkit                                                                                                  // 4700
			// "" is returned instead of "on" if a value isn't specified                                                        // 4701
			return elem.getAttribute("value") === null ? "on" : elem.value;                                                     // 4702
		};                                                                                                                   // 4703
	}                                                                                                                     // 4704
});                                                                                                                    // 4705
var rformElems = /^(?:input|select|textarea)$/i,                                                                       // 4706
	rkeyEvent = /^key/,                                                                                                   // 4707
	rmouseEvent = /^(?:mouse|contextmenu)|click/,                                                                         // 4708
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,                                                                      // 4709
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;                                                                              // 4710
                                                                                                                       // 4711
function returnTrue() {                                                                                                // 4712
	return true;                                                                                                          // 4713
}                                                                                                                      // 4714
                                                                                                                       // 4715
function returnFalse() {                                                                                               // 4716
	return false;                                                                                                         // 4717
}                                                                                                                      // 4718
                                                                                                                       // 4719
function safeActiveElement() {                                                                                         // 4720
	try {                                                                                                                 // 4721
		return document.activeElement;                                                                                       // 4722
	} catch ( err ) { }                                                                                                   // 4723
}                                                                                                                      // 4724
                                                                                                                       // 4725
/*                                                                                                                     // 4726
 * Helper functions for managing events -- not part of the public interface.                                           // 4727
 * Props to Dean Edwards' addEvent library for many of the ideas.                                                      // 4728
 */                                                                                                                    // 4729
jQuery.event = {                                                                                                       // 4730
                                                                                                                       // 4731
	global: {},                                                                                                           // 4732
                                                                                                                       // 4733
	add: function( elem, types, handler, data, selector ) {                                                               // 4734
		var tmp, events, t, handleObjIn,                                                                                     // 4735
			special, eventHandle, handleObj,                                                                                    // 4736
			handlers, type, namespaces, origType,                                                                               // 4737
			elemData = jQuery._data( elem );                                                                                    // 4738
                                                                                                                       // 4739
		// Don't attach events to noData or text/comment nodes (but allow plain objects)                                     // 4740
		if ( !elemData ) {                                                                                                   // 4741
			return;                                                                                                             // 4742
		}                                                                                                                    // 4743
                                                                                                                       // 4744
		// Caller can pass in an object of custom data in lieu of the handler                                                // 4745
		if ( handler.handler ) {                                                                                             // 4746
			handleObjIn = handler;                                                                                              // 4747
			handler = handleObjIn.handler;                                                                                      // 4748
			selector = handleObjIn.selector;                                                                                    // 4749
		}                                                                                                                    // 4750
                                                                                                                       // 4751
		// Make sure that the handler has a unique ID, used to find/remove it later                                          // 4752
		if ( !handler.guid ) {                                                                                               // 4753
			handler.guid = jQuery.guid++;                                                                                       // 4754
		}                                                                                                                    // 4755
                                                                                                                       // 4756
		// Init the element's event structure and main handler, if this is the first                                         // 4757
		if ( !(events = elemData.events) ) {                                                                                 // 4758
			events = elemData.events = {};                                                                                      // 4759
		}                                                                                                                    // 4760
		if ( !(eventHandle = elemData.handle) ) {                                                                            // 4761
			eventHandle = elemData.handle = function( e ) {                                                                     // 4762
				// Discard the second event of a jQuery.event.trigger() and                                                        // 4763
				// when an event is called after a page has unloaded                                                               // 4764
				return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?                          // 4765
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :                                                      // 4766
					undefined;                                                                                                        // 4767
			};                                                                                                                  // 4768
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events                       // 4769
			eventHandle.elem = elem;                                                                                            // 4770
		}                                                                                                                    // 4771
                                                                                                                       // 4772
		// Handle multiple events separated by a space                                                                       // 4773
		types = ( types || "" ).match( core_rnotwhite ) || [""];                                                             // 4774
		t = types.length;                                                                                                    // 4775
		while ( t-- ) {                                                                                                      // 4776
			tmp = rtypenamespace.exec( types[t] ) || [];                                                                        // 4777
			type = origType = tmp[1];                                                                                           // 4778
			namespaces = ( tmp[2] || "" ).split( "." ).sort();                                                                  // 4779
                                                                                                                       // 4780
			// There *must* be a type, no attaching namespace-only handlers                                                     // 4781
			if ( !type ) {                                                                                                      // 4782
				continue;                                                                                                          // 4783
			}                                                                                                                   // 4784
                                                                                                                       // 4785
			// If event changes its type, use the special event handlers for the changed type                                   // 4786
			special = jQuery.event.special[ type ] || {};                                                                       // 4787
                                                                                                                       // 4788
			// If selector defined, determine special event api type, otherwise given type                                      // 4789
			type = ( selector ? special.delegateType : special.bindType ) || type;                                              // 4790
                                                                                                                       // 4791
			// Update special based on newly reset type                                                                         // 4792
			special = jQuery.event.special[ type ] || {};                                                                       // 4793
                                                                                                                       // 4794
			// handleObj is passed to all event handlers                                                                        // 4795
			handleObj = jQuery.extend({                                                                                         // 4796
				type: type,                                                                                                        // 4797
				origType: origType,                                                                                                // 4798
				data: data,                                                                                                        // 4799
				handler: handler,                                                                                                  // 4800
				guid: handler.guid,                                                                                                // 4801
				selector: selector,                                                                                                // 4802
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),                                         // 4803
				namespace: namespaces.join(".")                                                                                    // 4804
			}, handleObjIn );                                                                                                   // 4805
                                                                                                                       // 4806
			// Init the event handler queue if we're the first                                                                  // 4807
			if ( !(handlers = events[ type ]) ) {                                                                               // 4808
				handlers = events[ type ] = [];                                                                                    // 4809
				handlers.delegateCount = 0;                                                                                        // 4810
                                                                                                                       // 4811
				// Only use addEventListener/attachEvent if the special events handler returns false                               // 4812
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {                     // 4813
					// Bind the global event handler to the element                                                                   // 4814
					if ( elem.addEventListener ) {                                                                                    // 4815
						elem.addEventListener( type, eventHandle, false );                                                               // 4816
                                                                                                                       // 4817
					} else if ( elem.attachEvent ) {                                                                                  // 4818
						elem.attachEvent( "on" + type, eventHandle );                                                                    // 4819
					}                                                                                                                 // 4820
				}                                                                                                                  // 4821
			}                                                                                                                   // 4822
                                                                                                                       // 4823
			if ( special.add ) {                                                                                                // 4824
				special.add.call( elem, handleObj );                                                                               // 4825
                                                                                                                       // 4826
				if ( !handleObj.handler.guid ) {                                                                                   // 4827
					handleObj.handler.guid = handler.guid;                                                                            // 4828
				}                                                                                                                  // 4829
			}                                                                                                                   // 4830
                                                                                                                       // 4831
			// Add to the element's handler list, delegates in front                                                            // 4832
			if ( selector ) {                                                                                                   // 4833
				handlers.splice( handlers.delegateCount++, 0, handleObj );                                                         // 4834
			} else {                                                                                                            // 4835
				handlers.push( handleObj );                                                                                        // 4836
			}                                                                                                                   // 4837
                                                                                                                       // 4838
			// Keep track of which events have ever been used, for event optimization                                           // 4839
			jQuery.event.global[ type ] = true;                                                                                 // 4840
		}                                                                                                                    // 4841
                                                                                                                       // 4842
		// Nullify elem to prevent memory leaks in IE                                                                        // 4843
		elem = null;                                                                                                         // 4844
	},                                                                                                                    // 4845
                                                                                                                       // 4846
	// Detach an event or set of events from an element                                                                   // 4847
	remove: function( elem, types, handler, selector, mappedTypes ) {                                                     // 4848
		var j, handleObj, tmp,                                                                                               // 4849
			origCount, t, events,                                                                                               // 4850
			special, handlers, type,                                                                                            // 4851
			namespaces, origType,                                                                                               // 4852
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );                                                          // 4853
                                                                                                                       // 4854
		if ( !elemData || !(events = elemData.events) ) {                                                                    // 4855
			return;                                                                                                             // 4856
		}                                                                                                                    // 4857
                                                                                                                       // 4858
		// Once for each type.namespace in types; type may be omitted                                                        // 4859
		types = ( types || "" ).match( core_rnotwhite ) || [""];                                                             // 4860
		t = types.length;                                                                                                    // 4861
		while ( t-- ) {                                                                                                      // 4862
			tmp = rtypenamespace.exec( types[t] ) || [];                                                                        // 4863
			type = origType = tmp[1];                                                                                           // 4864
			namespaces = ( tmp[2] || "" ).split( "." ).sort();                                                                  // 4865
                                                                                                                       // 4866
			// Unbind all events (on this namespace, if provided) for the element                                               // 4867
			if ( !type ) {                                                                                                      // 4868
				for ( type in events ) {                                                                                           // 4869
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );                                          // 4870
				}                                                                                                                  // 4871
				continue;                                                                                                          // 4872
			}                                                                                                                   // 4873
                                                                                                                       // 4874
			special = jQuery.event.special[ type ] || {};                                                                       // 4875
			type = ( selector ? special.delegateType : special.bindType ) || type;                                              // 4876
			handlers = events[ type ] || [];                                                                                    // 4877
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );                             // 4878
                                                                                                                       // 4879
			// Remove matching events                                                                                           // 4880
			origCount = j = handlers.length;                                                                                    // 4881
			while ( j-- ) {                                                                                                     // 4882
				handleObj = handlers[ j ];                                                                                         // 4883
                                                                                                                       // 4884
				if ( ( mappedTypes || origType === handleObj.origType ) &&                                                         // 4885
					( !handler || handler.guid === handleObj.guid ) &&                                                                // 4886
					( !tmp || tmp.test( handleObj.namespace ) ) &&                                                                    // 4887
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {                   // 4888
					handlers.splice( j, 1 );                                                                                          // 4889
                                                                                                                       // 4890
					if ( handleObj.selector ) {                                                                                       // 4891
						handlers.delegateCount--;                                                                                        // 4892
					}                                                                                                                 // 4893
					if ( special.remove ) {                                                                                           // 4894
						special.remove.call( elem, handleObj );                                                                          // 4895
					}                                                                                                                 // 4896
				}                                                                                                                  // 4897
			}                                                                                                                   // 4898
                                                                                                                       // 4899
			// Remove generic event handler if we removed something and no more handlers exist                                  // 4900
			// (avoids potential for endless recursion during removal of special event handlers)                                // 4901
			if ( origCount && !handlers.length ) {                                                                              // 4902
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {                 // 4903
					jQuery.removeEvent( elem, type, elemData.handle );                                                                // 4904
				}                                                                                                                  // 4905
                                                                                                                       // 4906
				delete events[ type ];                                                                                             // 4907
			}                                                                                                                   // 4908
		}                                                                                                                    // 4909
                                                                                                                       // 4910
		// Remove the expando if it's no longer used                                                                         // 4911
		if ( jQuery.isEmptyObject( events ) ) {                                                                              // 4912
			delete elemData.handle;                                                                                             // 4913
                                                                                                                       // 4914
			// removeData also checks for emptiness and clears the expando if empty                                             // 4915
			// so use it instead of delete                                                                                      // 4916
			jQuery._removeData( elem, "events" );                                                                               // 4917
		}                                                                                                                    // 4918
	},                                                                                                                    // 4919
                                                                                                                       // 4920
	trigger: function( event, data, elem, onlyHandlers ) {                                                                // 4921
		var handle, ontype, cur,                                                                                             // 4922
			bubbleType, special, tmp, i,                                                                                        // 4923
			eventPath = [ elem || document ],                                                                                   // 4924
			type = core_hasOwn.call( event, "type" ) ? event.type : event,                                                      // 4925
			namespaces = core_hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];                              // 4926
                                                                                                                       // 4927
		cur = tmp = elem = elem || document;                                                                                 // 4928
                                                                                                                       // 4929
		// Don't do events on text and comment nodes                                                                         // 4930
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {                                                                  // 4931
			return;                                                                                                             // 4932
		}                                                                                                                    // 4933
                                                                                                                       // 4934
		// focus/blur morphs to focusin/out; ensure we're not firing them right now                                          // 4935
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {                                                           // 4936
			return;                                                                                                             // 4937
		}                                                                                                                    // 4938
                                                                                                                       // 4939
		if ( type.indexOf(".") >= 0 ) {                                                                                      // 4940
			// Namespaced trigger; create a regexp to match event type in handle()                                              // 4941
			namespaces = type.split(".");                                                                                       // 4942
			type = namespaces.shift();                                                                                          // 4943
			namespaces.sort();                                                                                                  // 4944
		}                                                                                                                    // 4945
		ontype = type.indexOf(":") < 0 && "on" + type;                                                                       // 4946
                                                                                                                       // 4947
		// Caller can pass in a jQuery.Event object, Object, or just an event type string                                    // 4948
		event = event[ jQuery.expando ] ?                                                                                    // 4949
			event :                                                                                                             // 4950
			new jQuery.Event( type, typeof event === "object" && event );                                                       // 4951
                                                                                                                       // 4952
		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)                                            // 4953
		event.isTrigger = onlyHandlers ? 2 : 3;                                                                              // 4954
		event.namespace = namespaces.join(".");                                                                              // 4955
		event.namespace_re = event.namespace ?                                                                               // 4956
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :                                            // 4957
			null;                                                                                                               // 4958
                                                                                                                       // 4959
		// Clean up the event in case it is being reused                                                                     // 4960
		event.result = undefined;                                                                                            // 4961
		if ( !event.target ) {                                                                                               // 4962
			event.target = elem;                                                                                                // 4963
		}                                                                                                                    // 4964
                                                                                                                       // 4965
		// Clone any incoming data and prepend the event, creating the handler arg list                                      // 4966
		data = data == null ?                                                                                                // 4967
			[ event ] :                                                                                                         // 4968
			jQuery.makeArray( data, [ event ] );                                                                                // 4969
                                                                                                                       // 4970
		// Allow special events to draw outside the lines                                                                    // 4971
		special = jQuery.event.special[ type ] || {};                                                                        // 4972
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {                           // 4973
			return;                                                                                                             // 4974
		}                                                                                                                    // 4975
                                                                                                                       // 4976
		// Determine event propagation path in advance, per W3C events spec (#9951)                                          // 4977
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)                               // 4978
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {                                              // 4979
                                                                                                                       // 4980
			bubbleType = special.delegateType || type;                                                                          // 4981
			if ( !rfocusMorph.test( bubbleType + type ) ) {                                                                     // 4982
				cur = cur.parentNode;                                                                                              // 4983
			}                                                                                                                   // 4984
			for ( ; cur; cur = cur.parentNode ) {                                                                               // 4985
				eventPath.push( cur );                                                                                             // 4986
				tmp = cur;                                                                                                         // 4987
			}                                                                                                                   // 4988
                                                                                                                       // 4989
			// Only add window if we got to document (e.g., not plain obj or detached DOM)                                      // 4990
			if ( tmp === (elem.ownerDocument || document) ) {                                                                   // 4991
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );                                                   // 4992
			}                                                                                                                   // 4993
		}                                                                                                                    // 4994
                                                                                                                       // 4995
		// Fire handlers on the event path                                                                                   // 4996
		i = 0;                                                                                                               // 4997
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {                                                  // 4998
                                                                                                                       // 4999
			event.type = i > 1 ?                                                                                                // 5000
				bubbleType :                                                                                                       // 5001
				special.bindType || type;                                                                                          // 5002
                                                                                                                       // 5003
			// jQuery handler                                                                                                   // 5004
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );                    // 5005
			if ( handle ) {                                                                                                     // 5006
				handle.apply( cur, data );                                                                                         // 5007
			}                                                                                                                   // 5008
                                                                                                                       // 5009
			// Native handler                                                                                                   // 5010
			handle = ontype && cur[ ontype ];                                                                                   // 5011
			if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {                  // 5012
				event.preventDefault();                                                                                            // 5013
			}                                                                                                                   // 5014
		}                                                                                                                    // 5015
		event.type = type;                                                                                                   // 5016
                                                                                                                       // 5017
		// If nobody prevented the default action, do it now                                                                 // 5018
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {                                                                // 5019
                                                                                                                       // 5020
			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&                            // 5021
				jQuery.acceptData( elem ) ) {                                                                                      // 5022
                                                                                                                       // 5023
				// Call a native DOM method on the target with the same name name as the event.                                    // 5024
				// Can't use an .isFunction() check here because IE6/7 fails that test.                                            // 5025
				// Don't do default actions on window, that's where global variables be (#6170)                                    // 5026
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {                                                        // 5027
                                                                                                                       // 5028
					// Don't re-trigger an onFOO event when we call its FOO() method                                                  // 5029
					tmp = elem[ ontype ];                                                                                             // 5030
                                                                                                                       // 5031
					if ( tmp ) {                                                                                                      // 5032
						elem[ ontype ] = null;                                                                                           // 5033
					}                                                                                                                 // 5034
                                                                                                                       // 5035
					// Prevent re-triggering of the same event, since we already bubbled it above                                     // 5036
					jQuery.event.triggered = type;                                                                                    // 5037
					try {                                                                                                             // 5038
						elem[ type ]();                                                                                                  // 5039
					} catch ( e ) {                                                                                                   // 5040
						// IE<9 dies on focus/blur to hidden element (#1486,#12518)                                                      // 5041
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode                                                    // 5042
					}                                                                                                                 // 5043
					jQuery.event.triggered = undefined;                                                                               // 5044
                                                                                                                       // 5045
					if ( tmp ) {                                                                                                      // 5046
						elem[ ontype ] = tmp;                                                                                            // 5047
					}                                                                                                                 // 5048
				}                                                                                                                  // 5049
			}                                                                                                                   // 5050
		}                                                                                                                    // 5051
                                                                                                                       // 5052
		return event.result;                                                                                                 // 5053
	},                                                                                                                    // 5054
                                                                                                                       // 5055
	dispatch: function( event ) {                                                                                         // 5056
                                                                                                                       // 5057
		// Make a writable jQuery.Event from the native event object                                                         // 5058
		event = jQuery.event.fix( event );                                                                                   // 5059
                                                                                                                       // 5060
		var i, ret, handleObj, matched, j,                                                                                   // 5061
			handlerQueue = [],                                                                                                  // 5062
			args = core_slice.call( arguments ),                                                                                // 5063
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],                                            // 5064
			special = jQuery.event.special[ event.type ] || {};                                                                 // 5065
                                                                                                                       // 5066
		// Use the fix-ed jQuery.Event rather than the (read-only) native event                                              // 5067
		args[0] = event;                                                                                                     // 5068
		event.delegateTarget = this;                                                                                         // 5069
                                                                                                                       // 5070
		// Call the preDispatch hook for the mapped type, and let it bail if desired                                         // 5071
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {                                    // 5072
			return;                                                                                                             // 5073
		}                                                                                                                    // 5074
                                                                                                                       // 5075
		// Determine handlers                                                                                                // 5076
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );                                                  // 5077
                                                                                                                       // 5078
		// Run delegates first; they may want to stop propagation beneath us                                                 // 5079
		i = 0;                                                                                                               // 5080
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {                                         // 5081
			event.currentTarget = matched.elem;                                                                                 // 5082
                                                                                                                       // 5083
			j = 0;                                                                                                              // 5084
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {                         // 5085
                                                                                                                       // 5086
				// Triggered event must either 1) have no namespace, or                                                            // 5087
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).                // 5088
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {                                     // 5089
                                                                                                                       // 5090
					event.handleObj = handleObj;                                                                                      // 5091
					event.data = handleObj.data;                                                                                      // 5092
                                                                                                                       // 5093
					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )                          // 5094
							.apply( matched.elem, args );                                                                                   // 5095
                                                                                                                       // 5096
					if ( ret !== undefined ) {                                                                                        // 5097
						if ( (event.result = ret) === false ) {                                                                          // 5098
							event.preventDefault();                                                                                         // 5099
							event.stopPropagation();                                                                                        // 5100
						}                                                                                                                // 5101
					}                                                                                                                 // 5102
				}                                                                                                                  // 5103
			}                                                                                                                   // 5104
		}                                                                                                                    // 5105
                                                                                                                       // 5106
		// Call the postDispatch hook for the mapped type                                                                    // 5107
		if ( special.postDispatch ) {                                                                                        // 5108
			special.postDispatch.call( this, event );                                                                           // 5109
		}                                                                                                                    // 5110
                                                                                                                       // 5111
		return event.result;                                                                                                 // 5112
	},                                                                                                                    // 5113
                                                                                                                       // 5114
	handlers: function( event, handlers ) {                                                                               // 5115
		var sel, handleObj, matches, i,                                                                                      // 5116
			handlerQueue = [],                                                                                                  // 5117
			delegateCount = handlers.delegateCount,                                                                             // 5118
			cur = event.target;                                                                                                 // 5119
                                                                                                                       // 5120
		// Find delegate handlers                                                                                            // 5121
		// Black-hole SVG <use> instance trees (#13180)                                                                      // 5122
		// Avoid non-left-click bubbling in Firefox (#3861)                                                                  // 5123
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {                                  // 5124
                                                                                                                       // 5125
			/* jshint eqeqeq: false */                                                                                          // 5126
			for ( ; cur != this; cur = cur.parentNode || this ) {                                                               // 5127
				/* jshint eqeqeq: true */                                                                                          // 5128
                                                                                                                       // 5129
				// Don't check non-elements (#13208)                                                                               // 5130
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)                                        // 5131
				if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {                                   // 5132
					matches = [];                                                                                                     // 5133
					for ( i = 0; i < delegateCount; i++ ) {                                                                           // 5134
						handleObj = handlers[ i ];                                                                                       // 5135
                                                                                                                       // 5136
						// Don't conflict with Object.prototype properties (#13203)                                                      // 5137
						sel = handleObj.selector + " ";                                                                                  // 5138
                                                                                                                       // 5139
						if ( matches[ sel ] === undefined ) {                                                                            // 5140
							matches[ sel ] = handleObj.needsContext ?                                                                       // 5141
								jQuery( sel, this ).index( cur ) >= 0 :                                                                        // 5142
								jQuery.find( sel, this, null, [ cur ] ).length;                                                                // 5143
						}                                                                                                                // 5144
						if ( matches[ sel ] ) {                                                                                          // 5145
							matches.push( handleObj );                                                                                      // 5146
						}                                                                                                                // 5147
					}                                                                                                                 // 5148
					if ( matches.length ) {                                                                                           // 5149
						handlerQueue.push({ elem: cur, handlers: matches });                                                             // 5150
					}                                                                                                                 // 5151
				}                                                                                                                  // 5152
			}                                                                                                                   // 5153
		}                                                                                                                    // 5154
                                                                                                                       // 5155
		// Add the remaining (directly-bound) handlers                                                                       // 5156
		if ( delegateCount < handlers.length ) {                                                                             // 5157
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });                                       // 5158
		}                                                                                                                    // 5159
                                                                                                                       // 5160
		return handlerQueue;                                                                                                 // 5161
	},                                                                                                                    // 5162
                                                                                                                       // 5163
	fix: function( event ) {                                                                                              // 5164
		if ( event[ jQuery.expando ] ) {                                                                                     // 5165
			return event;                                                                                                       // 5166
		}                                                                                                                    // 5167
                                                                                                                       // 5168
		// Create a writable copy of the event object and normalize some properties                                          // 5169
		var i, prop, copy,                                                                                                   // 5170
			type = event.type,                                                                                                  // 5171
			originalEvent = event,                                                                                              // 5172
			fixHook = this.fixHooks[ type ];                                                                                    // 5173
                                                                                                                       // 5174
		if ( !fixHook ) {                                                                                                    // 5175
			this.fixHooks[ type ] = fixHook =                                                                                   // 5176
				rmouseEvent.test( type ) ? this.mouseHooks :                                                                       // 5177
				rkeyEvent.test( type ) ? this.keyHooks :                                                                           // 5178
				{};                                                                                                                // 5179
		}                                                                                                                    // 5180
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;                                              // 5181
                                                                                                                       // 5182
		event = new jQuery.Event( originalEvent );                                                                           // 5183
                                                                                                                       // 5184
		i = copy.length;                                                                                                     // 5185
		while ( i-- ) {                                                                                                      // 5186
			prop = copy[ i ];                                                                                                   // 5187
			event[ prop ] = originalEvent[ prop ];                                                                              // 5188
		}                                                                                                                    // 5189
                                                                                                                       // 5190
		// Support: IE<9                                                                                                     // 5191
		// Fix target property (#1925)                                                                                       // 5192
		if ( !event.target ) {                                                                                               // 5193
			event.target = originalEvent.srcElement || document;                                                                // 5194
		}                                                                                                                    // 5195
                                                                                                                       // 5196
		// Support: Chrome 23+, Safari?                                                                                      // 5197
		// Target should not be a text node (#504, #13143)                                                                   // 5198
		if ( event.target.nodeType === 3 ) {                                                                                 // 5199
			event.target = event.target.parentNode;                                                                             // 5200
		}                                                                                                                    // 5201
                                                                                                                       // 5202
		// Support: IE<9                                                                                                     // 5203
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)                                            // 5204
		event.metaKey = !!event.metaKey;                                                                                     // 5205
                                                                                                                       // 5206
		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;                                              // 5207
	},                                                                                                                    // 5208
                                                                                                                       // 5209
	// Includes some event props shared by KeyEvent and MouseEvent                                                        // 5210
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
                                                                                                                       // 5212
	fixHooks: {},                                                                                                         // 5213
                                                                                                                       // 5214
	keyHooks: {                                                                                                           // 5215
		props: "char charCode key keyCode".split(" "),                                                                       // 5216
		filter: function( event, original ) {                                                                                // 5217
                                                                                                                       // 5218
			// Add which for key events                                                                                         // 5219
			if ( event.which == null ) {                                                                                        // 5220
				event.which = original.charCode != null ? original.charCode : original.keyCode;                                    // 5221
			}                                                                                                                   // 5222
                                                                                                                       // 5223
			return event;                                                                                                       // 5224
		}                                                                                                                    // 5225
	},                                                                                                                    // 5226
                                                                                                                       // 5227
	mouseHooks: {                                                                                                         // 5228
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {                                                                                // 5230
			var body, eventDoc, doc,                                                                                            // 5231
				button = original.button,                                                                                          // 5232
				fromElement = original.fromElement;                                                                                // 5233
                                                                                                                       // 5234
			// Calculate pageX/Y if missing and clientX/Y available                                                             // 5235
			if ( event.pageX == null && original.clientX != null ) {                                                            // 5236
				eventDoc = event.target.ownerDocument || document;                                                                 // 5237
				doc = eventDoc.documentElement;                                                                                    // 5238
				body = eventDoc.body;                                                                                              // 5239
                                                                                                                       // 5240
				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}                                                                                                                   // 5243
                                                                                                                       // 5244
			// Add relatedTarget, if necessary                                                                                  // 5245
			if ( !event.relatedTarget && fromElement ) {                                                                        // 5246
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;                             // 5247
			}                                                                                                                   // 5248
                                                                                                                       // 5249
			// Add which for click: 1 === left; 2 === middle; 3 === right                                                       // 5250
			// Note: button is not normalized, so don't use it                                                                  // 5251
			if ( !event.which && button !== undefined ) {                                                                       // 5252
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );                                    // 5253
			}                                                                                                                   // 5254
                                                                                                                       // 5255
			return event;                                                                                                       // 5256
		}                                                                                                                    // 5257
	},                                                                                                                    // 5258
                                                                                                                       // 5259
	special: {                                                                                                            // 5260
		load: {                                                                                                              // 5261
			// Prevent triggered image.load events from bubbling to window.load                                                 // 5262
			noBubble: true                                                                                                      // 5263
		},                                                                                                                   // 5264
		focus: {                                                                                                             // 5265
			// Fire native event if possible so blur/focus sequence is correct                                                  // 5266
			trigger: function() {                                                                                               // 5267
				if ( this !== safeActiveElement() && this.focus ) {                                                                // 5268
					try {                                                                                                             // 5269
						this.focus();                                                                                                    // 5270
						return false;                                                                                                    // 5271
					} catch ( e ) {                                                                                                   // 5272
						// Support: IE<9                                                                                                 // 5273
						// If we error on focus to hidden element (#1486, #12518),                                                       // 5274
						// let .trigger() run the handlers                                                                               // 5275
					}                                                                                                                 // 5276
				}                                                                                                                  // 5277
			},                                                                                                                  // 5278
			delegateType: "focusin"                                                                                             // 5279
		},                                                                                                                   // 5280
		blur: {                                                                                                              // 5281
			trigger: function() {                                                                                               // 5282
				if ( this === safeActiveElement() && this.blur ) {                                                                 // 5283
					this.blur();                                                                                                      // 5284
					return false;                                                                                                     // 5285
				}                                                                                                                  // 5286
			},                                                                                                                  // 5287
			delegateType: "focusout"                                                                                            // 5288
		},                                                                                                                   // 5289
		click: {                                                                                                             // 5290
			// For checkbox, fire native event so checked state will be right                                                   // 5291
			trigger: function() {                                                                                               // 5292
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {                                // 5293
					this.click();                                                                                                     // 5294
					return false;                                                                                                     // 5295
				}                                                                                                                  // 5296
			},                                                                                                                  // 5297
                                                                                                                       // 5298
			// For cross-browser consistency, don't fire native .click() on links                                               // 5299
			_default: function( event ) {                                                                                       // 5300
				return jQuery.nodeName( event.target, "a" );                                                                       // 5301
			}                                                                                                                   // 5302
		},                                                                                                                   // 5303
                                                                                                                       // 5304
		beforeunload: {                                                                                                      // 5305
			postDispatch: function( event ) {                                                                                   // 5306
                                                                                                                       // 5307
				// Even when returnValue equals to undefined Firefox will still show alert                                         // 5308
				if ( event.result !== undefined ) {                                                                                // 5309
					event.originalEvent.returnValue = event.result;                                                                   // 5310
				}                                                                                                                  // 5311
			}                                                                                                                   // 5312
		}                                                                                                                    // 5313
	},                                                                                                                    // 5314
                                                                                                                       // 5315
	simulate: function( type, elem, event, bubble ) {                                                                     // 5316
		// Piggyback on a donor event to simulate a different one.                                                           // 5317
		// Fake originalEvent to avoid donor's stopPropagation, but if the                                                   // 5318
		// simulated event prevents default then we do the same on the donor.                                                // 5319
		var e = jQuery.extend(                                                                                               // 5320
			new jQuery.Event(),                                                                                                 // 5321
			event,                                                                                                              // 5322
			{                                                                                                                   // 5323
				type: type,                                                                                                        // 5324
				isSimulated: true,                                                                                                 // 5325
				originalEvent: {}                                                                                                  // 5326
			}                                                                                                                   // 5327
		);                                                                                                                   // 5328
		if ( bubble ) {                                                                                                      // 5329
			jQuery.event.trigger( e, null, elem );                                                                              // 5330
		} else {                                                                                                             // 5331
			jQuery.event.dispatch.call( elem, e );                                                                              // 5332
		}                                                                                                                    // 5333
		if ( e.isDefaultPrevented() ) {                                                                                      // 5334
			event.preventDefault();                                                                                             // 5335
		}                                                                                                                    // 5336
	}                                                                                                                     // 5337
};                                                                                                                     // 5338
                                                                                                                       // 5339
jQuery.removeEvent = document.removeEventListener ?                                                                    // 5340
	function( elem, type, handle ) {                                                                                      // 5341
		if ( elem.removeEventListener ) {                                                                                    // 5342
			elem.removeEventListener( type, handle, false );                                                                    // 5343
		}                                                                                                                    // 5344
	} :                                                                                                                   // 5345
	function( elem, type, handle ) {                                                                                      // 5346
		var name = "on" + type;                                                                                              // 5347
                                                                                                                       // 5348
		if ( elem.detachEvent ) {                                                                                            // 5349
                                                                                                                       // 5350
			// #8545, #7054, preventing memory leaks for custom events in IE6-8                                                 // 5351
			// detachEvent needed property on element, by name of that event, to properly expose it to GC                       // 5352
			if ( typeof elem[ name ] === core_strundefined ) {                                                                  // 5353
				elem[ name ] = null;                                                                                               // 5354
			}                                                                                                                   // 5355
                                                                                                                       // 5356
			elem.detachEvent( name, handle );                                                                                   // 5357
		}                                                                                                                    // 5358
	};                                                                                                                    // 5359
                                                                                                                       // 5360
jQuery.Event = function( src, props ) {                                                                                // 5361
	// Allow instantiation without the 'new' keyword                                                                      // 5362
	if ( !(this instanceof jQuery.Event) ) {                                                                              // 5363
		return new jQuery.Event( src, props );                                                                               // 5364
	}                                                                                                                     // 5365
                                                                                                                       // 5366
	// Event object                                                                                                       // 5367
	if ( src && src.type ) {                                                                                              // 5368
		this.originalEvent = src;                                                                                            // 5369
		this.type = src.type;                                                                                                // 5370
                                                                                                                       // 5371
		// Events bubbling up the document may have been marked as prevented                                                 // 5372
		// by a handler lower down the tree; reflect the correct value.                                                      // 5373
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||                                     // 5374
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;                                      // 5375
                                                                                                                       // 5376
	// Event type                                                                                                         // 5377
	} else {                                                                                                              // 5378
		this.type = src;                                                                                                     // 5379
	}                                                                                                                     // 5380
                                                                                                                       // 5381
	// Put explicitly provided properties onto the event object                                                           // 5382
	if ( props ) {                                                                                                        // 5383
		jQuery.extend( this, props );                                                                                        // 5384
	}                                                                                                                     // 5385
                                                                                                                       // 5386
	// Create a timestamp if incoming event doesn't have one                                                              // 5387
	this.timeStamp = src && src.timeStamp || jQuery.now();                                                                // 5388
                                                                                                                       // 5389
	// Mark it as fixed                                                                                                   // 5390
	this[ jQuery.expando ] = true;                                                                                        // 5391
};                                                                                                                     // 5392
                                                                                                                       // 5393
// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding                                // 5394
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html                                   // 5395
jQuery.Event.prototype = {                                                                                             // 5396
	isDefaultPrevented: returnFalse,                                                                                      // 5397
	isPropagationStopped: returnFalse,                                                                                    // 5398
	isImmediatePropagationStopped: returnFalse,                                                                           // 5399
                                                                                                                       // 5400
	preventDefault: function() {                                                                                          // 5401
		var e = this.originalEvent;                                                                                          // 5402
                                                                                                                       // 5403
		this.isDefaultPrevented = returnTrue;                                                                                // 5404
		if ( !e ) {                                                                                                          // 5405
			return;                                                                                                             // 5406
		}                                                                                                                    // 5407
                                                                                                                       // 5408
		// If preventDefault exists, run it on the original event                                                            // 5409
		if ( e.preventDefault ) {                                                                                            // 5410
			e.preventDefault();                                                                                                 // 5411
                                                                                                                       // 5412
		// Support: IE                                                                                                       // 5413
		// Otherwise set the returnValue property of the original event to false                                             // 5414
		} else {                                                                                                             // 5415
			e.returnValue = false;                                                                                              // 5416
		}                                                                                                                    // 5417
	},                                                                                                                    // 5418
	stopPropagation: function() {                                                                                         // 5419
		var e = this.originalEvent;                                                                                          // 5420
                                                                                                                       // 5421
		this.isPropagationStopped = returnTrue;                                                                              // 5422
		if ( !e ) {                                                                                                          // 5423
			return;                                                                                                             // 5424
		}                                                                                                                    // 5425
		// If stopPropagation exists, run it on the original event                                                           // 5426
		if ( e.stopPropagation ) {                                                                                           // 5427
			e.stopPropagation();                                                                                                // 5428
		}                                                                                                                    // 5429
                                                                                                                       // 5430
		// Support: IE                                                                                                       // 5431
		// Set the cancelBubble property of the original event to true                                                       // 5432
		e.cancelBubble = true;                                                                                               // 5433
	},                                                                                                                    // 5434
	stopImmediatePropagation: function() {                                                                                // 5435
		this.isImmediatePropagationStopped = returnTrue;                                                                     // 5436
		this.stopPropagation();                                                                                              // 5437
	}                                                                                                                     // 5438
};                                                                                                                     // 5439
                                                                                                                       // 5440
// Create mouseenter/leave events using mouseover/out and event-time checks                                            // 5441
jQuery.each({                                                                                                          // 5442
	mouseenter: "mouseover",                                                                                              // 5443
	mouseleave: "mouseout"                                                                                                // 5444
}, function( orig, fix ) {                                                                                             // 5445
	jQuery.event.special[ orig ] = {                                                                                      // 5446
		delegateType: fix,                                                                                                   // 5447
		bindType: fix,                                                                                                       // 5448
                                                                                                                       // 5449
		handle: function( event ) {                                                                                          // 5450
			var ret,                                                                                                            // 5451
				target = this,                                                                                                     // 5452
				related = event.relatedTarget,                                                                                     // 5453
				handleObj = event.handleObj;                                                                                       // 5454
                                                                                                                       // 5455
			// For mousenter/leave call the handler if related is outside the target.                                           // 5456
			// NB: No relatedTarget if the mouse left/entered the browser window                                                // 5457
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {                                    // 5458
				event.type = handleObj.origType;                                                                                   // 5459
				ret = handleObj.handler.apply( this, arguments );                                                                  // 5460
				event.type = fix;                                                                                                  // 5461
			}                                                                                                                   // 5462
			return ret;                                                                                                         // 5463
		}                                                                                                                    // 5464
	};                                                                                                                    // 5465
});                                                                                                                    // 5466
                                                                                                                       // 5467
// IE submit delegation                                                                                                // 5468
if ( !jQuery.support.submitBubbles ) {                                                                                 // 5469
                                                                                                                       // 5470
	jQuery.event.special.submit = {                                                                                       // 5471
		setup: function() {                                                                                                  // 5472
			// Only need this for delegated form submit events                                                                  // 5473
			if ( jQuery.nodeName( this, "form" ) ) {                                                                            // 5474
				return false;                                                                                                      // 5475
			}                                                                                                                   // 5476
                                                                                                                       // 5477
			// Lazy-add a submit handler when a descendant form may potentially be submitted                                    // 5478
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {                                           // 5479
				// Node name check avoids a VML-related crash in IE (#9807)                                                        // 5480
				var elem = e.target,                                                                                               // 5481
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;             // 5482
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {                                                            // 5483
					jQuery.event.add( form, "submit._submit", function( event ) {                                                     // 5484
						event._submit_bubble = true;                                                                                     // 5485
					});                                                                                                               // 5486
					jQuery._data( form, "submitBubbles", true );                                                                      // 5487
				}                                                                                                                  // 5488
			});                                                                                                                 // 5489
			// return undefined since we don't need an event listener                                                           // 5490
		},                                                                                                                   // 5491
                                                                                                                       // 5492
		postDispatch: function( event ) {                                                                                    // 5493
			// If form was submitted by the user, bubble the event up the tree                                                  // 5494
			if ( event._submit_bubble ) {                                                                                       // 5495
				delete event._submit_bubble;                                                                                       // 5496
				if ( this.parentNode && !event.isTrigger ) {                                                                       // 5497
					jQuery.event.simulate( "submit", this.parentNode, event, true );                                                  // 5498
				}                                                                                                                  // 5499
			}                                                                                                                   // 5500
		},                                                                                                                   // 5501
                                                                                                                       // 5502
		teardown: function() {                                                                                               // 5503
			// Only need this for delegated form submit events                                                                  // 5504
			if ( jQuery.nodeName( this, "form" ) ) {                                                                            // 5505
				return false;                                                                                                      // 5506
			}                                                                                                                   // 5507
                                                                                                                       // 5508
			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above                             // 5509
			jQuery.event.remove( this, "._submit" );                                                                            // 5510
		}                                                                                                                    // 5511
	};                                                                                                                    // 5512
}                                                                                                                      // 5513
                                                                                                                       // 5514
// IE change delegation and checkbox/radio fix                                                                         // 5515
if ( !jQuery.support.changeBubbles ) {                                                                                 // 5516
                                                                                                                       // 5517
	jQuery.event.special.change = {                                                                                       // 5518
                                                                                                                       // 5519
		setup: function() {                                                                                                  // 5520
                                                                                                                       // 5521
			if ( rformElems.test( this.nodeName ) ) {                                                                           // 5522
				// IE doesn't fire change on a check/radio until blur; trigger it on click                                         // 5523
				// after a propertychange. Eat the blur-change in special.change.handle.                                           // 5524
				// This still fires onchange a second time for check/radio after blur.                                             // 5525
				if ( this.type === "checkbox" || this.type === "radio" ) {                                                         // 5526
					jQuery.event.add( this, "propertychange._change", function( event ) {                                             // 5527
						if ( event.originalEvent.propertyName === "checked" ) {                                                          // 5528
							this._just_changed = true;                                                                                      // 5529
						}                                                                                                                // 5530
					});                                                                                                               // 5531
					jQuery.event.add( this, "click._change", function( event ) {                                                      // 5532
						if ( this._just_changed && !event.isTrigger ) {                                                                  // 5533
							this._just_changed = false;                                                                                     // 5534
						}                                                                                                                // 5535
						// Allow triggered, simulated change events (#11500)                                                             // 5536
						jQuery.event.simulate( "change", this, event, true );                                                            // 5537
					});                                                                                                               // 5538
				}                                                                                                                  // 5539
				return false;                                                                                                      // 5540
			}                                                                                                                   // 5541
			// Delegated event; lazy-add a change handler on descendant inputs                                                  // 5542
			jQuery.event.add( this, "beforeactivate._change", function( e ) {                                                   // 5543
				var elem = e.target;                                                                                               // 5544
                                                                                                                       // 5545
				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {                                // 5546
					jQuery.event.add( elem, "change._change", function( event ) {                                                     // 5547
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {                                               // 5548
							jQuery.event.simulate( "change", this.parentNode, event, true );                                                // 5549
						}                                                                                                                // 5550
					});                                                                                                               // 5551
					jQuery._data( elem, "changeBubbles", true );                                                                      // 5552
				}                                                                                                                  // 5553
			});                                                                                                                 // 5554
		},                                                                                                                   // 5555
                                                                                                                       // 5556
		handle: function( event ) {                                                                                          // 5557
			var elem = event.target;                                                                                            // 5558
                                                                                                                       // 5559
			// Swallow native change events from checkbox/radio, we already triggered them above                                // 5560
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );                                                           // 5562
			}                                                                                                                   // 5563
		},                                                                                                                   // 5564
                                                                                                                       // 5565
		teardown: function() {                                                                                               // 5566
			jQuery.event.remove( this, "._change" );                                                                            // 5567
                                                                                                                       // 5568
			return !rformElems.test( this.nodeName );                                                                           // 5569
		}                                                                                                                    // 5570
	};                                                                                                                    // 5571
}                                                                                                                      // 5572
                                                                                                                       // 5573
// Create "bubbling" focus and blur events                                                                             // 5574
if ( !jQuery.support.focusinBubbles ) {                                                                                // 5575
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {                                           // 5576
                                                                                                                       // 5577
		// Attach a single capturing handler while someone wants focusin/focusout                                            // 5578
		var attaches = 0,                                                                                                    // 5579
			handler = function( event ) {                                                                                       // 5580
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );                                       // 5581
			};                                                                                                                  // 5582
                                                                                                                       // 5583
		jQuery.event.special[ fix ] = {                                                                                      // 5584
			setup: function() {                                                                                                 // 5585
				if ( attaches++ === 0 ) {                                                                                          // 5586
					document.addEventListener( orig, handler, true );                                                                 // 5587
				}                                                                                                                  // 5588
			},                                                                                                                  // 5589
			teardown: function() {                                                                                              // 5590
				if ( --attaches === 0 ) {                                                                                          // 5591
					document.removeEventListener( orig, handler, true );                                                              // 5592
				}                                                                                                                  // 5593
			}                                                                                                                   // 5594
		};                                                                                                                   // 5595
	});                                                                                                                   // 5596
}                                                                                                                      // 5597
                                                                                                                       // 5598
jQuery.fn.extend({                                                                                                     // 5599
                                                                                                                       // 5600
	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {                                                         // 5601
		var type, origFn;                                                                                                    // 5602
                                                                                                                       // 5603
		// Types can be a map of types/handlers                                                                              // 5604
		if ( typeof types === "object" ) {                                                                                   // 5605
			// ( types-Object, selector, data )                                                                                 // 5606
			if ( typeof selector !== "string" ) {                                                                               // 5607
				// ( types-Object, data )                                                                                          // 5608
				data = data || selector;                                                                                           // 5609
				selector = undefined;                                                                                              // 5610
			}                                                                                                                   // 5611
			for ( type in types ) {                                                                                             // 5612
				this.on( type, selector, data, types[ type ], one );                                                               // 5613
			}                                                                                                                   // 5614
			return this;                                                                                                        // 5615
		}                                                                                                                    // 5616
                                                                                                                       // 5617
		if ( data == null && fn == null ) {                                                                                  // 5618
			// ( types, fn )                                                                                                    // 5619
			fn = selector;                                                                                                      // 5620
			data = selector = undefined;                                                                                        // 5621
		} else if ( fn == null ) {                                                                                           // 5622
			if ( typeof selector === "string" ) {                                                                               // 5623
				// ( types, selector, fn )                                                                                         // 5624
				fn = data;                                                                                                         // 5625
				data = undefined;                                                                                                  // 5626
			} else {                                                                                                            // 5627
				// ( types, data, fn )                                                                                             // 5628
				fn = data;                                                                                                         // 5629
				data = selector;                                                                                                   // 5630
				selector = undefined;                                                                                              // 5631
			}                                                                                                                   // 5632
		}                                                                                                                    // 5633
		if ( fn === false ) {                                                                                                // 5634
			fn = returnFalse;                                                                                                   // 5635
		} else if ( !fn ) {                                                                                                  // 5636
			return this;                                                                                                        // 5637
		}                                                                                                                    // 5638
                                                                                                                       // 5639
		if ( one === 1 ) {                                                                                                   // 5640
			origFn = fn;                                                                                                        // 5641
			fn = function( event ) {                                                                                            // 5642
				// Can use an empty set, since event contains the info                                                             // 5643
				jQuery().off( event );                                                                                             // 5644
				return origFn.apply( this, arguments );                                                                            // 5645
			};                                                                                                                  // 5646
			// Use same guid so caller can remove using origFn                                                                  // 5647
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );                                                           // 5648
		}                                                                                                                    // 5649
		return this.each( function() {                                                                                       // 5650
			jQuery.event.add( this, types, fn, data, selector );                                                                // 5651
		});                                                                                                                  // 5652
	},                                                                                                                    // 5653
	one: function( types, selector, data, fn ) {                                                                          // 5654
		return this.on( types, selector, data, fn, 1 );                                                                      // 5655
	},                                                                                                                    // 5656
	off: function( types, selector, fn ) {                                                                                // 5657
		var handleObj, type;                                                                                                 // 5658
		if ( types && types.preventDefault && types.handleObj ) {                                                            // 5659
			// ( event )  dispatched jQuery.Event                                                                               // 5660
			handleObj = types.handleObj;                                                                                        // 5661
			jQuery( types.delegateTarget ).off(                                                                                 // 5662
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,                         // 5663
				handleObj.selector,                                                                                                // 5664
				handleObj.handler                                                                                                  // 5665
			);                                                                                                                  // 5666
			return this;                                                                                                        // 5667
		}                                                                                                                    // 5668
		if ( typeof types === "object" ) {                                                                                   // 5669
			// ( types-object [, selector] )                                                                                    // 5670
			for ( type in types ) {                                                                                             // 5671
				this.off( type, selector, types[ type ] );                                                                         // 5672
			}                                                                                                                   // 5673
			return this;                                                                                                        // 5674
		}                                                                                                                    // 5675
		if ( selector === false || typeof selector === "function" ) {                                                        // 5676
			// ( types [, fn] )                                                                                                 // 5677
			fn = selector;                                                                                                      // 5678
			selector = undefined;                                                                                               // 5679
		}                                                                                                                    // 5680
		if ( fn === false ) {                                                                                                // 5681
			fn = returnFalse;                                                                                                   // 5682
		}                                                                                                                    // 5683
		return this.each(function() {                                                                                        // 5684
			jQuery.event.remove( this, types, fn, selector );                                                                   // 5685
		});                                                                                                                  // 5686
	},                                                                                                                    // 5687
                                                                                                                       // 5688
	trigger: function( type, data ) {                                                                                     // 5689
		return this.each(function() {                                                                                        // 5690
			jQuery.event.trigger( type, data, this );                                                                           // 5691
		});                                                                                                                  // 5692
	},                                                                                                                    // 5693
	triggerHandler: function( type, data ) {                                                                              // 5694
		var elem = this[0];                                                                                                  // 5695
		if ( elem ) {                                                                                                        // 5696
			return jQuery.event.trigger( type, data, elem, true );                                                              // 5697
		}                                                                                                                    // 5698
	}                                                                                                                     // 5699
});                                                                                                                    // 5700
var isSimple = /^.[^:#\[\.,]*$/,                                                                                       // 5701
	rparentsprev = /^(?:parents|prev(?:Until|All))/,                                                                      // 5702
	rneedsContext = jQuery.expr.match.needsContext,                                                                       // 5703
	// methods guaranteed to produce a unique set when starting from a unique set                                         // 5704
	guaranteedUnique = {                                                                                                  // 5705
		children: true,                                                                                                      // 5706
		contents: true,                                                                                                      // 5707
		next: true,                                                                                                          // 5708
		prev: true                                                                                                           // 5709
	};                                                                                                                    // 5710
                                                                                                                       // 5711
jQuery.fn.extend({                                                                                                     // 5712
	find: function( selector ) {                                                                                          // 5713
		var i,                                                                                                               // 5714
			ret = [],                                                                                                           // 5715
			self = this,                                                                                                        // 5716
			len = self.length;                                                                                                  // 5717
                                                                                                                       // 5718
		if ( typeof selector !== "string" ) {                                                                                // 5719
			return this.pushStack( jQuery( selector ).filter(function() {                                                       // 5720
				for ( i = 0; i < len; i++ ) {                                                                                      // 5721
					if ( jQuery.contains( self[ i ], this ) ) {                                                                       // 5722
						return true;                                                                                                     // 5723
					}                                                                                                                 // 5724
				}                                                                                                                  // 5725
			}) );                                                                                                               // 5726
		}                                                                                                                    // 5727
                                                                                                                       // 5728
		for ( i = 0; i < len; i++ ) {                                                                                        // 5729
			jQuery.find( selector, self[ i ], ret );                                                                            // 5730
		}                                                                                                                    // 5731
                                                                                                                       // 5732
		// Needed because $( selector, context ) becomes $( context ).find( selector )                                       // 5733
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );                                                        // 5734
		ret.selector = this.selector ? this.selector + " " + selector : selector;                                            // 5735
		return ret;                                                                                                          // 5736
	},                                                                                                                    // 5737
                                                                                                                       // 5738
	has: function( target ) {                                                                                             // 5739
		var i,                                                                                                               // 5740
			targets = jQuery( target, this ),                                                                                   // 5741
			len = targets.length;                                                                                               // 5742
                                                                                                                       // 5743
		return this.filter(function() {                                                                                      // 5744
			for ( i = 0; i < len; i++ ) {                                                                                       // 5745
				if ( jQuery.contains( this, targets[i] ) ) {                                                                       // 5746
					return true;                                                                                                      // 5747
				}                                                                                                                  // 5748
			}                                                                                                                   // 5749
		});                                                                                                                  // 5750
	},                                                                                                                    // 5751
                                                                                                                       // 5752
	not: function( selector ) {                                                                                           // 5753
		return this.pushStack( winnow(this, selector || [], true) );                                                         // 5754
	},                                                                                                                    // 5755
                                                                                                                       // 5756
	filter: function( selector ) {                                                                                        // 5757
		return this.pushStack( winnow(this, selector || [], false) );                                                        // 5758
	},                                                                                                                    // 5759
                                                                                                                       // 5760
	is: function( selector ) {                                                                                            // 5761
		return !!winnow(                                                                                                     // 5762
			this,                                                                                                               // 5763
                                                                                                                       // 5764
			// If this is a positional/relative selector, check membership in the returned set                                  // 5765
			// so $("p:first").is("p:last") won't return true for a doc with two "p".                                           // 5766
			typeof selector === "string" && rneedsContext.test( selector ) ?                                                    // 5767
				jQuery( selector ) :                                                                                               // 5768
				selector || [],                                                                                                    // 5769
			false                                                                                                               // 5770
		).length;                                                                                                            // 5771
	},                                                                                                                    // 5772
                                                                                                                       // 5773
	closest: function( selectors, context ) {                                                                             // 5774
		var cur,                                                                                                             // 5775
			i = 0,                                                                                                              // 5776
			l = this.length,                                                                                                    // 5777
			ret = [],                                                                                                           // 5778
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?                                            // 5779
				jQuery( selectors, context || this.context ) :                                                                     // 5780
				0;                                                                                                                 // 5781
                                                                                                                       // 5782
		for ( ; i < l; i++ ) {                                                                                               // 5783
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {                                               // 5784
				// Always skip document fragments                                                                                  // 5785
				if ( cur.nodeType < 11 && (pos ?                                                                                   // 5786
					pos.index(cur) > -1 :                                                                                             // 5787
                                                                                                                       // 5788
					// Don't pass non-elements to Sizzle                                                                              // 5789
					cur.nodeType === 1 &&                                                                                             // 5790
						jQuery.find.matchesSelector(cur, selectors)) ) {                                                                 // 5791
                                                                                                                       // 5792
					cur = ret.push( cur );                                                                                            // 5793
					break;                                                                                                            // 5794
				}                                                                                                                  // 5795
			}                                                                                                                   // 5796
		}                                                                                                                    // 5797
                                                                                                                       // 5798
		return this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );                                                // 5799
	},                                                                                                                    // 5800
                                                                                                                       // 5801
	// Determine the position of an element within                                                                        // 5802
	// the matched set of elements                                                                                        // 5803
	index: function( elem ) {                                                                                             // 5804
                                                                                                                       // 5805
		// No argument, return index in parent                                                                               // 5806
		if ( !elem ) {                                                                                                       // 5807
			return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;                                      // 5808
		}                                                                                                                    // 5809
                                                                                                                       // 5810
		// index in selector                                                                                                 // 5811
		if ( typeof elem === "string" ) {                                                                                    // 5812
			return jQuery.inArray( this[0], jQuery( elem ) );                                                                   // 5813
		}                                                                                                                    // 5814
                                                                                                                       // 5815
		// Locate the position of the desired element                                                                        // 5816
		return jQuery.inArray(                                                                                               // 5817
			// If it receives a jQuery object, the first element is used                                                        // 5818
			elem.jquery ? elem[0] : elem, this );                                                                               // 5819
	},                                                                                                                    // 5820
                                                                                                                       // 5821
	add: function( selector, context ) {                                                                                  // 5822
		var set = typeof selector === "string" ?                                                                             // 5823
				jQuery( selector, context ) :                                                                                      // 5824
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),                                       // 5825
			all = jQuery.merge( this.get(), set );                                                                              // 5826
                                                                                                                       // 5827
		return this.pushStack( jQuery.unique(all) );                                                                         // 5828
	},                                                                                                                    // 5829
                                                                                                                       // 5830
	addBack: function( selector ) {                                                                                       // 5831
		return this.add( selector == null ?                                                                                  // 5832
			this.prevObject : this.prevObject.filter(selector)                                                                  // 5833
		);                                                                                                                   // 5834
	}                                                                                                                     // 5835
});                                                                                                                    // 5836
                                                                                                                       // 5837
function sibling( cur, dir ) {                                                                                         // 5838
	do {                                                                                                                  // 5839
		cur = cur[ dir ];                                                                                                    // 5840
	} while ( cur && cur.nodeType !== 1 );                                                                                // 5841
                                                                                                                       // 5842
	return cur;                                                                                                           // 5843
}                                                                                                                      // 5844
                                                                                                                       // 5845
jQuery.each({                                                                                                          // 5846
	parent: function( elem ) {                                                                                            // 5847
		var parent = elem.parentNode;                                                                                        // 5848
		return parent && parent.nodeType !== 11 ? parent : null;                                                             // 5849
	},                                                                                                                    // 5850
	parents: function( elem ) {                                                                                           // 5851
		return jQuery.dir( elem, "parentNode" );                                                                             // 5852
	},                                                                                                                    // 5853
	parentsUntil: function( elem, i, until ) {                                                                            // 5854
		return jQuery.dir( elem, "parentNode", until );                                                                      // 5855
	},                                                                                                                    // 5856
	next: function( elem ) {                                                                                              // 5857
		return sibling( elem, "nextSibling" );                                                                               // 5858
	},                                                                                                                    // 5859
	prev: function( elem ) {                                                                                              // 5860
		return sibling( elem, "previousSibling" );                                                                           // 5861
	},                                                                                                                    // 5862
	nextAll: function( elem ) {                                                                                           // 5863
		return jQuery.dir( elem, "nextSibling" );                                                                            // 5864
	},                                                                                                                    // 5865
	prevAll: function( elem ) {                                                                                           // 5866
		return jQuery.dir( elem, "previousSibling" );                                                                        // 5867
	},                                                                                                                    // 5868
	nextUntil: function( elem, i, until ) {                                                                               // 5869
		return jQuery.dir( elem, "nextSibling", until );                                                                     // 5870
	},                                                                                                                    // 5871
	prevUntil: function( elem, i, until ) {                                                                               // 5872
		return jQuery.dir( elem, "previousSibling", until );                                                                 // 5873
	},                                                                                                                    // 5874
	siblings: function( elem ) {                                                                                          // 5875
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );                                                 // 5876
	},                                                                                                                    // 5877
	children: function( elem ) {                                                                                          // 5878
		return jQuery.sibling( elem.firstChild );                                                                            // 5879
	},                                                                                                                    // 5880
	contents: function( elem ) {                                                                                          // 5881
		return jQuery.nodeName( elem, "iframe" ) ?                                                                           // 5882
			elem.contentDocument || elem.contentWindow.document :                                                               // 5883
			jQuery.merge( [], elem.childNodes );                                                                                // 5884
	}                                                                                                                     // 5885
}, function( name, fn ) {                                                                                              // 5886
	jQuery.fn[ name ] = function( until, selector ) {                                                                     // 5887
		var ret = jQuery.map( this, fn, until );                                                                             // 5888
                                                                                                                       // 5889
		if ( name.slice( -5 ) !== "Until" ) {                                                                                // 5890
			selector = until;                                                                                                   // 5891
		}                                                                                                                    // 5892
                                                                                                                       // 5893
		if ( selector && typeof selector === "string" ) {                                                                    // 5894
			ret = jQuery.filter( selector, ret );                                                                               // 5895
		}                                                                                                                    // 5896
                                                                                                                       // 5897
		if ( this.length > 1 ) {                                                                                             // 5898
			// Remove duplicates                                                                                                // 5899
			if ( !guaranteedUnique[ name ] ) {                                                                                  // 5900
				ret = jQuery.unique( ret );                                                                                        // 5901
			}                                                                                                                   // 5902
                                                                                                                       // 5903
			// Reverse order for parents* and prev-derivatives                                                                  // 5904
			if ( rparentsprev.test( name ) ) {                                                                                  // 5905
				ret = ret.reverse();                                                                                               // 5906
			}                                                                                                                   // 5907
		}                                                                                                                    // 5908
                                                                                                                       // 5909
		return this.pushStack( ret );                                                                                        // 5910
	};                                                                                                                    // 5911
});                                                                                                                    // 5912
                                                                                                                       // 5913
jQuery.extend({                                                                                                        // 5914
	filter: function( expr, elems, not ) {                                                                                // 5915
		var elem = elems[ 0 ];                                                                                               // 5916
                                                                                                                       // 5917
		if ( not ) {                                                                                                         // 5918
			expr = ":not(" + expr + ")";                                                                                        // 5919
		}                                                                                                                    // 5920
                                                                                                                       // 5921
		return elems.length === 1 && elem.nodeType === 1 ?                                                                   // 5922
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :                                                         // 5923
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {                                                   // 5924
				return elem.nodeType === 1;                                                                                        // 5925
			}));                                                                                                                // 5926
	},                                                                                                                    // 5927
                                                                                                                       // 5928
	dir: function( elem, dir, until ) {                                                                                   // 5929
		var matched = [],                                                                                                    // 5930
			cur = elem[ dir ];                                                                                                  // 5931
                                                                                                                       // 5932
		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {   // 5933
			if ( cur.nodeType === 1 ) {                                                                                         // 5934
				matched.push( cur );                                                                                               // 5935
			}                                                                                                                   // 5936
			cur = cur[dir];                                                                                                     // 5937
		}                                                                                                                    // 5938
		return matched;                                                                                                      // 5939
	},                                                                                                                    // 5940
                                                                                                                       // 5941
	sibling: function( n, elem ) {                                                                                        // 5942
		var r = [];                                                                                                          // 5943
                                                                                                                       // 5944
		for ( ; n; n = n.nextSibling ) {                                                                                     // 5945
			if ( n.nodeType === 1 && n !== elem ) {                                                                             // 5946
				r.push( n );                                                                                                       // 5947
			}                                                                                                                   // 5948
		}                                                                                                                    // 5949
                                                                                                                       // 5950
		return r;                                                                                                            // 5951
	}                                                                                                                     // 5952
});                                                                                                                    // 5953
                                                                                                                       // 5954
// Implement the identical functionality for filter and not                                                            // 5955
function winnow( elements, qualifier, not ) {                                                                          // 5956
	if ( jQuery.isFunction( qualifier ) ) {                                                                               // 5957
		return jQuery.grep( elements, function( elem, i ) {                                                                  // 5958
			/* jshint -W018 */                                                                                                  // 5959
			return !!qualifier.call( elem, i, elem ) !== not;                                                                   // 5960
		});                                                                                                                  // 5961
                                                                                                                       // 5962
	}                                                                                                                     // 5963
                                                                                                                       // 5964
	if ( qualifier.nodeType ) {                                                                                           // 5965
		return jQuery.grep( elements, function( elem ) {                                                                     // 5966
			return ( elem === qualifier ) !== not;                                                                              // 5967
		});                                                                                                                  // 5968
                                                                                                                       // 5969
	}                                                                                                                     // 5970
                                                                                                                       // 5971
	if ( typeof qualifier === "string" ) {                                                                                // 5972
		if ( isSimple.test( qualifier ) ) {                                                                                  // 5973
			return jQuery.filter( qualifier, elements, not );                                                                   // 5974
		}                                                                                                                    // 5975
                                                                                                                       // 5976
		qualifier = jQuery.filter( qualifier, elements );                                                                    // 5977
	}                                                                                                                     // 5978
                                                                                                                       // 5979
	return jQuery.grep( elements, function( elem ) {                                                                      // 5980
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;                                                           // 5981
	});                                                                                                                   // 5982
}                                                                                                                      // 5983
function createSafeFragment( document ) {                                                                              // 5984
	var list = nodeNames.split( "|" ),                                                                                    // 5985
		safeFrag = document.createDocumentFragment();                                                                        // 5986
                                                                                                                       // 5987
	if ( safeFrag.createElement ) {                                                                                       // 5988
		while ( list.length ) {                                                                                              // 5989
			safeFrag.createElement(                                                                                             // 5990
				list.pop()                                                                                                         // 5991
			);                                                                                                                  // 5992
		}                                                                                                                    // 5993
	}                                                                                                                     // 5994
	return safeFrag;                                                                                                      // 5995
}                                                                                                                      // 5996
                                                                                                                       // 5997
var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +                // 5998
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",                                           // 5999
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,                                                                         // 6000
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),                                                      // 6001
	rleadingWhitespace = /^\s+/,                                                                                          // 6002
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,                                // 6003
	rtagName = /<([\w:]+)/,                                                                                               // 6004
	rtbody = /<tbody/i,                                                                                                   // 6005
	rhtml = /<|&#?\w+;/,                                                                                                  // 6006
	rnoInnerhtml = /<(?:script|style|link)/i,                                                                             // 6007
	manipulation_rcheckableType = /^(?:checkbox|radio)$/i,                                                                // 6008
	// checked="checked" or checked                                                                                       // 6009
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,                                                                       // 6010
	rscriptType = /^$|\/(?:java|ecma)script/i,                                                                            // 6011
	rscriptTypeMasked = /^true\/(.*)/,                                                                                    // 6012
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,                                                            // 6013
                                                                                                                       // 6014
	// We have to close these tags to support XHTML (#13200)                                                              // 6015
	wrapMap = {                                                                                                           // 6016
		option: [ 1, "<select multiple='multiple'>", "</select>" ],                                                          // 6017
		legend: [ 1, "<fieldset>", "</fieldset>" ],                                                                          // 6018
		area: [ 1, "<map>", "</map>" ],                                                                                      // 6019
		param: [ 1, "<object>", "</object>" ],                                                                               // 6020
		thead: [ 1, "<table>", "</table>" ],                                                                                 // 6021
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],                                                                     // 6022
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],                                               // 6023
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],                                                            // 6024
                                                                                                                       // 6025
		// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,                                           // 6026
		// unless wrapped in a div with non-breaking characters in front of it.                                              // 6027
		_default: jQuery.support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]                                  // 6028
	},                                                                                                                    // 6029
	safeFragment = createSafeFragment( document ),                                                                        // 6030
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );                                              // 6031
                                                                                                                       // 6032
wrapMap.optgroup = wrapMap.option;                                                                                     // 6033
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;                                    // 6034
wrapMap.th = wrapMap.td;                                                                                               // 6035
                                                                                                                       // 6036
jQuery.fn.extend({                                                                                                     // 6037
	text: function( value ) {                                                                                             // 6038
		return jQuery.access( this, function( value ) {                                                                      // 6039
			return value === undefined ?                                                                                        // 6040
				jQuery.text( this ) :                                                                                              // 6041
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );                   // 6042
		}, null, value, arguments.length );                                                                                  // 6043
	},                                                                                                                    // 6044
                                                                                                                       // 6045
	append: function() {                                                                                                  // 6046
		return this.domManip( arguments, function( elem ) {                                                                  // 6047
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {                                         // 6048
				var target = manipulationTarget( this, elem );                                                                     // 6049
				target.appendChild( elem );                                                                                        // 6050
			}                                                                                                                   // 6051
		});                                                                                                                  // 6052
	},                                                                                                                    // 6053
                                                                                                                       // 6054
	prepend: function() {                                                                                                 // 6055
		return this.domManip( arguments, function( elem ) {                                                                  // 6056
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {                                         // 6057
				var target = manipulationTarget( this, elem );                                                                     // 6058
				target.insertBefore( elem, target.firstChild );                                                                    // 6059
			}                                                                                                                   // 6060
		});                                                                                                                  // 6061
	},                                                                                                                    // 6062
                                                                                                                       // 6063
	before: function() {                                                                                                  // 6064
		return this.domManip( arguments, function( elem ) {                                                                  // 6065
			if ( this.parentNode ) {                                                                                            // 6066
				this.parentNode.insertBefore( elem, this );                                                                        // 6067
			}                                                                                                                   // 6068
		});                                                                                                                  // 6069
	},                                                                                                                    // 6070
                                                                                                                       // 6071
	after: function() {                                                                                                   // 6072
		return this.domManip( arguments, function( elem ) {                                                                  // 6073
			if ( this.parentNode ) {                                                                                            // 6074
				this.parentNode.insertBefore( elem, this.nextSibling );                                                            // 6075
			}                                                                                                                   // 6076
		});                                                                                                                  // 6077
	},                                                                                                                    // 6078
                                                                                                                       // 6079
	// keepData is for internal use only--do not document                                                                 // 6080
	remove: function( selector, keepData ) {                                                                              // 6081
		var elem,                                                                                                            // 6082
			elems = selector ? jQuery.filter( selector, this ) : this,                                                          // 6083
			i = 0;                                                                                                              // 6084
                                                                                                                       // 6085
		for ( ; (elem = elems[i]) != null; i++ ) {                                                                           // 6086
                                                                                                                       // 6087
			if ( !keepData && elem.nodeType === 1 ) {                                                                           // 6088
				jQuery.cleanData( getAll( elem ) );                                                                                // 6089
			}                                                                                                                   // 6090
                                                                                                                       // 6091
			if ( elem.parentNode ) {                                                                                            // 6092
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {                                                   // 6093
					setGlobalEval( getAll( elem, "script" ) );                                                                        // 6094
				}                                                                                                                  // 6095
				elem.parentNode.removeChild( elem );                                                                               // 6096
			}                                                                                                                   // 6097
		}                                                                                                                    // 6098
                                                                                                                       // 6099
		return this;                                                                                                         // 6100
	},                                                                                                                    // 6101
                                                                                                                       // 6102
	empty: function() {                                                                                                   // 6103
		var elem,                                                                                                            // 6104
			i = 0;                                                                                                              // 6105
                                                                                                                       // 6106
		for ( ; (elem = this[i]) != null; i++ ) {                                                                            // 6107
			// Remove element nodes and prevent memory leaks                                                                    // 6108
			if ( elem.nodeType === 1 ) {                                                                                        // 6109
				jQuery.cleanData( getAll( elem, false ) );                                                                         // 6110
			}                                                                                                                   // 6111
                                                                                                                       // 6112
			// Remove any remaining nodes                                                                                       // 6113
			while ( elem.firstChild ) {                                                                                         // 6114
				elem.removeChild( elem.firstChild );                                                                               // 6115
			}                                                                                                                   // 6116
                                                                                                                       // 6117
			// If this is a select, ensure that it displays empty (#12336)                                                      // 6118
			// Support: IE<9                                                                                                    // 6119
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {                                                          // 6120
				elem.options.length = 0;                                                                                           // 6121
			}                                                                                                                   // 6122
		}                                                                                                                    // 6123
                                                                                                                       // 6124
		return this;                                                                                                         // 6125
	},                                                                                                                    // 6126
                                                                                                                       // 6127
	clone: function( dataAndEvents, deepDataAndEvents ) {                                                                 // 6128
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;                                                       // 6129
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;                                   // 6130
                                                                                                                       // 6131
		return this.map( function () {                                                                                       // 6132
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );                                                      // 6133
		});                                                                                                                  // 6134
	},                                                                                                                    // 6135
                                                                                                                       // 6136
	html: function( value ) {                                                                                             // 6137
		return jQuery.access( this, function( value ) {                                                                      // 6138
			var elem = this[0] || {},                                                                                           // 6139
				i = 0,                                                                                                             // 6140
				l = this.length;                                                                                                   // 6141
                                                                                                                       // 6142
			if ( value === undefined ) {                                                                                        // 6143
				return elem.nodeType === 1 ?                                                                                       // 6144
					elem.innerHTML.replace( rinlinejQuery, "" ) :                                                                     // 6145
					undefined;                                                                                                        // 6146
			}                                                                                                                   // 6147
                                                                                                                       // 6148
			// See if we can take a shortcut and just use innerHTML                                                             // 6149
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&                                                    // 6150
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&                                                // 6151
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&                                       // 6152
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {                                            // 6153
                                                                                                                       // 6154
				value = value.replace( rxhtmlTag, "<$1></$2>" );                                                                   // 6155
                                                                                                                       // 6156
				try {                                                                                                              // 6157
					for (; i < l; i++ ) {                                                                                             // 6158
						// Remove element nodes and prevent memory leaks                                                                 // 6159
						elem = this[i] || {};                                                                                            // 6160
						if ( elem.nodeType === 1 ) {                                                                                     // 6161
							jQuery.cleanData( getAll( elem, false ) );                                                                      // 6162
							elem.innerHTML = value;                                                                                         // 6163
						}                                                                                                                // 6164
					}                                                                                                                 // 6165
                                                                                                                       // 6166
					elem = 0;                                                                                                         // 6167
                                                                                                                       // 6168
				// If using innerHTML throws an exception, use the fallback method                                                 // 6169
				} catch(e) {}                                                                                                      // 6170
			}                                                                                                                   // 6171
                                                                                                                       // 6172
			if ( elem ) {                                                                                                       // 6173
				this.empty().append( value );                                                                                      // 6174
			}                                                                                                                   // 6175
		}, null, value, arguments.length );                                                                                  // 6176
	},                                                                                                                    // 6177
                                                                                                                       // 6178
	replaceWith: function() {                                                                                             // 6179
		var                                                                                                                  // 6180
			// Snapshot the DOM in case .domManip sweeps something relevant into its fragment                                   // 6181
			args = jQuery.map( this, function( elem ) {                                                                         // 6182
				return [ elem.nextSibling, elem.parentNode ];                                                                      // 6183
			}),                                                                                                                 // 6184
			i = 0;                                                                                                              // 6185
                                                                                                                       // 6186
		// Make the changes, replacing each context element with the new content                                             // 6187
		this.domManip( arguments, function( elem ) {                                                                         // 6188
			var next = args[ i++ ],                                                                                             // 6189
				parent = args[ i++ ];                                                                                              // 6190
                                                                                                                       // 6191
			if ( parent ) {                                                                                                     // 6192
				// Don't use the snapshot next if it has moved (#13810)                                                            // 6193
				if ( next && next.parentNode !== parent ) {                                                                        // 6194
					next = this.nextSibling;                                                                                          // 6195
				}                                                                                                                  // 6196
				jQuery( this ).remove();                                                                                           // 6197
				parent.insertBefore( elem, next );                                                                                 // 6198
			}                                                                                                                   // 6199
		// Allow new content to include elements from the context set                                                        // 6200
		}, true );                                                                                                           // 6201
                                                                                                                       // 6202
		// Force removal if there was no new content (e.g., from empty arguments)                                            // 6203
		return i ? this : this.remove();                                                                                     // 6204
	},                                                                                                                    // 6205
                                                                                                                       // 6206
	detach: function( selector ) {                                                                                        // 6207
		return this.remove( selector, true );                                                                                // 6208
	},                                                                                                                    // 6209
                                                                                                                       // 6210
	domManip: function( args, callback, allowIntersection ) {                                                             // 6211
                                                                                                                       // 6212
		// Flatten any nested arrays                                                                                         // 6213
		args = core_concat.apply( [], args );                                                                                // 6214
                                                                                                                       // 6215
		var first, node, hasScripts,                                                                                         // 6216
			scripts, doc, fragment,                                                                                             // 6217
			i = 0,                                                                                                              // 6218
			l = this.length,                                                                                                    // 6219
			set = this,                                                                                                         // 6220
			iNoClone = l - 1,                                                                                                   // 6221
			value = args[0],                                                                                                    // 6222
			isFunction = jQuery.isFunction( value );                                                                            // 6223
                                                                                                                       // 6224
		// We can't cloneNode fragments that contain checked, in WebKit                                                      // 6225
		if ( isFunction || !( l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {
			return this.each(function( index ) {                                                                                // 6227
				var self = set.eq( index );                                                                                        // 6228
				if ( isFunction ) {                                                                                                // 6229
					args[0] = value.call( this, index, self.html() );                                                                 // 6230
				}                                                                                                                  // 6231
				self.domManip( args, callback, allowIntersection );                                                                // 6232
			});                                                                                                                 // 6233
		}                                                                                                                    // 6234
                                                                                                                       // 6235
		if ( l ) {                                                                                                           // 6236
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );                // 6237
			first = fragment.firstChild;                                                                                        // 6238
                                                                                                                       // 6239
			if ( fragment.childNodes.length === 1 ) {                                                                           // 6240
				fragment = first;                                                                                                  // 6241
			}                                                                                                                   // 6242
                                                                                                                       // 6243
			if ( first ) {                                                                                                      // 6244
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );                                               // 6245
				hasScripts = scripts.length;                                                                                       // 6246
                                                                                                                       // 6247
				// Use the original fragment for the last item instead of the first because it can end up                          // 6248
				// being emptied incorrectly in certain situations (#8070).                                                        // 6249
				for ( ; i < l; i++ ) {                                                                                             // 6250
					node = fragment;                                                                                                  // 6251
                                                                                                                       // 6252
					if ( i !== iNoClone ) {                                                                                           // 6253
						node = jQuery.clone( node, true, true );                                                                         // 6254
                                                                                                                       // 6255
						// Keep references to cloned scripts for later restoration                                                       // 6256
						if ( hasScripts ) {                                                                                              // 6257
							jQuery.merge( scripts, getAll( node, "script" ) );                                                              // 6258
						}                                                                                                                // 6259
					}                                                                                                                 // 6260
                                                                                                                       // 6261
					callback.call( this[i], node, i );                                                                                // 6262
				}                                                                                                                  // 6263
                                                                                                                       // 6264
				if ( hasScripts ) {                                                                                                // 6265
					doc = scripts[ scripts.length - 1 ].ownerDocument;                                                                // 6266
                                                                                                                       // 6267
					// Reenable scripts                                                                                               // 6268
					jQuery.map( scripts, restoreScript );                                                                             // 6269
                                                                                                                       // 6270
					// Evaluate executable scripts on first document insertion                                                        // 6271
					for ( i = 0; i < hasScripts; i++ ) {                                                                              // 6272
						node = scripts[ i ];                                                                                             // 6273
						if ( rscriptType.test( node.type || "" ) &&                                                                      // 6274
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {                                         // 6275
                                                                                                                       // 6276
							if ( node.src ) {                                                                                               // 6277
								// Hope ajax is available...                                                                                   // 6278
								jQuery._evalUrl( node.src );                                                                                   // 6279
							} else {                                                                                                        // 6280
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );    // 6281
							}                                                                                                               // 6282
						}                                                                                                                // 6283
					}                                                                                                                 // 6284
				}                                                                                                                  // 6285
                                                                                                                       // 6286
				// Fix #11809: Avoid leaking memory                                                                                // 6287
				fragment = first = null;                                                                                           // 6288
			}                                                                                                                   // 6289
		}                                                                                                                    // 6290
                                                                                                                       // 6291
		return this;                                                                                                         // 6292
	}                                                                                                                     // 6293
});                                                                                                                    // 6294
                                                                                                                       // 6295
// Support: IE<8                                                                                                       // 6296
// Manipulating tables requires a tbody                                                                                // 6297
function manipulationTarget( elem, content ) {                                                                         // 6298
	return jQuery.nodeName( elem, "table" ) &&                                                                            // 6299
		jQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, "tr" ) ?                                     // 6300
                                                                                                                       // 6301
		elem.getElementsByTagName("tbody")[0] ||                                                                             // 6302
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :                                                     // 6303
		elem;                                                                                                                // 6304
}                                                                                                                      // 6305
                                                                                                                       // 6306
// Replace/restore the type attribute of script elements for safe DOM manipulation                                     // 6307
function disableScript( elem ) {                                                                                       // 6308
	elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;                                            // 6309
	return elem;                                                                                                          // 6310
}                                                                                                                      // 6311
function restoreScript( elem ) {                                                                                       // 6312
	var match = rscriptTypeMasked.exec( elem.type );                                                                      // 6313
	if ( match ) {                                                                                                        // 6314
		elem.type = match[1];                                                                                                // 6315
	} else {                                                                                                              // 6316
		elem.removeAttribute("type");                                                                                        // 6317
	}                                                                                                                     // 6318
	return elem;                                                                                                          // 6319
}                                                                                                                      // 6320
                                                                                                                       // 6321
// Mark scripts as having already been evaluated                                                                       // 6322
function setGlobalEval( elems, refElements ) {                                                                         // 6323
	var elem,                                                                                                             // 6324
		i = 0;                                                                                                               // 6325
	for ( ; (elem = elems[i]) != null; i++ ) {                                                                            // 6326
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );                    // 6327
	}                                                                                                                     // 6328
}                                                                                                                      // 6329
                                                                                                                       // 6330
function cloneCopyEvent( src, dest ) {                                                                                 // 6331
                                                                                                                       // 6332
	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {                                                                // 6333
		return;                                                                                                              // 6334
	}                                                                                                                     // 6335
                                                                                                                       // 6336
	var type, i, l,                                                                                                       // 6337
		oldData = jQuery._data( src ),                                                                                       // 6338
		curData = jQuery._data( dest, oldData ),                                                                             // 6339
		events = oldData.events;                                                                                             // 6340
                                                                                                                       // 6341
	if ( events ) {                                                                                                       // 6342
		delete curData.handle;                                                                                               // 6343
		curData.events = {};                                                                                                 // 6344
                                                                                                                       // 6345
		for ( type in events ) {                                                                                             // 6346
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {                                                              // 6347
				jQuery.event.add( dest, type, events[ type ][ i ] );                                                               // 6348
			}                                                                                                                   // 6349
		}                                                                                                                    // 6350
	}                                                                                                                     // 6351
                                                                                                                       // 6352
	// make the cloned public data object a copy from the original                                                        // 6353
	if ( curData.data ) {                                                                                                 // 6354
		curData.data = jQuery.extend( {}, curData.data );                                                                    // 6355
	}                                                                                                                     // 6356
}                                                                                                                      // 6357
                                                                                                                       // 6358
function fixCloneNodeIssues( src, dest ) {                                                                             // 6359
	var nodeName, e, data;                                                                                                // 6360
                                                                                                                       // 6361
	// We do not need to do anything for non-Elements                                                                     // 6362
	if ( dest.nodeType !== 1 ) {                                                                                          // 6363
		return;                                                                                                              // 6364
	}                                                                                                                     // 6365
                                                                                                                       // 6366
	nodeName = dest.nodeName.toLowerCase();                                                                               // 6367
                                                                                                                       // 6368
	// IE6-8 copies events bound via attachEvent when using cloneNode.                                                    // 6369
	if ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {                                                       // 6370
		data = jQuery._data( dest );                                                                                         // 6371
                                                                                                                       // 6372
		for ( e in data.events ) {                                                                                           // 6373
			jQuery.removeEvent( dest, e, data.handle );                                                                         // 6374
		}                                                                                                                    // 6375
                                                                                                                       // 6376
		// Event data gets referenced instead of copied if the expando gets copied too                                       // 6377
		dest.removeAttribute( jQuery.expando );                                                                              // 6378
	}                                                                                                                     // 6379
                                                                                                                       // 6380
	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text                                      // 6381
	if ( nodeName === "script" && dest.text !== src.text ) {                                                              // 6382
		disableScript( dest ).text = src.text;                                                                               // 6383
		restoreScript( dest );                                                                                               // 6384
                                                                                                                       // 6385
	// IE6-10 improperly clones children of object elements using classid.                                                // 6386
	// IE10 throws NoModificationAllowedError if parent is null, #12132.                                                  // 6387
	} else if ( nodeName === "object" ) {                                                                                 // 6388
		if ( dest.parentNode ) {                                                                                             // 6389
			dest.outerHTML = src.outerHTML;                                                                                     // 6390
		}                                                                                                                    // 6391
                                                                                                                       // 6392
		// This path appears unavoidable for IE9. When cloning an object                                                     // 6393
		// element in IE9, the outerHTML strategy above is not sufficient.                                                   // 6394
		// If the src has innerHTML and the destination does not,                                                            // 6395
		// copy the src.innerHTML into the dest.innerHTML. #10324                                                            // 6396
		if ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {                              // 6397
			dest.innerHTML = src.innerHTML;                                                                                     // 6398
		}                                                                                                                    // 6399
                                                                                                                       // 6400
	} else if ( nodeName === "input" && manipulation_rcheckableType.test( src.type ) ) {                                  // 6401
		// IE6-8 fails to persist the checked state of a cloned checkbox                                                     // 6402
		// or radio button. Worse, IE6-7 fail to give the cloned element                                                     // 6403
		// a checked appearance if the defaultChecked value isn't also set                                                   // 6404
                                                                                                                       // 6405
		dest.defaultChecked = dest.checked = src.checked;                                                                    // 6406
                                                                                                                       // 6407
		// IE6-7 get confused and end up setting the value of a cloned                                                       // 6408
		// checkbox/radio button to an empty string instead of "on"                                                          // 6409
		if ( dest.value !== src.value ) {                                                                                    // 6410
			dest.value = src.value;                                                                                             // 6411
		}                                                                                                                    // 6412
                                                                                                                       // 6413
	// IE6-8 fails to return the selected option to the default selected                                                  // 6414
	// state when cloning options                                                                                         // 6415
	} else if ( nodeName === "option" ) {                                                                                 // 6416
		dest.defaultSelected = dest.selected = src.defaultSelected;                                                          // 6417
                                                                                                                       // 6418
	// IE6-8 fails to set the defaultValue to the correct value when                                                      // 6419
	// cloning other types of input fields                                                                                // 6420
	} else if ( nodeName === "input" || nodeName === "textarea" ) {                                                       // 6421
		dest.defaultValue = src.defaultValue;                                                                                // 6422
	}                                                                                                                     // 6423
}                                                                                                                      // 6424
                                                                                                                       // 6425
jQuery.each({                                                                                                          // 6426
	appendTo: "append",                                                                                                   // 6427
	prependTo: "prepend",                                                                                                 // 6428
	insertBefore: "before",                                                                                               // 6429
	insertAfter: "after",                                                                                                 // 6430
	replaceAll: "replaceWith"                                                                                             // 6431
}, function( name, original ) {                                                                                        // 6432
	jQuery.fn[ name ] = function( selector ) {                                                                            // 6433
		var elems,                                                                                                           // 6434
			i = 0,                                                                                                              // 6435
			ret = [],                                                                                                           // 6436
			insert = jQuery( selector ),                                                                                        // 6437
			last = insert.length - 1;                                                                                           // 6438
                                                                                                                       // 6439
		for ( ; i <= last; i++ ) {                                                                                           // 6440
			elems = i === last ? this : this.clone(true);                                                                       // 6441
			jQuery( insert[i] )[ original ]( elems );                                                                           // 6442
                                                                                                                       // 6443
			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()                                 // 6444
			core_push.apply( ret, elems.get() );                                                                                // 6445
		}                                                                                                                    // 6446
                                                                                                                       // 6447
		return this.pushStack( ret );                                                                                        // 6448
	};                                                                                                                    // 6449
});                                                                                                                    // 6450
                                                                                                                       // 6451
function getAll( context, tag ) {                                                                                      // 6452
	var elems, elem,                                                                                                      // 6453
		i = 0,                                                                                                               // 6454
		found = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || "*" ) :     // 6455
			typeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || "*" ) :                    // 6456
			undefined;                                                                                                          // 6457
                                                                                                                       // 6458
	if ( !found ) {                                                                                                       // 6459
		for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {                          // 6460
			if ( !tag || jQuery.nodeName( elem, tag ) ) {                                                                       // 6461
				found.push( elem );                                                                                                // 6462
			} else {                                                                                                            // 6463
				jQuery.merge( found, getAll( elem, tag ) );                                                                        // 6464
			}                                                                                                                   // 6465
		}                                                                                                                    // 6466
	}                                                                                                                     // 6467
                                                                                                                       // 6468
	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?                                                  // 6469
		jQuery.merge( [ context ], found ) :                                                                                 // 6470
		found;                                                                                                               // 6471
}                                                                                                                      // 6472
                                                                                                                       // 6473
// Used in buildFragment, fixes the defaultChecked property                                                            // 6474
function fixDefaultChecked( elem ) {                                                                                   // 6475
	if ( manipulation_rcheckableType.test( elem.type ) ) {                                                                // 6476
		elem.defaultChecked = elem.checked;                                                                                  // 6477
	}                                                                                                                     // 6478
}                                                                                                                      // 6479
                                                                                                                       // 6480
jQuery.extend({                                                                                                        // 6481
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {                                                           // 6482
		var destElements, node, clone, i, srcElements,                                                                       // 6483
			inPage = jQuery.contains( elem.ownerDocument, elem );                                                               // 6484
                                                                                                                       // 6485
		if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {       // 6486
			clone = elem.cloneNode( true );                                                                                     // 6487
                                                                                                                       // 6488
		// IE<=8 does not properly clone detached, unknown element nodes                                                     // 6489
		} else {                                                                                                             // 6490
			fragmentDiv.innerHTML = elem.outerHTML;                                                                             // 6491
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );                                                          // 6492
		}                                                                                                                    // 6493
                                                                                                                       // 6494
		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&                                             // 6495
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {                                        // 6496
                                                                                                                       // 6497
			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2                              // 6498
			destElements = getAll( clone );                                                                                     // 6499
			srcElements = getAll( elem );                                                                                       // 6500
                                                                                                                       // 6501
			// Fix all IE cloning issues                                                                                        // 6502
			for ( i = 0; (node = srcElements[i]) != null; ++i ) {                                                               // 6503
				// Ensure that the destination node is not null; Fixes #9587                                                       // 6504
				if ( destElements[i] ) {                                                                                           // 6505
					fixCloneNodeIssues( node, destElements[i] );                                                                      // 6506
				}                                                                                                                  // 6507
			}                                                                                                                   // 6508
		}                                                                                                                    // 6509
                                                                                                                       // 6510
		// Copy the events from the original to the clone                                                                    // 6511
		if ( dataAndEvents ) {                                                                                               // 6512
			if ( deepDataAndEvents ) {                                                                                          // 6513
				srcElements = srcElements || getAll( elem );                                                                       // 6514
				destElements = destElements || getAll( clone );                                                                    // 6515
                                                                                                                       // 6516
				for ( i = 0; (node = srcElements[i]) != null; i++ ) {                                                              // 6517
					cloneCopyEvent( node, destElements[i] );                                                                          // 6518
				}                                                                                                                  // 6519
			} else {                                                                                                            // 6520
				cloneCopyEvent( elem, clone );                                                                                     // 6521
			}                                                                                                                   // 6522
		}                                                                                                                    // 6523
                                                                                                                       // 6524
		// Preserve script evaluation history                                                                                // 6525
		destElements = getAll( clone, "script" );                                                                            // 6526
		if ( destElements.length > 0 ) {                                                                                     // 6527
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );                                                 // 6528
		}                                                                                                                    // 6529
                                                                                                                       // 6530
		destElements = srcElements = node = null;                                                                            // 6531
                                                                                                                       // 6532
		// Return the cloned set                                                                                             // 6533
		return clone;                                                                                                        // 6534
	},                                                                                                                    // 6535
                                                                                                                       // 6536
	buildFragment: function( elems, context, scripts, selection ) {                                                       // 6537
		var j, elem, contains,                                                                                               // 6538
			tmp, tag, tbody, wrap,                                                                                              // 6539
			l = elems.length,                                                                                                   // 6540
                                                                                                                       // 6541
			// Ensure a safe fragment                                                                                           // 6542
			safe = createSafeFragment( context ),                                                                               // 6543
                                                                                                                       // 6544
			nodes = [],                                                                                                         // 6545
			i = 0;                                                                                                              // 6546
                                                                                                                       // 6547
		for ( ; i < l; i++ ) {                                                                                               // 6548
			elem = elems[ i ];                                                                                                  // 6549
                                                                                                                       // 6550
			if ( elem || elem === 0 ) {                                                                                         // 6551
                                                                                                                       // 6552
				// Add nodes directly                                                                                              // 6553
				if ( jQuery.type( elem ) === "object" ) {                                                                          // 6554
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );                                                           // 6555
                                                                                                                       // 6556
				// Convert non-html into a text node                                                                               // 6557
				} else if ( !rhtml.test( elem ) ) {                                                                                // 6558
					nodes.push( context.createTextNode( elem ) );                                                                     // 6559
                                                                                                                       // 6560
				// Convert html into DOM nodes                                                                                     // 6561
				} else {                                                                                                           // 6562
					tmp = tmp || safe.appendChild( context.createElement("div") );                                                    // 6563
                                                                                                                       // 6564
					// Deserialize a standard representation                                                                          // 6565
					tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();                                                     // 6566
					wrap = wrapMap[ tag ] || wrapMap._default;                                                                        // 6567
                                                                                                                       // 6568
					tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];                                       // 6569
                                                                                                                       // 6570
					// Descend through wrappers to the right content                                                                  // 6571
					j = wrap[0];                                                                                                      // 6572
					while ( j-- ) {                                                                                                   // 6573
						tmp = tmp.lastChild;                                                                                             // 6574
					}                                                                                                                 // 6575
                                                                                                                       // 6576
					// Manually add leading whitespace removed by IE                                                                  // 6577
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {                                     // 6578
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );                                      // 6579
					}                                                                                                                 // 6580
                                                                                                                       // 6581
					// Remove IE's autoinserted <tbody> from table fragments                                                          // 6582
					if ( !jQuery.support.tbody ) {                                                                                    // 6583
                                                                                                                       // 6584
						// String was a <table>, *may* have spurious <tbody>                                                             // 6585
						elem = tag === "table" && !rtbody.test( elem ) ?                                                                 // 6586
							tmp.firstChild :                                                                                                // 6587
                                                                                                                       // 6588
							// String was a bare <thead> or <tfoot>                                                                         // 6589
							wrap[1] === "<table>" && !rtbody.test( elem ) ?                                                                 // 6590
								tmp :                                                                                                          // 6591
								0;                                                                                                             // 6592
                                                                                                                       // 6593
						j = elem && elem.childNodes.length;                                                                              // 6594
						while ( j-- ) {                                                                                                  // 6595
							if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {                   // 6596
								elem.removeChild( tbody );                                                                                     // 6597
							}                                                                                                               // 6598
						}                                                                                                                // 6599
					}                                                                                                                 // 6600
                                                                                                                       // 6601
					jQuery.merge( nodes, tmp.childNodes );                                                                            // 6602
                                                                                                                       // 6603
					// Fix #12392 for WebKit and IE > 9                                                                               // 6604
					tmp.textContent = "";                                                                                             // 6605
                                                                                                                       // 6606
					// Fix #12392 for oldIE                                                                                           // 6607
					while ( tmp.firstChild ) {                                                                                        // 6608
						tmp.removeChild( tmp.firstChild );                                                                               // 6609
					}                                                                                                                 // 6610
                                                                                                                       // 6611
					// Remember the top-level container for proper cleanup                                                            // 6612
					tmp = safe.lastChild;                                                                                             // 6613
				}                                                                                                                  // 6614
			}                                                                                                                   // 6615
		}                                                                                                                    // 6616
                                                                                                                       // 6617
		// Fix #11356: Clear elements from fragment                                                                          // 6618
		if ( tmp ) {                                                                                                         // 6619
			safe.removeChild( tmp );                                                                                            // 6620
		}                                                                                                                    // 6621
                                                                                                                       // 6622
		// Reset defaultChecked for any radios and checkboxes                                                                // 6623
		// about to be appended to the DOM in IE 6/7 (#8060)                                                                 // 6624
		if ( !jQuery.support.appendChecked ) {                                                                               // 6625
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );                                                         // 6626
		}                                                                                                                    // 6627
                                                                                                                       // 6628
		i = 0;                                                                                                               // 6629
		while ( (elem = nodes[ i++ ]) ) {                                                                                    // 6630
                                                                                                                       // 6631
			// #4087 - If origin and destination elements are the same, and this is                                             // 6632
			// that element, do not do anything                                                                                 // 6633
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {                                                      // 6634
				continue;                                                                                                          // 6635
			}                                                                                                                   // 6636
                                                                                                                       // 6637
			contains = jQuery.contains( elem.ownerDocument, elem );                                                             // 6638
                                                                                                                       // 6639
			// Append to fragment                                                                                               // 6640
			tmp = getAll( safe.appendChild( elem ), "script" );                                                                 // 6641
                                                                                                                       // 6642
			// Preserve script evaluation history                                                                               // 6643
			if ( contains ) {                                                                                                   // 6644
				setGlobalEval( tmp );                                                                                              // 6645
			}                                                                                                                   // 6646
                                                                                                                       // 6647
			// Capture executables                                                                                              // 6648
			if ( scripts ) {                                                                                                    // 6649
				j = 0;                                                                                                             // 6650
				while ( (elem = tmp[ j++ ]) ) {                                                                                    // 6651
					if ( rscriptType.test( elem.type || "" ) ) {                                                                      // 6652
						scripts.push( elem );                                                                                            // 6653
					}                                                                                                                 // 6654
				}                                                                                                                  // 6655
			}                                                                                                                   // 6656
		}                                                                                                                    // 6657
                                                                                                                       // 6658
		tmp = null;                                                                                                          // 6659
                                                                                                                       // 6660
		return safe;                                                                                                         // 6661
	},                                                                                                                    // 6662
                                                                                                                       // 6663
	cleanData: function( elems, /* internal */ acceptData ) {                                                             // 6664
		var elem, type, id, data,                                                                                            // 6665
			i = 0,                                                                                                              // 6666
			internalKey = jQuery.expando,                                                                                       // 6667
			cache = jQuery.cache,                                                                                               // 6668
			deleteExpando = jQuery.support.deleteExpando,                                                                       // 6669
			special = jQuery.event.special;                                                                                     // 6670
                                                                                                                       // 6671
		for ( ; (elem = elems[i]) != null; i++ ) {                                                                           // 6672
                                                                                                                       // 6673
			if ( acceptData || jQuery.acceptData( elem ) ) {                                                                    // 6674
                                                                                                                       // 6675
				id = elem[ internalKey ];                                                                                          // 6676
				data = id && cache[ id ];                                                                                          // 6677
                                                                                                                       // 6678
				if ( data ) {                                                                                                      // 6679
					if ( data.events ) {                                                                                              // 6680
						for ( type in data.events ) {                                                                                    // 6681
							if ( special[ type ] ) {                                                                                        // 6682
								jQuery.event.remove( elem, type );                                                                             // 6683
                                                                                                                       // 6684
							// This is a shortcut to avoid jQuery.event.remove's overhead                                                   // 6685
							} else {                                                                                                        // 6686
								jQuery.removeEvent( elem, type, data.handle );                                                                 // 6687
							}                                                                                                               // 6688
						}                                                                                                                // 6689
					}                                                                                                                 // 6690
                                                                                                                       // 6691
					// Remove cache only if it was not already removed by jQuery.event.remove                                         // 6692
					if ( cache[ id ] ) {                                                                                              // 6693
                                                                                                                       // 6694
						delete cache[ id ];                                                                                              // 6695
                                                                                                                       // 6696
						// IE does not allow us to delete expando properties from nodes,                                                 // 6697
						// nor does it have a removeAttribute function on Document nodes;                                                // 6698
						// we must handle all of these cases                                                                             // 6699
						if ( deleteExpando ) {                                                                                           // 6700
							delete elem[ internalKey ];                                                                                     // 6701
                                                                                                                       // 6702
						} else if ( typeof elem.removeAttribute !== core_strundefined ) {                                                // 6703
							elem.removeAttribute( internalKey );                                                                            // 6704
                                                                                                                       // 6705
						} else {                                                                                                         // 6706
							elem[ internalKey ] = null;                                                                                     // 6707
						}                                                                                                                // 6708
                                                                                                                       // 6709
						core_deletedIds.push( id );                                                                                      // 6710
					}                                                                                                                 // 6711
				}                                                                                                                  // 6712
			}                                                                                                                   // 6713
		}                                                                                                                    // 6714
	},                                                                                                                    // 6715
                                                                                                                       // 6716
	_evalUrl: function( url ) {                                                                                           // 6717
		return jQuery.ajax({                                                                                                 // 6718
			url: url,                                                                                                           // 6719
			type: "GET",                                                                                                        // 6720
			dataType: "script",                                                                                                 // 6721
			async: false,                                                                                                       // 6722
			global: false,                                                                                                      // 6723
			"throws": true                                                                                                      // 6724
		});                                                                                                                  // 6725
	}                                                                                                                     // 6726
});                                                                                                                    // 6727
jQuery.fn.extend({                                                                                                     // 6728
	wrapAll: function( html ) {                                                                                           // 6729
		if ( jQuery.isFunction( html ) ) {                                                                                   // 6730
			return this.each(function(i) {                                                                                      // 6731
				jQuery(this).wrapAll( html.call(this, i) );                                                                        // 6732
			});                                                                                                                 // 6733
		}                                                                                                                    // 6734
                                                                                                                       // 6735
		if ( this[0] ) {                                                                                                     // 6736
			// The elements to wrap the target around                                                                           // 6737
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);                                                 // 6738
                                                                                                                       // 6739
			if ( this[0].parentNode ) {                                                                                         // 6740
				wrap.insertBefore( this[0] );                                                                                      // 6741
			}                                                                                                                   // 6742
                                                                                                                       // 6743
			wrap.map(function() {                                                                                               // 6744
				var elem = this;                                                                                                   // 6745
                                                                                                                       // 6746
				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {                                                      // 6747
					elem = elem.firstChild;                                                                                           // 6748
				}                                                                                                                  // 6749
                                                                                                                       // 6750
				return elem;                                                                                                       // 6751
			}).append( this );                                                                                                  // 6752
		}                                                                                                                    // 6753
                                                                                                                       // 6754
		return this;                                                                                                         // 6755
	},                                                                                                                    // 6756
                                                                                                                       // 6757
	wrapInner: function( html ) {                                                                                         // 6758
		if ( jQuery.isFunction( html ) ) {                                                                                   // 6759
			return this.each(function(i) {                                                                                      // 6760
				jQuery(this).wrapInner( html.call(this, i) );                                                                      // 6761
			});                                                                                                                 // 6762
		}                                                                                                                    // 6763
                                                                                                                       // 6764
		return this.each(function() {                                                                                        // 6765
			var self = jQuery( this ),                                                                                          // 6766
				contents = self.contents();                                                                                        // 6767
                                                                                                                       // 6768
			if ( contents.length ) {                                                                                            // 6769
				contents.wrapAll( html );                                                                                          // 6770
                                                                                                                       // 6771
			} else {                                                                                                            // 6772
				self.append( html );                                                                                               // 6773
			}                                                                                                                   // 6774
		});                                                                                                                  // 6775
	},                                                                                                                    // 6776
                                                                                                                       // 6777
	wrap: function( html ) {                                                                                              // 6778
		var isFunction = jQuery.isFunction( html );                                                                          // 6779
                                                                                                                       // 6780
		return this.each(function(i) {                                                                                       // 6781
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );                                                   // 6782
		});                                                                                                                  // 6783
	},                                                                                                                    // 6784
                                                                                                                       // 6785
	unwrap: function() {                                                                                                  // 6786
		return this.parent().each(function() {                                                                               // 6787
			if ( !jQuery.nodeName( this, "body" ) ) {                                                                           // 6788
				jQuery( this ).replaceWith( this.childNodes );                                                                     // 6789
			}                                                                                                                   // 6790
		}).end();                                                                                                            // 6791
	}                                                                                                                     // 6792
});                                                                                                                    // 6793
var iframe, getStyles, curCSS,                                                                                         // 6794
	ralpha = /alpha\([^)]*\)/i,                                                                                           // 6795
	ropacity = /opacity\s*=\s*([^)]*)/,                                                                                   // 6796
	rposition = /^(top|right|bottom|left)$/,                                                                              // 6797
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"                 // 6798
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display                                  // 6799
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,                                                                           // 6800
	rmargin = /^margin/,                                                                                                  // 6801
	rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),                                                           // 6802
	rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),                                                  // 6803
	rrelNum = new RegExp( "^([+-])=(" + core_pnum + ")", "i" ),                                                           // 6804
	elemdisplay = { BODY: "block" },                                                                                      // 6805
                                                                                                                       // 6806
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },                                           // 6807
	cssNormalTransform = {                                                                                                // 6808
		letterSpacing: 0,                                                                                                    // 6809
		fontWeight: 400                                                                                                      // 6810
	},                                                                                                                    // 6811
                                                                                                                       // 6812
	cssExpand = [ "Top", "Right", "Bottom", "Left" ],                                                                     // 6813
	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];                                                                         // 6814
                                                                                                                       // 6815
// return a css property mapped to a potentially vendor prefixed property                                              // 6816
function vendorPropName( style, name ) {                                                                               // 6817
                                                                                                                       // 6818
	// shortcut for names that are not vendor prefixed                                                                    // 6819
	if ( name in style ) {                                                                                                // 6820
		return name;                                                                                                         // 6821
	}                                                                                                                     // 6822
                                                                                                                       // 6823
	// check for vendor prefixed names                                                                                    // 6824
	var capName = name.charAt(0).toUpperCase() + name.slice(1),                                                           // 6825
		origName = name,                                                                                                     // 6826
		i = cssPrefixes.length;                                                                                              // 6827
                                                                                                                       // 6828
	while ( i-- ) {                                                                                                       // 6829
		name = cssPrefixes[ i ] + capName;                                                                                   // 6830
		if ( name in style ) {                                                                                               // 6831
			return name;                                                                                                        // 6832
		}                                                                                                                    // 6833
	}                                                                                                                     // 6834
                                                                                                                       // 6835
	return origName;                                                                                                      // 6836
}                                                                                                                      // 6837
                                                                                                                       // 6838
function isHidden( elem, el ) {                                                                                        // 6839
	// isHidden might be called from jQuery#filter function;                                                              // 6840
	// in that case, element will be second argument                                                                      // 6841
	elem = el || elem;                                                                                                    // 6842
	return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );                      // 6843
}                                                                                                                      // 6844
                                                                                                                       // 6845
function showHide( elements, show ) {                                                                                  // 6846
	var display, elem, hidden,                                                                                            // 6847
		values = [],                                                                                                         // 6848
		index = 0,                                                                                                           // 6849
		length = elements.length;                                                                                            // 6850
                                                                                                                       // 6851
	for ( ; index < length; index++ ) {                                                                                   // 6852
		elem = elements[ index ];                                                                                            // 6853
		if ( !elem.style ) {                                                                                                 // 6854
			continue;                                                                                                           // 6855
		}                                                                                                                    // 6856
                                                                                                                       // 6857
		values[ index ] = jQuery._data( elem, "olddisplay" );                                                                // 6858
		display = elem.style.display;                                                                                        // 6859
		if ( show ) {                                                                                                        // 6860
			// Reset the inline display of this element to learn if it is                                                       // 6861
			// being hidden by cascaded rules or not                                                                            // 6862
			if ( !values[ index ] && display === "none" ) {                                                                     // 6863
				elem.style.display = "";                                                                                           // 6864
			}                                                                                                                   // 6865
                                                                                                                       // 6866
			// Set elements which have been overridden with display: none                                                       // 6867
			// in a stylesheet to whatever the default browser style is                                                         // 6868
			// for such an element                                                                                              // 6869
			if ( elem.style.display === "" && isHidden( elem ) ) {                                                              // 6870
				values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );                           // 6871
			}                                                                                                                   // 6872
		} else {                                                                                                             // 6873
                                                                                                                       // 6874
			if ( !values[ index ] ) {                                                                                           // 6875
				hidden = isHidden( elem );                                                                                         // 6876
                                                                                                                       // 6877
				if ( display && display !== "none" || !hidden ) {                                                                  // 6878
					jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );                             // 6879
				}                                                                                                                  // 6880
			}                                                                                                                   // 6881
		}                                                                                                                    // 6882
	}                                                                                                                     // 6883
                                                                                                                       // 6884
	// Set the display of most of the elements in a second loop                                                           // 6885
	// to avoid the constant reflow                                                                                       // 6886
	for ( index = 0; index < length; index++ ) {                                                                          // 6887
		elem = elements[ index ];                                                                                            // 6888
		if ( !elem.style ) {                                                                                                 // 6889
			continue;                                                                                                           // 6890
		}                                                                                                                    // 6891
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {                                         // 6892
			elem.style.display = show ? values[ index ] || "" : "none";                                                         // 6893
		}                                                                                                                    // 6894
	}                                                                                                                     // 6895
                                                                                                                       // 6896
	return elements;                                                                                                      // 6897
}                                                                                                                      // 6898
                                                                                                                       // 6899
jQuery.fn.extend({                                                                                                     // 6900
	css: function( name, value ) {                                                                                        // 6901
		return jQuery.access( this, function( elem, name, value ) {                                                          // 6902
			var len, styles,                                                                                                    // 6903
				map = {},                                                                                                          // 6904
				i = 0;                                                                                                             // 6905
                                                                                                                       // 6906
			if ( jQuery.isArray( name ) ) {                                                                                     // 6907
				styles = getStyles( elem );                                                                                        // 6908
				len = name.length;                                                                                                 // 6909
                                                                                                                       // 6910
				for ( ; i < len; i++ ) {                                                                                           // 6911
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );                                                  // 6912
				}                                                                                                                  // 6913
                                                                                                                       // 6914
				return map;                                                                                                        // 6915
			}                                                                                                                   // 6916
                                                                                                                       // 6917
			return value !== undefined ?                                                                                        // 6918
				jQuery.style( elem, name, value ) :                                                                                // 6919
				jQuery.css( elem, name );                                                                                          // 6920
		}, name, value, arguments.length > 1 );                                                                              // 6921
	},                                                                                                                    // 6922
	show: function() {                                                                                                    // 6923
		return showHide( this, true );                                                                                       // 6924
	},                                                                                                                    // 6925
	hide: function() {                                                                                                    // 6926
		return showHide( this );                                                                                             // 6927
	},                                                                                                                    // 6928
	toggle: function( state ) {                                                                                           // 6929
		if ( typeof state === "boolean" ) {                                                                                  // 6930
			return state ? this.show() : this.hide();                                                                           // 6931
		}                                                                                                                    // 6932
                                                                                                                       // 6933
		return this.each(function() {                                                                                        // 6934
			if ( isHidden( this ) ) {                                                                                           // 6935
				jQuery( this ).show();                                                                                             // 6936
			} else {                                                                                                            // 6937
				jQuery( this ).hide();                                                                                             // 6938
			}                                                                                                                   // 6939
		});                                                                                                                  // 6940
	}                                                                                                                     // 6941
});                                                                                                                    // 6942
                                                                                                                       // 6943
jQuery.extend({                                                                                                        // 6944
	// Add in style property hooks for overriding the default                                                             // 6945
	// behavior of getting and setting a style property                                                                   // 6946
	cssHooks: {                                                                                                           // 6947
		opacity: {                                                                                                           // 6948
			get: function( elem, computed ) {                                                                                   // 6949
				if ( computed ) {                                                                                                  // 6950
					// We should always get a number back from opacity                                                                // 6951
					var ret = curCSS( elem, "opacity" );                                                                              // 6952
					return ret === "" ? "1" : ret;                                                                                    // 6953
				}                                                                                                                  // 6954
			}                                                                                                                   // 6955
		}                                                                                                                    // 6956
	},                                                                                                                    // 6957
                                                                                                                       // 6958
	// Don't automatically add "px" to these possibly-unitless properties                                                 // 6959
	cssNumber: {                                                                                                          // 6960
		"columnCount": true,                                                                                                 // 6961
		"fillOpacity": true,                                                                                                 // 6962
		"fontWeight": true,                                                                                                  // 6963
		"lineHeight": true,                                                                                                  // 6964
		"opacity": true,                                                                                                     // 6965
		"order": true,                                                                                                       // 6966
		"orphans": true,                                                                                                     // 6967
		"widows": true,                                                                                                      // 6968
		"zIndex": true,                                                                                                      // 6969
		"zoom": true                                                                                                         // 6970
	},                                                                                                                    // 6971
                                                                                                                       // 6972
	// Add in properties whose names you wish to fix before                                                               // 6973
	// setting or getting the value                                                                                       // 6974
	cssProps: {                                                                                                           // 6975
		// normalize float css property                                                                                      // 6976
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"                                                         // 6977
	},                                                                                                                    // 6978
                                                                                                                       // 6979
	// Get and set the style property on a DOM Node                                                                       // 6980
	style: function( elem, name, value, extra ) {                                                                         // 6981
		// Don't set styles on text and comment nodes                                                                        // 6982
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {                                          // 6983
			return;                                                                                                             // 6984
		}                                                                                                                    // 6985
                                                                                                                       // 6986
		// Make sure that we're working with the right name                                                                  // 6987
		var ret, type, hooks,                                                                                                // 6988
			origName = jQuery.camelCase( name ),                                                                                // 6989
			style = elem.style;                                                                                                 // 6990
                                                                                                                       // 6991
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );           // 6992
                                                                                                                       // 6993
		// gets hook for the prefixed version                                                                                // 6994
		// followed by the unprefixed version                                                                                // 6995
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];                                                      // 6996
                                                                                                                       // 6997
		// Check if we're setting a value                                                                                    // 6998
		if ( value !== undefined ) {                                                                                         // 6999
			type = typeof value;                                                                                                // 7000
                                                                                                                       // 7001
			// convert relative number strings (+= or -=) to relative numbers. #7345                                            // 7002
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {                                                         // 7003
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );                                          // 7004
				// Fixes bug #9237                                                                                                 // 7005
				type = "number";                                                                                                   // 7006
			}                                                                                                                   // 7007
                                                                                                                       // 7008
			// Make sure that NaN and null values aren't set. See: #7116                                                        // 7009
			if ( value == null || type === "number" && isNaN( value ) ) {                                                       // 7010
				return;                                                                                                            // 7011
			}                                                                                                                   // 7012
                                                                                                                       // 7013
			// If a number was passed in, add 'px' to the (except for certain CSS properties)                                   // 7014
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {                                                         // 7015
				value += "px";                                                                                                     // 7016
			}                                                                                                                   // 7017
                                                                                                                       // 7018
			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,                                     // 7019
			// but it would mean to define eight (for every problematic property) identical functions                           // 7020
			if ( !jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {                        // 7021
				style[ name ] = "inherit";                                                                                         // 7022
			}                                                                                                                   // 7023
                                                                                                                       // 7024
			// If a hook was provided, use that value, otherwise just set the specified value                                   // 7025
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {                     // 7026
                                                                                                                       // 7027
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided                                   // 7028
				// Fixes bug #5509                                                                                                 // 7029
				try {                                                                                                              // 7030
					style[ name ] = value;                                                                                            // 7031
				} catch(e) {}                                                                                                      // 7032
			}                                                                                                                   // 7033
                                                                                                                       // 7034
		} else {                                                                                                             // 7035
			// If a hook was provided get the non-computed value from there                                                     // 7036
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {                           // 7037
				return ret;                                                                                                        // 7038
			}                                                                                                                   // 7039
                                                                                                                       // 7040
			// Otherwise just get the value from the style object                                                               // 7041
			return style[ name ];                                                                                               // 7042
		}                                                                                                                    // 7043
	},                                                                                                                    // 7044
                                                                                                                       // 7045
	css: function( elem, name, extra, styles ) {                                                                          // 7046
		var num, val, hooks,                                                                                                 // 7047
			origName = jQuery.camelCase( name );                                                                                // 7048
                                                                                                                       // 7049
		// Make sure that we're working with the right name                                                                  // 7050
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );      // 7051
                                                                                                                       // 7052
		// gets hook for the prefixed version                                                                                // 7053
		// followed by the unprefixed version                                                                                // 7054
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];                                                      // 7055
                                                                                                                       // 7056
		// If a hook was provided get the computed value from there                                                          // 7057
		if ( hooks && "get" in hooks ) {                                                                                     // 7058
			val = hooks.get( elem, true, extra );                                                                               // 7059
		}                                                                                                                    // 7060
                                                                                                                       // 7061
		// Otherwise, if a way to get the computed value exists, use that                                                    // 7062
		if ( val === undefined ) {                                                                                           // 7063
			val = curCSS( elem, name, styles );                                                                                 // 7064
		}                                                                                                                    // 7065
                                                                                                                       // 7066
		//convert "normal" to computed value                                                                                 // 7067
		if ( val === "normal" && name in cssNormalTransform ) {                                                              // 7068
			val = cssNormalTransform[ name ];                                                                                   // 7069
		}                                                                                                                    // 7070
                                                                                                                       // 7071
		// Return, converting to number if forced or a qualifier was provided and val looks numeric                          // 7072
		if ( extra === "" || extra ) {                                                                                       // 7073
			num = parseFloat( val );                                                                                            // 7074
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;                                                  // 7075
		}                                                                                                                    // 7076
		return val;                                                                                                          // 7077
	}                                                                                                                     // 7078
});                                                                                                                    // 7079
                                                                                                                       // 7080
// NOTE: we've included the "window" in window.getComputedStyle                                                        // 7081
// because jsdom on node.js will break without it.                                                                     // 7082
if ( window.getComputedStyle ) {                                                                                       // 7083
	getStyles = function( elem ) {                                                                                        // 7084
		return window.getComputedStyle( elem, null );                                                                        // 7085
	};                                                                                                                    // 7086
                                                                                                                       // 7087
	curCSS = function( elem, name, _computed ) {                                                                          // 7088
		var width, minWidth, maxWidth,                                                                                       // 7089
			computed = _computed || getStyles( elem ),                                                                          // 7090
                                                                                                                       // 7091
			// getPropertyValue is only needed for .css('filter') in IE9, see #12537                                            // 7092
			ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,                                 // 7093
			style = elem.style;                                                                                                 // 7094
                                                                                                                       // 7095
		if ( computed ) {                                                                                                    // 7096
                                                                                                                       // 7097
			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {                                                 // 7098
				ret = jQuery.style( elem, name );                                                                                  // 7099
			}                                                                                                                   // 7100
                                                                                                                       // 7101
			// A tribute to the "awesome hack by Dean Edwards"                                                                  // 7102
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right                        // 7103
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels     // 7104
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values                             // 7105
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {                                                              // 7106
                                                                                                                       // 7107
				// Remember the original values                                                                                    // 7108
				width = style.width;                                                                                               // 7109
				minWidth = style.minWidth;                                                                                         // 7110
				maxWidth = style.maxWidth;                                                                                         // 7111
                                                                                                                       // 7112
				// Put in the new values to get a computed value out                                                               // 7113
				style.minWidth = style.maxWidth = style.width = ret;                                                               // 7114
				ret = computed.width;                                                                                              // 7115
                                                                                                                       // 7116
				// Revert the changed values                                                                                       // 7117
				style.width = width;                                                                                               // 7118
				style.minWidth = minWidth;                                                                                         // 7119
				style.maxWidth = maxWidth;                                                                                         // 7120
			}                                                                                                                   // 7121
		}                                                                                                                    // 7122
                                                                                                                       // 7123
		return ret;                                                                                                          // 7124
	};                                                                                                                    // 7125
} else if ( document.documentElement.currentStyle ) {                                                                  // 7126
	getStyles = function( elem ) {                                                                                        // 7127
		return elem.currentStyle;                                                                                            // 7128
	};                                                                                                                    // 7129
                                                                                                                       // 7130
	curCSS = function( elem, name, _computed ) {                                                                          // 7131
		var left, rs, rsLeft,                                                                                                // 7132
			computed = _computed || getStyles( elem ),                                                                          // 7133
			ret = computed ? computed[ name ] : undefined,                                                                      // 7134
			style = elem.style;                                                                                                 // 7135
                                                                                                                       // 7136
		// Avoid setting ret to empty string here                                                                            // 7137
		// so we don't default to auto                                                                                       // 7138
		if ( ret == null && style && style[ name ] ) {                                                                       // 7139
			ret = style[ name ];                                                                                                // 7140
		}                                                                                                                    // 7141
                                                                                                                       // 7142
		// From the awesome hack by Dean Edwards                                                                             // 7143
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291                                                  // 7144
                                                                                                                       // 7145
		// If we're not dealing with a regular pixel number                                                                  // 7146
		// but a number that has a weird ending, we need to convert it to pixels                                             // 7147
		// but not position css attributes, as those are proportional to the parent element instead                          // 7148
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem                       // 7149
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {                                                            // 7150
                                                                                                                       // 7151
			// Remember the original values                                                                                     // 7152
			left = style.left;                                                                                                  // 7153
			rs = elem.runtimeStyle;                                                                                             // 7154
			rsLeft = rs && rs.left;                                                                                             // 7155
                                                                                                                       // 7156
			// Put in the new values to get a computed value out                                                                // 7157
			if ( rsLeft ) {                                                                                                     // 7158
				rs.left = elem.currentStyle.left;                                                                                  // 7159
			}                                                                                                                   // 7160
			style.left = name === "fontSize" ? "1em" : ret;                                                                     // 7161
			ret = style.pixelLeft + "px";                                                                                       // 7162
                                                                                                                       // 7163
			// Revert the changed values                                                                                        // 7164
			style.left = left;                                                                                                  // 7165
			if ( rsLeft ) {                                                                                                     // 7166
				rs.left = rsLeft;                                                                                                  // 7167
			}                                                                                                                   // 7168
		}                                                                                                                    // 7169
                                                                                                                       // 7170
		return ret === "" ? "auto" : ret;                                                                                    // 7171
	};                                                                                                                    // 7172
}                                                                                                                      // 7173
                                                                                                                       // 7174
function setPositiveNumber( elem, value, subtract ) {                                                                  // 7175
	var matches = rnumsplit.exec( value );                                                                                // 7176
	return matches ?                                                                                                      // 7177
		// Guard against undefined "subtract", e.g., when used as in cssHooks                                                // 7178
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :                                         // 7179
		value;                                                                                                               // 7180
}                                                                                                                      // 7181
                                                                                                                       // 7182
function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {                                              // 7183
	var i = extra === ( isBorderBox ? "border" : "content" ) ?                                                            // 7184
		// If we already have the right measurement, avoid augmentation                                                      // 7185
		4 :                                                                                                                  // 7186
		// Otherwise initialize for horizontal or vertical properties                                                        // 7187
		name === "width" ? 1 : 0,                                                                                            // 7188
                                                                                                                       // 7189
		val = 0;                                                                                                             // 7190
                                                                                                                       // 7191
	for ( ; i < 4; i += 2 ) {                                                                                             // 7192
		// both box models exclude margin, so add it if we want it                                                           // 7193
		if ( extra === "margin" ) {                                                                                          // 7194
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );                                                    // 7195
		}                                                                                                                    // 7196
                                                                                                                       // 7197
		if ( isBorderBox ) {                                                                                                 // 7198
			// border-box includes padding, so remove it if we want content                                                     // 7199
			if ( extra === "content" ) {                                                                                        // 7200
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );                                               // 7201
			}                                                                                                                   // 7202
                                                                                                                       // 7203
			// at this point, extra isn't border nor margin, so remove border                                                   // 7204
			if ( extra !== "margin" ) {                                                                                         // 7205
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );                                      // 7206
			}                                                                                                                   // 7207
		} else {                                                                                                             // 7208
			// at this point, extra isn't content, so add padding                                                               // 7209
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );                                                // 7210
                                                                                                                       // 7211
			// at this point, extra isn't content nor padding, so add border                                                    // 7212
			if ( extra !== "padding" ) {                                                                                        // 7213
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );                                      // 7214
			}                                                                                                                   // 7215
		}                                                                                                                    // 7216
	}                                                                                                                     // 7217
                                                                                                                       // 7218
	return val;                                                                                                           // 7219
}                                                                                                                      // 7220
                                                                                                                       // 7221
function getWidthOrHeight( elem, name, extra ) {                                                                       // 7222
                                                                                                                       // 7223
	// Start with offset property, which is equivalent to the border-box value                                            // 7224
	var valueIsBorderBox = true,                                                                                          // 7225
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,                                                       // 7226
		styles = getStyles( elem ),                                                                                          // 7227
		isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";           // 7228
                                                                                                                       // 7229
	// some non-html elements return undefined for offsetWidth, so check for null/undefined                               // 7230
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285                                                          // 7231
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668                                                       // 7232
	if ( val <= 0 || val == null ) {                                                                                      // 7233
		// Fall back to computed then uncomputed css if necessary                                                            // 7234
		val = curCSS( elem, name, styles );                                                                                  // 7235
		if ( val < 0 || val == null ) {                                                                                      // 7236
			val = elem.style[ name ];                                                                                           // 7237
		}                                                                                                                    // 7238
                                                                                                                       // 7239
		// Computed unit is not pixels. Stop here and return.                                                                // 7240
		if ( rnumnonpx.test(val) ) {                                                                                         // 7241
			return val;                                                                                                         // 7242
		}                                                                                                                    // 7243
                                                                                                                       // 7244
		// we need the check for style in case a browser which returns unreliable values                                     // 7245
		// for getComputedStyle silently falls back to the reliable elem.style                                               // 7246
		valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );                // 7247
                                                                                                                       // 7248
		// Normalize "", auto, and prepare for extra                                                                         // 7249
		val = parseFloat( val ) || 0;                                                                                        // 7250
	}                                                                                                                     // 7251
                                                                                                                       // 7252
	// use the active box-sizing model to add/subtract irrelevant styles                                                  // 7253
	return ( val +                                                                                                        // 7254
		augmentWidthOrHeight(                                                                                                // 7255
			elem,                                                                                                               // 7256
			name,                                                                                                               // 7257
			extra || ( isBorderBox ? "border" : "content" ),                                                                    // 7258
			valueIsBorderBox,                                                                                                   // 7259
			styles                                                                                                              // 7260
		)                                                                                                                    // 7261
	) + "px";                                                                                                             // 7262
}                                                                                                                      // 7263
                                                                                                                       // 7264
// Try to determine the default display value of an element                                                            // 7265
function css_defaultDisplay( nodeName ) {                                                                              // 7266
	var doc = document,                                                                                                   // 7267
		display = elemdisplay[ nodeName ];                                                                                   // 7268
                                                                                                                       // 7269
	if ( !display ) {                                                                                                     // 7270
		display = actualDisplay( nodeName, doc );                                                                            // 7271
                                                                                                                       // 7272
		// If the simple way fails, read from inside an iframe                                                               // 7273
		if ( display === "none" || !display ) {                                                                              // 7274
			// Use the already-created iframe if possible                                                                       // 7275
			iframe = ( iframe ||                                                                                                // 7276
				jQuery("<iframe frameborder='0' width='0' height='0'/>")                                                           // 7277
				.css( "cssText", "display:block !important" )                                                                      // 7278
			).appendTo( doc.documentElement );                                                                                  // 7279
                                                                                                                       // 7280
			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse                                      // 7281
			doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;                                            // 7282
			doc.write("<!doctype html><html><body>");                                                                           // 7283
			doc.close();                                                                                                        // 7284
                                                                                                                       // 7285
			display = actualDisplay( nodeName, doc );                                                                           // 7286
			iframe.detach();                                                                                                    // 7287
		}                                                                                                                    // 7288
                                                                                                                       // 7289
		// Store the correct default display                                                                                 // 7290
		elemdisplay[ nodeName ] = display;                                                                                   // 7291
	}                                                                                                                     // 7292
                                                                                                                       // 7293
	return display;                                                                                                       // 7294
}                                                                                                                      // 7295
                                                                                                                       // 7296
// Called ONLY from within css_defaultDisplay                                                                          // 7297
function actualDisplay( name, doc ) {                                                                                  // 7298
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),                                                  // 7299
		display = jQuery.css( elem[0], "display" );                                                                          // 7300
	elem.remove();                                                                                                        // 7301
	return display;                                                                                                       // 7302
}                                                                                                                      // 7303
                                                                                                                       // 7304
jQuery.each([ "height", "width" ], function( i, name ) {                                                               // 7305
	jQuery.cssHooks[ name ] = {                                                                                           // 7306
		get: function( elem, computed, extra ) {                                                                             // 7307
			if ( computed ) {                                                                                                   // 7308
				// certain elements can have dimension info if we invisibly show them                                              // 7309
				// however, it must have a current display style that would benefit from this                                      // 7310
				return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?                              // 7311
					jQuery.swap( elem, cssShow, function() {                                                                          // 7312
						return getWidthOrHeight( elem, name, extra );                                                                    // 7313
					}) :                                                                                                              // 7314
					getWidthOrHeight( elem, name, extra );                                                                            // 7315
			}                                                                                                                   // 7316
		},                                                                                                                   // 7317
                                                                                                                       // 7318
		set: function( elem, value, extra ) {                                                                                // 7319
			var styles = extra && getStyles( elem );                                                                            // 7320
			return setPositiveNumber( elem, value, extra ?                                                                      // 7321
				augmentWidthOrHeight(                                                                                              // 7322
					elem,                                                                                                             // 7323
					name,                                                                                                             // 7324
					extra,                                                                                                            // 7325
					jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",                      // 7326
					styles                                                                                                            // 7327
				) : 0                                                                                                              // 7328
			);                                                                                                                  // 7329
		}                                                                                                                    // 7330
	};                                                                                                                    // 7331
});                                                                                                                    // 7332
                                                                                                                       // 7333
if ( !jQuery.support.opacity ) {                                                                                       // 7334
	jQuery.cssHooks.opacity = {                                                                                           // 7335
		get: function( elem, computed ) {                                                                                    // 7336
			// IE uses filters for opacity                                                                                      // 7337
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?      // 7338
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :                                                                          // 7339
				computed ? "1" : "";                                                                                               // 7340
		},                                                                                                                   // 7341
                                                                                                                       // 7342
		set: function( elem, value ) {                                                                                       // 7343
			var style = elem.style,                                                                                             // 7344
				currentStyle = elem.currentStyle,                                                                                  // 7345
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",                                   // 7346
				filter = currentStyle && currentStyle.filter || style.filter || "";                                                // 7347
                                                                                                                       // 7348
			// IE has trouble with opacity if it does not have layout                                                           // 7349
			// Force it by setting the zoom level                                                                               // 7350
			style.zoom = 1;                                                                                                     // 7351
                                                                                                                       // 7352
			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652                   // 7353
			// if value === "", then remove inline opacity #12685                                                               // 7354
			if ( ( value >= 1 || value === "" ) &&                                                                              // 7355
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&                                                             // 7356
					style.removeAttribute ) {                                                                                         // 7357
                                                                                                                       // 7358
				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText                                     // 7359
				// if "filter:" is present at all, clearType is disabled, we want to avoid this                                    // 7360
				// style.removeAttribute is IE Only, but so apparently is this code path...                                        // 7361
				style.removeAttribute( "filter" );                                                                                 // 7362
                                                                                                                       // 7363
				// if there is no filter style applied in a css rule or unset inline opacity, we are done                          // 7364
				if ( value === "" || currentStyle && !currentStyle.filter ) {                                                      // 7365
					return;                                                                                                           // 7366
				}                                                                                                                  // 7367
			}                                                                                                                   // 7368
                                                                                                                       // 7369
			// otherwise, set new filter values                                                                                 // 7370
			style.filter = ralpha.test( filter ) ?                                                                              // 7371
				filter.replace( ralpha, opacity ) :                                                                                // 7372
				filter + " " + opacity;                                                                                            // 7373
		}                                                                                                                    // 7374
	};                                                                                                                    // 7375
}                                                                                                                      // 7376
                                                                                                                       // 7377
// These hooks cannot be added until DOM ready because the support test                                                // 7378
// for it is not run until after DOM ready                                                                             // 7379
jQuery(function() {                                                                                                    // 7380
	if ( !jQuery.support.reliableMarginRight ) {                                                                          // 7381
		jQuery.cssHooks.marginRight = {                                                                                      // 7382
			get: function( elem, computed ) {                                                                                   // 7383
				if ( computed ) {                                                                                                  // 7384
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right                                       // 7385
					// Work around by temporarily setting element display to inline-block                                             // 7386
					return jQuery.swap( elem, { "display": "inline-block" },                                                          // 7387
						curCSS, [ elem, "marginRight" ] );                                                                               // 7388
				}                                                                                                                  // 7389
			}                                                                                                                   // 7390
		};                                                                                                                   // 7391
	}                                                                                                                     // 7392
                                                                                                                       // 7393
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084                                                          // 7394
	// getComputedStyle returns percent when specified for top/left/bottom/right                                          // 7395
	// rather than make the css module depend on the offset module, we just check for it here                             // 7396
	if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {                                                          // 7397
		jQuery.each( [ "top", "left" ], function( i, prop ) {                                                                // 7398
			jQuery.cssHooks[ prop ] = {                                                                                         // 7399
				get: function( elem, computed ) {                                                                                  // 7400
					if ( computed ) {                                                                                                 // 7401
						computed = curCSS( elem, prop );                                                                                 // 7402
						// if curCSS returns percentage, fallback to offset                                                              // 7403
						return rnumnonpx.test( computed ) ?                                                                              // 7404
							jQuery( elem ).position()[ prop ] + "px" :                                                                      // 7405
							computed;                                                                                                       // 7406
					}                                                                                                                 // 7407
				}                                                                                                                  // 7408
			};                                                                                                                  // 7409
		});                                                                                                                  // 7410
	}                                                                                                                     // 7411
                                                                                                                       // 7412
});                                                                                                                    // 7413
                                                                                                                       // 7414
if ( jQuery.expr && jQuery.expr.filters ) {                                                                            // 7415
	jQuery.expr.filters.hidden = function( elem ) {                                                                       // 7416
		// Support: Opera <= 12.12                                                                                           // 7417
		// Opera reports offsetWidths and offsetHeights less than zero on some elements                                      // 7418
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||                                                            // 7419
			(!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};                                                                                                                    // 7421
                                                                                                                       // 7422
	jQuery.expr.filters.visible = function( elem ) {                                                                      // 7423
		return !jQuery.expr.filters.hidden( elem );                                                                          // 7424
	};                                                                                                                    // 7425
}                                                                                                                      // 7426
                                                                                                                       // 7427
// These hooks are used by animate to expand properties                                                                // 7428
jQuery.each({                                                                                                          // 7429
	margin: "",                                                                                                           // 7430
	padding: "",                                                                                                          // 7431
	border: "Width"                                                                                                       // 7432
}, function( prefix, suffix ) {                                                                                        // 7433
	jQuery.cssHooks[ prefix + suffix ] = {                                                                                // 7434
		expand: function( value ) {                                                                                          // 7435
			var i = 0,                                                                                                          // 7436
				expanded = {},                                                                                                     // 7437
                                                                                                                       // 7438
				// assumes a single number if not a string                                                                         // 7439
				parts = typeof value === "string" ? value.split(" ") : [ value ];                                                  // 7440
                                                                                                                       // 7441
			for ( ; i < 4; i++ ) {                                                                                              // 7442
				expanded[ prefix + cssExpand[ i ] + suffix ] =                                                                     // 7443
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];                                                                       // 7444
			}                                                                                                                   // 7445
                                                                                                                       // 7446
			return expanded;                                                                                                    // 7447
		}                                                                                                                    // 7448
	};                                                                                                                    // 7449
                                                                                                                       // 7450
	if ( !rmargin.test( prefix ) ) {                                                                                      // 7451
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;                                                          // 7452
	}                                                                                                                     // 7453
});                                                                                                                    // 7454
var r20 = /%20/g,                                                                                                      // 7455
	rbracket = /\[\]$/,                                                                                                   // 7456
	rCRLF = /\r?\n/g,                                                                                                     // 7457
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,                                                            // 7458
	rsubmittable = /^(?:input|select|textarea|keygen)/i;                                                                  // 7459
                                                                                                                       // 7460
jQuery.fn.extend({                                                                                                     // 7461
	serialize: function() {                                                                                               // 7462
		return jQuery.param( this.serializeArray() );                                                                        // 7463
	},                                                                                                                    // 7464
	serializeArray: function() {                                                                                          // 7465
		return this.map(function(){                                                                                          // 7466
			// Can add propHook for "elements" to filter or add form elements                                                   // 7467
			var elements = jQuery.prop( this, "elements" );                                                                     // 7468
			return elements ? jQuery.makeArray( elements ) : this;                                                              // 7469
		})                                                                                                                   // 7470
		.filter(function(){                                                                                                  // 7471
			var type = this.type;                                                                                               // 7472
			// Use .is(":disabled") so that fieldset[disabled] works                                                            // 7473
			return this.name && !jQuery( this ).is( ":disabled" ) &&                                                            // 7474
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&                                             // 7475
				( this.checked || !manipulation_rcheckableType.test( type ) );                                                     // 7476
		})                                                                                                                   // 7477
		.map(function( i, elem ){                                                                                            // 7478
			var val = jQuery( this ).val();                                                                                     // 7479
                                                                                                                       // 7480
			return val == null ?                                                                                                // 7481
				null :                                                                                                             // 7482
				jQuery.isArray( val ) ?                                                                                            // 7483
					jQuery.map( val, function( val ){                                                                                 // 7484
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };                                                 // 7485
					}) :                                                                                                              // 7486
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };                                                         // 7487
		}).get();                                                                                                            // 7488
	}                                                                                                                     // 7489
});                                                                                                                    // 7490
                                                                                                                       // 7491
//Serialize an array of form elements or a set of                                                                      // 7492
//key/values into a query string                                                                                       // 7493
jQuery.param = function( a, traditional ) {                                                                            // 7494
	var prefix,                                                                                                           // 7495
		s = [],                                                                                                              // 7496
		add = function( key, value ) {                                                                                       // 7497
			// If value is a function, invoke it and return its value                                                           // 7498
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );                                      // 7499
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );                                      // 7500
		};                                                                                                                   // 7501
                                                                                                                       // 7502
	// Set traditional to true for jQuery <= 1.3.2 behavior.                                                              // 7503
	if ( traditional === undefined ) {                                                                                    // 7504
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;                                                // 7505
	}                                                                                                                     // 7506
                                                                                                                       // 7507
	// If an array was passed in, assume that it is an array of form elements.                                            // 7508
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {                                            // 7509
		// Serialize the form elements                                                                                       // 7510
		jQuery.each( a, function() {                                                                                         // 7511
			add( this.name, this.value );                                                                                       // 7512
		});                                                                                                                  // 7513
                                                                                                                       // 7514
	} else {                                                                                                              // 7515
		// If traditional, encode the "old" way (the way 1.3.2 or older                                                      // 7516
		// did it), otherwise encode params recursively.                                                                     // 7517
		for ( prefix in a ) {                                                                                                // 7518
			buildParams( prefix, a[ prefix ], traditional, add );                                                               // 7519
		}                                                                                                                    // 7520
	}                                                                                                                     // 7521
                                                                                                                       // 7522
	// Return the resulting serialization                                                                                 // 7523
	return s.join( "&" ).replace( r20, "+" );                                                                             // 7524
};                                                                                                                     // 7525
                                                                                                                       // 7526
function buildParams( prefix, obj, traditional, add ) {                                                                // 7527
	var name;                                                                                                             // 7528
                                                                                                                       // 7529
	if ( jQuery.isArray( obj ) ) {                                                                                        // 7530
		// Serialize array item.                                                                                             // 7531
		jQuery.each( obj, function( i, v ) {                                                                                 // 7532
			if ( traditional || rbracket.test( prefix ) ) {                                                                     // 7533
				// Treat each array item as a scalar.                                                                              // 7534
				add( prefix, v );                                                                                                  // 7535
                                                                                                                       // 7536
			} else {                                                                                                            // 7537
				// Item is non-scalar (array or object), encode its numeric index.                                                 // 7538
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );                       // 7539
			}                                                                                                                   // 7540
		});                                                                                                                  // 7541
                                                                                                                       // 7542
	} else if ( !traditional && jQuery.type( obj ) === "object" ) {                                                       // 7543
		// Serialize object item.                                                                                            // 7544
		for ( name in obj ) {                                                                                                // 7545
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );                                            // 7546
		}                                                                                                                    // 7547
                                                                                                                       // 7548
	} else {                                                                                                              // 7549
		// Serialize scalar item.                                                                                            // 7550
		add( prefix, obj );                                                                                                  // 7551
	}                                                                                                                     // 7552
}                                                                                                                      // 7553
jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +                                // 7554
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +                                             // 7555
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {                    // 7556
                                                                                                                       // 7557
	// Handle event binding                                                                                               // 7558
	jQuery.fn[ name ] = function( data, fn ) {                                                                            // 7559
		return arguments.length > 0 ?                                                                                        // 7560
			this.on( name, null, data, fn ) :                                                                                   // 7561
			this.trigger( name );                                                                                               // 7562
	};                                                                                                                    // 7563
});                                                                                                                    // 7564
                                                                                                                       // 7565
jQuery.fn.extend({                                                                                                     // 7566
	hover: function( fnOver, fnOut ) {                                                                                    // 7567
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );                                                      // 7568
	},                                                                                                                    // 7569
                                                                                                                       // 7570
	bind: function( types, data, fn ) {                                                                                   // 7571
		return this.on( types, null, data, fn );                                                                             // 7572
	},                                                                                                                    // 7573
	unbind: function( types, fn ) {                                                                                       // 7574
		return this.off( types, null, fn );                                                                                  // 7575
	},                                                                                                                    // 7576
                                                                                                                       // 7577
	delegate: function( selector, types, data, fn ) {                                                                     // 7578
		return this.on( types, selector, data, fn );                                                                         // 7579
	},                                                                                                                    // 7580
	undelegate: function( selector, types, fn ) {                                                                         // 7581
		// ( namespace ) or ( selector, types [, fn] )                                                                       // 7582
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );                // 7583
	}                                                                                                                     // 7584
});                                                                                                                    // 7585
var                                                                                                                    // 7586
	// Document location                                                                                                  // 7587
	ajaxLocParts,                                                                                                         // 7588
	ajaxLocation,                                                                                                         // 7589
	ajax_nonce = jQuery.now(),                                                                                            // 7590
                                                                                                                       // 7591
	ajax_rquery = /\?/,                                                                                                   // 7592
	rhash = /#.*$/,                                                                                                       // 7593
	rts = /([?&])_=[^&]*/,                                                                                                // 7594
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL                                       // 7595
	// #7653, #8125, #8152: local protocol detection                                                                      // 7596
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,                                         // 7597
	rnoContent = /^(?:GET|HEAD)$/,                                                                                        // 7598
	rprotocol = /^\/\//,                                                                                                  // 7599
	rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,                                                                 // 7600
                                                                                                                       // 7601
	// Keep a copy of the old load method                                                                                 // 7602
	_load = jQuery.fn.load,                                                                                               // 7603
                                                                                                                       // 7604
	/* Prefilters                                                                                                         // 7605
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)                                // 7606
	 * 2) These are called:                                                                                               // 7607
	 *    - BEFORE asking for a transport                                                                                 // 7608
	 *    - AFTER param serialization (s.data is a string if s.processData is true)                                       // 7609
	 * 3) key is the dataType                                                                                             // 7610
	 * 4) the catchall symbol "*" can be used                                                                             // 7611
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed                            // 7612
	 */                                                                                                                   // 7613
	prefilters = {},                                                                                                      // 7614
                                                                                                                       // 7615
	/* Transports bindings                                                                                                // 7616
	 * 1) key is the dataType                                                                                             // 7617
	 * 2) the catchall symbol "*" can be used                                                                             // 7618
	 * 3) selection will start with transport dataType and THEN go to "*" if needed                                       // 7619
	 */                                                                                                                   // 7620
	transports = {},                                                                                                      // 7621
                                                                                                                       // 7622
	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression                               // 7623
	allTypes = "*/".concat("*");                                                                                          // 7624
                                                                                                                       // 7625
// #8138, IE may throw an exception when accessing                                                                     // 7626
// a field from window.location if document.domain has been set                                                        // 7627
try {                                                                                                                  // 7628
	ajaxLocation = location.href;                                                                                         // 7629
} catch( e ) {                                                                                                         // 7630
	// Use the href attribute of an A element                                                                             // 7631
	// since IE will modify it given document.location                                                                    // 7632
	ajaxLocation = document.createElement( "a" );                                                                         // 7633
	ajaxLocation.href = "";                                                                                               // 7634
	ajaxLocation = ajaxLocation.href;                                                                                     // 7635
}                                                                                                                      // 7636
                                                                                                                       // 7637
// Segment location into parts                                                                                         // 7638
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];                                                          // 7639
                                                                                                                       // 7640
// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport                                                // 7641
function addToPrefiltersOrTransports( structure ) {                                                                    // 7642
                                                                                                                       // 7643
	// dataTypeExpression is optional and defaults to "*"                                                                 // 7644
	return function( dataTypeExpression, func ) {                                                                         // 7645
                                                                                                                       // 7646
		if ( typeof dataTypeExpression !== "string" ) {                                                                      // 7647
			func = dataTypeExpression;                                                                                          // 7648
			dataTypeExpression = "*";                                                                                           // 7649
		}                                                                                                                    // 7650
                                                                                                                       // 7651
		var dataType,                                                                                                        // 7652
			i = 0,                                                                                                              // 7653
			dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];                                         // 7654
                                                                                                                       // 7655
		if ( jQuery.isFunction( func ) ) {                                                                                   // 7656
			// For each dataType in the dataTypeExpression                                                                      // 7657
			while ( (dataType = dataTypes[i++]) ) {                                                                             // 7658
				// Prepend if requested                                                                                            // 7659
				if ( dataType[0] === "+" ) {                                                                                       // 7660
					dataType = dataType.slice( 1 ) || "*";                                                                            // 7661
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );                                            // 7662
                                                                                                                       // 7663
				// Otherwise append                                                                                                // 7664
				} else {                                                                                                           // 7665
					(structure[ dataType ] = structure[ dataType ] || []).push( func );                                               // 7666
				}                                                                                                                  // 7667
			}                                                                                                                   // 7668
		}                                                                                                                    // 7669
	};                                                                                                                    // 7670
}                                                                                                                      // 7671
                                                                                                                       // 7672
// Base inspection function for prefilters and transports                                                              // 7673
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {                                 // 7674
                                                                                                                       // 7675
	var inspected = {},                                                                                                   // 7676
		seekingTransport = ( structure === transports );                                                                     // 7677
                                                                                                                       // 7678
	function inspect( dataType ) {                                                                                        // 7679
		var selected;                                                                                                        // 7680
		inspected[ dataType ] = true;                                                                                        // 7681
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {                                        // 7682
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );                                    // 7683
			if( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {           // 7684
				options.dataTypes.unshift( dataTypeOrTransport );                                                                  // 7685
				inspect( dataTypeOrTransport );                                                                                    // 7686
				return false;                                                                                                      // 7687
			} else if ( seekingTransport ) {                                                                                    // 7688
				return !( selected = dataTypeOrTransport );                                                                        // 7689
			}                                                                                                                   // 7690
		});                                                                                                                  // 7691
		return selected;                                                                                                     // 7692
	}                                                                                                                     // 7693
                                                                                                                       // 7694
	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );                                      // 7695
}                                                                                                                      // 7696
                                                                                                                       // 7697
// A special extend for ajax options                                                                                   // 7698
// that takes "flat" options (not to be deep extended)                                                                 // 7699
// Fixes #9887                                                                                                         // 7700
function ajaxExtend( target, src ) {                                                                                   // 7701
	var deep, key,                                                                                                        // 7702
		flatOptions = jQuery.ajaxSettings.flatOptions || {};                                                                 // 7703
                                                                                                                       // 7704
	for ( key in src ) {                                                                                                  // 7705
		if ( src[ key ] !== undefined ) {                                                                                    // 7706
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];                                      // 7707
		}                                                                                                                    // 7708
	}                                                                                                                     // 7709
	if ( deep ) {                                                                                                         // 7710
		jQuery.extend( true, target, deep );                                                                                 // 7711
	}                                                                                                                     // 7712
                                                                                                                       // 7713
	return target;                                                                                                        // 7714
}                                                                                                                      // 7715
                                                                                                                       // 7716
jQuery.fn.load = function( url, params, callback ) {                                                                   // 7717
	if ( typeof url !== "string" && _load ) {                                                                             // 7718
		return _load.apply( this, arguments );                                                                               // 7719
	}                                                                                                                     // 7720
                                                                                                                       // 7721
	var selector, response, type,                                                                                         // 7722
		self = this,                                                                                                         // 7723
		off = url.indexOf(" ");                                                                                              // 7724
                                                                                                                       // 7725
	if ( off >= 0 ) {                                                                                                     // 7726
		selector = url.slice( off, url.length );                                                                             // 7727
		url = url.slice( 0, off );                                                                                           // 7728
	}                                                                                                                     // 7729
                                                                                                                       // 7730
	// If it's a function                                                                                                 // 7731
	if ( jQuery.isFunction( params ) ) {                                                                                  // 7732
                                                                                                                       // 7733
		// We assume that it's the callback                                                                                  // 7734
		callback = params;                                                                                                   // 7735
		params = undefined;                                                                                                  // 7736
                                                                                                                       // 7737
	// Otherwise, build a param string                                                                                    // 7738
	} else if ( params && typeof params === "object" ) {                                                                  // 7739
		type = "POST";                                                                                                       // 7740
	}                                                                                                                     // 7741
                                                                                                                       // 7742
	// If we have elements to modify, make the request                                                                    // 7743
	if ( self.length > 0 ) {                                                                                              // 7744
		jQuery.ajax({                                                                                                        // 7745
			url: url,                                                                                                           // 7746
                                                                                                                       // 7747
			// if "type" variable is undefined, then "GET" method will be used                                                  // 7748
			type: type,                                                                                                         // 7749
			dataType: "html",                                                                                                   // 7750
			data: params                                                                                                        // 7751
		}).done(function( responseText ) {                                                                                   // 7752
                                                                                                                       // 7753
			// Save response for use in complete callback                                                                       // 7754
			response = arguments;                                                                                               // 7755
                                                                                                                       // 7756
			self.html( selector ?                                                                                               // 7757
                                                                                                                       // 7758
				// If a selector was specified, locate the right elements in a dummy div                                           // 7759
				// Exclude scripts to avoid IE 'Permission Denied' errors                                                          // 7760
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :                                      // 7761
                                                                                                                       // 7762
				// Otherwise use the full result                                                                                   // 7763
				responseText );                                                                                                    // 7764
                                                                                                                       // 7765
		}).complete( callback && function( jqXHR, status ) {                                                                 // 7766
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );                                           // 7767
		});                                                                                                                  // 7768
	}                                                                                                                     // 7769
                                                                                                                       // 7770
	return this;                                                                                                          // 7771
};                                                                                                                     // 7772
                                                                                                                       // 7773
// Attach a bunch of functions for handling common AJAX events                                                         // 7774
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ){ // 7775
	jQuery.fn[ type ] = function( fn ){                                                                                   // 7776
		return this.on( type, fn );                                                                                          // 7777
	};                                                                                                                    // 7778
});                                                                                                                    // 7779
                                                                                                                       // 7780
jQuery.extend({                                                                                                        // 7781
                                                                                                                       // 7782
	// Counter for holding the number of active queries                                                                   // 7783
	active: 0,                                                                                                            // 7784
                                                                                                                       // 7785
	// Last-Modified header cache for next request                                                                        // 7786
	lastModified: {},                                                                                                     // 7787
	etag: {},                                                                                                             // 7788
                                                                                                                       // 7789
	ajaxSettings: {                                                                                                       // 7790
		url: ajaxLocation,                                                                                                   // 7791
		type: "GET",                                                                                                         // 7792
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),                                                                   // 7793
		global: true,                                                                                                        // 7794
		processData: true,                                                                                                   // 7795
		async: true,                                                                                                         // 7796
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",                                                     // 7797
		/*                                                                                                                   // 7798
		timeout: 0,                                                                                                          // 7799
		data: null,                                                                                                          // 7800
		dataType: null,                                                                                                      // 7801
		username: null,                                                                                                      // 7802
		password: null,                                                                                                      // 7803
		cache: null,                                                                                                         // 7804
		throws: false,                                                                                                       // 7805
		traditional: false,                                                                                                  // 7806
		headers: {},                                                                                                         // 7807
		*/                                                                                                                   // 7808
                                                                                                                       // 7809
		accepts: {                                                                                                           // 7810
			"*": allTypes,                                                                                                      // 7811
			text: "text/plain",                                                                                                 // 7812
			html: "text/html",                                                                                                  // 7813
			xml: "application/xml, text/xml",                                                                                   // 7814
			json: "application/json, text/javascript"                                                                           // 7815
		},                                                                                                                   // 7816
                                                                                                                       // 7817
		contents: {                                                                                                          // 7818
			xml: /xml/,                                                                                                         // 7819
			html: /html/,                                                                                                       // 7820
			json: /json/                                                                                                        // 7821
		},                                                                                                                   // 7822
                                                                                                                       // 7823
		responseFields: {                                                                                                    // 7824
			xml: "responseXML",                                                                                                 // 7825
			text: "responseText",                                                                                               // 7826
			json: "responseJSON"                                                                                                // 7827
		},                                                                                                                   // 7828
                                                                                                                       // 7829
		// Data converters                                                                                                   // 7830
		// Keys separate source (or catchall "*") and destination types with a single space                                  // 7831
		converters: {                                                                                                        // 7832
                                                                                                                       // 7833
			// Convert anything to text                                                                                         // 7834
			"* text": String,                                                                                                   // 7835
                                                                                                                       // 7836
			// Text to html (true = no transformation)                                                                          // 7837
			"text html": true,                                                                                                  // 7838
                                                                                                                       // 7839
			// Evaluate text as a json expression                                                                               // 7840
			"text json": jQuery.parseJSON,                                                                                      // 7841
                                                                                                                       // 7842
			// Parse text as xml                                                                                                // 7843
			"text xml": jQuery.parseXML                                                                                         // 7844
		},                                                                                                                   // 7845
                                                                                                                       // 7846
		// For options that shouldn't be deep extended:                                                                      // 7847
		// you can add your own custom options here if                                                                       // 7848
		// and when you create one that shouldn't be                                                                         // 7849
		// deep extended (see ajaxExtend)                                                                                    // 7850
		flatOptions: {                                                                                                       // 7851
			url: true,                                                                                                          // 7852
			context: true                                                                                                       // 7853
		}                                                                                                                    // 7854
	},                                                                                                                    // 7855
                                                                                                                       // 7856
	// Creates a full fledged settings object into target                                                                 // 7857
	// with both ajaxSettings and settings fields.                                                                        // 7858
	// If target is omitted, writes into ajaxSettings.                                                                    // 7859
	ajaxSetup: function( target, settings ) {                                                                             // 7860
		return settings ?                                                                                                    // 7861
                                                                                                                       // 7862
			// Building a settings object                                                                                       // 7863
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :                                                 // 7864
                                                                                                                       // 7865
			// Extending ajaxSettings                                                                                           // 7866
			ajaxExtend( jQuery.ajaxSettings, target );                                                                          // 7867
	},                                                                                                                    // 7868
                                                                                                                       // 7869
	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),                                                             // 7870
	ajaxTransport: addToPrefiltersOrTransports( transports ),                                                             // 7871
                                                                                                                       // 7872
	// Main method                                                                                                        // 7873
	ajax: function( url, options ) {                                                                                      // 7874
                                                                                                                       // 7875
		// If url is an object, simulate pre-1.5 signature                                                                   // 7876
		if ( typeof url === "object" ) {                                                                                     // 7877
			options = url;                                                                                                      // 7878
			url = undefined;                                                                                                    // 7879
		}                                                                                                                    // 7880
                                                                                                                       // 7881
		// Force options to be an object                                                                                     // 7882
		options = options || {};                                                                                             // 7883
                                                                                                                       // 7884
		var // Cross-domain detection vars                                                                                   // 7885
			parts,                                                                                                              // 7886
			// Loop variable                                                                                                    // 7887
			i,                                                                                                                  // 7888
			// URL without anti-cache param                                                                                     // 7889
			cacheURL,                                                                                                           // 7890
			// Response headers as string                                                                                       // 7891
			responseHeadersString,                                                                                              // 7892
			// timeout handle                                                                                                   // 7893
			timeoutTimer,                                                                                                       // 7894
                                                                                                                       // 7895
			// To know if global events are to be dispatched                                                                    // 7896
			fireGlobals,                                                                                                        // 7897
                                                                                                                       // 7898
			transport,                                                                                                          // 7899
			// Response headers                                                                                                 // 7900
			responseHeaders,                                                                                                    // 7901
			// Create the final options object                                                                                  // 7902
			s = jQuery.ajaxSetup( {}, options ),                                                                                // 7903
			// Callbacks context                                                                                                // 7904
			callbackContext = s.context || s,                                                                                   // 7905
			// Context for global events is callbackContext if it is a DOM node or jQuery collection                            // 7906
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?                          // 7907
				jQuery( callbackContext ) :                                                                                        // 7908
				jQuery.event,                                                                                                      // 7909
			// Deferreds                                                                                                        // 7910
			deferred = jQuery.Deferred(),                                                                                       // 7911
			completeDeferred = jQuery.Callbacks("once memory"),                                                                 // 7912
			// Status-dependent callbacks                                                                                       // 7913
			statusCode = s.statusCode || {},                                                                                    // 7914
			// Headers (they are sent all at once)                                                                              // 7915
			requestHeaders = {},                                                                                                // 7916
			requestHeadersNames = {},                                                                                           // 7917
			// The jqXHR state                                                                                                  // 7918
			state = 0,                                                                                                          // 7919
			// Default abort message                                                                                            // 7920
			strAbort = "canceled",                                                                                              // 7921
			// Fake xhr                                                                                                         // 7922
			jqXHR = {                                                                                                           // 7923
				readyState: 0,                                                                                                     // 7924
                                                                                                                       // 7925
				// Builds headers hashtable if needed                                                                              // 7926
				getResponseHeader: function( key ) {                                                                               // 7927
					var match;                                                                                                        // 7928
					if ( state === 2 ) {                                                                                              // 7929
						if ( !responseHeaders ) {                                                                                        // 7930
							responseHeaders = {};                                                                                           // 7931
							while ( (match = rheaders.exec( responseHeadersString )) ) {                                                    // 7932
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];                                                        // 7933
							}                                                                                                               // 7934
						}                                                                                                                // 7935
						match = responseHeaders[ key.toLowerCase() ];                                                                    // 7936
					}                                                                                                                 // 7937
					return match == null ? null : match;                                                                              // 7938
				},                                                                                                                 // 7939
                                                                                                                       // 7940
				// Raw string                                                                                                      // 7941
				getAllResponseHeaders: function() {                                                                                // 7942
					return state === 2 ? responseHeadersString : null;                                                                // 7943
				},                                                                                                                 // 7944
                                                                                                                       // 7945
				// Caches the header                                                                                               // 7946
				setRequestHeader: function( name, value ) {                                                                        // 7947
					var lname = name.toLowerCase();                                                                                   // 7948
					if ( !state ) {                                                                                                   // 7949
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;                                      // 7950
						requestHeaders[ name ] = value;                                                                                  // 7951
					}                                                                                                                 // 7952
					return this;                                                                                                      // 7953
				},                                                                                                                 // 7954
                                                                                                                       // 7955
				// Overrides response content-type header                                                                          // 7956
				overrideMimeType: function( type ) {                                                                               // 7957
					if ( !state ) {                                                                                                   // 7958
						s.mimeType = type;                                                                                               // 7959
					}                                                                                                                 // 7960
					return this;                                                                                                      // 7961
				},                                                                                                                 // 7962
                                                                                                                       // 7963
				// Status-dependent callbacks                                                                                      // 7964
				statusCode: function( map ) {                                                                                      // 7965
					var code;                                                                                                         // 7966
					if ( map ) {                                                                                                      // 7967
						if ( state < 2 ) {                                                                                               // 7968
							for ( code in map ) {                                                                                           // 7969
								// Lazy-add the new callback in a way that preserves old ones                                                  // 7970
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];                                                      // 7971
							}                                                                                                               // 7972
						} else {                                                                                                         // 7973
							// Execute the appropriate callbacks                                                                            // 7974
							jqXHR.always( map[ jqXHR.status ] );                                                                            // 7975
						}                                                                                                                // 7976
					}                                                                                                                 // 7977
					return this;                                                                                                      // 7978
				},                                                                                                                 // 7979
                                                                                                                       // 7980
				// Cancel the request                                                                                              // 7981
				abort: function( statusText ) {                                                                                    // 7982
					var finalText = statusText || strAbort;                                                                           // 7983
					if ( transport ) {                                                                                                // 7984
						transport.abort( finalText );                                                                                    // 7985
					}                                                                                                                 // 7986
					done( 0, finalText );                                                                                             // 7987
					return this;                                                                                                      // 7988
				}                                                                                                                  // 7989
			};                                                                                                                  // 7990
                                                                                                                       // 7991
		// Attach deferreds                                                                                                  // 7992
		deferred.promise( jqXHR ).complete = completeDeferred.add;                                                           // 7993
		jqXHR.success = jqXHR.done;                                                                                          // 7994
		jqXHR.error = jqXHR.fail;                                                                                            // 7995
                                                                                                                       // 7996
		// Remove hash character (#7531: and string promotion)                                                               // 7997
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)                                           // 7998
		// Handle falsy url in the settings object (#10093: consistency with old signature)                                  // 7999
		// We also use the url parameter if available                                                                        // 8000
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
                                                                                                                       // 8002
		// Alias method option to type as per ticket #12004                                                                  // 8003
		s.type = options.method || options.type || s.method || s.type;                                                       // 8004
                                                                                                                       // 8005
		// Extract dataTypes list                                                                                            // 8006
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( core_rnotwhite ) || [""];                        // 8007
                                                                                                                       // 8008
		// A cross-domain request is in order when we have a protocol:host:port mismatch                                     // 8009
		if ( s.crossDomain == null ) {                                                                                       // 8010
			parts = rurl.exec( s.url.toLowerCase() );                                                                           // 8011
			s.crossDomain = !!( parts &&                                                                                        // 8012
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||                                          // 8013
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==                                                   // 8014
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )                                      // 8015
			);                                                                                                                  // 8016
		}                                                                                                                    // 8017
                                                                                                                       // 8018
		// Convert data if not already a string                                                                              // 8019
		if ( s.data && s.processData && typeof s.data !== "string" ) {                                                       // 8020
			s.data = jQuery.param( s.data, s.traditional );                                                                     // 8021
		}                                                                                                                    // 8022
                                                                                                                       // 8023
		// Apply prefilters                                                                                                  // 8024
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );                                                      // 8025
                                                                                                                       // 8026
		// If request was aborted inside a prefilter, stop there                                                             // 8027
		if ( state === 2 ) {                                                                                                 // 8028
			return jqXHR;                                                                                                       // 8029
		}                                                                                                                    // 8030
                                                                                                                       // 8031
		// We can fire global events as of now if asked to                                                                   // 8032
		fireGlobals = s.global;                                                                                              // 8033
                                                                                                                       // 8034
		// Watch for a new set of requests                                                                                   // 8035
		if ( fireGlobals && jQuery.active++ === 0 ) {                                                                        // 8036
			jQuery.event.trigger("ajaxStart");                                                                                  // 8037
		}                                                                                                                    // 8038
                                                                                                                       // 8039
		// Uppercase the type                                                                                                // 8040
		s.type = s.type.toUpperCase();                                                                                       // 8041
                                                                                                                       // 8042
		// Determine if request has content                                                                                  // 8043
		s.hasContent = !rnoContent.test( s.type );                                                                           // 8044
                                                                                                                       // 8045
		// Save the URL in case we're toying with the If-Modified-Since                                                      // 8046
		// and/or If-None-Match header later on                                                                              // 8047
		cacheURL = s.url;                                                                                                    // 8048
                                                                                                                       // 8049
		// More options handling for requests with no content                                                                // 8050
		if ( !s.hasContent ) {                                                                                               // 8051
                                                                                                                       // 8052
			// If data is available, append data to url                                                                         // 8053
			if ( s.data ) {                                                                                                     // 8054
				cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + s.data );                                     // 8055
				// #9682: remove data so that it's not used in an eventual retry                                                   // 8056
				delete s.data;                                                                                                     // 8057
			}                                                                                                                   // 8058
                                                                                                                       // 8059
			// Add anti-cache in url if needed                                                                                  // 8060
			if ( s.cache === false ) {                                                                                          // 8061
				s.url = rts.test( cacheURL ) ?                                                                                     // 8062
                                                                                                                       // 8063
					// If there is already a '_' parameter, set its value                                                             // 8064
					cacheURL.replace( rts, "$1_=" + ajax_nonce++ ) :                                                                  // 8065
                                                                                                                       // 8066
					// Otherwise add one to the end                                                                                   // 8067
					cacheURL + ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ajax_nonce++;                                    // 8068
			}                                                                                                                   // 8069
		}                                                                                                                    // 8070
                                                                                                                       // 8071
		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.                                     // 8072
		if ( s.ifModified ) {                                                                                                // 8073
			if ( jQuery.lastModified[ cacheURL ] ) {                                                                            // 8074
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );                                    // 8075
			}                                                                                                                   // 8076
			if ( jQuery.etag[ cacheURL ] ) {                                                                                    // 8077
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );                                                // 8078
			}                                                                                                                   // 8079
		}                                                                                                                    // 8080
                                                                                                                       // 8081
		// Set the correct header, if data is being sent                                                                     // 8082
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {                                    // 8083
			jqXHR.setRequestHeader( "Content-Type", s.contentType );                                                            // 8084
		}                                                                                                                    // 8085
                                                                                                                       // 8086
		// Set the Accepts header for the server, depending on the dataType                                                  // 8087
		jqXHR.setRequestHeader(                                                                                              // 8088
			"Accept",                                                                                                           // 8089
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?                                                                   // 8090
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :                   // 8091
				s.accepts[ "*" ]                                                                                                   // 8092
		);                                                                                                                   // 8093
                                                                                                                       // 8094
		// Check for headers option                                                                                          // 8095
		for ( i in s.headers ) {                                                                                             // 8096
			jqXHR.setRequestHeader( i, s.headers[ i ] );                                                                        // 8097
		}                                                                                                                    // 8098
                                                                                                                       // 8099
		// Allow custom headers/mimetypes and early abort                                                                    // 8100
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {                 // 8101
			// Abort if not done already and return                                                                             // 8102
			return jqXHR.abort();                                                                                               // 8103
		}                                                                                                                    // 8104
                                                                                                                       // 8105
		// aborting is no longer a cancellation                                                                              // 8106
		strAbort = "abort";                                                                                                  // 8107
                                                                                                                       // 8108
		// Install callbacks on deferreds                                                                                    // 8109
		for ( i in { success: 1, error: 1, complete: 1 } ) {                                                                 // 8110
			jqXHR[ i ]( s[ i ] );                                                                                               // 8111
		}                                                                                                                    // 8112
                                                                                                                       // 8113
		// Get transport                                                                                                     // 8114
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );                                          // 8115
                                                                                                                       // 8116
		// If no transport, we auto-abort                                                                                    // 8117
		if ( !transport ) {                                                                                                  // 8118
			done( -1, "No Transport" );                                                                                         // 8119
		} else {                                                                                                             // 8120
			jqXHR.readyState = 1;                                                                                               // 8121
                                                                                                                       // 8122
			// Send global event                                                                                                // 8123
			if ( fireGlobals ) {                                                                                                // 8124
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );                                                            // 8125
			}                                                                                                                   // 8126
			// Timeout                                                                                                          // 8127
			if ( s.async && s.timeout > 0 ) {                                                                                   // 8128
				timeoutTimer = setTimeout(function() {                                                                             // 8129
					jqXHR.abort("timeout");                                                                                           // 8130
				}, s.timeout );                                                                                                    // 8131
			}                                                                                                                   // 8132
                                                                                                                       // 8133
			try {                                                                                                               // 8134
				state = 1;                                                                                                         // 8135
				transport.send( requestHeaders, done );                                                                            // 8136
			} catch ( e ) {                                                                                                     // 8137
				// Propagate exception as error if not done                                                                        // 8138
				if ( state < 2 ) {                                                                                                 // 8139
					done( -1, e );                                                                                                    // 8140
				// Simply rethrow otherwise                                                                                        // 8141
				} else {                                                                                                           // 8142
					throw e;                                                                                                          // 8143
				}                                                                                                                  // 8144
			}                                                                                                                   // 8145
		}                                                                                                                    // 8146
                                                                                                                       // 8147
		// Callback for when everything is done                                                                              // 8148
		function done( status, nativeStatusText, responses, headers ) {                                                      // 8149
			var isSuccess, success, error, response, modified,                                                                  // 8150
				statusText = nativeStatusText;                                                                                     // 8151
                                                                                                                       // 8152
			// Called once                                                                                                      // 8153
			if ( state === 2 ) {                                                                                                // 8154
				return;                                                                                                            // 8155
			}                                                                                                                   // 8156
                                                                                                                       // 8157
			// State is "done" now                                                                                              // 8158
			state = 2;                                                                                                          // 8159
                                                                                                                       // 8160
			// Clear timeout if it exists                                                                                       // 8161
			if ( timeoutTimer ) {                                                                                               // 8162
				clearTimeout( timeoutTimer );                                                                                      // 8163
			}                                                                                                                   // 8164
                                                                                                                       // 8165
			// Dereference transport for early garbage collection                                                               // 8166
			// (no matter how long the jqXHR object will be used)                                                               // 8167
			transport = undefined;                                                                                              // 8168
                                                                                                                       // 8169
			// Cache response headers                                                                                           // 8170
			responseHeadersString = headers || "";                                                                              // 8171
                                                                                                                       // 8172
			// Set readyState                                                                                                   // 8173
			jqXHR.readyState = status > 0 ? 4 : 0;                                                                              // 8174
                                                                                                                       // 8175
			// Determine if successful                                                                                          // 8176
			isSuccess = status >= 200 && status < 300 || status === 304;                                                        // 8177
                                                                                                                       // 8178
			// Get response data                                                                                                // 8179
			if ( responses ) {                                                                                                  // 8180
				response = ajaxHandleResponses( s, jqXHR, responses );                                                             // 8181
			}                                                                                                                   // 8182
                                                                                                                       // 8183
			// Convert no matter what (that way responseXXX fields are always set)                                              // 8184
			response = ajaxConvert( s, response, jqXHR, isSuccess );                                                            // 8185
                                                                                                                       // 8186
			// If successful, handle type chaining                                                                              // 8187
			if ( isSuccess ) {                                                                                                  // 8188
                                                                                                                       // 8189
				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.                                   // 8190
				if ( s.ifModified ) {                                                                                              // 8191
					modified = jqXHR.getResponseHeader("Last-Modified");                                                              // 8192
					if ( modified ) {                                                                                                 // 8193
						jQuery.lastModified[ cacheURL ] = modified;                                                                      // 8194
					}                                                                                                                 // 8195
					modified = jqXHR.getResponseHeader("etag");                                                                       // 8196
					if ( modified ) {                                                                                                 // 8197
						jQuery.etag[ cacheURL ] = modified;                                                                              // 8198
					}                                                                                                                 // 8199
				}                                                                                                                  // 8200
                                                                                                                       // 8201
				// if no content                                                                                                   // 8202
				if ( status === 204 || s.type === "HEAD" ) {                                                                       // 8203
					statusText = "nocontent";                                                                                         // 8204
                                                                                                                       // 8205
				// if not modified                                                                                                 // 8206
				} else if ( status === 304 ) {                                                                                     // 8207
					statusText = "notmodified";                                                                                       // 8208
                                                                                                                       // 8209
				// If we have data, let's convert it                                                                               // 8210
				} else {                                                                                                           // 8211
					statusText = response.state;                                                                                      // 8212
					success = response.data;                                                                                          // 8213
					error = response.error;                                                                                           // 8214
					isSuccess = !error;                                                                                               // 8215
				}                                                                                                                  // 8216
			} else {                                                                                                            // 8217
				// We extract error from statusText                                                                                // 8218
				// then normalize statusText and status for non-aborts                                                             // 8219
				error = statusText;                                                                                                // 8220
				if ( status || !statusText ) {                                                                                     // 8221
					statusText = "error";                                                                                             // 8222
					if ( status < 0 ) {                                                                                               // 8223
						status = 0;                                                                                                      // 8224
					}                                                                                                                 // 8225
				}                                                                                                                  // 8226
			}                                                                                                                   // 8227
                                                                                                                       // 8228
			// Set data for the fake xhr object                                                                                 // 8229
			jqXHR.status = status;                                                                                              // 8230
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";                                                         // 8231
                                                                                                                       // 8232
			// Success/Error                                                                                                    // 8233
			if ( isSuccess ) {                                                                                                  // 8234
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );                                           // 8235
			} else {                                                                                                            // 8236
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );                                              // 8237
			}                                                                                                                   // 8238
                                                                                                                       // 8239
			// Status-dependent callbacks                                                                                       // 8240
			jqXHR.statusCode( statusCode );                                                                                     // 8241
			statusCode = undefined;                                                                                             // 8242
                                                                                                                       // 8243
			if ( fireGlobals ) {                                                                                                // 8244
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",                                               // 8245
					[ jqXHR, s, isSuccess ? success : error ] );                                                                      // 8246
			}                                                                                                                   // 8247
                                                                                                                       // 8248
			// Complete                                                                                                         // 8249
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );                                                // 8250
                                                                                                                       // 8251
			if ( fireGlobals ) {                                                                                                // 8252
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );                                                        // 8253
				// Handle the global AJAX counter                                                                                  // 8254
				if ( !( --jQuery.active ) ) {                                                                                      // 8255
					jQuery.event.trigger("ajaxStop");                                                                                 // 8256
				}                                                                                                                  // 8257
			}                                                                                                                   // 8258
		}                                                                                                                    // 8259
                                                                                                                       // 8260
		return jqXHR;                                                                                                        // 8261
	},                                                                                                                    // 8262
                                                                                                                       // 8263
	getJSON: function( url, data, callback ) {                                                                            // 8264
		return jQuery.get( url, data, callback, "json" );                                                                    // 8265
	},                                                                                                                    // 8266
                                                                                                                       // 8267
	getScript: function( url, callback ) {                                                                                // 8268
		return jQuery.get( url, undefined, callback, "script" );                                                             // 8269
	}                                                                                                                     // 8270
});                                                                                                                    // 8271
                                                                                                                       // 8272
jQuery.each( [ "get", "post" ], function( i, method ) {                                                                // 8273
	jQuery[ method ] = function( url, data, callback, type ) {                                                            // 8274
		// shift arguments if data argument was omitted                                                                      // 8275
		if ( jQuery.isFunction( data ) ) {                                                                                   // 8276
			type = type || callback;                                                                                            // 8277
			callback = data;                                                                                                    // 8278
			data = undefined;                                                                                                   // 8279
		}                                                                                                                    // 8280
                                                                                                                       // 8281
		return jQuery.ajax({                                                                                                 // 8282
			url: url,                                                                                                           // 8283
			type: method,                                                                                                       // 8284
			dataType: type,                                                                                                     // 8285
			data: data,                                                                                                         // 8286
			success: callback                                                                                                   // 8287
		});                                                                                                                  // 8288
	};                                                                                                                    // 8289
});                                                                                                                    // 8290
                                                                                                                       // 8291
/* Handles responses to an ajax request:                                                                               // 8292
 * - finds the right dataType (mediates between content-type and expected dataType)                                    // 8293
 * - returns the corresponding response                                                                                // 8294
 */                                                                                                                    // 8295
function ajaxHandleResponses( s, jqXHR, responses ) {                                                                  // 8296
	var firstDataType, ct, finalDataType, type,                                                                           // 8297
		contents = s.contents,                                                                                               // 8298
		dataTypes = s.dataTypes;                                                                                             // 8299
                                                                                                                       // 8300
	// Remove auto dataType and get content-type in the process                                                           // 8301
	while( dataTypes[ 0 ] === "*" ) {                                                                                     // 8302
		dataTypes.shift();                                                                                                   // 8303
		if ( ct === undefined ) {                                                                                            // 8304
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");                                                         // 8305
		}                                                                                                                    // 8306
	}                                                                                                                     // 8307
                                                                                                                       // 8308
	// Check if we're dealing with a known content-type                                                                   // 8309
	if ( ct ) {                                                                                                           // 8310
		for ( type in contents ) {                                                                                           // 8311
			if ( contents[ type ] && contents[ type ].test( ct ) ) {                                                            // 8312
				dataTypes.unshift( type );                                                                                         // 8313
				break;                                                                                                             // 8314
			}                                                                                                                   // 8315
		}                                                                                                                    // 8316
	}                                                                                                                     // 8317
                                                                                                                       // 8318
	// Check to see if we have a response for the expected dataType                                                       // 8319
	if ( dataTypes[ 0 ] in responses ) {                                                                                  // 8320
		finalDataType = dataTypes[ 0 ];                                                                                      // 8321
	} else {                                                                                                              // 8322
		// Try convertible dataTypes                                                                                         // 8323
		for ( type in responses ) {                                                                                          // 8324
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {                                               // 8325
				finalDataType = type;                                                                                              // 8326
				break;                                                                                                             // 8327
			}                                                                                                                   // 8328
			if ( !firstDataType ) {                                                                                             // 8329
				firstDataType = type;                                                                                              // 8330
			}                                                                                                                   // 8331
		}                                                                                                                    // 8332
		// Or just use first one                                                                                             // 8333
		finalDataType = finalDataType || firstDataType;                                                                      // 8334
	}                                                                                                                     // 8335
                                                                                                                       // 8336
	// If we found a dataType                                                                                             // 8337
	// We add the dataType to the list if needed                                                                          // 8338
	// and return the corresponding response                                                                              // 8339
	if ( finalDataType ) {                                                                                                // 8340
		if ( finalDataType !== dataTypes[ 0 ] ) {                                                                            // 8341
			dataTypes.unshift( finalDataType );                                                                                 // 8342
		}                                                                                                                    // 8343
		return responses[ finalDataType ];                                                                                   // 8344
	}                                                                                                                     // 8345
}                                                                                                                      // 8346
                                                                                                                       // 8347
/* Chain conversions given the request and the original response                                                       // 8348
 * Also sets the responseXXX fields on the jqXHR instance                                                              // 8349
 */                                                                                                                    // 8350
function ajaxConvert( s, response, jqXHR, isSuccess ) {                                                                // 8351
	var conv2, current, conv, tmp, prev,                                                                                  // 8352
		converters = {},                                                                                                     // 8353
		// Work with a copy of dataTypes in case we need to modify it for conversion                                         // 8354
		dataTypes = s.dataTypes.slice();                                                                                     // 8355
                                                                                                                       // 8356
	// Create converters map with lowercased keys                                                                         // 8357
	if ( dataTypes[ 1 ] ) {                                                                                               // 8358
		for ( conv in s.converters ) {                                                                                       // 8359
			converters[ conv.toLowerCase() ] = s.converters[ conv ];                                                            // 8360
		}                                                                                                                    // 8361
	}                                                                                                                     // 8362
                                                                                                                       // 8363
	current = dataTypes.shift();                                                                                          // 8364
                                                                                                                       // 8365
	// Convert to each sequential dataType                                                                                // 8366
	while ( current ) {                                                                                                   // 8367
                                                                                                                       // 8368
		if ( s.responseFields[ current ] ) {                                                                                 // 8369
			jqXHR[ s.responseFields[ current ] ] = response;                                                                    // 8370
		}                                                                                                                    // 8371
                                                                                                                       // 8372
		// Apply the dataFilter if provided                                                                                  // 8373
		if ( !prev && isSuccess && s.dataFilter ) {                                                                          // 8374
			response = s.dataFilter( response, s.dataType );                                                                    // 8375
		}                                                                                                                    // 8376
                                                                                                                       // 8377
		prev = current;                                                                                                      // 8378
		current = dataTypes.shift();                                                                                         // 8379
                                                                                                                       // 8380
		if ( current ) {                                                                                                     // 8381
                                                                                                                       // 8382
			// There's only work to do if current dataType is non-auto                                                          // 8383
			if ( current === "*" ) {                                                                                            // 8384
                                                                                                                       // 8385
				current = prev;                                                                                                    // 8386
                                                                                                                       // 8387
			// Convert response if prev dataType is non-auto and differs from current                                           // 8388
			} else if ( prev !== "*" && prev !== current ) {                                                                    // 8389
                                                                                                                       // 8390
				// Seek a direct converter                                                                                         // 8391
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];                                         // 8392
                                                                                                                       // 8393
				// If none found, seek a pair                                                                                      // 8394
				if ( !conv ) {                                                                                                     // 8395
					for ( conv2 in converters ) {                                                                                     // 8396
                                                                                                                       // 8397
						// If conv2 outputs current                                                                                      // 8398
						tmp = conv2.split( " " );                                                                                        // 8399
						if ( tmp[ 1 ] === current ) {                                                                                    // 8400
                                                                                                                       // 8401
							// If prev can be converted to accepted input                                                                   // 8402
							conv = converters[ prev + " " + tmp[ 0 ] ] ||                                                                   // 8403
								converters[ "* " + tmp[ 0 ] ];                                                                                 // 8404
							if ( conv ) {                                                                                                   // 8405
								// Condense equivalence converters                                                                             // 8406
								if ( conv === true ) {                                                                                         // 8407
									conv = converters[ conv2 ];                                                                                   // 8408
                                                                                                                       // 8409
								// Otherwise, insert the intermediate dataType                                                                 // 8410
								} else if ( converters[ conv2 ] !== true ) {                                                                   // 8411
									current = tmp[ 0 ];                                                                                           // 8412
									dataTypes.unshift( tmp[ 1 ] );                                                                                // 8413
								}                                                                                                              // 8414
								break;                                                                                                         // 8415
							}                                                                                                               // 8416
						}                                                                                                                // 8417
					}                                                                                                                 // 8418
				}                                                                                                                  // 8419
                                                                                                                       // 8420
				// Apply converter (if not an equivalence)                                                                         // 8421
				if ( conv !== true ) {                                                                                             // 8422
                                                                                                                       // 8423
					// Unless errors are allowed to bubble, catch and return them                                                     // 8424
					if ( conv && s[ "throws" ] ) {                                                                                    // 8425
						response = conv( response );                                                                                     // 8426
					} else {                                                                                                          // 8427
						try {                                                                                                            // 8428
							response = conv( response );                                                                                    // 8429
						} catch ( e ) {                                                                                                  // 8430
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };             // 8431
						}                                                                                                                // 8432
					}                                                                                                                 // 8433
				}                                                                                                                  // 8434
			}                                                                                                                   // 8435
		}                                                                                                                    // 8436
	}                                                                                                                     // 8437
                                                                                                                       // 8438
	return { state: "success", data: response };                                                                          // 8439
}                                                                                                                      // 8440
// Install script dataType                                                                                             // 8441
jQuery.ajaxSetup({                                                                                                     // 8442
	accepts: {                                                                                                            // 8443
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"                  // 8444
	},                                                                                                                    // 8445
	contents: {                                                                                                           // 8446
		script: /(?:java|ecma)script/                                                                                        // 8447
	},                                                                                                                    // 8448
	converters: {                                                                                                         // 8449
		"text script": function( text ) {                                                                                    // 8450
			jQuery.globalEval( text );                                                                                          // 8451
			return text;                                                                                                        // 8452
		}                                                                                                                    // 8453
	}                                                                                                                     // 8454
});                                                                                                                    // 8455
                                                                                                                       // 8456
// Handle cache's special case and global                                                                              // 8457
jQuery.ajaxPrefilter( "script", function( s ) {                                                                        // 8458
	if ( s.cache === undefined ) {                                                                                        // 8459
		s.cache = false;                                                                                                     // 8460
	}                                                                                                                     // 8461
	if ( s.crossDomain ) {                                                                                                // 8462
		s.type = "GET";                                                                                                      // 8463
		s.global = false;                                                                                                    // 8464
	}                                                                                                                     // 8465
});                                                                                                                    // 8466
                                                                                                                       // 8467
// Bind script tag hack transport                                                                                      // 8468
jQuery.ajaxTransport( "script", function(s) {                                                                          // 8469
                                                                                                                       // 8470
	// This transport only deals with cross domain requests                                                               // 8471
	if ( s.crossDomain ) {                                                                                                // 8472
                                                                                                                       // 8473
		var script,                                                                                                          // 8474
			head = document.head || jQuery("head")[0] || document.documentElement;                                              // 8475
                                                                                                                       // 8476
		return {                                                                                                             // 8477
                                                                                                                       // 8478
			send: function( _, callback ) {                                                                                     // 8479
                                                                                                                       // 8480
				script = document.createElement("script");                                                                         // 8481
                                                                                                                       // 8482
				script.async = true;                                                                                               // 8483
                                                                                                                       // 8484
				if ( s.scriptCharset ) {                                                                                           // 8485
					script.charset = s.scriptCharset;                                                                                 // 8486
				}                                                                                                                  // 8487
                                                                                                                       // 8488
				script.src = s.url;                                                                                                // 8489
                                                                                                                       // 8490
				// Attach handlers for all browsers                                                                                // 8491
				script.onload = script.onreadystatechange = function( _, isAbort ) {                                               // 8492
                                                                                                                       // 8493
					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {                             // 8494
                                                                                                                       // 8495
						// Handle memory leak in IE                                                                                      // 8496
						script.onload = script.onreadystatechange = null;                                                                // 8497
                                                                                                                       // 8498
						// Remove the script                                                                                             // 8499
						if ( script.parentNode ) {                                                                                       // 8500
							script.parentNode.removeChild( script );                                                                        // 8501
						}                                                                                                                // 8502
                                                                                                                       // 8503
						// Dereference the script                                                                                        // 8504
						script = null;                                                                                                   // 8505
                                                                                                                       // 8506
						// Callback if not abort                                                                                         // 8507
						if ( !isAbort ) {                                                                                                // 8508
							callback( 200, "success" );                                                                                     // 8509
						}                                                                                                                // 8510
					}                                                                                                                 // 8511
				};                                                                                                                 // 8512
                                                                                                                       // 8513
				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending                                          // 8514
				// Use native DOM manipulation to avoid our domManip AJAX trickery                                                 // 8515
				head.insertBefore( script, head.firstChild );                                                                      // 8516
			},                                                                                                                  // 8517
                                                                                                                       // 8518
			abort: function() {                                                                                                 // 8519
				if ( script ) {                                                                                                    // 8520
					script.onload( undefined, true );                                                                                 // 8521
				}                                                                                                                  // 8522
			}                                                                                                                   // 8523
		};                                                                                                                   // 8524
	}                                                                                                                     // 8525
});                                                                                                                    // 8526
var oldCallbacks = [],                                                                                                 // 8527
	rjsonp = /(=)\?(?=&|$)|\?\?/;                                                                                         // 8528
                                                                                                                       // 8529
// Default jsonp settings                                                                                              // 8530
jQuery.ajaxSetup({                                                                                                     // 8531
	jsonp: "callback",                                                                                                    // 8532
	jsonpCallback: function() {                                                                                           // 8533
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( ajax_nonce++ ) );                                    // 8534
		this[ callback ] = true;                                                                                             // 8535
		return callback;                                                                                                     // 8536
	}                                                                                                                     // 8537
});                                                                                                                    // 8538
                                                                                                                       // 8539
// Detect, normalize options and install callbacks for jsonp requests                                                  // 8540
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {                                           // 8541
                                                                                                                       // 8542
	var callbackName, overwritten, responseContainer,                                                                     // 8543
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?                                                             // 8544
			"url" :                                                                                                             // 8545
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);                                                                                                                   // 8547
                                                                                                                       // 8548
	// Handle iff the expected data type is "jsonp" or we have a parameter to set                                         // 8549
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {                                                                     // 8550
                                                                                                                       // 8551
		// Get callback name, remembering preexisting value associated with it                                               // 8552
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?                                              // 8553
			s.jsonpCallback() :                                                                                                 // 8554
			s.jsonpCallback;                                                                                                    // 8555
                                                                                                                       // 8556
		// Insert callback into url or form data                                                                             // 8557
		if ( jsonProp ) {                                                                                                    // 8558
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );                                               // 8559
		} else if ( s.jsonp !== false ) {                                                                                    // 8560
			s.url += ( ajax_rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;                                  // 8561
		}                                                                                                                    // 8562
                                                                                                                       // 8563
		// Use data converter to retrieve json after script execution                                                        // 8564
		s.converters["script json"] = function() {                                                                           // 8565
			if ( !responseContainer ) {                                                                                         // 8566
				jQuery.error( callbackName + " was not called" );                                                                  // 8567
			}                                                                                                                   // 8568
			return responseContainer[ 0 ];                                                                                      // 8569
		};                                                                                                                   // 8570
                                                                                                                       // 8571
		// force json dataType                                                                                               // 8572
		s.dataTypes[ 0 ] = "json";                                                                                           // 8573
                                                                                                                       // 8574
		// Install callback                                                                                                  // 8575
		overwritten = window[ callbackName ];                                                                                // 8576
		window[ callbackName ] = function() {                                                                                // 8577
			responseContainer = arguments;                                                                                      // 8578
		};                                                                                                                   // 8579
                                                                                                                       // 8580
		// Clean-up function (fires after converters)                                                                        // 8581
		jqXHR.always(function() {                                                                                            // 8582
			// Restore preexisting value                                                                                        // 8583
			window[ callbackName ] = overwritten;                                                                               // 8584
                                                                                                                       // 8585
			// Save back as free                                                                                                // 8586
			if ( s[ callbackName ] ) {                                                                                          // 8587
				// make sure that re-using the options doesn't screw things around                                                 // 8588
				s.jsonpCallback = originalSettings.jsonpCallback;                                                                  // 8589
                                                                                                                       // 8590
				// save the callback name for future use                                                                           // 8591
				oldCallbacks.push( callbackName );                                                                                 // 8592
			}                                                                                                                   // 8593
                                                                                                                       // 8594
			// Call if it was a function and we have a response                                                                 // 8595
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {                                                      // 8596
				overwritten( responseContainer[ 0 ] );                                                                             // 8597
			}                                                                                                                   // 8598
                                                                                                                       // 8599
			responseContainer = overwritten = undefined;                                                                        // 8600
		});                                                                                                                  // 8601
                                                                                                                       // 8602
		// Delegate to script                                                                                                // 8603
		return "script";                                                                                                     // 8604
	}                                                                                                                     // 8605
});                                                                                                                    // 8606
var xhrCallbacks, xhrSupported,                                                                                        // 8607
	xhrId = 0,                                                                                                            // 8608
	// #5280: Internet Explorer will keep connections alive if we don't abort on unload                                   // 8609
	xhrOnUnloadAbort = window.ActiveXObject && function() {                                                               // 8610
		// Abort all pending requests                                                                                        // 8611
		var key;                                                                                                             // 8612
		for ( key in xhrCallbacks ) {                                                                                        // 8613
			xhrCallbacks[ key ]( undefined, true );                                                                             // 8614
		}                                                                                                                    // 8615
	};                                                                                                                    // 8616
                                                                                                                       // 8617
// Functions to create xhrs                                                                                            // 8618
function createStandardXHR() {                                                                                         // 8619
	try {                                                                                                                 // 8620
		return new window.XMLHttpRequest();                                                                                  // 8621
	} catch( e ) {}                                                                                                       // 8622
}                                                                                                                      // 8623
                                                                                                                       // 8624
function createActiveXHR() {                                                                                           // 8625
	try {                                                                                                                 // 8626
		return new window.ActiveXObject("Microsoft.XMLHTTP");                                                                // 8627
	} catch( e ) {}                                                                                                       // 8628
}                                                                                                                      // 8629
                                                                                                                       // 8630
// Create the request object                                                                                           // 8631
// (This is still attached to ajaxSettings for backward compatibility)                                                 // 8632
jQuery.ajaxSettings.xhr = window.ActiveXObject ?                                                                       // 8633
	/* Microsoft failed to properly                                                                                       // 8634
	 * implement the XMLHttpRequest in IE7 (can't request local files),                                                   // 8635
	 * so we use the ActiveXObject when it is available                                                                   // 8636
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so                                                          // 8637
	 * we need a fallback.                                                                                                // 8638
	 */                                                                                                                   // 8639
	function() {                                                                                                          // 8640
		return !this.isLocal && createStandardXHR() || createActiveXHR();                                                    // 8641
	} :                                                                                                                   // 8642
	// For all other browsers, use the standard XMLHttpRequest object                                                     // 8643
	createStandardXHR;                                                                                                    // 8644
                                                                                                                       // 8645
// Determine support properties                                                                                        // 8646
xhrSupported = jQuery.ajaxSettings.xhr();                                                                              // 8647
jQuery.support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );                                         // 8648
xhrSupported = jQuery.support.ajax = !!xhrSupported;                                                                   // 8649
                                                                                                                       // 8650
// Create transport if the browser can provide an xhr                                                                  // 8651
if ( xhrSupported ) {                                                                                                  // 8652
                                                                                                                       // 8653
	jQuery.ajaxTransport(function( s ) {                                                                                  // 8654
		// Cross domain only allowed if supported through XMLHttpRequest                                                     // 8655
		if ( !s.crossDomain || jQuery.support.cors ) {                                                                       // 8656
                                                                                                                       // 8657
			var callback;                                                                                                       // 8658
                                                                                                                       // 8659
			return {                                                                                                            // 8660
				send: function( headers, complete ) {                                                                              // 8661
                                                                                                                       // 8662
					// Get a new xhr                                                                                                  // 8663
					var handle, i,                                                                                                    // 8664
						xhr = s.xhr();                                                                                                   // 8665
                                                                                                                       // 8666
					// Open the socket                                                                                                // 8667
					// Passing null username, generates a login popup on Opera (#2865)                                                // 8668
					if ( s.username ) {                                                                                               // 8669
						xhr.open( s.type, s.url, s.async, s.username, s.password );                                                      // 8670
					} else {                                                                                                          // 8671
						xhr.open( s.type, s.url, s.async );                                                                              // 8672
					}                                                                                                                 // 8673
                                                                                                                       // 8674
					// Apply custom fields if provided                                                                                // 8675
					if ( s.xhrFields ) {                                                                                              // 8676
						for ( i in s.xhrFields ) {                                                                                       // 8677
							xhr[ i ] = s.xhrFields[ i ];                                                                                    // 8678
						}                                                                                                                // 8679
					}                                                                                                                 // 8680
                                                                                                                       // 8681
					// Override mime type if needed                                                                                   // 8682
					if ( s.mimeType && xhr.overrideMimeType ) {                                                                       // 8683
						xhr.overrideMimeType( s.mimeType );                                                                              // 8684
					}                                                                                                                 // 8685
                                                                                                                       // 8686
					// X-Requested-With header                                                                                        // 8687
					// For cross-domain requests, seeing as conditions for a preflight are                                            // 8688
					// akin to a jigsaw puzzle, we simply never set it to be sure.                                                    // 8689
					// (it can always be set on a per-request basis or even using ajaxSetup)                                          // 8690
					// For same-domain requests, won't change header if already provided.                                             // 8691
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {                                                           // 8692
						headers["X-Requested-With"] = "XMLHttpRequest";                                                                  // 8693
					}                                                                                                                 // 8694
                                                                                                                       // 8695
					// Need an extra try/catch for cross domain requests in Firefox 3                                                 // 8696
					try {                                                                                                             // 8697
						for ( i in headers ) {                                                                                           // 8698
							xhr.setRequestHeader( i, headers[ i ] );                                                                        // 8699
						}                                                                                                                // 8700
					} catch( err ) {}                                                                                                 // 8701
                                                                                                                       // 8702
					// Do send the request                                                                                            // 8703
					// This may raise an exception which is actually                                                                  // 8704
					// handled in jQuery.ajax (so no try/catch here)                                                                  // 8705
					xhr.send( ( s.hasContent && s.data ) || null );                                                                   // 8706
                                                                                                                       // 8707
					// Listener                                                                                                       // 8708
					callback = function( _, isAbort ) {                                                                               // 8709
						var status, responseHeaders, statusText, responses;                                                              // 8710
                                                                                                                       // 8711
						// Firefox throws exceptions when accessing properties                                                           // 8712
						// of an xhr when a network error occurred                                                                       // 8713
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE) // 8714
						try {                                                                                                            // 8715
                                                                                                                       // 8716
							// Was never called and is aborted or complete                                                                  // 8717
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {                                                        // 8718
                                                                                                                       // 8719
								// Only called once                                                                                            // 8720
								callback = undefined;                                                                                          // 8721
                                                                                                                       // 8722
								// Do not keep as active anymore                                                                               // 8723
								if ( handle ) {                                                                                                // 8724
									xhr.onreadystatechange = jQuery.noop;                                                                         // 8725
									if ( xhrOnUnloadAbort ) {                                                                                     // 8726
										delete xhrCallbacks[ handle ];                                                                               // 8727
									}                                                                                                             // 8728
								}                                                                                                              // 8729
                                                                                                                       // 8730
								// If it's an abort                                                                                            // 8731
								if ( isAbort ) {                                                                                               // 8732
									// Abort it manually if needed                                                                                // 8733
									if ( xhr.readyState !== 4 ) {                                                                                 // 8734
										xhr.abort();                                                                                                 // 8735
									}                                                                                                             // 8736
								} else {                                                                                                       // 8737
									responses = {};                                                                                               // 8738
									status = xhr.status;                                                                                          // 8739
									responseHeaders = xhr.getAllResponseHeaders();                                                                // 8740
                                                                                                                       // 8741
									// When requesting binary data, IE6-9 will throw an exception                                                 // 8742
									// on any attempt to access responseText (#11426)                                                             // 8743
									if ( typeof xhr.responseText === "string" ) {                                                                 // 8744
										responses.text = xhr.responseText;                                                                           // 8745
									}                                                                                                             // 8746
                                                                                                                       // 8747
									// Firefox throws an exception when accessing                                                                 // 8748
									// statusText for faulty cross-domain requests                                                                // 8749
									try {                                                                                                         // 8750
										statusText = xhr.statusText;                                                                                 // 8751
									} catch( e ) {                                                                                                // 8752
										// We normalize with Webkit giving an empty statusText                                                       // 8753
										statusText = "";                                                                                             // 8754
									}                                                                                                             // 8755
                                                                                                                       // 8756
									// Filter status for non standard behaviors                                                                   // 8757
                                                                                                                       // 8758
									// If the request is local and we have data: assume a success                                                 // 8759
									// (success with no data won't get notified, that's the best we                                               // 8760
									// can do given current implementations)                                                                      // 8761
									if ( !status && s.isLocal && !s.crossDomain ) {                                                               // 8762
										status = responses.text ? 200 : 404;                                                                         // 8763
									// IE - #1450: sometimes returns 1223 when it should be 204                                                   // 8764
									} else if ( status === 1223 ) {                                                                               // 8765
										status = 204;                                                                                                // 8766
									}                                                                                                             // 8767
								}                                                                                                              // 8768
							}                                                                                                               // 8769
						} catch( firefoxAccessException ) {                                                                              // 8770
							if ( !isAbort ) {                                                                                               // 8771
								complete( -1, firefoxAccessException );                                                                        // 8772
							}                                                                                                               // 8773
						}                                                                                                                // 8774
                                                                                                                       // 8775
						// Call complete if needed                                                                                       // 8776
						if ( responses ) {                                                                                               // 8777
							complete( status, statusText, responses, responseHeaders );                                                     // 8778
						}                                                                                                                // 8779
					};                                                                                                                // 8780
                                                                                                                       // 8781
					if ( !s.async ) {                                                                                                 // 8782
						// if we're in sync mode we fire the callback                                                                    // 8783
						callback();                                                                                                      // 8784
					} else if ( xhr.readyState === 4 ) {                                                                              // 8785
						// (IE6 & IE7) if it's in cache and has been                                                                     // 8786
						// retrieved directly we need to fire the callback                                                               // 8787
						setTimeout( callback );                                                                                          // 8788
					} else {                                                                                                          // 8789
						handle = ++xhrId;                                                                                                // 8790
						if ( xhrOnUnloadAbort ) {                                                                                        // 8791
							// Create the active xhrs callbacks list if needed                                                              // 8792
							// and attach the unload handler                                                                                // 8793
							if ( !xhrCallbacks ) {                                                                                          // 8794
								xhrCallbacks = {};                                                                                             // 8795
								jQuery( window ).unload( xhrOnUnloadAbort );                                                                   // 8796
							}                                                                                                               // 8797
							// Add to list of active xhrs callbacks                                                                         // 8798
							xhrCallbacks[ handle ] = callback;                                                                              // 8799
						}                                                                                                                // 8800
						xhr.onreadystatechange = callback;                                                                               // 8801
					}                                                                                                                 // 8802
				},                                                                                                                 // 8803
                                                                                                                       // 8804
				abort: function() {                                                                                                // 8805
					if ( callback ) {                                                                                                 // 8806
						callback( undefined, true );                                                                                     // 8807
					}                                                                                                                 // 8808
				}                                                                                                                  // 8809
			};                                                                                                                  // 8810
		}                                                                                                                    // 8811
	});                                                                                                                   // 8812
}                                                                                                                      // 8813
var fxNow, timerId,                                                                                                    // 8814
	rfxtypes = /^(?:toggle|show|hide)$/,                                                                                  // 8815
	rfxnum = new RegExp( "^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),                                             // 8816
	rrun = /queueHooks$/,                                                                                                 // 8817
	animationPrefilters = [ defaultPrefilter ],                                                                           // 8818
	tweeners = {                                                                                                          // 8819
		"*": [function( prop, value ) {                                                                                      // 8820
			var tween = this.createTween( prop, value ),                                                                        // 8821
				target = tween.cur(),                                                                                              // 8822
				parts = rfxnum.exec( value ),                                                                                      // 8823
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),                                            // 8824
                                                                                                                       // 8825
				// Starting value computation is required for potential unit mismatches                                            // 8826
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&                                                // 8827
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),                                                                    // 8828
				scale = 1,                                                                                                         // 8829
				maxIterations = 20;                                                                                                // 8830
                                                                                                                       // 8831
			if ( start && start[ 3 ] !== unit ) {                                                                               // 8832
				// Trust units reported by jQuery.css                                                                              // 8833
				unit = unit || start[ 3 ];                                                                                         // 8834
                                                                                                                       // 8835
				// Make sure we update the tween properties later on                                                               // 8836
				parts = parts || [];                                                                                               // 8837
                                                                                                                       // 8838
				// Iteratively approximate from a nonzero starting point                                                           // 8839
				start = +target || 1;                                                                                              // 8840
                                                                                                                       // 8841
				do {                                                                                                               // 8842
					// If previous iteration zeroed out, double until we get *something*                                              // 8843
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below                         // 8844
					scale = scale || ".5";                                                                                            // 8845
                                                                                                                       // 8846
					// Adjust and apply                                                                                               // 8847
					start = start / scale;                                                                                            // 8848
					jQuery.style( tween.elem, prop, start + unit );                                                                   // 8849
                                                                                                                       // 8850
				// Update scale, tolerating zero or NaN from tween.cur()                                                           // 8851
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough                             // 8852
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );                            // 8853
			}                                                                                                                   // 8854
                                                                                                                       // 8855
			// Update tween properties                                                                                          // 8856
			if ( parts ) {                                                                                                      // 8857
				start = tween.start = +start || +target || 0;                                                                      // 8858
				tween.unit = unit;                                                                                                 // 8859
				// If a +=/-= token was provided, we're doing a relative animation                                                 // 8860
				tween.end = parts[ 1 ] ?                                                                                           // 8861
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :                                                                         // 8862
					+parts[ 2 ];                                                                                                      // 8863
			}                                                                                                                   // 8864
                                                                                                                       // 8865
			return tween;                                                                                                       // 8866
		}]                                                                                                                   // 8867
	};                                                                                                                    // 8868
                                                                                                                       // 8869
// Animations created synchronously will run synchronously                                                             // 8870
function createFxNow() {                                                                                               // 8871
	setTimeout(function() {                                                                                               // 8872
		fxNow = undefined;                                                                                                   // 8873
	});                                                                                                                   // 8874
	return ( fxNow = jQuery.now() );                                                                                      // 8875
}                                                                                                                      // 8876
                                                                                                                       // 8877
function createTween( value, prop, animation ) {                                                                       // 8878
	var tween,                                                                                                            // 8879
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),                                                   // 8880
		index = 0,                                                                                                           // 8881
		length = collection.length;                                                                                          // 8882
	for ( ; index < length; index++ ) {                                                                                   // 8883
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {                                                // 8884
                                                                                                                       // 8885
			// we're done with this property                                                                                    // 8886
			return tween;                                                                                                       // 8887
		}                                                                                                                    // 8888
	}                                                                                                                     // 8889
}                                                                                                                      // 8890
                                                                                                                       // 8891
function Animation( elem, properties, options ) {                                                                      // 8892
	var result,                                                                                                           // 8893
		stopped,                                                                                                             // 8894
		index = 0,                                                                                                           // 8895
		length = animationPrefilters.length,                                                                                 // 8896
		deferred = jQuery.Deferred().always( function() {                                                                    // 8897
			// don't match elem in the :animated selector                                                                       // 8898
			delete tick.elem;                                                                                                   // 8899
		}),                                                                                                                  // 8900
		tick = function() {                                                                                                  // 8901
			if ( stopped ) {                                                                                                    // 8902
				return false;                                                                                                      // 8903
			}                                                                                                                   // 8904
			var currentTime = fxNow || createFxNow(),                                                                           // 8905
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),                                 // 8906
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)                                               // 8907
				temp = remaining / animation.duration || 0,                                                                        // 8908
				percent = 1 - temp,                                                                                                // 8909
				index = 0,                                                                                                         // 8910
				length = animation.tweens.length;                                                                                  // 8911
                                                                                                                       // 8912
			for ( ; index < length ; index++ ) {                                                                                // 8913
				animation.tweens[ index ].run( percent );                                                                          // 8914
			}                                                                                                                   // 8915
                                                                                                                       // 8916
			deferred.notifyWith( elem, [ animation, percent, remaining ]);                                                      // 8917
                                                                                                                       // 8918
			if ( percent < 1 && length ) {                                                                                      // 8919
				return remaining;                                                                                                  // 8920
			} else {                                                                                                            // 8921
				deferred.resolveWith( elem, [ animation ] );                                                                       // 8922
				return false;                                                                                                      // 8923
			}                                                                                                                   // 8924
		},                                                                                                                   // 8925
		animation = deferred.promise({                                                                                       // 8926
			elem: elem,                                                                                                         // 8927
			props: jQuery.extend( {}, properties ),                                                                             // 8928
			opts: jQuery.extend( true, { specialEasing: {} }, options ),                                                        // 8929
			originalProperties: properties,                                                                                     // 8930
			originalOptions: options,                                                                                           // 8931
			startTime: fxNow || createFxNow(),                                                                                  // 8932
			duration: options.duration,                                                                                         // 8933
			tweens: [],                                                                                                         // 8934
			createTween: function( prop, end ) {                                                                                // 8935
				var tween = jQuery.Tween( elem, animation.opts, prop, end,                                                         // 8936
						animation.opts.specialEasing[ prop ] || animation.opts.easing );                                                 // 8937
				animation.tweens.push( tween );                                                                                    // 8938
				return tween;                                                                                                      // 8939
			},                                                                                                                  // 8940
			stop: function( gotoEnd ) {                                                                                         // 8941
				var index = 0,                                                                                                     // 8942
					// if we are going to the end, we want to run all the tweens                                                      // 8943
					// otherwise we skip this part                                                                                    // 8944
					length = gotoEnd ? animation.tweens.length : 0;                                                                   // 8945
				if ( stopped ) {                                                                                                   // 8946
					return this;                                                                                                      // 8947
				}                                                                                                                  // 8948
				stopped = true;                                                                                                    // 8949
				for ( ; index < length ; index++ ) {                                                                               // 8950
					animation.tweens[ index ].run( 1 );                                                                               // 8951
				}                                                                                                                  // 8952
                                                                                                                       // 8953
				// resolve when we played the last frame                                                                           // 8954
				// otherwise, reject                                                                                               // 8955
				if ( gotoEnd ) {                                                                                                   // 8956
					deferred.resolveWith( elem, [ animation, gotoEnd ] );                                                             // 8957
				} else {                                                                                                           // 8958
					deferred.rejectWith( elem, [ animation, gotoEnd ] );                                                              // 8959
				}                                                                                                                  // 8960
				return this;                                                                                                       // 8961
			}                                                                                                                   // 8962
		}),                                                                                                                  // 8963
		props = animation.props;                                                                                             // 8964
                                                                                                                       // 8965
	propFilter( props, animation.opts.specialEasing );                                                                    // 8966
                                                                                                                       // 8967
	for ( ; index < length ; index++ ) {                                                                                  // 8968
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );                                // 8969
		if ( result ) {                                                                                                      // 8970
			return result;                                                                                                      // 8971
		}                                                                                                                    // 8972
	}                                                                                                                     // 8973
                                                                                                                       // 8974
	jQuery.map( props, createTween, animation );                                                                          // 8975
                                                                                                                       // 8976
	if ( jQuery.isFunction( animation.opts.start ) ) {                                                                    // 8977
		animation.opts.start.call( elem, animation );                                                                        // 8978
	}                                                                                                                     // 8979
                                                                                                                       // 8980
	jQuery.fx.timer(                                                                                                      // 8981
		jQuery.extend( tick, {                                                                                               // 8982
			elem: elem,                                                                                                         // 8983
			anim: animation,                                                                                                    // 8984
			queue: animation.opts.queue                                                                                         // 8985
		})                                                                                                                   // 8986
	);                                                                                                                    // 8987
                                                                                                                       // 8988
	// attach callbacks from options                                                                                      // 8989
	return animation.progress( animation.opts.progress )                                                                  // 8990
		.done( animation.opts.done, animation.opts.complete )                                                                // 8991
		.fail( animation.opts.fail )                                                                                         // 8992
		.always( animation.opts.always );                                                                                    // 8993
}                                                                                                                      // 8994
                                                                                                                       // 8995
function propFilter( props, specialEasing ) {                                                                          // 8996
	var index, name, easing, value, hooks;                                                                                // 8997
                                                                                                                       // 8998
	// camelCase, specialEasing and expand cssHook pass                                                                   // 8999
	for ( index in props ) {                                                                                              // 9000
		name = jQuery.camelCase( index );                                                                                    // 9001
		easing = specialEasing[ name ];                                                                                      // 9002
		value = props[ index ];                                                                                              // 9003
		if ( jQuery.isArray( value ) ) {                                                                                     // 9004
			easing = value[ 1 ];                                                                                                // 9005
			value = props[ index ] = value[ 0 ];                                                                                // 9006
		}                                                                                                                    // 9007
                                                                                                                       // 9008
		if ( index !== name ) {                                                                                              // 9009
			props[ name ] = value;                                                                                              // 9010
			delete props[ index ];                                                                                              // 9011
		}                                                                                                                    // 9012
                                                                                                                       // 9013
		hooks = jQuery.cssHooks[ name ];                                                                                     // 9014
		if ( hooks && "expand" in hooks ) {                                                                                  // 9015
			value = hooks.expand( value );                                                                                      // 9016
			delete props[ name ];                                                                                               // 9017
                                                                                                                       // 9018
			// not quite $.extend, this wont overwrite keys already present.                                                    // 9019
			// also - reusing 'index' from above because we have the correct "name"                                             // 9020
			for ( index in value ) {                                                                                            // 9021
				if ( !( index in props ) ) {                                                                                       // 9022
					props[ index ] = value[ index ];                                                                                  // 9023
					specialEasing[ index ] = easing;                                                                                  // 9024
				}                                                                                                                  // 9025
			}                                                                                                                   // 9026
		} else {                                                                                                             // 9027
			specialEasing[ name ] = easing;                                                                                     // 9028
		}                                                                                                                    // 9029
	}                                                                                                                     // 9030
}                                                                                                                      // 9031
                                                                                                                       // 9032
jQuery.Animation = jQuery.extend( Animation, {                                                                         // 9033
                                                                                                                       // 9034
	tweener: function( props, callback ) {                                                                                // 9035
		if ( jQuery.isFunction( props ) ) {                                                                                  // 9036
			callback = props;                                                                                                   // 9037
			props = [ "*" ];                                                                                                    // 9038
		} else {                                                                                                             // 9039
			props = props.split(" ");                                                                                           // 9040
		}                                                                                                                    // 9041
                                                                                                                       // 9042
		var prop,                                                                                                            // 9043
			index = 0,                                                                                                          // 9044
			length = props.length;                                                                                              // 9045
                                                                                                                       // 9046
		for ( ; index < length ; index++ ) {                                                                                 // 9047
			prop = props[ index ];                                                                                              // 9048
			tweeners[ prop ] = tweeners[ prop ] || [];                                                                          // 9049
			tweeners[ prop ].unshift( callback );                                                                               // 9050
		}                                                                                                                    // 9051
	},                                                                                                                    // 9052
                                                                                                                       // 9053
	prefilter: function( callback, prepend ) {                                                                            // 9054
		if ( prepend ) {                                                                                                     // 9055
			animationPrefilters.unshift( callback );                                                                            // 9056
		} else {                                                                                                             // 9057
			animationPrefilters.push( callback );                                                                               // 9058
		}                                                                                                                    // 9059
	}                                                                                                                     // 9060
});                                                                                                                    // 9061
                                                                                                                       // 9062
function defaultPrefilter( elem, props, opts ) {                                                                       // 9063
	/* jshint validthis: true */                                                                                          // 9064
	var prop, value, toggle, tween, hooks, oldfire,                                                                       // 9065
		anim = this,                                                                                                         // 9066
		orig = {},                                                                                                           // 9067
		style = elem.style,                                                                                                  // 9068
		hidden = elem.nodeType && isHidden( elem ),                                                                          // 9069
		dataShow = jQuery._data( elem, "fxshow" );                                                                           // 9070
                                                                                                                       // 9071
	// handle queue: false promises                                                                                       // 9072
	if ( !opts.queue ) {                                                                                                  // 9073
		hooks = jQuery._queueHooks( elem, "fx" );                                                                            // 9074
		if ( hooks.unqueued == null ) {                                                                                      // 9075
			hooks.unqueued = 0;                                                                                                 // 9076
			oldfire = hooks.empty.fire;                                                                                         // 9077
			hooks.empty.fire = function() {                                                                                     // 9078
				if ( !hooks.unqueued ) {                                                                                           // 9079
					oldfire();                                                                                                        // 9080
				}                                                                                                                  // 9081
			};                                                                                                                  // 9082
		}                                                                                                                    // 9083
		hooks.unqueued++;                                                                                                    // 9084
                                                                                                                       // 9085
		anim.always(function() {                                                                                             // 9086
			// doing this makes sure that the complete handler will be called                                                   // 9087
			// before this completes                                                                                            // 9088
			anim.always(function() {                                                                                            // 9089
				hooks.unqueued--;                                                                                                  // 9090
				if ( !jQuery.queue( elem, "fx" ).length ) {                                                                        // 9091
					hooks.empty.fire();                                                                                               // 9092
				}                                                                                                                  // 9093
			});                                                                                                                 // 9094
		});                                                                                                                  // 9095
	}                                                                                                                     // 9096
                                                                                                                       // 9097
	// height/width overflow pass                                                                                         // 9098
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {                                             // 9099
		// Make sure that nothing sneaks out                                                                                 // 9100
		// Record all 3 overflow attributes because IE does not                                                              // 9101
		// change the overflow attribute when overflowX and                                                                  // 9102
		// overflowY are set to the same value                                                                               // 9103
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];                                                // 9104
                                                                                                                       // 9105
		// Set display property to inline-block for height/width                                                             // 9106
		// animations on inline elements that are having width/height animated                                               // 9107
		if ( jQuery.css( elem, "display" ) === "inline" &&                                                                   // 9108
				jQuery.css( elem, "float" ) === "none" ) {                                                                         // 9109
                                                                                                                       // 9110
			// inline-level elements accept inline-block;                                                                       // 9111
			// block-level elements need to be inline with layout                                                               // 9112
			if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {                 // 9113
				style.display = "inline-block";                                                                                    // 9114
                                                                                                                       // 9115
			} else {                                                                                                            // 9116
				style.zoom = 1;                                                                                                    // 9117
			}                                                                                                                   // 9118
		}                                                                                                                    // 9119
	}                                                                                                                     // 9120
                                                                                                                       // 9121
	if ( opts.overflow ) {                                                                                                // 9122
		style.overflow = "hidden";                                                                                           // 9123
		if ( !jQuery.support.shrinkWrapBlocks ) {                                                                            // 9124
			anim.always(function() {                                                                                            // 9125
				style.overflow = opts.overflow[ 0 ];                                                                               // 9126
				style.overflowX = opts.overflow[ 1 ];                                                                              // 9127
				style.overflowY = opts.overflow[ 2 ];                                                                              // 9128
			});                                                                                                                 // 9129
		}                                                                                                                    // 9130
	}                                                                                                                     // 9131
                                                                                                                       // 9132
                                                                                                                       // 9133
	// show/hide pass                                                                                                     // 9134
	for ( prop in props ) {                                                                                               // 9135
		value = props[ prop ];                                                                                               // 9136
		if ( rfxtypes.exec( value ) ) {                                                                                      // 9137
			delete props[ prop ];                                                                                               // 9138
			toggle = toggle || value === "toggle";                                                                              // 9139
			if ( value === ( hidden ? "hide" : "show" ) ) {                                                                     // 9140
				continue;                                                                                                          // 9141
			}                                                                                                                   // 9142
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );                                          // 9143
		}                                                                                                                    // 9144
	}                                                                                                                     // 9145
                                                                                                                       // 9146
	if ( !jQuery.isEmptyObject( orig ) ) {                                                                                // 9147
		if ( dataShow ) {                                                                                                    // 9148
			if ( "hidden" in dataShow ) {                                                                                       // 9149
				hidden = dataShow.hidden;                                                                                          // 9150
			}                                                                                                                   // 9151
		} else {                                                                                                             // 9152
			dataShow = jQuery._data( elem, "fxshow", {} );                                                                      // 9153
		}                                                                                                                    // 9154
                                                                                                                       // 9155
		// store state if its toggle - enables .stop().toggle() to "reverse"                                                 // 9156
		if ( toggle ) {                                                                                                      // 9157
			dataShow.hidden = !hidden;                                                                                          // 9158
		}                                                                                                                    // 9159
		if ( hidden ) {                                                                                                      // 9160
			jQuery( elem ).show();                                                                                              // 9161
		} else {                                                                                                             // 9162
			anim.done(function() {                                                                                              // 9163
				jQuery( elem ).hide();                                                                                             // 9164
			});                                                                                                                 // 9165
		}                                                                                                                    // 9166
		anim.done(function() {                                                                                               // 9167
			var prop;                                                                                                           // 9168
			jQuery._removeData( elem, "fxshow" );                                                                               // 9169
			for ( prop in orig ) {                                                                                              // 9170
				jQuery.style( elem, prop, orig[ prop ] );                                                                          // 9171
			}                                                                                                                   // 9172
		});                                                                                                                  // 9173
		for ( prop in orig ) {                                                                                               // 9174
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );                                                   // 9175
                                                                                                                       // 9176
			if ( !( prop in dataShow ) ) {                                                                                      // 9177
				dataShow[ prop ] = tween.start;                                                                                    // 9178
				if ( hidden ) {                                                                                                    // 9179
					tween.end = tween.start;                                                                                          // 9180
					tween.start = prop === "width" || prop === "height" ? 1 : 0;                                                      // 9181
				}                                                                                                                  // 9182
			}                                                                                                                   // 9183
		}                                                                                                                    // 9184
	}                                                                                                                     // 9185
}                                                                                                                      // 9186
                                                                                                                       // 9187
function Tween( elem, options, prop, end, easing ) {                                                                   // 9188
	return new Tween.prototype.init( elem, options, prop, end, easing );                                                  // 9189
}                                                                                                                      // 9190
jQuery.Tween = Tween;                                                                                                  // 9191
                                                                                                                       // 9192
Tween.prototype = {                                                                                                    // 9193
	constructor: Tween,                                                                                                   // 9194
	init: function( elem, options, prop, end, easing, unit ) {                                                            // 9195
		this.elem = elem;                                                                                                    // 9196
		this.prop = prop;                                                                                                    // 9197
		this.easing = easing || "swing";                                                                                     // 9198
		this.options = options;                                                                                              // 9199
		this.start = this.now = this.cur();                                                                                  // 9200
		this.end = end;                                                                                                      // 9201
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );                                                        // 9202
	},                                                                                                                    // 9203
	cur: function() {                                                                                                     // 9204
		var hooks = Tween.propHooks[ this.prop ];                                                                            // 9205
                                                                                                                       // 9206
		return hooks && hooks.get ?                                                                                          // 9207
			hooks.get( this ) :                                                                                                 // 9208
			Tween.propHooks._default.get( this );                                                                               // 9209
	},                                                                                                                    // 9210
	run: function( percent ) {                                                                                            // 9211
		var eased,                                                                                                           // 9212
			hooks = Tween.propHooks[ this.prop ];                                                                               // 9213
                                                                                                                       // 9214
		if ( this.options.duration ) {                                                                                       // 9215
			this.pos = eased = jQuery.easing[ this.easing ](                                                                    // 9216
				percent, this.options.duration * percent, 0, 1, this.options.duration                                              // 9217
			);                                                                                                                  // 9218
		} else {                                                                                                             // 9219
			this.pos = eased = percent;                                                                                         // 9220
		}                                                                                                                    // 9221
		this.now = ( this.end - this.start ) * eased + this.start;                                                           // 9222
                                                                                                                       // 9223
		if ( this.options.step ) {                                                                                           // 9224
			this.options.step.call( this.elem, this.now, this );                                                                // 9225
		}                                                                                                                    // 9226
                                                                                                                       // 9227
		if ( hooks && hooks.set ) {                                                                                          // 9228
			hooks.set( this );                                                                                                  // 9229
		} else {                                                                                                             // 9230
			Tween.propHooks._default.set( this );                                                                               // 9231
		}                                                                                                                    // 9232
		return this;                                                                                                         // 9233
	}                                                                                                                     // 9234
};                                                                                                                     // 9235
                                                                                                                       // 9236
Tween.prototype.init.prototype = Tween.prototype;                                                                      // 9237
                                                                                                                       // 9238
Tween.propHooks = {                                                                                                    // 9239
	_default: {                                                                                                           // 9240
		get: function( tween ) {                                                                                             // 9241
			var result;                                                                                                         // 9242
                                                                                                                       // 9243
			if ( tween.elem[ tween.prop ] != null &&                                                                            // 9244
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {                                                  // 9245
				return tween.elem[ tween.prop ];                                                                                   // 9246
			}                                                                                                                   // 9247
                                                                                                                       // 9248
			// passing an empty string as a 3rd parameter to .css will automatically                                            // 9249
			// attempt a parseFloat and fallback to a string if the parse fails                                                 // 9250
			// so, simple values such as "10px" are parsed to Float.                                                            // 9251
			// complex values such as "rotate(1rad)" are returned as is.                                                        // 9252
			result = jQuery.css( tween.elem, tween.prop, "" );                                                                  // 9253
			// Empty strings, null, undefined and "auto" are converted to 0.                                                    // 9254
			return !result || result === "auto" ? 0 : result;                                                                   // 9255
		},                                                                                                                   // 9256
		set: function( tween ) {                                                                                             // 9257
			// use step hook for back compat - use cssHook if its there - use .style if its                                     // 9258
			// available and use plain properties where available                                                               // 9259
			if ( jQuery.fx.step[ tween.prop ] ) {                                                                               // 9260
				jQuery.fx.step[ tween.prop ]( tween );                                                                             // 9261
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );                                                    // 9263
			} else {                                                                                                            // 9264
				tween.elem[ tween.prop ] = tween.now;                                                                              // 9265
			}                                                                                                                   // 9266
		}                                                                                                                    // 9267
	}                                                                                                                     // 9268
};                                                                                                                     // 9269
                                                                                                                       // 9270
// Support: IE <=9                                                                                                     // 9271
// Panic based approach to setting things on disconnected nodes                                                        // 9272
                                                                                                                       // 9273
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {                                                             // 9274
	set: function( tween ) {                                                                                              // 9275
		if ( tween.elem.nodeType && tween.elem.parentNode ) {                                                                // 9276
			tween.elem[ tween.prop ] = tween.now;                                                                               // 9277
		}                                                                                                                    // 9278
	}                                                                                                                     // 9279
};                                                                                                                     // 9280
                                                                                                                       // 9281
jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {                                                        // 9282
	var cssFn = jQuery.fn[ name ];                                                                                        // 9283
	jQuery.fn[ name ] = function( speed, easing, callback ) {                                                             // 9284
		return speed == null || typeof speed === "boolean" ?                                                                 // 9285
			cssFn.apply( this, arguments ) :                                                                                    // 9286
			this.animate( genFx( name, true ), speed, easing, callback );                                                       // 9287
	};                                                                                                                    // 9288
});                                                                                                                    // 9289
                                                                                                                       // 9290
jQuery.fn.extend({                                                                                                     // 9291
	fadeTo: function( speed, to, easing, callback ) {                                                                     // 9292
                                                                                                                       // 9293
		// show any hidden elements after setting opacity to 0                                                               // 9294
		return this.filter( isHidden ).css( "opacity", 0 ).show()                                                            // 9295
                                                                                                                       // 9296
			// animate to the value specified                                                                                   // 9297
			.end().animate({ opacity: to }, speed, easing, callback );                                                          // 9298
	},                                                                                                                    // 9299
	animate: function( prop, speed, easing, callback ) {                                                                  // 9300
		var empty = jQuery.isEmptyObject( prop ),                                                                            // 9301
			optall = jQuery.speed( speed, easing, callback ),                                                                   // 9302
			doAnimation = function() {                                                                                          // 9303
				// Operate on a copy of prop so per-property easing won't be lost                                                  // 9304
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );                                                   // 9305
                                                                                                                       // 9306
				// Empty animations, or finishing resolves immediately                                                             // 9307
				if ( empty || jQuery._data( this, "finish" ) ) {                                                                   // 9308
					anim.stop( true );                                                                                                // 9309
				}                                                                                                                  // 9310
			};                                                                                                                  // 9311
			doAnimation.finish = doAnimation;                                                                                   // 9312
                                                                                                                       // 9313
		return empty || optall.queue === false ?                                                                             // 9314
			this.each( doAnimation ) :                                                                                          // 9315
			this.queue( optall.queue, doAnimation );                                                                            // 9316
	},                                                                                                                    // 9317
	stop: function( type, clearQueue, gotoEnd ) {                                                                         // 9318
		var stopQueue = function( hooks ) {                                                                                  // 9319
			var stop = hooks.stop;                                                                                              // 9320
			delete hooks.stop;                                                                                                  // 9321
			stop( gotoEnd );                                                                                                    // 9322
		};                                                                                                                   // 9323
                                                                                                                       // 9324
		if ( typeof type !== "string" ) {                                                                                    // 9325
			gotoEnd = clearQueue;                                                                                               // 9326
			clearQueue = type;                                                                                                  // 9327
			type = undefined;                                                                                                   // 9328
		}                                                                                                                    // 9329
		if ( clearQueue && type !== false ) {                                                                                // 9330
			this.queue( type || "fx", [] );                                                                                     // 9331
		}                                                                                                                    // 9332
                                                                                                                       // 9333
		return this.each(function() {                                                                                        // 9334
			var dequeue = true,                                                                                                 // 9335
				index = type != null && type + "queueHooks",                                                                       // 9336
				timers = jQuery.timers,                                                                                            // 9337
				data = jQuery._data( this );                                                                                       // 9338
                                                                                                                       // 9339
			if ( index ) {                                                                                                      // 9340
				if ( data[ index ] && data[ index ].stop ) {                                                                       // 9341
					stopQueue( data[ index ] );                                                                                       // 9342
				}                                                                                                                  // 9343
			} else {                                                                                                            // 9344
				for ( index in data ) {                                                                                            // 9345
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {                                                // 9346
						stopQueue( data[ index ] );                                                                                      // 9347
					}                                                                                                                 // 9348
				}                                                                                                                  // 9349
			}                                                                                                                   // 9350
                                                                                                                       // 9351
			for ( index = timers.length; index--; ) {                                                                           // 9352
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {                         // 9353
					timers[ index ].anim.stop( gotoEnd );                                                                             // 9354
					dequeue = false;                                                                                                  // 9355
					timers.splice( index, 1 );                                                                                        // 9356
				}                                                                                                                  // 9357
			}                                                                                                                   // 9358
                                                                                                                       // 9359
			// start the next in the queue if the last step wasn't forced                                                       // 9360
			// timers currently will call their complete callbacks, which will dequeue                                          // 9361
			// but only if they were gotoEnd                                                                                    // 9362
			if ( dequeue || !gotoEnd ) {                                                                                        // 9363
				jQuery.dequeue( this, type );                                                                                      // 9364
			}                                                                                                                   // 9365
		});                                                                                                                  // 9366
	},                                                                                                                    // 9367
	finish: function( type ) {                                                                                            // 9368
		if ( type !== false ) {                                                                                              // 9369
			type = type || "fx";                                                                                                // 9370
		}                                                                                                                    // 9371
		return this.each(function() {                                                                                        // 9372
			var index,                                                                                                          // 9373
				data = jQuery._data( this ),                                                                                       // 9374
				queue = data[ type + "queue" ],                                                                                    // 9375
				hooks = data[ type + "queueHooks" ],                                                                               // 9376
				timers = jQuery.timers,                                                                                            // 9377
				length = queue ? queue.length : 0;                                                                                 // 9378
                                                                                                                       // 9379
			// enable finishing flag on private data                                                                            // 9380
			data.finish = true;                                                                                                 // 9381
                                                                                                                       // 9382
			// empty the queue first                                                                                            // 9383
			jQuery.queue( this, type, [] );                                                                                     // 9384
                                                                                                                       // 9385
			if ( hooks && hooks.stop ) {                                                                                        // 9386
				hooks.stop.call( this, true );                                                                                     // 9387
			}                                                                                                                   // 9388
                                                                                                                       // 9389
			// look for any active animations, and finish them                                                                  // 9390
			for ( index = timers.length; index--; ) {                                                                           // 9391
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {                                           // 9392
					timers[ index ].anim.stop( true );                                                                                // 9393
					timers.splice( index, 1 );                                                                                        // 9394
				}                                                                                                                  // 9395
			}                                                                                                                   // 9396
                                                                                                                       // 9397
			// look for any animations in the old queue and finish them                                                         // 9398
			for ( index = 0; index < length; index++ ) {                                                                        // 9399
				if ( queue[ index ] && queue[ index ].finish ) {                                                                   // 9400
					queue[ index ].finish.call( this );                                                                               // 9401
				}                                                                                                                  // 9402
			}                                                                                                                   // 9403
                                                                                                                       // 9404
			// turn off finishing flag                                                                                          // 9405
			delete data.finish;                                                                                                 // 9406
		});                                                                                                                  // 9407
	}                                                                                                                     // 9408
});                                                                                                                    // 9409
                                                                                                                       // 9410
// Generate parameters to create a standard animation                                                                  // 9411
function genFx( type, includeWidth ) {                                                                                 // 9412
	var which,                                                                                                            // 9413
		attrs = { height: type },                                                                                            // 9414
		i = 0;                                                                                                               // 9415
                                                                                                                       // 9416
	// if we include width, step value is 1 to do all cssExpand values,                                                   // 9417
	// if we don't include width, step value is 2 to skip over Left and Right                                             // 9418
	includeWidth = includeWidth? 1 : 0;                                                                                   // 9419
	for( ; i < 4 ; i += 2 - includeWidth ) {                                                                              // 9420
		which = cssExpand[ i ];                                                                                              // 9421
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;                                                       // 9422
	}                                                                                                                     // 9423
                                                                                                                       // 9424
	if ( includeWidth ) {                                                                                                 // 9425
		attrs.opacity = attrs.width = type;                                                                                  // 9426
	}                                                                                                                     // 9427
                                                                                                                       // 9428
	return attrs;                                                                                                         // 9429
}                                                                                                                      // 9430
                                                                                                                       // 9431
// Generate shortcuts for custom animations                                                                            // 9432
jQuery.each({                                                                                                          // 9433
	slideDown: genFx("show"),                                                                                             // 9434
	slideUp: genFx("hide"),                                                                                               // 9435
	slideToggle: genFx("toggle"),                                                                                         // 9436
	fadeIn: { opacity: "show" },                                                                                          // 9437
	fadeOut: { opacity: "hide" },                                                                                         // 9438
	fadeToggle: { opacity: "toggle" }                                                                                     // 9439
}, function( name, props ) {                                                                                           // 9440
	jQuery.fn[ name ] = function( speed, easing, callback ) {                                                             // 9441
		return this.animate( props, speed, easing, callback );                                                               // 9442
	};                                                                                                                    // 9443
});                                                                                                                    // 9444
                                                                                                                       // 9445
jQuery.speed = function( speed, easing, fn ) {                                                                         // 9446
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {                                         // 9447
		complete: fn || !fn && easing ||                                                                                     // 9448
			jQuery.isFunction( speed ) && speed,                                                                                // 9449
		duration: speed,                                                                                                     // 9450
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing                                             // 9451
	};                                                                                                                    // 9452
                                                                                                                       // 9453
	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :                                  // 9454
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;                     // 9455
                                                                                                                       // 9456
	// normalize opt.queue - true/undefined/null -> "fx"                                                                  // 9457
	if ( opt.queue == null || opt.queue === true ) {                                                                      // 9458
		opt.queue = "fx";                                                                                                    // 9459
	}                                                                                                                     // 9460
                                                                                                                       // 9461
	// Queueing                                                                                                           // 9462
	opt.old = opt.complete;                                                                                               // 9463
                                                                                                                       // 9464
	opt.complete = function() {                                                                                           // 9465
		if ( jQuery.isFunction( opt.old ) ) {                                                                                // 9466
			opt.old.call( this );                                                                                               // 9467
		}                                                                                                                    // 9468
                                                                                                                       // 9469
		if ( opt.queue ) {                                                                                                   // 9470
			jQuery.dequeue( this, opt.queue );                                                                                  // 9471
		}                                                                                                                    // 9472
	};                                                                                                                    // 9473
                                                                                                                       // 9474
	return opt;                                                                                                           // 9475
};                                                                                                                     // 9476
                                                                                                                       // 9477
jQuery.easing = {                                                                                                      // 9478
	linear: function( p ) {                                                                                               // 9479
		return p;                                                                                                            // 9480
	},                                                                                                                    // 9481
	swing: function( p ) {                                                                                                // 9482
		return 0.5 - Math.cos( p*Math.PI ) / 2;                                                                              // 9483
	}                                                                                                                     // 9484
};                                                                                                                     // 9485
                                                                                                                       // 9486
jQuery.timers = [];                                                                                                    // 9487
jQuery.fx = Tween.prototype.init;                                                                                      // 9488
jQuery.fx.tick = function() {                                                                                          // 9489
	var timer,                                                                                                            // 9490
		timers = jQuery.timers,                                                                                              // 9491
		i = 0;                                                                                                               // 9492
                                                                                                                       // 9493
	fxNow = jQuery.now();                                                                                                 // 9494
                                                                                                                       // 9495
	for ( ; i < timers.length; i++ ) {                                                                                    // 9496
		timer = timers[ i ];                                                                                                 // 9497
		// Checks the timer has not already been removed                                                                     // 9498
		if ( !timer() && timers[ i ] === timer ) {                                                                           // 9499
			timers.splice( i--, 1 );                                                                                            // 9500
		}                                                                                                                    // 9501
	}                                                                                                                     // 9502
                                                                                                                       // 9503
	if ( !timers.length ) {                                                                                               // 9504
		jQuery.fx.stop();                                                                                                    // 9505
	}                                                                                                                     // 9506
	fxNow = undefined;                                                                                                    // 9507
};                                                                                                                     // 9508
                                                                                                                       // 9509
jQuery.fx.timer = function( timer ) {                                                                                  // 9510
	if ( timer() && jQuery.timers.push( timer ) ) {                                                                       // 9511
		jQuery.fx.start();                                                                                                   // 9512
	}                                                                                                                     // 9513
};                                                                                                                     // 9514
                                                                                                                       // 9515
jQuery.fx.interval = 13;                                                                                               // 9516
                                                                                                                       // 9517
jQuery.fx.start = function() {                                                                                         // 9518
	if ( !timerId ) {                                                                                                     // 9519
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );                                                         // 9520
	}                                                                                                                     // 9521
};                                                                                                                     // 9522
                                                                                                                       // 9523
jQuery.fx.stop = function() {                                                                                          // 9524
	clearInterval( timerId );                                                                                             // 9525
	timerId = null;                                                                                                       // 9526
};                                                                                                                     // 9527
                                                                                                                       // 9528
jQuery.fx.speeds = {                                                                                                   // 9529
	slow: 600,                                                                                                            // 9530
	fast: 200,                                                                                                            // 9531
	// Default speed                                                                                                      // 9532
	_default: 400                                                                                                         // 9533
};                                                                                                                     // 9534
                                                                                                                       // 9535
// Back Compat <1.8 extension point                                                                                    // 9536
jQuery.fx.step = {};                                                                                                   // 9537
                                                                                                                       // 9538
if ( jQuery.expr && jQuery.expr.filters ) {                                                                            // 9539
	jQuery.expr.filters.animated = function( elem ) {                                                                     // 9540
		return jQuery.grep(jQuery.timers, function( fn ) {                                                                   // 9541
			return elem === fn.elem;                                                                                            // 9542
		}).length;                                                                                                           // 9543
	};                                                                                                                    // 9544
}                                                                                                                      // 9545
jQuery.fn.offset = function( options ) {                                                                               // 9546
	if ( arguments.length ) {                                                                                             // 9547
		return options === undefined ?                                                                                       // 9548
			this :                                                                                                              // 9549
			this.each(function( i ) {                                                                                           // 9550
				jQuery.offset.setOffset( this, options, i );                                                                       // 9551
			});                                                                                                                 // 9552
	}                                                                                                                     // 9553
                                                                                                                       // 9554
	var docElem, win,                                                                                                     // 9555
		box = { top: 0, left: 0 },                                                                                           // 9556
		elem = this[ 0 ],                                                                                                    // 9557
		doc = elem && elem.ownerDocument;                                                                                    // 9558
                                                                                                                       // 9559
	if ( !doc ) {                                                                                                         // 9560
		return;                                                                                                              // 9561
	}                                                                                                                     // 9562
                                                                                                                       // 9563
	docElem = doc.documentElement;                                                                                        // 9564
                                                                                                                       // 9565
	// Make sure it's not a disconnected DOM node                                                                         // 9566
	if ( !jQuery.contains( docElem, elem ) ) {                                                                            // 9567
		return box;                                                                                                          // 9568
	}                                                                                                                     // 9569
                                                                                                                       // 9570
	// If we don't have gBCR, just use 0,0 rather than error                                                              // 9571
	// BlackBerry 5, iOS 3 (original iPhone)                                                                              // 9572
	if ( typeof elem.getBoundingClientRect !== core_strundefined ) {                                                      // 9573
		box = elem.getBoundingClientRect();                                                                                  // 9574
	}                                                                                                                     // 9575
	win = getWindow( doc );                                                                                               // 9576
	return {                                                                                                              // 9577
		top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),                             // 9578
		left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )                             // 9579
	};                                                                                                                    // 9580
};                                                                                                                     // 9581
                                                                                                                       // 9582
jQuery.offset = {                                                                                                      // 9583
                                                                                                                       // 9584
	setOffset: function( elem, options, i ) {                                                                             // 9585
		var position = jQuery.css( elem, "position" );                                                                       // 9586
                                                                                                                       // 9587
		// set position first, in-case top/left are set even on static elem                                                  // 9588
		if ( position === "static" ) {                                                                                       // 9589
			elem.style.position = "relative";                                                                                   // 9590
		}                                                                                                                    // 9591
                                                                                                                       // 9592
		var curElem = jQuery( elem ),                                                                                        // 9593
			curOffset = curElem.offset(),                                                                                       // 9594
			curCSSTop = jQuery.css( elem, "top" ),                                                                              // 9595
			curCSSLeft = jQuery.css( elem, "left" ),                                                                            // 9596
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;                                                                      // 9598
                                                                                                                       // 9599
		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed      // 9600
		if ( calculatePosition ) {                                                                                           // 9601
			curPosition = curElem.position();                                                                                   // 9602
			curTop = curPosition.top;                                                                                           // 9603
			curLeft = curPosition.left;                                                                                         // 9604
		} else {                                                                                                             // 9605
			curTop = parseFloat( curCSSTop ) || 0;                                                                              // 9606
			curLeft = parseFloat( curCSSLeft ) || 0;                                                                            // 9607
		}                                                                                                                    // 9608
                                                                                                                       // 9609
		if ( jQuery.isFunction( options ) ) {                                                                                // 9610
			options = options.call( elem, i, curOffset );                                                                       // 9611
		}                                                                                                                    // 9612
                                                                                                                       // 9613
		if ( options.top != null ) {                                                                                         // 9614
			props.top = ( options.top - curOffset.top ) + curTop;                                                               // 9615
		}                                                                                                                    // 9616
		if ( options.left != null ) {                                                                                        // 9617
			props.left = ( options.left - curOffset.left ) + curLeft;                                                           // 9618
		}                                                                                                                    // 9619
                                                                                                                       // 9620
		if ( "using" in options ) {                                                                                          // 9621
			options.using.call( elem, props );                                                                                  // 9622
		} else {                                                                                                             // 9623
			curElem.css( props );                                                                                               // 9624
		}                                                                                                                    // 9625
	}                                                                                                                     // 9626
};                                                                                                                     // 9627
                                                                                                                       // 9628
                                                                                                                       // 9629
jQuery.fn.extend({                                                                                                     // 9630
                                                                                                                       // 9631
	position: function() {                                                                                                // 9632
		if ( !this[ 0 ] ) {                                                                                                  // 9633
			return;                                                                                                             // 9634
		}                                                                                                                    // 9635
                                                                                                                       // 9636
		var offsetParent, offset,                                                                                            // 9637
			parentOffset = { top: 0, left: 0 },                                                                                 // 9638
			elem = this[ 0 ];                                                                                                   // 9639
                                                                                                                       // 9640
		// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent     // 9641
		if ( jQuery.css( elem, "position" ) === "fixed" ) {                                                                  // 9642
			// we assume that getBoundingClientRect is available when computed position is fixed                                // 9643
			offset = elem.getBoundingClientRect();                                                                              // 9644
		} else {                                                                                                             // 9645
			// Get *real* offsetParent                                                                                          // 9646
			offsetParent = this.offsetParent();                                                                                 // 9647
                                                                                                                       // 9648
			// Get correct offsets                                                                                              // 9649
			offset = this.offset();                                                                                             // 9650
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {                                                              // 9651
				parentOffset = offsetParent.offset();                                                                              // 9652
			}                                                                                                                   // 9653
                                                                                                                       // 9654
			// Add offsetParent borders                                                                                         // 9655
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );                                       // 9656
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );                                      // 9657
		}                                                                                                                    // 9658
                                                                                                                       // 9659
		// Subtract parent offsets and element margins                                                                       // 9660
		// note: when an element has margin: auto the offsetLeft and marginLeft                                              // 9661
		// are the same in Safari causing offset.left to incorrectly be 0                                                    // 9662
		return {                                                                                                             // 9663
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),                                       // 9664
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)                                       // 9665
		};                                                                                                                   // 9666
	},                                                                                                                    // 9667
                                                                                                                       // 9668
	offsetParent: function() {                                                                                            // 9669
		return this.map(function() {                                                                                         // 9670
			var offsetParent = this.offsetParent || docElem;                                                                    // 9671
			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position") === "static" ) ) {
				offsetParent = offsetParent.offsetParent;                                                                          // 9673
			}                                                                                                                   // 9674
			return offsetParent || docElem;                                                                                     // 9675
		});                                                                                                                  // 9676
	}                                                                                                                     // 9677
});                                                                                                                    // 9678
                                                                                                                       // 9679
                                                                                                                       // 9680
// Create scrollLeft and scrollTop methods                                                                             // 9681
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {                         // 9682
	var top = /Y/.test( prop );                                                                                           // 9683
                                                                                                                       // 9684
	jQuery.fn[ method ] = function( val ) {                                                                               // 9685
		return jQuery.access( this, function( elem, method, val ) {                                                          // 9686
			var win = getWindow( elem );                                                                                        // 9687
                                                                                                                       // 9688
			if ( val === undefined ) {                                                                                          // 9689
				return win ? (prop in win) ? win[ prop ] :                                                                         // 9690
					win.document.documentElement[ method ] :                                                                          // 9691
					elem[ method ];                                                                                                   // 9692
			}                                                                                                                   // 9693
                                                                                                                       // 9694
			if ( win ) {                                                                                                        // 9695
				win.scrollTo(                                                                                                      // 9696
					!top ? val : jQuery( win ).scrollLeft(),                                                                          // 9697
					top ? val : jQuery( win ).scrollTop()                                                                             // 9698
				);                                                                                                                 // 9699
                                                                                                                       // 9700
			} else {                                                                                                            // 9701
				elem[ method ] = val;                                                                                              // 9702
			}                                                                                                                   // 9703
		}, method, val, arguments.length, null );                                                                            // 9704
	};                                                                                                                    // 9705
});                                                                                                                    // 9706
                                                                                                                       // 9707
function getWindow( elem ) {                                                                                           // 9708
	return jQuery.isWindow( elem ) ?                                                                                      // 9709
		elem :                                                                                                               // 9710
		elem.nodeType === 9 ?                                                                                                // 9711
			elem.defaultView || elem.parentWindow :                                                                             // 9712
			false;                                                                                                              // 9713
}                                                                                                                      // 9714
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods                                   // 9715
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {                                            // 9716
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {     // 9717
		// margin is only for outerHeight, outerWidth                                                                        // 9718
		jQuery.fn[ funcName ] = function( margin, value ) {                                                                  // 9719
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),                                // 9720
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );                               // 9721
                                                                                                                       // 9722
			return jQuery.access( this, function( elem, type, value ) {                                                         // 9723
				var doc;                                                                                                           // 9724
                                                                                                                       // 9725
				if ( jQuery.isWindow( elem ) ) {                                                                                   // 9726
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there                                  // 9727
					// isn't a whole lot we can do. See pull request at this URL for discussion:                                      // 9728
					// https://github.com/jquery/jquery/pull/764                                                                      // 9729
					return elem.document.documentElement[ "client" + name ];                                                          // 9730
				}                                                                                                                  // 9731
                                                                                                                       // 9732
				// Get document width or height                                                                                    // 9733
				if ( elem.nodeType === 9 ) {                                                                                       // 9734
					doc = elem.documentElement;                                                                                       // 9735
                                                                                                                       // 9736
					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest             // 9737
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.       // 9738
					return Math.max(                                                                                                  // 9739
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],                                                            // 9740
						elem.body[ "offset" + name ], doc[ "offset" + name ],                                                            // 9741
						doc[ "client" + name ]                                                                                           // 9742
					);                                                                                                                // 9743
				}                                                                                                                  // 9744
                                                                                                                       // 9745
				return value === undefined ?                                                                                       // 9746
					// Get width or height on the element, requesting but not forcing parseFloat                                      // 9747
					jQuery.css( elem, type, extra ) :                                                                                 // 9748
                                                                                                                       // 9749
					// Set width or height on the element                                                                             // 9750
					jQuery.style( elem, type, value, extra );                                                                         // 9751
			}, type, chainable ? margin : undefined, chainable, null );                                                         // 9752
		};                                                                                                                   // 9753
	});                                                                                                                   // 9754
});                                                                                                                    // 9755
// Limit scope pollution from any deprecated API                                                                       // 9756
// (function() {                                                                                                       // 9757
                                                                                                                       // 9758
// The number of elements contained in the matched element set                                                         // 9759
jQuery.fn.size = function() {                                                                                          // 9760
	return this.length;                                                                                                   // 9761
};                                                                                                                     // 9762
                                                                                                                       // 9763
jQuery.fn.andSelf = jQuery.fn.addBack;                                                                                 // 9764
                                                                                                                       // 9765
// })();                                                                                                               // 9766
if ( typeof module === "object" && module && typeof module.exports === "object" ) {                                    // 9767
	// Expose jQuery as module.exports in loaders that implement the Node                                                 // 9768
	// module pattern (including browserify). Do not create the global, since                                             // 9769
	// the user will be storing it themselves locally, and globals are frowned                                            // 9770
	// upon in the Node module world.                                                                                     // 9771
	module.exports = jQuery;                                                                                              // 9772
} else {                                                                                                               // 9773
	// Otherwise expose jQuery to the global object as usual                                                              // 9774
	window.jQuery = window.$ = jQuery;                                                                                    // 9775
                                                                                                                       // 9776
	// Register as a named AMD module, since jQuery can be concatenated with other                                        // 9777
	// files that may use define, but not via a proper concatenation script that                                          // 9778
	// understands anonymous AMD modules. A named AMD is safest and most robust                                           // 9779
	// way to register. Lowercase jquery is used because AMD module names are                                             // 9780
	// derived from file names, and jQuery is normally delivered in a lowercase                                           // 9781
	// file name. Do this after creating the global so that if an AMD module wants                                        // 9782
	// to call noConflict to hide this version of jQuery, it will work.                                                   // 9783
	if ( typeof define === "function" && define.amd ) {                                                                   // 9784
		define( "jquery", [], function () { return jQuery; } );                                                              // 9785
	}                                                                                                                     // 9786
}                                                                                                                      // 9787
                                                                                                                       // 9788
})( window );                                                                                                          // 9789
                                                                                                                       // 9790
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/jquery/post.js                                                                                             //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
// Put jQuery and $ in our exported package-scope variables and remove window.$.                                       // 1
// (Sadly, we don't call noConflict(true), which would also remove                                                     // 2
// window.jQuery, because bootstrap very specifically relies on window.jQuery.)                                        // 3
$ = jQuery = window.jQuery.noConflict();                                                                               // 4
                                                                                                                       // 5
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.jquery = {
  $: $,
  jQuery: jQuery
};

})();

//# sourceMappingURL=5978a910eadb45ea575f412686b11169f992024b.map


//--------- observe-sequence.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var Deps = Package.deps.Deps;
var LocalCollection = Package.minimongo.LocalCollection;
var Minimongo = Package.minimongo.Minimongo;

/* Package-scope variables */
var ObserveSequence, id;

(function () {

////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
// packages/observe-sequence/observe_sequence.js                                  //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////
                                                                                  //
var warn;                                                                         // 1
if (typeof console !== 'undefined' && console.warn) {                             // 2
  warn = function () {                                                            // 3
    if (ObserveSequence._suppressWarnings) {                                      // 4
      ObserveSequence._suppressWarnings--;                                        // 5
    } else {                                                                      // 6
      console.warn.apply(console, arguments);                                     // 7
      ObserveSequence._loggedWarnings++;                                          // 8
    }                                                                             // 9
  };                                                                              // 10
} else {                                                                          // 11
  warn = function () {};                                                          // 12
}                                                                                 // 13
                                                                                  // 14
var idStringify = LocalCollection._idStringify;                                   // 15
var idParse = LocalCollection._idParse;                                           // 16
                                                                                  // 17
ObserveSequence = {                                                               // 18
  _suppressWarnings: 0,                                                           // 19
  _loggedWarnings: 0,                                                             // 20
                                                                                  // 21
  // A mechanism similar to cursor.observe which receives a reactive              // 22
  // function returning a sequence type and firing appropriate callbacks          // 23
  // when the value changes.                                                      // 24
  //                                                                              // 25
  // @param sequenceFunc {Function} a reactive function returning a               // 26
  //     sequence type. The currently supported sequence types are:               // 27
  //     'null', arrays and cursors.                                              // 28
  //                                                                              // 29
  // @param callbacks {Object} similar to a specific subset of                    // 30
  //     callbacks passed to `cursor.observe`                                     // 31
  //     (http://docs.meteor.com/#observe), with minor variations to              // 32
  //     support the fact that not all sequences contain objects with             // 33
  //     _id fields.  Specifically:                                               // 34
  //                                                                              // 35
  //     * addedAt(id, item, atIndex, beforeId)                                   // 36
  //     * changed(id, newItem, oldItem)                                          // 37
  //     * removed(id, oldItem)                                                   // 38
  //     * movedTo(id, item, fromIndex, toIndex, beforeId)                        // 39
  //                                                                              // 40
  // @returns {Object(stop: Function)} call 'stop' on the return value            // 41
  //     to stop observing this sequence function.                                // 42
  //                                                                              // 43
  // We don't make any assumptions about our ability to compare sequence          // 44
  // elements (ie, we don't assume EJSON.equals works; maybe there is extra       // 45
  // state/random methods on the objects) so unlike cursor.observe, we may        // 46
  // sometimes call changed() when nothing actually changed.                      // 47
  // XXX consider if we *can* make the stronger assumption and avoid              // 48
  //     no-op changed calls (in some cases?)                                     // 49
  //                                                                              // 50
  // XXX currently only supports the callbacks used by our                        // 51
  // implementation of {{#each}}, but this can be expanded.                       // 52
  //                                                                              // 53
  // XXX #each doesn't use the indices (though we'll eventually need              // 54
  // a way to get them when we support `@index`), but calling                     // 55
  // `cursor.observe` causes the index to be calculated on every                  // 56
  // callback using a linear scan (unless you turn it off by passing              // 57
  // `_no_indices`).  Any way to avoid calculating indices on a pure              // 58
  // cursor observe like we used to?                                              // 59
  observe: function (sequenceFunc, callbacks) {                                   // 60
    var lastSeq = null;                                                           // 61
    var activeObserveHandle = null;                                               // 62
                                                                                  // 63
    // 'lastSeqArray' contains the previous value of the sequence                 // 64
    // we're observing. It is an array of objects with '_id' and                  // 65
    // 'item' fields.  'item' is the element in the array, or the                 // 66
    // document in the cursor.                                                    // 67
    //                                                                            // 68
    // '_id' is whichever of the following is relevant, unless it has             // 69
    // already appeared -- in which case it's randomly generated.                 // 70
    //                                                                            // 71
    // * if 'item' is an object:                                                  // 72
    //   * an '_id' field, if present                                             // 73
    //   * otherwise, the index in the array                                      // 74
    //                                                                            // 75
    // * if 'item' is a number or string, use that value                          // 76
    //                                                                            // 77
    // XXX this can be generalized by allowing {{#each}} to accept a              // 78
    // general 'key' argument which could be a function, a dotted                 // 79
    // field name, or the special @index value.                                   // 80
    var lastSeqArray = []; // elements are objects of form {_id, item}            // 81
    var computation = Deps.autorun(function () {                                  // 82
      var seq = sequenceFunc();                                                   // 83
                                                                                  // 84
      Deps.nonreactive(function () {                                              // 85
        var seqArray; // same structure as `lastSeqArray` above.                  // 86
                                                                                  // 87
        // If we were previously observing a cursor, replace lastSeqArray with    // 88
        // more up-to-date information (specifically, the state of the observe    // 89
        // before it was stopped, which may be older than the DB).                // 90
        if (activeObserveHandle) {                                                // 91
          lastSeqArray = _.map(activeObserveHandle._fetch(), function (doc) {     // 92
            return {_id: doc._id, item: doc};                                     // 93
          });                                                                     // 94
          activeObserveHandle.stop();                                             // 95
          activeObserveHandle = null;                                             // 96
        }                                                                         // 97
                                                                                  // 98
        if (!seq) {                                                               // 99
          seqArray = [];                                                          // 100
          diffArray(lastSeqArray, seqArray, callbacks);                           // 101
        } else if (seq instanceof Array) {                                        // 102
          var idsUsed = {};                                                       // 103
          seqArray = _.map(seq, function (item, index) {                          // 104
            if (typeof item === 'string' ||                                       // 105
                typeof item === 'number' ||                                       // 106
                typeof item === 'boolean' ||                                      // 107
                item === undefined)                                               // 108
              id = item;                                                          // 109
            else if (typeof item === 'object')                                    // 110
              id = (item && item._id) || index;                                   // 111
            else                                                                  // 112
              throw new Error("unsupported type in {{#each}}: " + typeof item);   // 113
                                                                                  // 114
            var idString = idStringify(id);                                       // 115
            if (idsUsed[idString]) {                                              // 116
              warn("duplicate id " + id + " in", seq);                            // 117
              id = Random.id();                                                   // 118
            } else {                                                              // 119
              idsUsed[idString] = true;                                           // 120
            }                                                                     // 121
                                                                                  // 122
            return { _id: id, item: item };                                       // 123
          });                                                                     // 124
                                                                                  // 125
          diffArray(lastSeqArray, seqArray, callbacks);                           // 126
        } else if (isMinimongoCursor(seq)) {                                      // 127
          var cursor = seq;                                                       // 128
          seqArray = [];                                                          // 129
                                                                                  // 130
          var initial = true; // are we observing initial data from cursor?       // 131
          activeObserveHandle = cursor.observe({                                  // 132
            addedAt: function (document, atIndex, before) {                       // 133
              if (initial) {                                                      // 134
                // keep track of initial data so that we can diff once            // 135
                // we exit `observe`.                                             // 136
                if (before !== null)                                              // 137
                  throw new Error("Expected initial data from observe in order"); // 138
                seqArray.push({ _id: document._id, item: document });             // 139
              } else {                                                            // 140
                callbacks.addedAt(document._id, document, atIndex, before);       // 141
              }                                                                   // 142
            },                                                                    // 143
            changed: function (newDocument, oldDocument) {                        // 144
              callbacks.changed(newDocument._id, newDocument, oldDocument);       // 145
            },                                                                    // 146
            removed: function (oldDocument) {                                     // 147
              callbacks.removed(oldDocument._id, oldDocument);                    // 148
            },                                                                    // 149
            movedTo: function (document, fromIndex, toIndex, before) {            // 150
              callbacks.movedTo(                                                  // 151
                document._id, document, fromIndex, toIndex, before);              // 152
            }                                                                     // 153
          });                                                                     // 154
          initial = false;                                                        // 155
                                                                                  // 156
          // diff the old sequnce with initial data in the new cursor. this will  // 157
          // fire `addedAt` callbacks on the initial data.                        // 158
          diffArray(lastSeqArray, seqArray, callbacks);                           // 159
                                                                                  // 160
        } else {                                                                  // 161
          throw new Error("Not a recognized sequence type. Currently only " +     // 162
                          "arrays, cursors or falsey values accepted.");          // 163
        }                                                                         // 164
                                                                                  // 165
        lastSeq = seq;                                                            // 166
        lastSeqArray = seqArray;                                                  // 167
      });                                                                         // 168
    });                                                                           // 169
                                                                                  // 170
    return {                                                                      // 171
      stop: function () {                                                         // 172
        computation.stop();                                                       // 173
        if (activeObserveHandle)                                                  // 174
          activeObserveHandle.stop();                                             // 175
      }                                                                           // 176
    };                                                                            // 177
  },                                                                              // 178
                                                                                  // 179
  // Fetch the items of `seq` into an array, where `seq` is of one of the         // 180
  // sequence types accepted by `observe`.  If `seq` is a cursor, a               // 181
  // dependency is established.                                                   // 182
  fetch: function (seq) {                                                         // 183
    if (!seq) {                                                                   // 184
      return [];                                                                  // 185
    } else if (seq instanceof Array) {                                            // 186
      return seq;                                                                 // 187
    } else if (isMinimongoCursor(seq)) {                                          // 188
      return seq.fetch();                                                         // 189
    } else {                                                                      // 190
      throw new Error("Not a recognized sequence type. Currently only " +         // 191
                      "arrays, cursors or falsey values accepted.");              // 192
    }                                                                             // 193
  }                                                                               // 194
};                                                                                // 195
                                                                                  // 196
var isMinimongoCursor = function (seq) {                                          // 197
  var minimongo = Package.minimongo;                                              // 198
  return !!minimongo && (seq instanceof minimongo.LocalCollection.Cursor);        // 199
};                                                                                // 200
                                                                                  // 201
// Calculates the differences between `lastSeqArray` and                          // 202
// `seqArray` and calls appropriate functions from `callbacks`.                   // 203
// Reuses Minimongo's diff algorithm implementation.                              // 204
var diffArray = function (lastSeqArray, seqArray, callbacks) {                    // 205
  var diffFn = Package.minimongo.LocalCollection._diffQueryOrderedChanges;        // 206
  var oldIdObjects = [];                                                          // 207
  var newIdObjects = [];                                                          // 208
  var posOld = {}; // maps from idStringify'd ids                                 // 209
  var posNew = {}; // ditto                                                       // 210
                                                                                  // 211
  _.each(seqArray, function (doc, i) {                                            // 212
    newIdObjects.push(_.pick(doc, '_id'));                                        // 213
    posNew[idStringify(doc._id)] = i;                                             // 214
  });                                                                             // 215
  _.each(lastSeqArray, function (doc, i) {                                        // 216
    oldIdObjects.push(_.pick(doc, '_id'));                                        // 217
    posOld[idStringify(doc._id)] = i;                                             // 218
  });                                                                             // 219
                                                                                  // 220
  // Arrays can contain arbitrary objects. We don't diff the                      // 221
  // objects. Instead we always fire 'changed' callback on every                  // 222
  // object. The consumer of `observe-sequence` should deal with                  // 223
  // it appropriately.                                                            // 224
  diffFn(oldIdObjects, newIdObjects, {                                            // 225
    addedBefore: function (id, doc, before) {                                     // 226
      callbacks.addedAt(                                                          // 227
        id,                                                                       // 228
        seqArray[posNew[idStringify(id)]].item,                                   // 229
        posNew[idStringify(id)],                                                  // 230
        before);                                                                  // 231
    },                                                                            // 232
    movedBefore: function (id, before) {                                          // 233
      callbacks.movedTo(                                                          // 234
        id,                                                                       // 235
        seqArray[posNew[idStringify(id)]].item,                                   // 236
        posOld[idStringify(id)],                                                  // 237
        posNew[idStringify(id)],                                                  // 238
        before);                                                                  // 239
    },                                                                            // 240
    removed: function (id) {                                                      // 241
      callbacks.removed(                                                          // 242
        id,                                                                       // 243
        lastSeqArray[posOld[idStringify(id)]].item);                              // 244
    }                                                                             // 245
  });                                                                             // 246
                                                                                  // 247
  _.each(posNew, function (pos, idString) {                                       // 248
    var id = idParse(idString);                                                   // 249
    if (_.has(posOld, idString)) {                                                // 250
      // specifically for primitive types, compare equality before                // 251
      // firing the changed callback. otherwise, always fire it                   // 252
      // because doing a deep EJSON comparison is not guaranteed to               // 253
      // work (an array can contain arbitrary objects, and 'transform'            // 254
      // can be used on cursors). also, deep diffing is not                       // 255
      // necessarily the most efficient (if only a specific subfield              // 256
      // of the object is later accessed).                                        // 257
      var newItem = seqArray[pos].item;                                           // 258
      var oldItem = lastSeqArray[posOld[idString]].item;                          // 259
                                                                                  // 260
      if (typeof newItem === 'object' || newItem !== oldItem)                     // 261
        callbacks.changed(id, newItem, oldItem);                                  // 262
    }                                                                             // 263
  });                                                                             // 264
};                                                                                // 265
                                                                                  // 266
////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['observe-sequence'] = {
  ObserveSequence: ObserveSequence
};

})();

//# sourceMappingURL=a9897998fa9e65b3bad6c80a147a06e3b05f0eaa.map


//--------- htmljs.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;

/* Package-scope variables */
var HTML;

(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                      //
// packages/htmljs/utils.js                                                                             //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                        //
                                                                                                        // 1
HTML = {};                                                                                              // 2
                                                                                                        // 3
HTML.isNully = function (node) {                                                                        // 4
  if (node == null)                                                                                     // 5
    // null or undefined                                                                                // 6
    return true;                                                                                        // 7
                                                                                                        // 8
  if (node instanceof Array) {                                                                          // 9
    // is it an empty array or an array of all nully items?                                             // 10
    for (var i = 0; i < node.length; i++)                                                               // 11
      if (! HTML.isNully(node[i]))                                                                      // 12
        return false;                                                                                   // 13
    return true;                                                                                        // 14
  }                                                                                                     // 15
                                                                                                        // 16
  return false;                                                                                         // 17
};                                                                                                      // 18
                                                                                                        // 19
HTML.asciiLowerCase = function (str) {                                                                  // 20
  return str.replace(/[A-Z]/g, function (c) {                                                           // 21
    return String.fromCharCode(c.charCodeAt(0) + 32);                                                   // 22
  });                                                                                                   // 23
};                                                                                                      // 24
                                                                                                        // 25
HTML.escapeData = function (str) {                                                                      // 26
  // string; escape the two special chars in HTML data and RCDATA                                       // 27
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;');                                              // 28
};                                                                                                      // 29
                                                                                                        // 30
var svgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef glyphRef gradientTransform gradientTransform gradientUnits gradientUnits kernelMatrix kernelUnitLength kernelUnitLength kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent specularExponent spreadMethod spreadMethod startOffset stdDeviation stitchTiles surfaceScale surfaceScale systemLanguage tableValues targetX targetY textLength textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split(' ');
var svgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split(' ');
var svgCamelCaseAttributesMap = (function (map) {                                                       // 33
  for (var i = 0; i < svgCamelCaseAttributes.length; i++) {                                             // 34
    var a = svgCamelCaseAttributes[i];                                                                  // 35
    map[HTML.asciiLowerCase(a)] = a;                                                                    // 36
  }                                                                                                     // 37
  return map;                                                                                           // 38
})({});                                                                                                 // 39
var svgCamelCaseElementsMap = (function (map) {                                                         // 40
  for (var i = 0; i < svgCamelCaseElements.length; i++) {                                               // 41
    var e = svgCamelCaseElements[i];                                                                    // 42
    map[HTML.asciiLowerCase(e)] = e;                                                                    // 43
  }                                                                                                     // 44
  return map;                                                                                           // 45
})({});                                                                                                 // 46
                                                                                                        // 47
                                                                                                        // 48
// Take a tag name in any case and make it the proper case for HTML.                                    // 49
//                                                                                                      // 50
// Modern browsers let you embed SVG in HTML, but SVG elements are special                              // 51
// in that they have a case-sensitive DOM API (nodeName, getAttribute,                                  // 52
// setAttribute).  For example, it has to be `setAttribute("viewBox")`,                                 // 53
// not `"viewbox"`.  However, the HTML parser will fix the case for you,                                // 54
// so if you write `<svg viewbox="...">` you actually get a `"viewBox"`                                 // 55
// attribute.                                                                                           // 56
HTML.properCaseTagName = function (name) {                                                              // 57
  var lowered = HTML.asciiLowerCase(name);                                                              // 58
  return svgCamelCaseElementsMap.hasOwnProperty(lowered) ?                                              // 59
    svgCamelCaseElementsMap[lowered] : lowered;                                                         // 60
};                                                                                                      // 61
                                                                                                        // 62
// See docs for properCaseTagName.                                                                      // 63
HTML.properCaseAttributeName = function (name) {                                                        // 64
  var lowered = HTML.asciiLowerCase(name);                                                              // 65
  return svgCamelCaseAttributesMap.hasOwnProperty(lowered) ?                                            // 66
    svgCamelCaseAttributesMap[lowered] : lowered;                                                       // 67
};                                                                                                      // 68
                                                                                                        // 69
// The HTML spec and the DOM API (in particular `setAttribute`) have different                          // 70
// definitions of what characters are legal in an attribute.  The HTML                                  // 71
// parser is extremely permissive (allowing, for example, `<a %=%>`), while                             // 72
// `setAttribute` seems to use something like the XML grammar for names (and                            // 73
// throws an error if a name is invalid, making that attribute unsettable).                             // 74
// If we knew exactly what grammar browsers used for `setAttribute`, we could                           // 75
// include various Unicode ranges in what's legal.  For now, allow ASCII chars                          // 76
// that are known to be valid XML, valid HTML, and settable via `setAttribute`:                         // 77
//                                                                                                      // 78
// * Starts with `:`, `_`, `A-Z` or `a-z`                                                               // 79
// * Consists of any of those plus `-`, `.`, and `0-9`.                                                 // 80
//                                                                                                      // 81
// See <http://www.w3.org/TR/REC-xml/#NT-Name> and                                                      // 82
// <http://dev.w3.org/html5/markup/syntax.html#syntax-attributes>.                                      // 83
HTML.isValidAttributeName = function (name) {                                                           // 84
  return /^[:_A-Za-z][:_A-Za-z0-9.\-]*/.test(name);                                                     // 85
};                                                                                                      // 86
                                                                                                        // 87
                                                                                                        // 88
HTML.knownElementNames = 'a abbr acronym address applet area b base basefont bdo big blockquote body br button caption center cite code col colgroup dd del dfn dir div dl dt em fieldset font form frame frameset h1 h2 h3 h4 h5 h6 head hr html i iframe img input ins isindex kbd label legend li link map menu meta noframes noscript object ol optgroup option p param pre q s samp script select small span strike strong style sub sup table tbody td textarea tfoot th thead title tr tt u ul var article aside audio bdi canvas command data datagrid datalist details embed eventsource figcaption figure footer header hgroup keygen mark meter nav output progress ruby rp rt section source summary time track video wbr'.split(' ');
                                                                                                        // 90
HTML.voidElementNames = 'area base br col command embed hr img input keygen link meta param source track wbr'.split(' ');
                                                                                                        // 92
HTML.knownSVGElementNames = 'a altGlyph altGlyphDef altGlyphItem animate animateColor animateMotion animateTransform circle clipPath color-profile cursor defs desc ellipse feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence filter font font-face font-face-format font-face-name font-face-src font-face-uri foreignObject g glyph glyphRef hkern image line linearGradient marker mask metadata missing-glyph path pattern polygon polyline radialGradient rect script set stop style svg switch symbol text textPath title tref tspan use view vkern'.split(' ');
                                                                                                        // 94
var YES = {yes:true};                                                                                   // 95
var makeSet = function (array) {                                                                        // 96
  var set = {};                                                                                         // 97
  for (var i = 0; i < array.length; i++)                                                                // 98
    set[array[i]] = YES;                                                                                // 99
  return set;                                                                                           // 100
};                                                                                                      // 101
                                                                                                        // 102
var voidElementSet = makeSet(HTML.voidElementNames);                                                    // 103
var knownElementSet = makeSet(HTML.knownElementNames);                                                  // 104
var knownSVGElementSet = makeSet(HTML.knownSVGElementNames);                                            // 105
                                                                                                        // 106
HTML.isKnownElement = function (name) {                                                                 // 107
  return knownElementSet[HTML.properCaseTagName(name)] === YES;                                         // 108
};                                                                                                      // 109
                                                                                                        // 110
HTML.isVoidElement = function (name) {                                                                  // 111
  return voidElementSet[HTML.properCaseTagName(name)] === YES;                                          // 112
};                                                                                                      // 113
                                                                                                        // 114
HTML.isKnownSVGElement = function (name) {                                                              // 115
  return knownSVGElementSet[HTML.properCaseTagName(name)] === YES;                                      // 116
};                                                                                                      // 117
                                                                                                        // 118
//////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                      //
// packages/htmljs/html.js                                                                              //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                        //
                                                                                                        // 1
// Tag instances are `instanceof HTML.Tag`.                                                             // 2
//                                                                                                      // 3
// This is a private constructor.  Internally, we set                                                   // 4
// `HTML.P.prototype = new HTML.Tag("P")`.                                                              // 5
HTML.Tag = function (tagName) {                                                                         // 6
  this.tagName = tagName;                                                                               // 7
  this.attrs = null;                                                                                    // 8
  this.children = [];                                                                                   // 9
};                                                                                                      // 10
                                                                                                        // 11
// Call all functions and instantiate all components, when fine-grained                                 // 12
// reactivity is not needed (for example, in attributes).                                               // 13
HTML.evaluate = function (node, parentComponent) {                                                      // 14
  if (node == null) {                                                                                   // 15
    return node;                                                                                        // 16
  } else if (typeof node === 'function') {                                                              // 17
    return HTML.evaluate(node(), parentComponent);                                                      // 18
  } else if (node instanceof Array) {                                                                   // 19
    var result = [];                                                                                    // 20
    for (var i = 0; i < node.length; i++)                                                               // 21
      result.push(HTML.evaluate(node[i], parentComponent));                                             // 22
    return result;                                                                                      // 23
  } else if (typeof node.instantiate === 'function') {                                                  // 24
    // component                                                                                        // 25
    var instance = node.instantiate(parentComponent || null);                                           // 26
    var content = instance.render('STATIC');                                                            // 27
    return HTML.evaluate(content, instance);                                                            // 28
  }  else if (node instanceof HTML.Tag) {                                                               // 29
    var newChildren = [];                                                                               // 30
    for (var i = 0; i < node.children.length; i++)                                                      // 31
      newChildren.push(HTML.evaluate(node.children[i], parentComponent));                               // 32
    var newTag = HTML.getTag(node.tagName).apply(null, newChildren);                                    // 33
    newTag.attrs = {};                                                                                  // 34
    for (var k in node.attrs)                                                                           // 35
      newTag.attrs[k] = HTML.evaluate(node.attrs[k], parentComponent);                                  // 36
    return newTag;                                                                                      // 37
  } else {                                                                                              // 38
    return node;                                                                                        // 39
  }                                                                                                     // 40
};                                                                                                      // 41
                                                                                                        // 42
var extendAttrs = function (tgt, src, parentComponent) {                                                // 43
  for (var k in src) {                                                                                  // 44
    if (k === '$dynamic')                                                                               // 45
      continue;                                                                                         // 46
    if (! HTML.isValidAttributeName(k))                                                                 // 47
      throw new Error("Illegal HTML attribute name: " + k);                                             // 48
    var value = HTML.evaluate(src[k], parentComponent);                                                 // 49
    if (! HTML.isNully(value))                                                                          // 50
      tgt[k] = value;                                                                                   // 51
  }                                                                                                     // 52
};                                                                                                      // 53
                                                                                                        // 54
// Process the `attrs.$dynamic` directive, if present, returning the final                              // 55
// attributes dictionary.  The value of `attrs.$dynamic` must be an array                               // 56
// of attributes dictionaries or functions returning attribute dictionaries.                            // 57
// These attributes are used to extend `attrs` as long as they are non-nully.                           // 58
// All attributes are "evaluated," calling functions and instantiating                                  // 59
// components.                                                                                          // 60
HTML.evaluateAttributes = function (attrs, parentComponent) {                                           // 61
  if (! attrs)                                                                                          // 62
    return attrs;                                                                                       // 63
                                                                                                        // 64
  var result = {};                                                                                      // 65
  extendAttrs(result, attrs, parentComponent);                                                          // 66
                                                                                                        // 67
  if ('$dynamic' in attrs) {                                                                            // 68
    if (! (attrs.$dynamic instanceof Array))                                                            // 69
      throw new Error("$dynamic must be an array");                                                     // 70
    // iterate over attrs.$dynamic, calling each element if it                                          // 71
    // is a function and then using it to extend `result`.                                              // 72
    var dynamics = attrs.$dynamic;                                                                      // 73
    for (var i = 0; i < dynamics.length; i++) {                                                         // 74
      var moreAttrs = dynamics[i];                                                                      // 75
      if (typeof moreAttrs === 'function')                                                              // 76
        moreAttrs = moreAttrs();                                                                        // 77
      extendAttrs(result, moreAttrs, parentComponent);                                                  // 78
    }                                                                                                   // 79
  }                                                                                                     // 80
                                                                                                        // 81
  return result;                                                                                        // 82
};                                                                                                      // 83
                                                                                                        // 84
HTML.Tag.prototype.evaluateAttributes = function (parentComponent) {                                    // 85
  return HTML.evaluateAttributes(this.attrs, parentComponent);                                          // 86
};                                                                                                      // 87
                                                                                                        // 88
// Given "P" create the function `HTML.P`.                                                              // 89
var makeTagConstructor = function (tagName) {                                                           // 90
  // Do a little dance so that tags print nicely in the Chrome console.                                 // 91
  // First make tag name suitable for insertion into evaluated JS code,                                 // 92
  // for security reasons mainly.                                                                       // 93
  var sanitizedName = String(tagName).replace(                                                          // 94
      /^[^a-zA-Z_]|[^a-zA-Z_0-9]/g, '_') || 'Tag';                                                      // 95
                                                                                                        // 96
  // Generate a constructor function whose name is the tag name.                                        // 97
  // We try to choose generic-sounding variable names in case V8 infers                                 // 98
  // them as type names and they show up in the developer console.                                      // 99
  // HTMLTag is the constructor function for our specific tag type.                                     // 100
  var HTMLTag = (new Function(                                                                          // 101
    '_constructTag',                                                                                    // 102
    'var Tag; return (Tag = function ' +                                                                // 103
      sanitizedName + '_Tag(/*arguments*/) { ' +                                                        // 104
      'return _constructTag(Tag, this, arguments); });'))(_constructTag);                               // 105
                                                                                                        // 106
  HTMLTag.prototype = new HTML.Tag(tagName);                                                            // 107
  HTMLTag.prototype.constructor = HTMLTag;                                                              // 108
                                                                                                        // 109
  return HTMLTag;                                                                                       // 110
};                                                                                                      // 111
                                                                                                        // 112
// Given "P", create and assign `HTML.P` if it doesn't already exist.                                   // 113
// Then return it.                                                                                      // 114
HTML.getTag = function (tagName) {                                                                      // 115
  tagName = tagName.toUpperCase();                                                                      // 116
                                                                                                        // 117
  if (! HTML[tagName])                                                                                  // 118
    HTML[tagName] = makeTagConstructor(tagName);                                                        // 119
                                                                                                        // 120
  return HTML[tagName];                                                                                 // 121
};                                                                                                      // 122
                                                                                                        // 123
// Given "P", make sure `HTML.P` exists.                                                                // 124
HTML.ensureTag = function (tagName) {                                                                   // 125
  HTML.getTag(tagName); // don't return it                                                              // 126
};                                                                                                      // 127
                                                                                                        // 128
// When you call either `HTML.P(...)` or `new HTML.P(...)`,                                             // 129
// this function handles the actual implementation.                                                     // 130
var _constructTag = function (constructor, instance, args) {                                            // 131
  if (! (instance instanceof HTML.Tag)) {                                                               // 132
    // If you called `HTML.P(...)` without `new`, we don't actually                                     // 133
    // have an instance in `this`.  Create one by calling `new HTML.P`                                  // 134
    // with no arguments (which will invoke `_constructTag` reentrantly,                                // 135
    // but doing essentially nothing).                                                                  // 136
    instance = new constructor;                                                                         // 137
  }                                                                                                     // 138
                                                                                                        // 139
  var i = 0;                                                                                            // 140
  var attrs = (args.length && args[0]);                                                                 // 141
  if (attrs && (typeof attrs === 'object') &&                                                           // 142
      (attrs.constructor === Object)) {                                                                 // 143
    instance.attrs = attrs;                                                                             // 144
    i++;                                                                                                // 145
  }                                                                                                     // 146
  instance.children = Array.prototype.slice.call(args, i);                                              // 147
                                                                                                        // 148
  return instance;                                                                                      // 149
};                                                                                                      // 150
                                                                                                        // 151
HTML.CharRef = function (attrs) {                                                                       // 152
  if (! (this instanceof HTML.CharRef))                                                                 // 153
    // called without `new`                                                                             // 154
    return new HTML.CharRef(attrs);                                                                     // 155
                                                                                                        // 156
  if (! (attrs && attrs.html && attrs.str))                                                             // 157
    throw new Error(                                                                                    // 158
      "HTML.CharRef must be constructed with ({html:..., str:...})");                                   // 159
                                                                                                        // 160
  this.html = attrs.html;                                                                               // 161
  this.str = attrs.str;                                                                                 // 162
};                                                                                                      // 163
                                                                                                        // 164
HTML.Comment = function (value) {                                                                       // 165
  if (! (this instanceof HTML.Comment))                                                                 // 166
    // called without `new`                                                                             // 167
    return new HTML.Comment(value);                                                                     // 168
                                                                                                        // 169
  if (typeof value !== 'string')                                                                        // 170
    throw new Error('HTML.Comment must be constructed with a string');                                  // 171
                                                                                                        // 172
  this.value = value;                                                                                   // 173
  // Kill illegal hyphens in comment value (no way to escape them in HTML)                              // 174
  this.sanitizedValue = value.replace(/^-|--+|-$/g, '');                                                // 175
};                                                                                                      // 176
                                                                                                        // 177
HTML.Raw = function (value) {                                                                           // 178
  if (! (this instanceof HTML.Raw))                                                                     // 179
    // called without `new`                                                                             // 180
    return new HTML.Raw(value);                                                                         // 181
                                                                                                        // 182
  if (typeof value !== 'string')                                                                        // 183
    throw new Error('HTML.Raw must be constructed with a string');                                      // 184
                                                                                                        // 185
  this.value = value;                                                                                   // 186
};                                                                                                      // 187
                                                                                                        // 188
HTML.EmitCode = function (value) {                                                                      // 189
  if (! (this instanceof HTML.EmitCode))                                                                // 190
    // called without `new`                                                                             // 191
    return new HTML.EmitCode(value);                                                                    // 192
                                                                                                        // 193
  if (typeof value !== 'string')                                                                        // 194
    throw new Error('HTML.EmitCode must be constructed with a string');                                 // 195
                                                                                                        // 196
  this.value = value;                                                                                   // 197
};                                                                                                      // 198
                                                                                                        // 199
HTML.isTagEnsured = function (t) {                                                                      // 200
  return HTML.isKnownElement(t) || HTML.isKnownSVGElement(t);                                           // 201
};                                                                                                      // 202
                                                                                                        // 203
(function () {                                                                                          // 204
  for (var i = 0; i < HTML.knownElementNames.length; i++)                                               // 205
    HTML.ensureTag(HTML.knownElementNames[i]);                                                          // 206
                                                                                                        // 207
  for (var i = 0; i < HTML.knownSVGElementNames.length; i++)                                            // 208
    HTML.ensureTag(HTML.knownSVGElementNames[i]);                                                       // 209
})();                                                                                                   // 210
                                                                                                        // 211
//////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                      //
// packages/htmljs/tohtml.js                                                                            //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                        //
                                                                                                        // 1
HTML.toHTML = function (node, parentComponent) {                                                        // 2
  if (node == null) {                                                                                   // 3
    // null or undefined                                                                                // 4
    return '';                                                                                          // 5
  } else if ((typeof node === 'string') || (typeof node === 'boolean') || (typeof node === 'number')) { // 6
    // string; escape special chars                                                                     // 7
    return HTML.escapeData(String(node));                                                               // 8
  } else if (node instanceof Array) {                                                                   // 9
    // array                                                                                            // 10
    var parts = [];                                                                                     // 11
    for (var i = 0; i < node.length; i++)                                                               // 12
      parts.push(HTML.toHTML(node[i], parentComponent));                                                // 13
    return parts.join('');                                                                              // 14
  } else if (typeof node.instantiate === 'function') {                                                  // 15
    // component                                                                                        // 16
    var instance = node.instantiate(parentComponent || null);                                           // 17
    var content = instance.render('STATIC');                                                            // 18
    // recurse with a new value for parentComponent                                                     // 19
    return HTML.toHTML(content, instance);                                                              // 20
  } else if (typeof node === 'function') {                                                              // 21
    return HTML.toHTML(node(), parentComponent);                                                        // 22
  } else if (node.toHTML) {                                                                             // 23
    // Tag or something else                                                                            // 24
    return node.toHTML(parentComponent);                                                                // 25
  } else {                                                                                              // 26
    throw new Error("Expected tag, string, array, component, null, undefined, or " +                    // 27
                    "object with a toHTML method; found: " + node);                                     // 28
  }                                                                                                     // 29
};                                                                                                      // 30
                                                                                                        // 31
HTML.Comment.prototype.toHTML = function () {                                                           // 32
  return '<!--' + this.sanitizedValue + '-->';                                                          // 33
};                                                                                                      // 34
                                                                                                        // 35
HTML.CharRef.prototype.toHTML = function () {                                                           // 36
  return this.html;                                                                                     // 37
};                                                                                                      // 38
                                                                                                        // 39
HTML.Raw.prototype.toHTML = function () {                                                               // 40
  return this.value;                                                                                    // 41
};                                                                                                      // 42
                                                                                                        // 43
HTML.Tag.prototype.toHTML = function (parentComponent) {                                                // 44
  var attrStrs = [];                                                                                    // 45
  var attrs = this.evaluateAttributes(parentComponent);                                                 // 46
  if (attrs) {                                                                                          // 47
    for (var k in attrs) {                                                                              // 48
      k = HTML.properCaseAttributeName(k);                                                              // 49
      var v = HTML.toText(attrs[k], HTML.TEXTMODE.ATTRIBUTE, parentComponent);                          // 50
      attrStrs.push(' ' + k + '="' + v + '"');                                                          // 51
    }                                                                                                   // 52
  }                                                                                                     // 53
                                                                                                        // 54
  var tagName = this.tagName;                                                                           // 55
  var startTag = '<' + HTML.properCaseTagName(tagName) + attrStrs.join('') + '>';                       // 56
                                                                                                        // 57
  var childStrs = [];                                                                                   // 58
  var content;                                                                                          // 59
  if (tagName === 'TEXTAREA') {                                                                         // 60
    for (var i = 0; i < this.children.length; i++)                                                      // 61
      childStrs.push(HTML.toText(this.children[i], HTML.TEXTMODE.RCDATA, parentComponent));             // 62
                                                                                                        // 63
    content = childStrs.join('');                                                                       // 64
    if (content.slice(0, 1) === '\n')                                                                   // 65
      // TEXTAREA will absorb a newline, so if we see one, add                                          // 66
      // another one.                                                                                   // 67
      content = '\n' + content;                                                                         // 68
                                                                                                        // 69
  } else {                                                                                              // 70
    for (var i = 0; i < this.children.length; i++)                                                      // 71
      childStrs.push(HTML.toHTML(this.children[i], parentComponent));                                   // 72
                                                                                                        // 73
    content = childStrs.join('');                                                                       // 74
  }                                                                                                     // 75
                                                                                                        // 76
  var result = startTag + content;                                                                      // 77
                                                                                                        // 78
  if (this.children.length || ! HTML.isVoidElement(tagName)) {                                          // 79
    // "Void" elements like BR are the only ones that don't get a close                                 // 80
    // tag in HTML5.  They shouldn't have contents, either, so we could                                 // 81
    // throw an error upon seeing contents here.                                                        // 82
    result += '</' + HTML.properCaseTagName(tagName) + '>';                                             // 83
  }                                                                                                     // 84
                                                                                                        // 85
  return result;                                                                                        // 86
};                                                                                                      // 87
                                                                                                        // 88
HTML.TEXTMODE = {                                                                                       // 89
  ATTRIBUTE: 1,                                                                                         // 90
  RCDATA: 2,                                                                                            // 91
  STRING: 3                                                                                             // 92
};                                                                                                      // 93
                                                                                                        // 94
HTML.toText = function (node, textMode, parentComponent) {                                              // 95
  if (node == null) {                                                                                   // 96
    // null or undefined                                                                                // 97
    return '';                                                                                          // 98
  } else if ((typeof node === 'string') || (typeof node === 'boolean') || (typeof node === 'number')) { // 99
    node = String(node);                                                                                // 100
    // string                                                                                           // 101
    if (textMode === HTML.TEXTMODE.STRING) {                                                            // 102
      return node;                                                                                      // 103
    } else if (textMode === HTML.TEXTMODE.RCDATA) {                                                     // 104
      return HTML.escapeData(node);                                                                     // 105
    } else if (textMode === HTML.TEXTMODE.ATTRIBUTE) {                                                  // 106
      // escape `&` and `"` this time, not `&` and `<`                                                  // 107
      return node.replace(/&/g, '&amp;').replace(/"/g, '&quot;');                                       // 108
    } else {                                                                                            // 109
      throw new Error("Unknown TEXTMODE: " + textMode);                                                 // 110
    }                                                                                                   // 111
  } else if (node instanceof Array) {                                                                   // 112
    // array                                                                                            // 113
    var parts = [];                                                                                     // 114
    for (var i = 0; i < node.length; i++)                                                               // 115
      parts.push(HTML.toText(node[i], textMode, parentComponent));                                      // 116
    return parts.join('');                                                                              // 117
  } else if (typeof node === 'function') {                                                              // 118
    return HTML.toText(node(), textMode, parentComponent);                                              // 119
  } else if (typeof node.instantiate === 'function') {                                                  // 120
    // component                                                                                        // 121
    var instance = node.instantiate(parentComponent || null);                                           // 122
    var content = instance.render('STATIC');                                                            // 123
    return HTML.toText(content, textMode, instance);                                                    // 124
  } else if (node.toText) {                                                                             // 125
    // Something else                                                                                   // 126
    return node.toText(textMode, parentComponent);                                                      // 127
  } else {                                                                                              // 128
    throw new Error("Expected tag, string, array, component, null, undefined, or " +                    // 129
                    "object with a toText method; found: " + node);                                     // 130
  }                                                                                                     // 131
                                                                                                        // 132
};                                                                                                      // 133
                                                                                                        // 134
HTML.Raw.prototype.toText = function () {                                                               // 135
  return this.value;                                                                                    // 136
};                                                                                                      // 137
                                                                                                        // 138
// used when including templates within {{#markdown}}                                                   // 139
HTML.Tag.prototype.toText = function (textMode, parentComponent) {                                      // 140
  if (textMode === HTML.TEXTMODE.STRING)                                                                // 141
    // stringify the tag as HTML, then convert to text                                                  // 142
    return HTML.toText(this.toHTML(parentComponent), textMode);                                         // 143
  else                                                                                                  // 144
    throw new Error("Can't insert tags in attributes or TEXTAREA elements");                            // 145
};                                                                                                      // 146
                                                                                                        // 147
HTML.CharRef.prototype.toText = function (textMode) {                                                   // 148
  if (textMode === HTML.TEXTMODE.STRING)                                                                // 149
    return this.str;                                                                                    // 150
  else if (textMode === HTML.TEXTMODE.RCDATA)                                                           // 151
    return this.html;                                                                                   // 152
  else if (textMode === HTML.TEXTMODE.ATTRIBUTE)                                                        // 153
    return this.html;                                                                                   // 154
  else                                                                                                  // 155
    throw new Error("Unknown TEXTMODE: " + textMode);                                                   // 156
};                                                                                                      // 157
                                                                                                        // 158
//////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.htmljs = {
  HTML: HTML
};

})();

//# sourceMappingURL=9f120d9b73379b8d2e9df885740cb330fd6eb244.map


//--------- ui.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var $ = Package.jquery.$;
var jQuery = Package.jquery.jQuery;
var Deps = Package.deps.Deps;
var Random = Package.random.Random;
var EJSON = Package.ejson.EJSON;
var _ = Package.underscore._;
var OrderedDict = Package['ordered-dict'].OrderedDict;
var LocalCollection = Package.minimongo.LocalCollection;
var Minimongo = Package.minimongo.Minimongo;
var ObserveSequence = Package['observe-sequence'].ObserveSequence;
var HTML = Package.htmljs.HTML;

/* Package-scope variables */
var UI, Handlebars, reportUIException, _extend, Component, findComponentWithProp, getComponentData, updateTemplateInstance, AttributeHandler, makeAttributeHandler;

(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                      //
// packages/ui/exceptions.js                                                                            //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                        //
                                                                                                        // 1
var debugFunc;                                                                                          // 2
                                                                                                        // 3
// Meteor UI calls into user code in many places, and it's nice to catch exceptions                     // 4
// propagated from user code immediately so that the whole system doesn't just                          // 5
// break.  Catching exceptions is easy; reporting them is hard.  This helper                            // 6
// reports exceptions.                                                                                  // 7
//                                                                                                      // 8
// Usage:                                                                                               // 9
//                                                                                                      // 10
// ```                                                                                                  // 11
// try {                                                                                                // 12
//   // ... someStuff ...                                                                               // 13
// } catch (e) {                                                                                        // 14
//   reportUIException(e);                                                                              // 15
// }                                                                                                    // 16
// ```                                                                                                  // 17
//                                                                                                      // 18
// An optional second argument overrides the default message.                                           // 19
                                                                                                        // 20
reportUIException = function (e, msg) {                                                                 // 21
  if (! debugFunc)                                                                                      // 22
    // adapted from Deps                                                                                // 23
    debugFunc = function () {                                                                           // 24
      return (typeof Meteor !== "undefined" ? Meteor._debug :                                           // 25
              ((typeof console !== "undefined") && console.log ? console.log :                          // 26
               function () {}));                                                                        // 27
    };                                                                                                  // 28
                                                                                                        // 29
  // In Chrome, `e.stack` is a multiline string that starts with the message                            // 30
  // and contains a stack trace.  Furthermore, `console.log` makes it clickable.                        // 31
  // `console.log` supplies the space between the two arguments.                                        // 32
  debugFunc()(msg || 'Exception in Meteor UI:', e.stack || e.message);                                  // 33
};                                                                                                      // 34
                                                                                                        // 35
//////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                      //
// packages/ui/base.js                                                                                  //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                        //
UI = {};                                                                                                // 1
                                                                                                        // 2
// A very basic operation like Underscore's `_.extend` that                                             // 3
// copies `src`'s own, enumerable properties onto `tgt` and                                             // 4
// returns `tgt`.                                                                                       // 5
_extend = function (tgt, src) {                                                                         // 6
  for (var k in src)                                                                                    // 7
    if (src.hasOwnProperty(k))                                                                          // 8
      tgt[k] = src[k];                                                                                  // 9
  return tgt;                                                                                           // 10
};                                                                                                      // 11
                                                                                                        // 12
// Defines a single non-enumerable, read-only property                                                  // 13
// on `tgt`.                                                                                            // 14
// It won't be non-enumerable in IE 8, so its                                                           // 15
// non-enumerability can't be relied on for logic                                                       // 16
// purposes, it just makes things prettier in                                                           // 17
// the dev console.                                                                                     // 18
var _defineNonEnum = function (tgt, name, value) {                                                      // 19
  try {                                                                                                 // 20
    Object.defineProperty(tgt, name, {value: value});                                                   // 21
  } catch (e) {                                                                                         // 22
    // IE < 9                                                                                           // 23
    tgt[name] = value;                                                                                  // 24
  }                                                                                                     // 25
  return tgt;                                                                                           // 26
};                                                                                                      // 27
                                                                                                        // 28
// Make `typeName` a non-empty string starting with an ASCII                                            // 29
// letter or underscore and containing only letters, underscores,                                       // 30
// and numbers.  This makes it safe to insert into evaled JS                                            // 31
// code.                                                                                                // 32
var sanitizeTypeName = function (typeName) {                                                            // 33
  return String(typeName).replace(/^[^a-zA-Z_]|[^a-zA-Z_0-9]+/g,                                        // 34
                                  '') || 'Component';                                                   // 35
};                                                                                                      // 36
                                                                                                        // 37
// Named function (like `function Component() {}` below) make                                           // 38
// inspection in debuggers more descriptive. In IE, this sets the                                       // 39
// value of the `Component` var in the function scope in which it's                                     // 40
// executed. We already have a top-level `Component` var so we create                                   // 41
// a new function scope to not write it over in IE.                                                     // 42
(function () {                                                                                          // 43
                                                                                                        // 44
  // Components and Component kinds are the same thing, just                                            // 45
  // objects; there are no constructor functions, no `new`,                                             // 46
  // and no `instanceof`.  A Component object is like a class,                                          // 47
  // until it is inited, at which point it becomes more like                                            // 48
  // an instance.                                                                                       // 49
  //                                                                                                    // 50
  // `y = x.extend({ ...new props })` creates a new Component                                           // 51
  // `y` with `x` as its prototype, plus additional properties                                          // 52
  // on `y` itself.  `extend` is used both to subclass and to                                           // 53
  // create instances (and the hope is we can gloss over the                                            // 54
  // difference in the docs).                                                                           // 55
  UI.Component = (function (constr) {                                                                   // 56
                                                                                                        // 57
    // Make sure the "class name" that Chrome infers for                                                // 58
    // UI.Component is "Component", and that                                                            // 59
    // `new UI.Component._constr` (which is what `extend`                                               // 60
    // does) also produces objects whose inferred class                                                 // 61
    // name is "Component".  Chrome's name inference rules                                              // 62
    // are a little mysterious, but a function name in                                                  // 63
    // the source code (as in `function Component() {}`)                                                // 64
    // seems to be reliable and high precedence.                                                        // 65
    var C = new constr;                                                                                 // 66
    _defineNonEnum(C, '_constr', constr);                                                               // 67
    _defineNonEnum(C, '_super', null);                                                                  // 68
    return C;                                                                                           // 69
  })(function Component() {});                                                                          // 70
})();                                                                                                   // 71
                                                                                                        // 72
_extend(UI, {                                                                                           // 73
  nextGuid: 2, // Component is 1!                                                                       // 74
                                                                                                        // 75
  isComponent: function (obj) {                                                                         // 76
    return obj && UI.isKindOf(obj, UI.Component);                                                       // 77
  },                                                                                                    // 78
  // `UI.isKindOf(a, b)` where `a` and `b` are Components                                               // 79
  // (or kinds) asks if `a` is or descends from                                                         // 80
  // (transitively extends) `b`.                                                                        // 81
  isKindOf: function (a, b) {                                                                           // 82
    while (a) {                                                                                         // 83
      if (a === b)                                                                                      // 84
        return true;                                                                                    // 85
      a = a._super;                                                                                     // 86
    }                                                                                                   // 87
    return false;                                                                                       // 88
  },                                                                                                    // 89
  // use these to produce error messages for developers                                                 // 90
  // (though throwing a more specific error message is                                                  // 91
  // even better)                                                                                       // 92
  _requireNotDestroyed: function (c) {                                                                  // 93
    if (c.isDestroyed)                                                                                  // 94
      throw new Error("Component has been destroyed; can't perform this operation");                    // 95
  },                                                                                                    // 96
  _requireInited: function (c) {                                                                        // 97
    if (! c.isInited)                                                                                   // 98
      throw new Error("Component must be inited to perform this operation");                            // 99
  },                                                                                                    // 100
  _requireDom: function (c) {                                                                           // 101
    if (! c.dom)                                                                                        // 102
      throw new Error("Component must be built into DOM to perform this operation");                    // 103
  }                                                                                                     // 104
});                                                                                                     // 105
                                                                                                        // 106
Component = UI.Component;                                                                               // 107
                                                                                                        // 108
_extend(UI.Component, {                                                                                 // 109
  // If a Component has a `kind` property set via `extend`,                                             // 110
  // we make it use that name when printed in Chrome Dev Tools.                                         // 111
  // If you then extend this Component and don't supply any                                             // 112
  // new `kind`, it should use the same value of kind (or the                                           // 113
  // most specific one in the case of an `extend` chain with                                            // 114
  // `kind` set at multiple points).                                                                    // 115
  //                                                                                                    // 116
  // To accomplish this, keeping performance in mind,                                                   // 117
  // any Component where `kind` is explicitly set                                                       // 118
  // also has a function property `_constr` whose source-code                                           // 119
  // name is `kind`.  `extend` creates this `_constr`                                                   // 120
  // function, which can then be used internally as a                                                   // 121
  // constructor to quickly create new instances that                                                   // 122
  // pretty-print correctly.                                                                            // 123
  kind: "Component",                                                                                    // 124
  guid: "1",                                                                                            // 125
  dom: null,                                                                                            // 126
  // Has this Component ever been inited?                                                               // 127
  isInited: false,                                                                                      // 128
  // Has this Component been destroyed?  Only inited Components                                         // 129
  // can be destroyed.                                                                                  // 130
  isDestroyed: false,                                                                                   // 131
  // Component that created this component (typically also                                              // 132
  // the DOM containment parent).                                                                       // 133
  // No child pointers (except in `dom`).                                                               // 134
  parent: null,                                                                                         // 135
                                                                                                        // 136
  // create a new subkind or instance whose proto pointer                                               // 137
  // points to this, with additional props set.                                                         // 138
  extend: function (props) {                                                                            // 139
    // this function should never cause `props` to be                                                   // 140
    // mutated in case people want to reuse `props` objects                                             // 141
    // in a mixin-like way.                                                                             // 142
                                                                                                        // 143
    if (this.isInited)                                                                                  // 144
      // Disallow extending inited Components so that                                                   // 145
      // inited Components don't inherit instance-specific                                              // 146
      // properties from other inited Components, just                                                  // 147
      // default values.                                                                                // 148
      throw new Error("Can't extend an inited Component");                                              // 149
                                                                                                        // 150
    var constr;                                                                                         // 151
    var constrMade = false;                                                                             // 152
    // Any Component with a kind of "Foo" (say) is given                                                // 153
    // a `._constr` of the form `function Foo() {}`.                                                    // 154
    if (props && props.kind) {                                                                          // 155
      constr = Function("return function " +                                                            // 156
                        sanitizeTypeName(props.kind) +                                                  // 157
                        "() {};")();                                                                    // 158
      constrMade = true;                                                                                // 159
    } else {                                                                                            // 160
      constr = this._constr;                                                                            // 161
    }                                                                                                   // 162
                                                                                                        // 163
    // We don't know where we're getting `constr` from --                                               // 164
    // it might be from some supertype -- just that it has                                              // 165
    // the right function name.  So set the `prototype`                                                 // 166
    // property each time we use it as a constructor.                                                   // 167
    constr.prototype = this;                                                                            // 168
                                                                                                        // 169
    var c = new constr;                                                                                 // 170
    if (constrMade)                                                                                     // 171
      c._constr = constr;                                                                               // 172
                                                                                                        // 173
    if (props)                                                                                          // 174
      _extend(c, props);                                                                                // 175
                                                                                                        // 176
    // for efficient Component instantiations, we assign                                                // 177
    // as few things as possible here.                                                                  // 178
    _defineNonEnum(c, '_super', this);                                                                  // 179
    c.guid = String(UI.nextGuid++);                                                                     // 180
                                                                                                        // 181
    return c;                                                                                           // 182
  }                                                                                                     // 183
});                                                                                                     // 184
                                                                                                        // 185
//callChainedCallback = function (comp, propName, orig) {                                               // 186
  // Call `comp.foo`, `comp._super.foo`,                                                                // 187
  // `comp._super._super.foo`, and so on, but in reverse                                                // 188
  // order, and only if `foo` is an "own property" in each                                              // 189
  // case.  Furthermore, the passed value of `this` should                                              // 190
  // remain `comp` for all calls (which is achieved by                                                  // 191
  // filling in `orig` when recursing).                                                                 // 192
//  if (comp._super)                                                                                    // 193
//    callChainedCallback(comp._super, propName, orig || comp);                                         // 194
//                                                                                                      // 195
//  if (comp.hasOwnProperty(propName))                                                                  // 196
//    comp[propName].call(orig || comp);                                                                // 197
//};                                                                                                    // 198
                                                                                                        // 199
                                                                                                        // 200
// Returns 0 if the nodes are the same or either one contains the other;                                // 201
// otherwise, -1 if a comes before b, or else 1 if b comes before a in                                  // 202
// document order.                                                                                      // 203
// Requires: `a` and `b` are element nodes in the same document tree.                                   // 204
var compareElementIndex = function (a, b) {                                                             // 205
  // See http://ejohn.org/blog/comparing-document-position/                                             // 206
  if (a === b)                                                                                          // 207
    return 0;                                                                                           // 208
  if (a.compareDocumentPosition) {                                                                      // 209
    var n = a.compareDocumentPosition(b);                                                               // 210
    return ((n & 0x18) ? 0 : ((n & 0x4) ? -1 : 1));                                                     // 211
  } else {                                                                                              // 212
    // Only old IE is known to not have compareDocumentPosition (though Safari                          // 213
    // originally lacked it).  Thankfully, IE gives us a way of comparing elements                      // 214
    // via the "sourceIndex" property.                                                                  // 215
    if (a.contains(b) || b.contains(a))                                                                 // 216
      return 0;                                                                                         // 217
    return (a.sourceIndex < b.sourceIndex ? -1 : 1);                                                    // 218
  }                                                                                                     // 219
};                                                                                                      // 220
                                                                                                        // 221
findComponentWithProp = function (id, comp) {                                                           // 222
  while (comp) {                                                                                        // 223
    if (typeof comp[id] !== 'undefined')                                                                // 224
      return comp;                                                                                      // 225
    comp = comp.parent;                                                                                 // 226
  }                                                                                                     // 227
  return null;                                                                                          // 228
};                                                                                                      // 229
                                                                                                        // 230
getComponentData = function (comp) {                                                                    // 231
  comp = findComponentWithProp('data', comp);                                                           // 232
  return (comp ?                                                                                        // 233
          (typeof comp.data === 'function' ?                                                            // 234
           comp.data() : comp.data) :                                                                   // 235
          null);                                                                                        // 236
};                                                                                                      // 237
                                                                                                        // 238
updateTemplateInstance = function (comp) {                                                              // 239
  // Populate `comp.templateInstance.{firstNode,lastNode,data}`                                         // 240
  // on demand.                                                                                         // 241
  var tmpl = comp.templateInstance;                                                                     // 242
  tmpl.data = getComponentData(comp);                                                                   // 243
                                                                                                        // 244
  if (comp.dom && !comp.isDestroyed) {                                                                  // 245
    tmpl.firstNode = comp.dom.startNode().nextSibling;                                                  // 246
    tmpl.lastNode = comp.dom.endNode().previousSibling;                                                 // 247
    // Catch the case where the DomRange is empty and we'd                                              // 248
    // otherwise pass the out-of-order nodes (end, start)                                               // 249
    // as (firstNode, lastNode).                                                                        // 250
    if (tmpl.lastNode && tmpl.lastNode.nextSibling === tmpl.firstNode)                                  // 251
      tmpl.lastNode = tmpl.firstNode;                                                                   // 252
  } else {                                                                                              // 253
    // on 'created' or 'destroyed' callbacks we don't have a DomRange                                   // 254
    tmpl.firstNode = null;                                                                              // 255
    tmpl.lastNode = null;                                                                               // 256
  }                                                                                                     // 257
};                                                                                                      // 258
                                                                                                        // 259
_extend(UI.Component, {                                                                                 // 260
  // We implement the old APIs here, including how data is passed                                       // 261
  // to helpers in `this`.                                                                              // 262
  helpers: function (dict) {                                                                            // 263
    _extend(this, dict);                                                                                // 264
  },                                                                                                    // 265
  events: function (dict) {                                                                             // 266
    var events;                                                                                         // 267
    if (this.hasOwnProperty('_events'))                                                                 // 268
      events = this._events;                                                                            // 269
    else                                                                                                // 270
      events = (this._events = []);                                                                     // 271
                                                                                                        // 272
    _.each(dict, function (handler, spec) {                                                             // 273
      var clauses = spec.split(/,\s+/);                                                                 // 274
      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']                                // 275
      _.each(clauses, function (clause) {                                                               // 276
        var parts = clause.split(/\s+/);                                                                // 277
        if (parts.length === 0)                                                                         // 278
          return;                                                                                       // 279
                                                                                                        // 280
        var newEvents = parts.shift();                                                                  // 281
        var selector = parts.join(' ');                                                                 // 282
        events.push({events: newEvents,                                                                 // 283
                     selector: selector,                                                                // 284
                     handler: handler});                                                                // 285
      });                                                                                               // 286
    });                                                                                                 // 287
  }                                                                                                     // 288
});                                                                                                     // 289
                                                                                                        // 290
// XXX we don't really want this to be a user-visible callback,                                         // 291
// it's just a particular signal we need from DomRange.                                                 // 292
UI.Component.notifyParented = function () {                                                             // 293
  var self = this;                                                                                      // 294
  for (var comp = self; comp; comp = comp._super) {                                                     // 295
    var events = (comp.hasOwnProperty('_events') && comp._events) || null;                              // 296
    if ((! events) && comp.hasOwnProperty('events') &&                                                  // 297
        typeof comp.events === 'object') {                                                              // 298
      // Provide limited back-compat support for `.events = {...}`                                      // 299
      // syntax.  Pass `comp.events` to the original `.events(...)`                                     // 300
      // function.  This code must run only once per component, in                                      // 301
      // order to not bind the handlers more than once, which is                                        // 302
      // ensured by the fact that we only do this when `comp._events`                                   // 303
      // is falsy, and we cause it to be set now.                                                       // 304
      UI.Component.events.call(comp, comp.events);                                                      // 305
      events = comp._events;                                                                            // 306
    }                                                                                                   // 307
    _.each(events, function (esh) { // {events, selector, handler}                                      // 308
      // wrap the handler here, per instance of the template that                                       // 309
      // declares the event map, so we can pass the instance to                                         // 310
      // the event handler.                                                                             // 311
      var wrappedHandler = function (event) {                                                           // 312
        var comp = UI.DomRange.getContainingComponent(event.currentTarget);                             // 313
        var data = comp && getComponentData(comp);                                                      // 314
        updateTemplateInstance(self);                                                                   // 315
        Deps.nonreactive(function () {                                                                  // 316
          // Don't want to be in a deps context, even if we were somehow                                // 317
          // triggered synchronously in an existing deps context                                        // 318
          // (the `blur` event can do this).                                                            // 319
          // XXX we should probably do what Spark did and block all                                     // 320
          // event handling during our DOM manip.  Many apps had weird                                  // 321
          // unanticipated bugs until we did that.                                                      // 322
          esh.handler.call(data, event, self.templateInstance);                                         // 323
        });                                                                                             // 324
      };                                                                                                // 325
                                                                                                        // 326
      self.dom.on(esh.events, esh.selector, wrappedHandler);                                            // 327
    });                                                                                                 // 328
  }                                                                                                     // 329
                                                                                                        // 330
  // XXX this is an undocumented callback                                                               // 331
  if (self.parented) {                                                                                  // 332
    Deps.nonreactive(function () {                                                                      // 333
      updateTemplateInstance(self);                                                                     // 334
      self.parented.call(self.templateInstance);                                                        // 335
    });                                                                                                 // 336
  }                                                                                                     // 337
                                                                                                        // 338
  if (self.rendered) {                                                                                  // 339
    // Defer rendered callback until flush time.                                                        // 340
    Deps.afterFlush(function () {                                                                       // 341
      if (! self.isDestroyed) {                                                                         // 342
        updateTemplateInstance(self);                                                                   // 343
        self.rendered.call(self.templateInstance);                                                      // 344
      }                                                                                                 // 345
    });                                                                                                 // 346
  }                                                                                                     // 347
};                                                                                                      // 348
                                                                                                        // 349
// past compat                                                                                          // 350
UI.Component.preserve = function () {};                                                                 // 351
                                                                                                        // 352
//////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                      //
// packages/ui/dombackend.js                                                                            //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                        //
if (Meteor.isClient) {                                                                                  // 1
                                                                                                        // 2
  // XXX in the future, make the jQuery adapter a separate                                              // 3
  // package and make the choice of back-end library                                                    // 4
  // configurable.  Adapters all expose the same DomBackend interface.                                  // 5
                                                                                                        // 6
  if (! Package.jquery)                                                                                 // 7
    throw new Error("Meteor UI jQuery adapter: jQuery not found.");                                     // 8
                                                                                                        // 9
  var $jq = Package.jquery.jQuery;                                                                      // 10
                                                                                                        // 11
  var DomBackend = {};                                                                                  // 12
  UI.DomBackend = DomBackend;                                                                           // 13
                                                                                                        // 14
  ///// Removal detection and interoperability.                                                         // 15
                                                                                                        // 16
  // For an explanation of this technique, see:                                                         // 17
  // http://bugs.jquery.com/ticket/12213#comment:23 .                                                   // 18
  //                                                                                                    // 19
  // In short, an element is considered "removed" when jQuery                                           // 20
  // cleans up its *private* userdata on the element,                                                   // 21
  // which we can detect using a custom event with a teardown                                           // 22
  // hook.                                                                                              // 23
                                                                                                        // 24
  var JQUERY_REMOVAL_WATCHER_EVENT_NAME = 'meteor_ui_removal_watcher';                                  // 25
  var REMOVAL_CALLBACKS_PROPERTY_NAME = '$meteor_ui_removal_callbacks';                                 // 26
  var NOOP = function () {};                                                                            // 27
                                                                                                        // 28
  // Causes `elem` (a DOM element) to be detached from its parent, if any.                              // 29
  // Whether or not `elem` was detached, causes any callbacks registered                                // 30
  // with `onRemoveElement` on `elem` and its descendants to fire.                                      // 31
  // Not for use on non-element nodes.                                                                  // 32
  //                                                                                                    // 33
  // This method is modeled after the behavior of jQuery's `$(elem).remove()`,                          // 34
  // which causes teardown on the subtree being removed.                                                // 35
  DomBackend.removeElement = function (elem) {                                                          // 36
    $jq(elem).remove();                                                                                 // 37
  };                                                                                                    // 38
                                                                                                        // 39
  // Registers a callback function to be called when the given element or                               // 40
  // one of its ancestors is removed from the DOM via the backend library.                              // 41
  // The callback function is called at most once, and it receives the element                          // 42
  // in question as an argument.                                                                        // 43
  DomBackend.onRemoveElement = function (elem, func) {                                                  // 44
    if (! elem[REMOVAL_CALLBACKS_PROPERTY_NAME]) {                                                      // 45
      elem[REMOVAL_CALLBACKS_PROPERTY_NAME] = [];                                                       // 46
                                                                                                        // 47
      // Set up the event, only the first time.                                                         // 48
      $jq(elem).on(JQUERY_REMOVAL_WATCHER_EVENT_NAME, NOOP);                                            // 49
    }                                                                                                   // 50
                                                                                                        // 51
    elem[REMOVAL_CALLBACKS_PROPERTY_NAME].push(func);                                                   // 52
  };                                                                                                    // 53
                                                                                                        // 54
  $jq.event.special[JQUERY_REMOVAL_WATCHER_EVENT_NAME] = {                                              // 55
    teardown: function() {                                                                              // 56
      var elem = this;                                                                                  // 57
      var callbacks = elem[REMOVAL_CALLBACKS_PROPERTY_NAME];                                            // 58
      if (callbacks) {                                                                                  // 59
        for (var i = 0; i < callbacks.length; i++)                                                      // 60
          callbacks[i](elem);                                                                           // 61
        elem[REMOVAL_CALLBACKS_PROPERTY_NAME] = null;                                                   // 62
      }                                                                                                 // 63
    }                                                                                                   // 64
  };                                                                                                    // 65
                                                                                                        // 66
  DomBackend.parseHTML = function (html) {                                                              // 67
    // Return an array of nodes.                                                                        // 68
    //                                                                                                  // 69
    // jQuery does fancy stuff like creating an appropriate                                             // 70
    // container element and setting innerHTML on it, as well                                           // 71
    // as working around various IE quirks.                                                             // 72
    return $jq.parseHTML(html) || [];                                                                   // 73
  };                                                                                                    // 74
                                                                                                        // 75
  // Must use jQuery semantics for `context`, not                                                       // 76
  // querySelectorAll's.  In other words, all the parts                                                 // 77
  // of `selector` must be found under `context`.                                                       // 78
  DomBackend.findBySelector = function (selector, context) {                                            // 79
    return $jq.find(selector, context);                                                                 // 80
  };                                                                                                    // 81
                                                                                                        // 82
  DomBackend.newFragment = function (nodeArray) {                                                       // 83
    // jQuery fragments are built specially in                                                          // 84
    // IE<9 so that they can safely hold HTML5                                                          // 85
    // elements.                                                                                        // 86
    return $jq.buildFragment(nodeArray, document);                                                      // 87
  };                                                                                                    // 88
                                                                                                        // 89
  // `selector` is non-null.  `type` is one type (but                                                   // 90
  // may be in backend-specific form, e.g. have namespaces).                                            // 91
  // Order fired must be order bound.                                                                   // 92
  DomBackend.delegateEvents = function (elem, type, selector, handler) {                                // 93
    $jq(elem).on(type, selector, handler);                                                              // 94
  };                                                                                                    // 95
                                                                                                        // 96
  DomBackend.undelegateEvents = function (elem, type, handler) {                                        // 97
    $jq(elem).off(type, handler);                                                                       // 98
  };                                                                                                    // 99
                                                                                                        // 100
  DomBackend.bindEventCapturer = function (elem, type, selector, handler) {                             // 101
    var $elem = $jq(elem);                                                                              // 102
                                                                                                        // 103
    var wrapper = function (event) {                                                                    // 104
      event = $jq.event.fix(event);                                                                     // 105
      event.currentTarget = event.target;                                                               // 106
                                                                                                        // 107
      // Note: It might improve jQuery interop if we called into jQuery                                 // 108
      // here somehow.  Since we don't use jQuery to dispatch the event,                                // 109
      // we don't fire any of jQuery's event hooks or anything.  However,                               // 110
      // since jQuery can't bind capturing handlers, it's not clear                                     // 111
      // where we would hook in.  Internal jQuery functions like `dispatch`                             // 112
      // are too high-level.                                                                            // 113
      var $target = $jq(event.currentTarget);                                                           // 114
      if ($target.is($elem.find(selector)))                                                             // 115
        handler.call(elem, event);                                                                      // 116
    };                                                                                                  // 117
                                                                                                        // 118
    handler._meteorui_wrapper = wrapper;                                                                // 119
                                                                                                        // 120
    type = this.parseEventType(type);                                                                   // 121
    // add *capturing* event listener                                                                   // 122
    elem.addEventListener(type, wrapper, true);                                                         // 123
  };                                                                                                    // 124
                                                                                                        // 125
  DomBackend.unbindEventCapturer = function (elem, type, handler) {                                     // 126
    type = this.parseEventType(type);                                                                   // 127
    elem.removeEventListener(type, handler._meteorui_wrapper, true);                                    // 128
  };                                                                                                    // 129
                                                                                                        // 130
  DomBackend.parseEventType = function (type) {                                                         // 131
    // strip off namespaces                                                                             // 132
    var dotLoc = type.indexOf('.');                                                                     // 133
    if (dotLoc >= 0)                                                                                    // 134
      return type.slice(0, dotLoc);                                                                     // 135
    return type;                                                                                        // 136
  };                                                                                                    // 137
                                                                                                        // 138
}                                                                                                       // 139
//////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                      //
// packages/ui/domrange.js                                                                              //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                        //
// TODO                                                                                                 // 1
// - Lazy removal detection                                                                             // 2
// - UI hooks (expose, test)                                                                            // 3
// - Quick remove/add (mark "leaving" members; needs UI hooks)                                          // 4
// - Event removal on removal                                                                           // 5
// - Event moving on TBODY move                                                                         // 6
                                                                                                        // 7
var DomBackend = UI.DomBackend;                                                                         // 8
                                                                                                        // 9
var removeNode = function (n) {                                                                         // 10
//  if (n.nodeType === 1 &&                                                                             // 11
//      n.parentNode.$uihooks && n.parentNode.$uihooks.removeElement)                                   // 12
//    n.parentNode.$uihooks.removeElement(n);                                                           // 13
//  else                                                                                                // 14
    n.parentNode.removeChild(n);                                                                        // 15
};                                                                                                      // 16
                                                                                                        // 17
var insertNode = function (n, parent, next) {                                                           // 18
//  if (n.nodeType === 1 &&                                                                             // 19
//      parent.$uihooks && parent.$uihooks.insertElement)                                               // 20
//    parent.$uihooks.insertElement(n, parent, next);                                                   // 21
//  else                                                                                                // 22
    // `|| null` because IE throws an error if 'next' is undefined                                      // 23
  parent.insertBefore(n, next || null);                                                                 // 24
};                                                                                                      // 25
                                                                                                        // 26
var moveNode = function (n, parent, next) {                                                             // 27
//  if (n.nodeType === 1 &&                                                                             // 28
//      parent.$uihooks && parent.$uihooks.moveElement)                                                 // 29
//    parent.$uihooks.moveElement(n, parent, next);                                                     // 30
//  else                                                                                                // 31
    // `|| null` because IE throws an error if 'next' is undefined                                      // 32
    parent.insertBefore(n, next || null);                                                               // 33
};                                                                                                      // 34
                                                                                                        // 35
// A very basic operation like Underscore's `_.extend` that                                             // 36
// copies `src`'s own, enumerable properties onto `tgt` and                                             // 37
// returns `tgt`.                                                                                       // 38
var _extend = function (tgt, src) {                                                                     // 39
  for (var k in src)                                                                                    // 40
    if (src.hasOwnProperty(k))                                                                          // 41
      tgt[k] = src[k];                                                                                  // 42
  return tgt;                                                                                           // 43
};                                                                                                      // 44
                                                                                                        // 45
var _contains = function (list, item) {                                                                 // 46
  if (! list)                                                                                           // 47
    return false;                                                                                       // 48
  for (var i = 0, N = list.length; i < N; i++)                                                          // 49
    if (list[i] === item)                                                                               // 50
      return true;                                                                                      // 51
  return false;                                                                                         // 52
};                                                                                                      // 53
                                                                                                        // 54
var isArray = function (x) {                                                                            // 55
  return !!((typeof x.length === 'number') &&                                                           // 56
            (x.sort || x.splice));                                                                      // 57
};                                                                                                      // 58
                                                                                                        // 59
// Text nodes consisting of only whitespace                                                             // 60
// are "insignificant" nodes.                                                                           // 61
var isSignificantNode = function (n) {                                                                  // 62
  return ! (n.nodeType === 3 &&                                                                         // 63
            (! n.nodeValue ||                                                                           // 64
             /^\s+$/.test(n.nodeValue)));                                                               // 65
};                                                                                                      // 66
                                                                                                        // 67
var checkId = function (id) {                                                                           // 68
  if (typeof id !== 'string')                                                                           // 69
    throw new Error("id must be a string");                                                             // 70
  if (! id)                                                                                             // 71
    throw new Error("id may not be empty");                                                             // 72
};                                                                                                      // 73
                                                                                                        // 74
var textExpandosSupported = (function () {                                                              // 75
  var tn = document.createTextNode('');                                                                 // 76
  try {                                                                                                 // 77
    tn.blahblah = true;                                                                                 // 78
    return true;                                                                                        // 79
  } catch (e) {                                                                                         // 80
    // IE 8                                                                                             // 81
    return false;                                                                                       // 82
  }                                                                                                     // 83
})();                                                                                                   // 84
                                                                                                        // 85
var createMarkerNode = (                                                                                // 86
  textExpandosSupported ?                                                                               // 87
    function () { return document.createTextNode(""); } :                                               // 88
  function () { return document.createComment("IE"); });                                                // 89
                                                                                                        // 90
var rangeParented = function (range) {                                                                  // 91
  if (! range.isParented) {                                                                             // 92
    range.isParented = true;                                                                            // 93
                                                                                                        // 94
    if (! range.owner) {                                                                                // 95
      // top-level (unowned) ranges in an element,                                                      // 96
      // keep a pointer to the range on the parent                                                      // 97
      // element.  This is really just for IE 9+                                                        // 98
      // TextNode GC issues, but we can't do reliable                                                   // 99
      // feature detection (i.e. bug detection).                                                        // 100
      // Note that because we keep a direct pointer to                                                  // 101
      // `parentNode.$_uiranges`, it doesn't matter                                                     // 102
      // if we are reparented (e.g. wrapped in a TBODY).                                                // 103
      var parentNode = range.parentNode();                                                              // 104
      var rangeDict = (                                                                                 // 105
        parentNode.$_uiranges ||                                                                        // 106
          (parentNode.$_uiranges = {}));                                                                // 107
      rangeDict[range._rangeId] = range;                                                                // 108
      range._rangeDict = rangeDict;                                                                     // 109
                                                                                                        // 110
      // get jQuery to tell us when this node is removed                                                // 111
      DomBackend.onRemoveElement(parentNode, function () {                                              // 112
        rangeRemoved(range);                                                                            // 113
      });                                                                                               // 114
    }                                                                                                   // 115
                                                                                                        // 116
    if (range.component && range.component.notifyParented)                                              // 117
      range.component.notifyParented();                                                                 // 118
                                                                                                        // 119
    // recurse on member ranges                                                                         // 120
    var members = range.members;                                                                        // 121
    for (var k in members) {                                                                            // 122
      var mem = members[k];                                                                             // 123
      if (mem instanceof DomRange)                                                                      // 124
        rangeParented(mem);                                                                             // 125
    }                                                                                                   // 126
  }                                                                                                     // 127
};                                                                                                      // 128
                                                                                                        // 129
var rangeRemoved = function (range) {                                                                   // 130
  if (! range.isRemoved) {                                                                              // 131
    range.isRemoved = true;                                                                             // 132
                                                                                                        // 133
    if (range._rangeDict)                                                                               // 134
      delete range._rangeDict[range._rangeId];                                                          // 135
                                                                                                        // 136
    // XXX clean up events in $_uievents                                                                // 137
                                                                                                        // 138
    // notify component of removal                                                                      // 139
    if (range.removed)                                                                                  // 140
      range.removed();                                                                                  // 141
                                                                                                        // 142
    membersRemoved(range);                                                                              // 143
  }                                                                                                     // 144
};                                                                                                      // 145
                                                                                                        // 146
var nodeRemoved = function (node, viaBackend) {                                                         // 147
  if (node.nodeType === 1) { // ELEMENT                                                                 // 148
    var comps = DomRange.getComponents(node);                                                           // 149
    for (var i = 0, N = comps.length; i < N; i++)                                                       // 150
      rangeRemoved(comps[i]);                                                                           // 151
                                                                                                        // 152
    if (! viaBackend)                                                                                   // 153
      DomBackend.removeElement(node);                                                                   // 154
  }                                                                                                     // 155
};                                                                                                      // 156
                                                                                                        // 157
var membersRemoved = function (range) {                                                                 // 158
  var members = range.members;                                                                          // 159
  for (var k in members) {                                                                              // 160
    var mem = members[k];                                                                               // 161
    if (mem instanceof DomRange)                                                                        // 162
      rangeRemoved(mem);                                                                                // 163
    else                                                                                                // 164
      nodeRemoved(mem);                                                                                 // 165
  }                                                                                                     // 166
};                                                                                                      // 167
                                                                                                        // 168
var nextGuid = 1;                                                                                       // 169
                                                                                                        // 170
var DomRange = function () {                                                                            // 171
  var start = createMarkerNode();                                                                       // 172
  var end = createMarkerNode();                                                                         // 173
  var fragment = DomBackend.newFragment([start, end]);                                                  // 174
  fragment.$_uiIsOffscreen = true;                                                                      // 175
                                                                                                        // 176
  this.start = start;                                                                                   // 177
  this.end = end;                                                                                       // 178
  start.$ui = this;                                                                                     // 179
  end.$ui = this;                                                                                       // 180
                                                                                                        // 181
  this.members = {};                                                                                    // 182
  this.nextMemberId = 1;                                                                                // 183
  this.owner = null;                                                                                    // 184
  this._rangeId = nextGuid++;                                                                           // 185
  this._rangeDict = null;                                                                               // 186
                                                                                                        // 187
  this.isParented = false;                                                                              // 188
  this.isRemoved = false;                                                                               // 189
};                                                                                                      // 190
                                                                                                        // 191
_extend(DomRange.prototype, {                                                                           // 192
  getNodes: function () {                                                                               // 193
    if (! this.parentNode())                                                                            // 194
      return [];                                                                                        // 195
                                                                                                        // 196
    this.refresh();                                                                                     // 197
                                                                                                        // 198
    var afterNode = this.end.nextSibling;                                                               // 199
    var nodes = [];                                                                                     // 200
    for (var n = this.start;                                                                            // 201
         n && n !== afterNode;                                                                          // 202
         n = n.nextSibling)                                                                             // 203
      nodes.push(n);                                                                                    // 204
    return nodes;                                                                                       // 205
  },                                                                                                    // 206
  removeAll: function () {                                                                              // 207
    if (! this.parentNode())                                                                            // 208
      return;                                                                                           // 209
                                                                                                        // 210
    this.refresh();                                                                                     // 211
                                                                                                        // 212
    // leave start and end                                                                              // 213
    var afterNode = this.end;                                                                           // 214
    var nodes = [];                                                                                     // 215
    for (var n = this.start.nextSibling;                                                                // 216
         n && n !== afterNode;                                                                          // 217
         n = n.nextSibling) {                                                                           // 218
      // don't remove yet since then we'd lose nextSibling                                              // 219
      nodes.push(n);                                                                                    // 220
    }                                                                                                   // 221
    for (var i = 0, N = nodes.length; i < N; i++)                                                       // 222
      removeNode(nodes[i]);                                                                             // 223
                                                                                                        // 224
    membersRemoved(this);                                                                               // 225
                                                                                                        // 226
    this.members = {};                                                                                  // 227
  },                                                                                                    // 228
  // (_nextNode is internal)                                                                            // 229
  add: function (id, newMemberOrArray, beforeId, _nextNode) {                                           // 230
    if (id != null && typeof id !== 'string') {                                                         // 231
      if (typeof id !== 'object')                                                                       // 232
        // a non-object first argument is probably meant                                                // 233
        // as an id, NOT a new member, so complain about it                                             // 234
        // as such.                                                                                     // 235
        throw new Error("id must be a string");                                                         // 236
      beforeId = newMemberOrArray;                                                                      // 237
      newMemberOrArray = id;                                                                            // 238
      id = null;                                                                                        // 239
    }                                                                                                   // 240
                                                                                                        // 241
    if (! newMemberOrArray || typeof newMemberOrArray !== 'object')                                     // 242
      throw new Error("Expected component, node, or array");                                            // 243
                                                                                                        // 244
    if (isArray(newMemberOrArray)) {                                                                    // 245
      if (newMemberOrArray.length === 1) {                                                              // 246
        newMemberOrArray = newMemberOrArray[0];                                                         // 247
      } else {                                                                                          // 248
        if (id != null)                                                                                 // 249
          throw new Error("Can only add one node or one component if id is given");                     // 250
        var array = newMemberOrArray;                                                                   // 251
        // calculate `nextNode` once in case it involves a refresh                                      // 252
        _nextNode = this.getInsertionPoint(beforeId);                                                   // 253
        for (var i = 0; i < array.length; i++)                                                          // 254
          this.add(null, array[i], beforeId, _nextNode);                                                // 255
        return;                                                                                         // 256
      }                                                                                                 // 257
    }                                                                                                   // 258
                                                                                                        // 259
    var parentNode = this.parentNode();                                                                 // 260
    // Consider ourselves removed (and don't mind) if                                                   // 261
    // start marker has no parent.                                                                      // 262
    if (! parentNode)                                                                                   // 263
      return;                                                                                           // 264
    // because this may call `refresh`, it must be done                                                 // 265
    // early, before we add the new member.                                                             // 266
    var nextNode = (_nextNode ||                                                                        // 267
                    this.getInsertionPoint(beforeId));                                                  // 268
                                                                                                        // 269
    var newMember = newMemberOrArray;                                                                   // 270
    if (id == null) {                                                                                   // 271
      id = this.nextMemberId++;                                                                         // 272
    } else {                                                                                            // 273
      checkId(id);                                                                                      // 274
      id = ' ' + id;                                                                                    // 275
    }                                                                                                   // 276
                                                                                                        // 277
    var members = this.members;                                                                         // 278
    if (members.hasOwnProperty(id)) {                                                                   // 279
      var oldMember = members[id];                                                                      // 280
      if (oldMember instanceof DomRange) {                                                              // 281
        // range, does it still exist?                                                                  // 282
        var oldRange = oldMember;                                                                       // 283
        if (oldRange.start.parentNode !== parentNode) {                                                 // 284
          delete members[id];                                                                           // 285
          oldRange.owner = null;                                                                        // 286
          rangeRemoved(oldRange);                                                                       // 287
        } else {                                                                                        // 288
          throw new Error("Member already exists: " + id.slice(1));                                     // 289
        }                                                                                               // 290
      } else {                                                                                          // 291
        // node, does it still exist?                                                                   // 292
        var oldNode = oldMember;                                                                        // 293
        if (oldNode.parentNode !== parentNode) {                                                        // 294
          nodeRemoved(oldNode);                                                                         // 295
          delete members[id];                                                                           // 296
        } else {                                                                                        // 297
          throw new Error("Member already exists: " + id.slice(1));                                     // 298
        }                                                                                               // 299
      }                                                                                                 // 300
    }                                                                                                   // 301
                                                                                                        // 302
    if (newMember instanceof DomRange) {                                                                // 303
      // Range                                                                                          // 304
      var range = newMember;                                                                            // 305
      range.owner = this;                                                                               // 306
      var nodes = range.getNodes();                                                                     // 307
                                                                                                        // 308
      if (tbodyFixNeeded(nodes, parentNode))                                                            // 309
        // may cause a refresh(); important that the                                                    // 310
        // member isn't added yet                                                                       // 311
        parentNode = moveWithOwnersIntoTbody(this);                                                     // 312
                                                                                                        // 313
      members[id] = newMember;                                                                          // 314
      for (var i = 0; i < nodes.length; i++)                                                            // 315
        insertNode(nodes[i], parentNode, nextNode);                                                     // 316
                                                                                                        // 317
      if (this.isParented)                                                                              // 318
        rangeParented(range);                                                                           // 319
    } else {                                                                                            // 320
      // Node                                                                                           // 321
      if (typeof newMember.nodeType !== 'number')                                                       // 322
        throw new Error("Expected Component or Node");                                                  // 323
      var node = newMember;                                                                             // 324
      // can't attach `$ui` to a TextNode in IE 8, so                                                   // 325
      // don't bother on any browser.                                                                   // 326
      if (node.nodeType !== 3)                                                                          // 327
        node.$ui = this;                                                                                // 328
                                                                                                        // 329
      if (tbodyFixNeeded(node, parentNode))                                                             // 330
        // may cause a refresh(); important that the                                                    // 331
        // member isn't added yet                                                                       // 332
        parentNode = moveWithOwnersIntoTbody(this);                                                     // 333
                                                                                                        // 334
      members[id] = newMember;                                                                          // 335
      insertNode(node, parentNode, nextNode);                                                           // 336
    }                                                                                                   // 337
  },                                                                                                    // 338
  remove: function (id) {                                                                               // 339
    if (id == null) {                                                                                   // 340
      // remove self                                                                                    // 341
      this.removeAll();                                                                                 // 342
      removeNode(this.start);                                                                           // 343
      removeNode(this.end);                                                                             // 344
      this.owner = null;                                                                                // 345
      rangeRemoved(this);                                                                               // 346
      return;                                                                                           // 347
    }                                                                                                   // 348
                                                                                                        // 349
    checkId(id);                                                                                        // 350
    id = ' ' + id;                                                                                      // 351
    var members = this.members;                                                                         // 352
    var member = (members.hasOwnProperty(id) &&                                                         // 353
                  members[id]);                                                                         // 354
    delete members[id];                                                                                 // 355
                                                                                                        // 356
    // Don't mind double-remove.                                                                        // 357
    if (! member)                                                                                       // 358
      return;                                                                                           // 359
                                                                                                        // 360
    var parentNode = this.parentNode();                                                                 // 361
    // Consider ourselves removed (and don't mind) if                                                   // 362
    // start marker has no parent.                                                                      // 363
    if (! parentNode)                                                                                   // 364
      return;                                                                                           // 365
                                                                                                        // 366
    if (member instanceof DomRange) {                                                                   // 367
      // Range                                                                                          // 368
      var range = member;                                                                               // 369
      range.owner = null;                                                                               // 370
      // Don't mind if range (specifically its start                                                    // 371
      // marker) has been removed already.                                                              // 372
      if (range.start.parentNode === parentNode)                                                        // 373
        member.remove();                                                                                // 374
    } else {                                                                                            // 375
      // Node                                                                                           // 376
      var node = member;                                                                                // 377
      // Don't mind if node has been removed already.                                                   // 378
      if (node.parentNode === parentNode)                                                               // 379
        removeNode(node);                                                                               // 380
    }                                                                                                   // 381
  },                                                                                                    // 382
  moveBefore: function (id, beforeId) {                                                                 // 383
    var nextNode = this.getInsertionPoint(beforeId);                                                    // 384
    checkId(id);                                                                                        // 385
    id = ' ' + id;                                                                                      // 386
    var members = this.members;                                                                         // 387
    var member =                                                                                        // 388
          (members.hasOwnProperty(id) &&                                                                // 389
           members[id]);                                                                                // 390
    // Don't mind if member doesn't exist.                                                              // 391
    if (! member)                                                                                       // 392
      return;                                                                                           // 393
                                                                                                        // 394
    var parentNode = this.parentNode();                                                                 // 395
    // Consider ourselves removed (and don't mind) if                                                   // 396
    // start marker has no parent.                                                                      // 397
    if (! parentNode)                                                                                   // 398
      return;                                                                                           // 399
                                                                                                        // 400
    if (member instanceof DomRange) {                                                                   // 401
      // Range                                                                                          // 402
      var range = member;                                                                               // 403
      // Don't mind if range (specifically its start marker)                                            // 404
      // has been removed already.                                                                      // 405
      if (range.start.parentNode === parentNode) {                                                      // 406
        range.refresh();                                                                                // 407
        var nodes = range.getNodes();                                                                   // 408
        for (var i = 0; i < nodes.length; i++)                                                          // 409
          moveNode(nodes[i], parentNode, nextNode);                                                     // 410
      }                                                                                                 // 411
    } else {                                                                                            // 412
      // Node                                                                                           // 413
      var node = member;                                                                                // 414
      moveNode(node, parentNode, nextNode);                                                             // 415
    }                                                                                                   // 416
  },                                                                                                    // 417
  get: function (id) {                                                                                  // 418
    checkId(id);                                                                                        // 419
    id = ' ' + id;                                                                                      // 420
    var members = this.members;                                                                         // 421
    if (members.hasOwnProperty(id))                                                                     // 422
      return members[id];                                                                               // 423
    return null;                                                                                        // 424
  },                                                                                                    // 425
  parentNode: function () {                                                                             // 426
    return this.start.parentNode;                                                                       // 427
  },                                                                                                    // 428
  startNode: function () {                                                                              // 429
    return this.start;                                                                                  // 430
  },                                                                                                    // 431
  endNode: function () {                                                                                // 432
    return this.end;                                                                                    // 433
  },                                                                                                    // 434
  eachMember: function (nodeFunc, rangeFunc) {                                                          // 435
    var members = this.members;                                                                         // 436
    var parentNode = this.parentNode();                                                                 // 437
    for (var k in members) {                                                                            // 438
      // mem is a component (hosting a Range) or a Node                                                 // 439
      var mem = members[k];                                                                             // 440
      if (mem instanceof DomRange) {                                                                    // 441
        // Range                                                                                        // 442
        var range = mem;                                                                                // 443
        if (range.start.parentNode === parentNode) {                                                    // 444
          rangeFunc && rangeFunc(range); // still there                                                 // 445
        } else {                                                                                        // 446
          range.owner = null;                                                                           // 447
          delete members[k]; // gone                                                                    // 448
          rangeRemoved(range);                                                                          // 449
        }                                                                                               // 450
      } else {                                                                                          // 451
        // Node                                                                                         // 452
        var node = mem;                                                                                 // 453
        if (node.parentNode === parentNode) {                                                           // 454
          nodeFunc && nodeFunc(node); // still there                                                    // 455
        } else {                                                                                        // 456
          delete members[k]; // gone                                                                    // 457
          nodeRemoved(node);                                                                            // 458
        }                                                                                               // 459
      }                                                                                                 // 460
    }                                                                                                   // 461
  },                                                                                                    // 462
                                                                                                        // 463
  ///////////// INTERNALS below this point, pretty much                                                 // 464
                                                                                                        // 465
  // The purpose of "refreshing" a DomRange is to                                                       // 466
  // take into account any element removals or moves                                                    // 467
  // that may have occurred, and to "fix" the start                                                     // 468
  // and end markers before the entire range is moved                                                   // 469
  // or removed so that they bracket the appropriate                                                    // 470
  // content.                                                                                           // 471
  //                                                                                                    // 472
  // For example, if a DomRange contains a single element                                               // 473
  // node, and this node is moved using jQuery, refreshing                                              // 474
  // the DomRange will look to the element as ground truth                                              // 475
  // and move the start/end markers around the element.                                                 // 476
  // A refreshed DomRange's nodes may surround nodes from                                               // 477
  // sibling DomRanges (including their marker nodes)                                                   // 478
  // until the sibling DomRange is refreshed.                                                           // 479
  //                                                                                                    // 480
  // Specifically, `refresh` moves the `start`                                                          // 481
  // and `end` nodes to immediate before the first,                                                     // 482
  // and after the last, "significant" node the                                                         // 483
  // DomRange contains, where a significant node                                                        // 484
  // is any node except a whitespace-only text-node.                                                    // 485
  // All member ranges are refreshed first.  Adjacent                                                   // 486
  // insignificant member nodes are included between                                                    // 487
  // `start` and `end` as well, but it's possible that                                                  // 488
  // other insignificant nodes remain as siblings                                                       // 489
  // elsewhere.  Nodes with no DomRange owner that are                                                  // 490
  // found between this DomRange's nodes are adopted.                                                   // 491
  //                                                                                                    // 492
  // Performing add/move/remove operations on an "each"                                                 // 493
  // shouldn't require refreshing the entire each, just                                                 // 494
  // the member in question.  (However, adding to the                                                   // 495
  // end may require refreshing the whole "each";                                                       // 496
  // see `getInsertionPoint`.  Adding multiple members                                                  // 497
  // at once using `add(array)` is faster.                                                              // 498
  refresh: function () {                                                                                // 499
                                                                                                        // 500
    var parentNode = this.parentNode();                                                                 // 501
    if (! parentNode)                                                                                   // 502
      return;                                                                                           // 503
                                                                                                        // 504
    // Using `eachMember`, do several things:                                                           // 505
    // - Refresh all member ranges                                                                      // 506
    // - Count our members                                                                              // 507
    // - If there's only one, get that one                                                              // 508
    // - Make a list of member TextNodes, which we                                                      // 509
    //   can't detect with a `$ui` property because                                                     // 510
    //   IE 8 doesn't allow user-defined properties                                                     // 511
    //   on TextNodes.                                                                                  // 512
    var someNode = null;                                                                                // 513
    var someRange = null;                                                                               // 514
    var numMembers = 0;                                                                                 // 515
    var textNodes = null;                                                                               // 516
    this.eachMember(function (node) {                                                                   // 517
      someNode = node;                                                                                  // 518
      numMembers++;                                                                                     // 519
      if (node.nodeType === 3) {                                                                        // 520
        textNodes = (textNodes || []);                                                                  // 521
        textNodes.push(node);                                                                           // 522
      }                                                                                                 // 523
    }, function (range) {                                                                               // 524
      range.refresh();                                                                                  // 525
      someRange = range;                                                                                // 526
      numMembers++;                                                                                     // 527
    });                                                                                                 // 528
                                                                                                        // 529
    var firstNode = null;                                                                               // 530
    var lastNode = null;                                                                                // 531
                                                                                                        // 532
    if (numMembers === 0) {                                                                             // 533
      // don't scan for members                                                                         // 534
    } else if (numMembers === 1) {                                                                      // 535
      if (someNode) {                                                                                   // 536
        firstNode = someNode;                                                                           // 537
        lastNode = someNode;                                                                            // 538
      } else if (someRange) {                                                                           // 539
        firstNode = someRange.start;                                                                    // 540
        lastNode = someRange.end;                                                                       // 541
      }                                                                                                 // 542
    } else {                                                                                            // 543
      // This loop is O(childNodes.length), even if our members                                         // 544
      // are already consecutive.  This means refreshing just one                                       // 545
      // item in a list is technically order of the total number                                        // 546
      // of siblings, including in other list items.                                                    // 547
      //                                                                                                // 548
      // The root cause is we intentionally don't track the                                             // 549
      // DOM order of our members, so finding the first                                                 // 550
      // and last in sibling order either involves a scan                                               // 551
      // or a bunch of calls to compareDocumentPosition.                                                // 552
      //                                                                                                // 553
      // Fortunately, the common cases of zero and one members                                          // 554
      // are optimized.  Also, the scan is super-fast because                                           // 555
      // no work is done for unknown nodes.  It could be possible                                       // 556
      // to optimize this code further if it becomes a problem.                                         // 557
      for (var node = parentNode.firstChild;                                                            // 558
           node; node = node.nextSibling) {                                                             // 559
                                                                                                        // 560
        var nodeOwner;                                                                                  // 561
        if (node.$ui &&                                                                                 // 562
            (nodeOwner = node.$ui) &&                                                                   // 563
            ((nodeOwner === this &&                                                                     // 564
              node !== this.start &&                                                                    // 565
              node !== this.end &&                                                                      // 566
              isSignificantNode(node)) ||                                                               // 567
             (nodeOwner !== this &&                                                                     // 568
              nodeOwner.owner === this &&                                                               // 569
              nodeOwner.start === node))) {                                                             // 570
          // found a member range or node                                                               // 571
          // (excluding "insignificant" empty text nodes,                                               // 572
          // which won't be moved by, say, jQuery)                                                      // 573
          if (firstNode) {                                                                              // 574
            // if we've already found a member in our                                                   // 575
            // scan, see if there are some easy ownerless                                               // 576
            // nodes to "adopt" by scanning backwards.                                                  // 577
            for (var n = firstNode.previousSibling;                                                     // 578
                 n && ! n.$ui;                                                                          // 579
                 n = n.previousSibling) {                                                               // 580
              this.members[this.nextMemberId++] = n;                                                    // 581
              // can't attach `$ui` to a TextNode in IE 8, so                                           // 582
              // don't bother on any browser.                                                           // 583
              if (n.nodeType !== 3)                                                                     // 584
                n.$ui = this;                                                                           // 585
            }                                                                                           // 586
          }                                                                                             // 587
          if (node.$ui === this) {                                                                      // 588
            // Node                                                                                     // 589
            firstNode = (firstNode || node);                                                            // 590
            lastNode = node;                                                                            // 591
          } else {                                                                                      // 592
            // Range                                                                                    // 593
            // skip it and include its nodes in                                                         // 594
            // firstNode/lastNode.                                                                      // 595
            firstNode = (firstNode || node);                                                            // 596
            node = node.$ui.end;                                                                        // 597
            lastNode = node;                                                                            // 598
          }                                                                                             // 599
        }                                                                                               // 600
      }                                                                                                 // 601
    }                                                                                                   // 602
    if (firstNode) {                                                                                    // 603
      // some member or significant node was found.                                                     // 604
      // expand to include our insigificant member                                                      // 605
      // nodes as well.                                                                                 // 606
      for (var n;                                                                                       // 607
           (n = firstNode.previousSibling) &&                                                           // 608
           (n.$ui && n.$ui === this ||                                                                  // 609
            _contains(textNodes, n));)                                                                  // 610
        firstNode = n;                                                                                  // 611
      for (var n;                                                                                       // 612
           (n = lastNode.nextSibling) &&                                                                // 613
           (n.$ui && n.$ui === this ||                                                                  // 614
            _contains(textNodes, n));)                                                                  // 615
        lastNode = n;                                                                                   // 616
      // adjust our start/end pointers                                                                  // 617
      if (firstNode !== this.start)                                                                     // 618
        insertNode(this.start,                                                                          // 619
                   parentNode, firstNode);                                                              // 620
      if (lastNode !== this.end)                                                                        // 621
        insertNode(this.end, parentNode,                                                                // 622
                 lastNode.nextSibling);                                                                 // 623
    }                                                                                                   // 624
  },                                                                                                    // 625
  getInsertionPoint: function (beforeId) {                                                              // 626
    var members = this.members;                                                                         // 627
    var parentNode = this.parentNode();                                                                 // 628
                                                                                                        // 629
    if (! beforeId) {                                                                                   // 630
      // Refreshing here is necessary if we want to                                                     // 631
      // allow elements to move around arbitrarily.                                                     // 632
      // If jQuery is used to reorder elements, it could                                                // 633
      // easily make our `end` pointer meaningless,                                                     // 634
      // even though all our members continue to make                                                   // 635
      // good reference points as long as they are refreshed.                                           // 636
      //                                                                                                // 637
      // However, a refresh is expensive!  Let's                                                        // 638
      // make the developer manually refresh if                                                         // 639
      // elements are being re-ordered externally.                                                      // 640
      return this.end;                                                                                  // 641
    }                                                                                                   // 642
                                                                                                        // 643
    checkId(beforeId);                                                                                  // 644
    beforeId = ' ' + beforeId;                                                                          // 645
    var mem = members[beforeId];                                                                        // 646
                                                                                                        // 647
    if (mem instanceof DomRange) {                                                                      // 648
      // Range                                                                                          // 649
      var range = mem;                                                                                  // 650
      if (range.start.parentNode === parentNode) {                                                      // 651
        // still there                                                                                  // 652
        range.refresh();                                                                                // 653
        return range.start;                                                                             // 654
      } else {                                                                                          // 655
        range.owner = null;                                                                             // 656
        rangeRemoved(range);                                                                            // 657
      }                                                                                                 // 658
    } else {                                                                                            // 659
      // Node                                                                                           // 660
      var node = mem;                                                                                   // 661
      if (node.parentNode === parentNode)                                                               // 662
        return node; // still there                                                                     // 663
      else                                                                                              // 664
        nodeRemoved(node);                                                                              // 665
    }                                                                                                   // 666
                                                                                                        // 667
    // not there anymore                                                                                // 668
    delete members[beforeId];                                                                           // 669
    // no good position                                                                                 // 670
    return this.end;                                                                                    // 671
  }                                                                                                     // 672
});                                                                                                     // 673
                                                                                                        // 674
DomRange.prototype.elements = function (intoArray) {                                                    // 675
  intoArray = (intoArray || []);                                                                        // 676
  this.eachMember(function (node) {                                                                     // 677
    if (node.nodeType === 1)                                                                            // 678
      intoArray.push(node);                                                                             // 679
  }, function (range) {                                                                                 // 680
    range.elements(intoArray);                                                                          // 681
  });                                                                                                   // 682
  return intoArray;                                                                                     // 683
};                                                                                                      // 684
                                                                                                        // 685
// XXX alias the below as `UI.refresh` and `UI.insert`                                                  // 686
                                                                                                        // 687
// In a real-life case where you need a refresh,                                                        // 688
// you probably don't have easy                                                                         // 689
// access to the appropriate DomRange or component,                                                     // 690
// just the enclosing element:                                                                          // 691
//                                                                                                      // 692
// ```                                                                                                  // 693
// {{#Sortable}}                                                                                        // 694
//   <div>                                                                                              // 695
//     {{#each}}                                                                                        // 696
//       ...                                                                                            // 697
// ```                                                                                                  // 698
//                                                                                                      // 699
// In this case, Sortable wants to call `refresh`                                                       // 700
// on the div, not the each, so it would use this function.                                             // 701
DomRange.refresh = function (element) {                                                                 // 702
  var comps = DomRange.getComponents(element);                                                          // 703
                                                                                                        // 704
  for (var i = 0, N = comps.length; i < N; i++)                                                         // 705
    comps[i].refresh();                                                                                 // 706
};                                                                                                      // 707
                                                                                                        // 708
DomRange.getComponents = function (element) {                                                           // 709
  var topLevelComps = [];                                                                               // 710
  for (var n = element.firstChild;                                                                      // 711
       n; n = n.nextSibling) {                                                                          // 712
    if (n.$ui && n === n.$ui.start &&                                                                   // 713
        ! n.$ui.owner)                                                                                  // 714
      topLevelComps.push(n.$ui);                                                                        // 715
  }                                                                                                     // 716
  return topLevelComps;                                                                                 // 717
};                                                                                                      // 718
                                                                                                        // 719
// `parentNode` must be an ELEMENT, not a fragment                                                      // 720
DomRange.insert = function (range, parentNode, nextNode) {                                              // 721
  var nodes = range.getNodes();                                                                         // 722
  if (tbodyFixNeeded(nodes, parentNode))                                                                // 723
    parentNode = makeOrFindTbody(parentNode, nextNode);                                                 // 724
  for (var i = 0; i < nodes.length; i++)                                                                // 725
    insertNode(nodes[i], parentNode, nextNode);                                                         // 726
  rangeParented(range);                                                                                 // 727
};                                                                                                      // 728
                                                                                                        // 729
DomRange.getContainingComponent = function (element) {                                                  // 730
  while (element && ! element.$ui)                                                                      // 731
    element = element.parentNode;                                                                       // 732
                                                                                                        // 733
  var range = (element && element.$ui);                                                                 // 734
                                                                                                        // 735
  while (range) {                                                                                       // 736
    if (range.component)                                                                                // 737
      return range.component;                                                                           // 738
    range = range.owner;                                                                                // 739
  }                                                                                                     // 740
  return null;                                                                                          // 741
};                                                                                                      // 742
                                                                                                        // 743
///// TBODY FIX for compatibility with jQuery.                                                          // 744
//                                                                                                      // 745
// Because people might use jQuery from UI hooks, and                                                   // 746
// jQuery is unable to do $(myTable).append(myTR) without                                               // 747
// adding a TBODY (for historical reasons), we move any DomRange                                        // 748
// that gains a TR, and its immediately enclosing DomRanges,                                            // 749
// into a TBODY.                                                                                        // 750
//                                                                                                      // 751
// See http://www.quora.com/David-Greenspan/Posts/The-Great-TBODY-Debacle                               // 752
var tbodyFixNeeded = function (childOrChildren, parent) {                                               // 753
  if (parent.nodeName !== 'TABLE')                                                                      // 754
    return false;                                                                                       // 755
                                                                                                        // 756
  if (isArray(childOrChildren)) {                                                                       // 757
    var foundTR = false;                                                                                // 758
    for (var i = 0, N = childOrChildren.length; i < N; i++) {                                           // 759
      var n = childOrChildren[i];                                                                       // 760
      if (n.nodeType === 1 && n.nodeName === 'TR') {                                                    // 761
        foundTR = true;                                                                                 // 762
        break;                                                                                          // 763
      }                                                                                                 // 764
    }                                                                                                   // 765
    if (! foundTR)                                                                                      // 766
      return false;                                                                                     // 767
  } else {                                                                                              // 768
    var n = childOrChildren;                                                                            // 769
    if (! (n.nodeType === 1 && n.nodeName === 'TR'))                                                    // 770
      return false;                                                                                     // 771
  }                                                                                                     // 772
                                                                                                        // 773
  return true;                                                                                          // 774
};                                                                                                      // 775
                                                                                                        // 776
var makeOrFindTbody = function (parent, next) {                                                         // 777
  // we have a TABLE > TR situation                                                                     // 778
  var tbody = parent.getElementsByTagName('tbody')[0];                                                  // 779
  if (! tbody) {                                                                                        // 780
    tbody = parent.ownerDocument.createElement("tbody");                                                // 781
    parent.insertBefore(tbody, next || null);                                                           // 782
  }                                                                                                     // 783
  return tbody;                                                                                         // 784
};                                                                                                      // 785
                                                                                                        // 786
var moveWithOwnersIntoTbody = function (range) {                                                        // 787
  while (range.owner)                                                                                   // 788
    range = range.owner;                                                                                // 789
                                                                                                        // 790
  var nodes = range.getNodes(); // causes refresh                                                       // 791
  var tbody = makeOrFindTbody(range.parentNode(),                                                       // 792
                              range.end.nextSibling);                                                   // 793
  for (var i = 0; i < nodes.length; i++)                                                                // 794
    tbody.appendChild(nodes[i]);                                                                        // 795
                                                                                                        // 796
  // XXX complete the reparenting by moving event                                                       // 797
  // HandlerRecs of `range`.                                                                            // 798
                                                                                                        // 799
  return tbody;                                                                                         // 800
};                                                                                                      // 801
                                                                                                        // 802
///// FIND BY SELECTOR                                                                                  // 803
                                                                                                        // 804
DomRange.prototype.contains = function (compOrNode) {                                                   // 805
  if (! compOrNode)                                                                                     // 806
    throw new Error("Expected Component or Node");                                                      // 807
                                                                                                        // 808
  var parentNode = this.parentNode();                                                                   // 809
  if (! parentNode)                                                                                     // 810
    return false;                                                                                       // 811
                                                                                                        // 812
  var range;                                                                                            // 813
  if (compOrNode instanceof DomRange) {                                                                 // 814
    // Component                                                                                        // 815
    range = compOrNode;                                                                                 // 816
    var pn = range.parentNode();                                                                        // 817
    if (! pn)                                                                                           // 818
      return false;                                                                                     // 819
    // If parentNode is different, it must be a node                                                    // 820
    // we contain.                                                                                      // 821
    if (pn !== parentNode)                                                                              // 822
      return this.contains(pn);                                                                         // 823
    if (range === this)                                                                                 // 824
      return false; // don't contain self                                                               // 825
    // Ok, `range` is a same-parent range to see if we                                                  // 826
    // contain.                                                                                         // 827
  } else {                                                                                              // 828
    // Node                                                                                             // 829
    var node = compOrNode;                                                                              // 830
    if (! elementContains(parentNode, node))                                                            // 831
      return false;                                                                                     // 832
                                                                                                        // 833
    while (node.parentNode !== parentNode)                                                              // 834
      node = node.parentNode;                                                                           // 835
                                                                                                        // 836
    range = node.$ui;                                                                                   // 837
  }                                                                                                     // 838
                                                                                                        // 839
  // Now see if `range` is truthy and either `this`                                                     // 840
  // or an immediate subrange                                                                           // 841
                                                                                                        // 842
  while (range && range !== this)                                                                       // 843
    range = range.owner;                                                                                // 844
                                                                                                        // 845
  return range === this;                                                                                // 846
};                                                                                                      // 847
                                                                                                        // 848
DomRange.prototype.$ = function (selector) {                                                            // 849
  var self = this;                                                                                      // 850
                                                                                                        // 851
  var parentNode = this.parentNode();                                                                   // 852
  if (! parentNode)                                                                                     // 853
    throw new Error("Can't select in removed DomRange");                                                // 854
                                                                                                        // 855
  // Strategy: Find all selector matches under parentNode,                                              // 856
  // then filter out the ones that aren't in this DomRange                                              // 857
  // using upwards pointers ($ui, owner, parentNode).  This is                                          // 858
  // asymptotically slow in the presence of O(N) sibling                                                // 859
  // content that is under parentNode but not in our range,                                             // 860
  // so if performance is an issue, the selector should be                                              // 861
  // run on a child element.                                                                            // 862
                                                                                                        // 863
  // Since jQuery can't run selectors on a DocumentFragment,                                            // 864
  // we don't expect findBySelector to work.                                                            // 865
  if (parentNode.nodeType === 11 /* DocumentFragment */ ||                                              // 866
      parentNode.$_uiIsOffscreen)                                                                       // 867
    throw new Error("Can't use $ on an offscreen component");                                           // 868
                                                                                                        // 869
  var results = DomBackend.findBySelector(selector, parentNode);                                        // 870
                                                                                                        // 871
  // We don't assume `results` has jQuery API; a plain array                                            // 872
  // should do just as well.  However, if we do have a jQuery                                           // 873
  // array, we want to end up with one also, so we use                                                  // 874
  // `.filter`.                                                                                         // 875
                                                                                                        // 876
                                                                                                        // 877
  // Function that selects only elements that are actually                                              // 878
  // in this DomRange, rather than simply descending from                                               // 879
  // `parentNode`.                                                                                      // 880
  var filterFunc = function (elem) {                                                                    // 881
    // handle jQuery's arguments to filter, where the node                                              // 882
    // is in `this` and the index is the first argument.                                                // 883
    if (typeof elem === 'number')                                                                       // 884
      elem = this;                                                                                      // 885
                                                                                                        // 886
    return self.contains(elem);                                                                         // 887
  };                                                                                                    // 888
                                                                                                        // 889
  if (! results.filter) {                                                                               // 890
    // not a jQuery array, and not a browser with                                                       // 891
    // Array.prototype.filter (e.g. IE <9)                                                              // 892
    var newResults = [];                                                                                // 893
    for (var i = 0; i < results.length; i++) {                                                          // 894
      var x = results[i];                                                                               // 895
      if (filterFunc(x))                                                                                // 896
        newResults.push(x);                                                                             // 897
    }                                                                                                   // 898
    results = newResults;                                                                               // 899
  } else {                                                                                              // 900
    // `results.filter` is either jQuery's or ECMAScript's `filter`                                     // 901
    results = results.filter(filterFunc);                                                               // 902
  }                                                                                                     // 903
                                                                                                        // 904
  return results;                                                                                       // 905
};                                                                                                      // 906
                                                                                                        // 907
                                                                                                        // 908
///// EVENTS                                                                                            // 909
                                                                                                        // 910
// List of events to always delegate, never capture.                                                    // 911
// Since jQuery fakes bubbling for certain events in                                                    // 912
// certain browsers (like `submit`), we don't want to                                                   // 913
// get in its way.                                                                                      // 914
//                                                                                                      // 915
// We could list all known bubbling                                                                     // 916
// events here to avoid creating speculative capturers                                                  // 917
// for them, but it would only be an optimization.                                                      // 918
var eventsToDelegate = {                                                                                // 919
  blur: 1, change: 1, click: 1, focus: 1, focusin: 1,                                                   // 920
  focusout: 1, reset: 1, submit: 1                                                                      // 921
};                                                                                                      // 922
                                                                                                        // 923
var EVENT_MODE_TBD = 0;                                                                                 // 924
var EVENT_MODE_BUBBLING = 1;                                                                            // 925
var EVENT_MODE_CAPTURING = 2;                                                                           // 926
                                                                                                        // 927
var HandlerRec = function (elem, type, selector, handler, $ui) {                                        // 928
  this.elem = elem;                                                                                     // 929
  this.type = type;                                                                                     // 930
  this.selector = selector;                                                                             // 931
  this.handler = handler;                                                                               // 932
  this.$ui = $ui;                                                                                       // 933
                                                                                                        // 934
  this.mode = EVENT_MODE_TBD;                                                                           // 935
                                                                                                        // 936
  // It's important that delegatedHandler be a different                                                // 937
  // instance for each handlerRecord, because its identity                                              // 938
  // is used to remove it.                                                                              // 939
  //                                                                                                    // 940
  // It's also important that the closure have access to                                                // 941
  // `this` when it is not called with it set.                                                          // 942
  this.delegatedHandler = (function (h) {                                                               // 943
    return function (evt) {                                                                             // 944
      if ((! h.selector) && evt.currentTarget !== evt.target)                                           // 945
        // no selector means only fire on target                                                        // 946
        return;                                                                                         // 947
      if (! h.$ui.contains(evt.currentTarget))                                                          // 948
        return;                                                                                         // 949
      return h.handler.call(h.$ui, evt);                                                                // 950
    };                                                                                                  // 951
  })(this);                                                                                             // 952
                                                                                                        // 953
  // WHY CAPTURE AND DELEGATE: jQuery can't delegate                                                    // 954
  // non-bubbling events, because                                                                       // 955
  // event capture doesn't work in IE 8.  However, there                                                // 956
  // are all sorts of new-fangled non-bubbling events                                                   // 957
  // like "play" and "touchenter".  We delegate these                                                   // 958
  // events using capture in all browsers except IE 8.                                                  // 959
  // IE 8 doesn't support these events anyway.                                                          // 960
                                                                                                        // 961
  var tryCapturing = elem.addEventListener &&                                                           // 962
        (! eventsToDelegate.hasOwnProperty(                                                             // 963
          DomBackend.parseEventType(type)));                                                            // 964
                                                                                                        // 965
  if (tryCapturing) {                                                                                   // 966
    this.capturingHandler = (function (h) {                                                             // 967
      return function (evt) {                                                                           // 968
        if (h.mode === EVENT_MODE_TBD) {                                                                // 969
          // must be first time we're called.                                                           // 970
          if (evt.bubbles) {                                                                            // 971
            // this type of event bubbles, so don't                                                     // 972
            // get called again.                                                                        // 973
            h.mode = EVENT_MODE_BUBBLING;                                                               // 974
            DomBackend.unbindEventCapturer(                                                             // 975
              h.elem, h.type, h.capturingHandler);                                                      // 976
            return;                                                                                     // 977
          } else {                                                                                      // 978
            // this type of event doesn't bubble,                                                       // 979
            // so unbind the delegation, preventing                                                     // 980
            // it from ever firing.                                                                     // 981
            h.mode = EVENT_MODE_CAPTURING;                                                              // 982
            DomBackend.undelegateEvents(                                                                // 983
              h.elem, h.type, h.delegatedHandler);                                                      // 984
          }                                                                                             // 985
        }                                                                                               // 986
                                                                                                        // 987
        h.delegatedHandler(evt);                                                                        // 988
      };                                                                                                // 989
    })(this);                                                                                           // 990
                                                                                                        // 991
  } else {                                                                                              // 992
    this.mode = EVENT_MODE_BUBBLING;                                                                    // 993
  }                                                                                                     // 994
};                                                                                                      // 995
                                                                                                        // 996
HandlerRec.prototype.bind = function () {                                                               // 997
  // `this.mode` may be EVENT_MODE_TBD, in which case we bind both. in                                  // 998
  // this case, 'capturingHandler' is in charge of detecting the                                        // 999
  // correct mode and turning off one or the other handlers.                                            // 1000
  if (this.mode !== EVENT_MODE_BUBBLING) {                                                              // 1001
    DomBackend.bindEventCapturer(                                                                       // 1002
      this.elem, this.type, this.selector || '*',                                                       // 1003
      this.capturingHandler);                                                                           // 1004
  }                                                                                                     // 1005
                                                                                                        // 1006
  if (this.mode !== EVENT_MODE_CAPTURING)                                                               // 1007
    DomBackend.delegateEvents(                                                                          // 1008
      this.elem, this.type,                                                                             // 1009
      this.selector || '*', this.delegatedHandler);                                                     // 1010
};                                                                                                      // 1011
                                                                                                        // 1012
HandlerRec.prototype.unbind = function () {                                                             // 1013
  if (this.mode !== EVENT_MODE_BUBBLING)                                                                // 1014
    DomBackend.unbindEventCapturer(this.elem, this.type,                                                // 1015
                                   this.capturingHandler);                                              // 1016
                                                                                                        // 1017
  if (this.mode !== EVENT_MODE_CAPTURING)                                                               // 1018
    DomBackend.undelegateEvents(this.elem, this.type,                                                   // 1019
                                this.delegatedHandler);                                                 // 1020
};                                                                                                      // 1021
                                                                                                        // 1022
                                                                                                        // 1023
// XXX could write the form of arguments for this function                                              // 1024
// in several different ways, including simply as an event map.                                         // 1025
DomRange.prototype.on = function (events, selector, handler) {                                          // 1026
  var parentNode = this.parentNode();                                                                   // 1027
  if (! parentNode)                                                                                     // 1028
    // if we're not in the DOM, silently fail.                                                          // 1029
    return;                                                                                             // 1030
  // haven't been added yet; error                                                                      // 1031
  if (parentNode.$_uiIsOffscreen)                                                                       // 1032
    throw new Error("Can't bind events before DomRange is inserted");                                   // 1033
                                                                                                        // 1034
  var eventTypes = [];                                                                                  // 1035
  events.replace(/[^ /]+/g, function (e) {                                                              // 1036
    eventTypes.push(e);                                                                                 // 1037
  });                                                                                                   // 1038
                                                                                                        // 1039
  if (! handler && (typeof selector === 'function')) {                                                  // 1040
    // omitted `selector`                                                                               // 1041
    handler = selector;                                                                                 // 1042
    selector = null;                                                                                    // 1043
  } else if (! selector) {                                                                              // 1044
    // take `""` to `null`                                                                              // 1045
    selector = null;                                                                                    // 1046
  }                                                                                                     // 1047
                                                                                                        // 1048
  for (var i = 0, N = eventTypes.length; i < N; i++) {                                                  // 1049
    var type = eventTypes[i];                                                                           // 1050
                                                                                                        // 1051
    var eventDict = parentNode.$_uievents;                                                              // 1052
    if (! eventDict)                                                                                    // 1053
      eventDict = (parentNode.$_uievents = {});                                                         // 1054
                                                                                                        // 1055
    var info = eventDict[type];                                                                         // 1056
    if (! info) {                                                                                       // 1057
      info = eventDict[type] = {};                                                                      // 1058
      info.handlers = [];                                                                               // 1059
    }                                                                                                   // 1060
    var handlerList = info.handlers;                                                                    // 1061
    var handlerRec = new HandlerRec(                                                                    // 1062
      parentNode, type, selector, handler, this);                                                       // 1063
    handlerRec.bind();                                                                                  // 1064
    handlerList.push(handlerRec);                                                                       // 1065
    // move handlers of enclosing ranges to end                                                         // 1066
    for (var r = this.owner; r; r = r.owner) {                                                          // 1067
      // r is an enclosing DomRange                                                                     // 1068
      for (var j = 0, Nj = handlerList.length;                                                          // 1069
           j < Nj; j++) {                                                                               // 1070
        var h = handlerList[j];                                                                         // 1071
        if (h.$ui === r) {                                                                              // 1072
          h.unbind();                                                                                   // 1073
          h.bind();                                                                                     // 1074
          handlerList.splice(j, 1); // remove handlerList[j]                                            // 1075
          handlerList.push(h);                                                                          // 1076
          j--; // account for removed handler                                                           // 1077
          Nj--; // don't visit appended handlers                                                        // 1078
        }                                                                                               // 1079
      }                                                                                                 // 1080
    }                                                                                                   // 1081
  }                                                                                                     // 1082
};                                                                                                      // 1083
                                                                                                        // 1084
  // Returns true if element a contains node b and is not node b.                                       // 1085
  var elementContains = function (a, b) {                                                               // 1086
    if (a.nodeType !== 1) // ELEMENT                                                                    // 1087
      return false;                                                                                     // 1088
    if (a === b)                                                                                        // 1089
      return false;                                                                                     // 1090
                                                                                                        // 1091
    if (a.compareDocumentPosition) {                                                                    // 1092
      return a.compareDocumentPosition(b) & 0x10;                                                       // 1093
    } else {                                                                                            // 1094
          // Should be only old IE and maybe other old browsers here.                                   // 1095
          // Modern Safari has both functions but seems to get contains() wrong.                        // 1096
          // IE can't handle b being a text node.  We work around this                                  // 1097
          // by doing a direct parent test now.                                                         // 1098
      b = b.parentNode;                                                                                 // 1099
      if (! (b && b.nodeType === 1)) // ELEMENT                                                         // 1100
        return false;                                                                                   // 1101
      if (a === b)                                                                                      // 1102
        return true;                                                                                    // 1103
                                                                                                        // 1104
      return a.contains(b);                                                                             // 1105
    }                                                                                                   // 1106
  };                                                                                                    // 1107
                                                                                                        // 1108
                                                                                                        // 1109
UI.DomRange = DomRange;                                                                                 // 1110
//////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                      //
// packages/ui/attrs.js                                                                                 //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                        //
                                                                                                        // 1
// An AttributeHandler object is responsible for updating a particular attribute                        // 2
// of a particular element.  AttributeHandler subclasses implement                                      // 3
// browser-specific logic for dealing with particular attributes across                                 // 4
// different browsers.                                                                                  // 5
//                                                                                                      // 6
// To define a new type of AttributeHandler, use                                                        // 7
// `var FooHandler = AttributeHandler.extend({ update: function ... })`                                 // 8
// where the `update` function takes arguments `(element, oldValue, value)`.                            // 9
// The `element` argument is always the same between calls to `update` on                               // 10
// the same instance.  `oldValue` and `value` are each either `null` or                                 // 11
// a Unicode string of the type that might be passed to the value argument                              // 12
// of `setAttribute` (i.e. not an HTML string with character references).                               // 13
// When an AttributeHandler is installed, an initial call to `update` is                                // 14
// always made with `oldValue = null`.  The `update` method can access                                  // 15
// `this.name` if the AttributeHandler class is a generic one that applies                              // 16
// to multiple attribute names.                                                                         // 17
//                                                                                                      // 18
// AttributeHandlers can store custom properties on `this`, as long as they                             // 19
// don't use the names `element`, `name`, `value`, and `oldValue`.                                      // 20
//                                                                                                      // 21
// AttributeHandlers can't influence how attributes appear in rendered HTML,                            // 22
// only how they are updated after materialization as DOM.                                              // 23
                                                                                                        // 24
AttributeHandler = function (name, value) {                                                             // 25
  this.name = name;                                                                                     // 26
  this.value = value;                                                                                   // 27
};                                                                                                      // 28
                                                                                                        // 29
_.extend(AttributeHandler.prototype, {                                                                  // 30
  update: function (element, oldValue, value) {                                                         // 31
    if (value === null) {                                                                               // 32
      if (oldValue !== null)                                                                            // 33
        element.removeAttribute(this.name);                                                             // 34
    } else {                                                                                            // 35
      element.setAttribute(this.name, this.value);                                                      // 36
    }                                                                                                   // 37
  }                                                                                                     // 38
});                                                                                                     // 39
                                                                                                        // 40
AttributeHandler.extend = function (options) {                                                          // 41
  var curType = this;                                                                                   // 42
  var subType = function AttributeHandlerSubtype(/*arguments*/) {                                       // 43
    AttributeHandler.apply(this, arguments);                                                            // 44
  };                                                                                                    // 45
  subType.prototype = new curType;                                                                      // 46
  subType.extend = curType.extend;                                                                      // 47
  if (options)                                                                                          // 48
    _.extend(subType.prototype, options);                                                               // 49
  return subType;                                                                                       // 50
};                                                                                                      // 51
                                                                                                        // 52
// Extended below to support both regular and SVG elements                                              // 53
var BaseClassHandler = AttributeHandler.extend({                                                        // 54
  update: function (element, oldValue, value) {                                                         // 55
    if (!this.getCurrentValue || !this.setValue)                                                        // 56
      throw new Error("Missing methods in subclass of 'BaseClassHandler'");                             // 57
                                                                                                        // 58
    var oldClasses = oldValue ? _.compact(oldValue.split(' ')) : [];                                    // 59
    var newClasses = value ? _.compact(value.split(' ')) : [];                                          // 60
                                                                                                        // 61
    // the current classes on the element, which we will mutate.                                        // 62
    var classes = _.compact(this.getCurrentValue(element).split(' '));                                  // 63
                                                                                                        // 64
    // optimize this later (to be asymptotically faster) if necessary                                   // 65
    _.each(oldClasses, function (c) {                                                                   // 66
      if (_.indexOf(newClasses, c) < 0)                                                                 // 67
        classes = _.without(classes, c);                                                                // 68
    });                                                                                                 // 69
    _.each(newClasses, function (c) {                                                                   // 70
      if (_.indexOf(oldClasses, c) < 0 &&                                                               // 71
          _.indexOf(classes, c) < 0)                                                                    // 72
        classes.push(c);                                                                                // 73
    });                                                                                                 // 74
                                                                                                        // 75
    this.setValue(element, classes.join(' '));                                                          // 76
  }                                                                                                     // 77
});                                                                                                     // 78
                                                                                                        // 79
var ClassHandler = BaseClassHandler.extend({                                                            // 80
  // @param rawValue {String}                                                                           // 81
  getCurrentValue: function (element) {                                                                 // 82
    return element.className;                                                                           // 83
  },                                                                                                    // 84
  setValue: function (element, className) {                                                             // 85
    element.className = className;                                                                      // 86
  }                                                                                                     // 87
});                                                                                                     // 88
                                                                                                        // 89
var SVGClassHandler = BaseClassHandler.extend({                                                         // 90
  getCurrentValue: function (element) {                                                                 // 91
    return element.className.baseVal;                                                                   // 92
  },                                                                                                    // 93
  setValue: function (element, className) {                                                             // 94
    element.setAttribute('class', className);                                                           // 95
  }                                                                                                     // 96
});                                                                                                     // 97
                                                                                                        // 98
var BooleanHandler = AttributeHandler.extend({                                                          // 99
  update: function (element, oldValue, value) {                                                         // 100
    var name = this.name;                                                                               // 101
    if (value == null) {                                                                                // 102
      if (oldValue != null)                                                                             // 103
        element[name] = false;                                                                          // 104
    } else {                                                                                            // 105
      element[name] = true;                                                                             // 106
    }                                                                                                   // 107
  }                                                                                                     // 108
});                                                                                                     // 109
                                                                                                        // 110
var ValueHandler = AttributeHandler.extend({                                                            // 111
  update: function (element, oldValue, value) {                                                         // 112
    var focused = (element === document.activeElement);                                                 // 113
                                                                                                        // 114
    if (!focused)                                                                                       // 115
      element.value = value;                                                                            // 116
  }                                                                                                     // 117
});                                                                                                     // 118
                                                                                                        // 119
// cross-browser version of `instanceof SVGElement`                                                     // 120
var isSVGElement = function (elem) {                                                                    // 121
  return 'ownerSVGElement' in elem;                                                                     // 122
};                                                                                                      // 123
                                                                                                        // 124
// XXX make it possible for users to register attribute handlers!                                       // 125
makeAttributeHandler = function (elem, name, value) {                                                   // 126
  // generally, use setAttribute but certain attributes need to be set                                  // 127
  // by directly setting a JavaScript property on the DOM element.                                      // 128
  if (name === 'class') {                                                                               // 129
    if (isSVGElement(elem)) {                                                                           // 130
      return new SVGClassHandler(name, value);                                                          // 131
    } else {                                                                                            // 132
      return new ClassHandler(name, value);                                                             // 133
    }                                                                                                   // 134
  } else if (name === 'selected' || name === 'checked') {                                               // 135
    return new BooleanHandler(name, value);                                                             // 136
  } else if ((elem.tagName === 'TEXTAREA' || elem.tagName === 'INPUT')                                  // 137
             && name === 'value') {                                                                     // 138
    // internally, TEXTAREAs tracks their value in the 'value'                                          // 139
    // attribute just like INPUTs.                                                                      // 140
    return new ValueHandler(name, value);                                                               // 141
  } else {                                                                                              // 142
    return new AttributeHandler(name, value);                                                           // 143
  }                                                                                                     // 144
                                                                                                        // 145
  // XXX will need one for 'style' on IE, though modern browsers                                        // 146
  // seem to handle setAttribute ok.                                                                    // 147
};                                                                                                      // 148
                                                                                                        // 149
//////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                      //
// packages/ui/render.js                                                                                //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                        //
                                                                                                        // 1
UI.Component.instantiate = function (parent) {                                                          // 2
  var kind = this;                                                                                      // 3
                                                                                                        // 4
  // check arguments                                                                                    // 5
  if (UI.isComponent(kind)) {                                                                           // 6
    if (kind.isInited)                                                                                  // 7
      throw new Error("A component kind is required, not an instance");                                 // 8
  } else {                                                                                              // 9
    throw new Error("Expected Component kind");                                                         // 10
  }                                                                                                     // 11
                                                                                                        // 12
  var inst = kind.extend(); // XXX args go here                                                         // 13
  inst.isInited = true;                                                                                 // 14
                                                                                                        // 15
  // XXX messy to define this here                                                                      // 16
  inst.templateInstance = {                                                                             // 17
    findAll: function (selector) {                                                                      // 18
      // XXX check that `.dom` exists here?                                                             // 19
      return inst.dom.$(selector);                                                                      // 20
    },                                                                                                  // 21
    find: function (selector) {                                                                         // 22
      var result = this.findAll(selector);                                                              // 23
      return result[0] || null;                                                                         // 24
    },                                                                                                  // 25
    firstNode: null,                                                                                    // 26
    lastNode: null,                                                                                     // 27
    data: null,                                                                                         // 28
    __component__: inst                                                                                 // 29
  };                                                                                                    // 30
                                                                                                        // 31
  inst.parent = (parent || null);                                                                       // 32
                                                                                                        // 33
  if (inst.init)                                                                                        // 34
    inst.init();                                                                                        // 35
                                                                                                        // 36
  if (inst.created) {                                                                                   // 37
    updateTemplateInstance(inst);                                                                       // 38
    inst.created.call(inst.templateInstance);                                                           // 39
  }                                                                                                     // 40
                                                                                                        // 41
  return inst;                                                                                          // 42
};                                                                                                      // 43
                                                                                                        // 44
UI.Component.render = function () {                                                                     // 45
  return null;                                                                                          // 46
};                                                                                                      // 47
                                                                                                        // 48
                                                                                                        // 49
// Takes a reactive function (call it `inner`) and returns a reactive function                          // 50
// `outer` which is equivalent except in its reactive behavior.  Specifically,                          // 51
// `outer` has the following two special properties:                                                    // 52
//                                                                                                      // 53
// 1. Isolation:  An invocation of `outer()` only invalidates its context                               // 54
//    when the value of `inner()` changes.  For example, `inner` may be a                               // 55
//    function that gets one or more Session variables and calculates a                                 // 56
//    true/false value.  `outer` blocks invalidation signals caused by the                              // 57
//    Session variables changing and sends a signal out only when the value                             // 58
//    changes between true and false (in this example).  The value can be                               // 59
//    of any type, and it is compared with `===` unless an `equals` function                            // 60
//    is provided.                                                                                      // 61
//                                                                                                      // 62
// 2. Value Sharing:  The `outer` function returned by `emboxValue` can be                              // 63
//    shared between different contexts, for example by assigning it to an                              // 64
//    object as a method that can be accessed at any time, such as by                                   // 65
//    different templates or different parts of a template.  No matter                                  // 66
//    how many times `outer` is called, `inner` is only called once until                               // 67
//    it changes.  The most recent value is stored internally.                                          // 68
//                                                                                                      // 69
// Conceptually, an emboxed value is much like a Session variable which is                              // 70
// kept up to date by an autorun.  Session variables provide storage                                    // 71
// (value sharing) and they don't notify their listeners unless a value                                 // 72
// actually changes (isolation).  The biggest difference is that such an                                // 73
// autorun would never be stopped, and the Session variable would never be                              // 74
// deleted even if it wasn't used any more.  An emboxed value, on the other                             // 75
// hand, automatically stops computing when it's not being used, and starts                             // 76
// again when called from a reactive context.  This means that when it stops                            // 77
// being used, it can be completely garbage-collected.                                                  // 78
//                                                                                                      // 79
// If a non-function value is supplied to `emboxValue` instead of a reactive                            // 80
// function, then `outer` is still a function but it simply returns the value.                          // 81
//                                                                                                      // 82
UI.emboxValue = function (funcOrValue, equals) {                                                        // 83
  if (typeof funcOrValue === 'function') {                                                              // 84
    var func = funcOrValue;                                                                             // 85
                                                                                                        // 86
    var curResult = null;                                                                               // 87
    // There's one shared Dependency and Computation for all callers of                                 // 88
    // our box function.  It gets kicked off if necessary, and when                                     // 89
    // there are no more dependents, it gets stopped to avoid leaking                                   // 90
    // memory.                                                                                          // 91
    var resultDep = null;                                                                               // 92
    var computation = null;                                                                             // 93
                                                                                                        // 94
    return function () {                                                                                // 95
      if (! computation) {                                                                              // 96
        if (! Deps.active) {                                                                            // 97
          // Not in a reactive context.  Just call func, and don't start a                              // 98
          // computation if there isn't one running already.                                            // 99
          return func();                                                                                // 100
        }                                                                                               // 101
                                                                                                        // 102
        // No running computation, so kick one off.  Since this computation                             // 103
        // will be shared, avoid any association with the current computation                           // 104
        // by using `Deps.nonreactive`.                                                                 // 105
        resultDep = new Deps.Dependency;                                                                // 106
                                                                                                        // 107
        computation = Deps.nonreactive(function () {                                                    // 108
          return Deps.autorun(function (c) {                                                            // 109
            var oldResult = curResult;                                                                  // 110
            curResult = func();                                                                         // 111
            if (! c.firstRun) {                                                                         // 112
              if (! (equals ? equals(curResult, oldResult) :                                            // 113
                     curResult === oldResult))                                                          // 114
                resultDep.changed();                                                                    // 115
            }                                                                                           // 116
          });                                                                                           // 117
        });                                                                                             // 118
      }                                                                                                 // 119
                                                                                                        // 120
      if (Deps.active) {                                                                                // 121
        var isNew = resultDep.depend();                                                                 // 122
        if (isNew) {                                                                                    // 123
          // For each new dependent, schedule a task for after that dependent's                         // 124
          // invalidation time and the subsequent flush. The task checks                                // 125
          // whether the computation should be torn down.                                               // 126
          Deps.onInvalidate(function () {                                                               // 127
            if (resultDep && ! resultDep.hasDependents()) {                                             // 128
              Deps.afterFlush(function () {                                                             // 129
                // use a second afterFlush to bump ourselves to the END of the                          // 130
                // flush, after computation re-runs have had a chance to                                // 131
                // re-establish their connections to our computation.                                   // 132
                Deps.afterFlush(function () {                                                           // 133
                  if (resultDep && ! resultDep.hasDependents()) {                                       // 134
                    computation.stop();                                                                 // 135
                    computation = null;                                                                 // 136
                    resultDep = null;                                                                   // 137
                  }                                                                                     // 138
                });                                                                                     // 139
              });                                                                                       // 140
            }                                                                                           // 141
          });                                                                                           // 142
        }                                                                                               // 143
      }                                                                                                 // 144
                                                                                                        // 145
      return curResult;                                                                                 // 146
    };                                                                                                  // 147
                                                                                                        // 148
  } else {                                                                                              // 149
    var value = funcOrValue;                                                                            // 150
    var result = function () {                                                                          // 151
      return value;                                                                                     // 152
    };                                                                                                  // 153
    result._isEmboxedConstant = true;                                                                   // 154
    return result;                                                                                      // 155
  }                                                                                                     // 156
};                                                                                                      // 157
                                                                                                        // 158
                                                                                                        // 159
////////////////////////////////////////                                                                // 160
                                                                                                        // 161
// Insert a DOM node or DomRange into a DOM element or DomRange.                                        // 162
//                                                                                                      // 163
// One of three things happens depending on what needs to be inserted into what:                        // 164
// - `range.add` (anything into DomRange)                                                               // 165
// - `UI.DomRange.insert` (DomRange into element)                                                       // 166
// - `elem.insertBefore` (node into element)                                                            // 167
//                                                                                                      // 168
// The optional `before` argument is an existing node or id to insert before in                         // 169
// the parent element or DomRange.                                                                      // 170
var insert = function (nodeOrRange, parent, before) {                                                   // 171
  if (! parent)                                                                                         // 172
    throw new Error("Materialization parent required");                                                 // 173
                                                                                                        // 174
  if (parent instanceof UI.DomRange) {                                                                  // 175
    parent.add(nodeOrRange, before);                                                                    // 176
  } else if (nodeOrRange instanceof UI.DomRange) {                                                      // 177
    // parent is an element; inserting a range                                                          // 178
    UI.DomRange.insert(nodeOrRange, parent, before);                                                    // 179
  } else {                                                                                              // 180
    // parent is an element; inserting an element                                                       // 181
    parent.insertBefore(nodeOrRange, before || null); // `null` for IE                                  // 182
  }                                                                                                     // 183
};                                                                                                      // 184
                                                                                                        // 185
// Update attributes on `elem` to the dictionary `attrs`, using the                                     // 186
// dictionary of existing `handlers` if provided.                                                       // 187
//                                                                                                      // 188
// Values in the `attrs` dictionary are in pseudo-DOM form -- a string,                                 // 189
// CharRef, or array of strings and CharRefs -- but they are passed to                                  // 190
// the AttributeHandler in string form.                                                                 // 191
var updateAttributes = function(elem, newAttrs, handlers) {                                             // 192
                                                                                                        // 193
  if (handlers) {                                                                                       // 194
    for (var k in handlers) {                                                                           // 195
      if (! newAttrs.hasOwnProperty(k)) {                                                               // 196
        // remove attributes (and handlers) for attribute names                                         // 197
        // that don't exist as keys of `newAttrs` and so won't                                          // 198
        // be visited when traversing it.  (Attributes that                                             // 199
        // exist in the `newAttrs` object but are `null`                                                // 200
        // are handled later.)                                                                          // 201
        var handler = handlers[k];                                                                      // 202
        var oldValue = handler.value;                                                                   // 203
        handler.value = null;                                                                           // 204
        handler.update(elem, oldValue, null);                                                           // 205
        delete handlers[k];                                                                             // 206
      }                                                                                                 // 207
    }                                                                                                   // 208
  }                                                                                                     // 209
                                                                                                        // 210
  for (var k in newAttrs) {                                                                             // 211
    var handler = null;                                                                                 // 212
    var oldValue;                                                                                       // 213
    var value = newAttrs[k];                                                                            // 214
    if ((! handlers) || (! handlers.hasOwnProperty(k))) {                                               // 215
      if (value !== null) {                                                                             // 216
        // make new handler                                                                             // 217
        handler = makeAttributeHandler(elem, k, value);                                                 // 218
        if (handlers)                                                                                   // 219
          handlers[k] = handler;                                                                        // 220
        oldValue = null;                                                                                // 221
      }                                                                                                 // 222
    } else {                                                                                            // 223
      handler = handlers[k];                                                                            // 224
      oldValue = handler.value;                                                                         // 225
    }                                                                                                   // 226
    if (handler && oldValue !== value) {                                                                // 227
      handler.value = value;                                                                            // 228
      handler.update(elem, oldValue, value);                                                            // 229
      if (value === null)                                                                               // 230
        delete handlers[k];                                                                             // 231
    }                                                                                                   // 232
  }                                                                                                     // 233
};                                                                                                      // 234
                                                                                                        // 235
UI.render = function (kind, parentComponent) {                                                          // 236
  if (kind.isInited)                                                                                    // 237
    throw new Error("Can't render component instance, only component kind");                            // 238
  var inst = kind.instantiate(parentComponent);                                                         // 239
                                                                                                        // 240
  var content = (inst.render && inst.render());                                                         // 241
                                                                                                        // 242
  var range = new UI.DomRange;                                                                          // 243
  inst.dom = range;                                                                                     // 244
  range.component = inst;                                                                               // 245
                                                                                                        // 246
  materialize(content, range, null, inst);                                                              // 247
                                                                                                        // 248
  range.removed = function () {                                                                         // 249
    inst.isDestroyed = true;                                                                            // 250
    if (inst.destroyed) {                                                                               // 251
      updateTemplateInstance(inst);                                                                     // 252
      inst.destroyed.call(inst.templateInstance);                                                       // 253
    }                                                                                                   // 254
  };                                                                                                    // 255
                                                                                                        // 256
  return inst;                                                                                          // 257
};                                                                                                      // 258
                                                                                                        // 259
var contentEquals = function (a, b) {                                                                   // 260
  if (a instanceof HTML.Raw) {                                                                          // 261
    return (b instanceof HTML.Raw) && (a.value === b.value);                                            // 262
  } else if (a == null) {                                                                               // 263
    return (b == null);                                                                                 // 264
  } else {                                                                                              // 265
    return (a === b) &&                                                                                 // 266
      ((typeof a === 'number') || (typeof a === 'boolean') ||                                           // 267
       (typeof a === 'string'));                                                                        // 268
  }                                                                                                     // 269
};                                                                                                      // 270
                                                                                                        // 271
UI.InTemplateScope = function (tmplInstance, content) {                                                 // 272
  if (! (this instanceof UI.InTemplateScope))                                                           // 273
    // called without `new`                                                                             // 274
    return new UI.InTemplateScope(tmplInstance, content);                                               // 275
                                                                                                        // 276
  var parentPtr = tmplInstance.parent;                                                                  // 277
  if (parentPtr.__isTemplateWith)                                                                       // 278
    parentPtr = parentPtr.parent;                                                                       // 279
                                                                                                        // 280
  this.parentPtr = parentPtr;                                                                           // 281
  this.content = content;                                                                               // 282
};                                                                                                      // 283
                                                                                                        // 284
UI.InTemplateScope.prototype.toHTML = function (parentComponent) {                                      // 285
  return HTML.toHTML(this.content, this.parentPtr);                                                     // 286
};                                                                                                      // 287
                                                                                                        // 288
UI.InTemplateScope.prototype.toText = function (textMode, parentComponent) {                            // 289
  return HTML.toText(this.content, textMode, this.parentPtr);                                           // 290
};                                                                                                      // 291
                                                                                                        // 292
// Convert the pseudoDOM `node` into reactive DOM nodes and insert them                                 // 293
// into the element or DomRange `parent`, before the node or id `before`.                               // 294
var materialize = function (node, parent, before, parentComponent) {                                    // 295
  // XXX should do more error-checking for the case where user is supplying the tags.                   // 296
  // For example, check that CharRef has `html` and `str` properties and no content.                    // 297
  // Check that Comment has a single string child and no attributes.  Etc.                              // 298
                                                                                                        // 299
  if (node == null) {                                                                                   // 300
    // null or undefined.                                                                               // 301
    // do nothinge.                                                                                     // 302
  } else if ((typeof node === 'string') || (typeof node === 'boolean') || (typeof node === 'number')) { // 303
    node = String(node);                                                                                // 304
    insert(document.createTextNode(node), parent, before);                                              // 305
  } else if (node instanceof Array) {                                                                   // 306
    for (var i = 0; i < node.length; i++)                                                               // 307
      materialize(node[i], parent, before, parentComponent);                                            // 308
  } else if (typeof node === 'function') {                                                              // 309
                                                                                                        // 310
    var range = new UI.DomRange;                                                                        // 311
    var lastContent = null;                                                                             // 312
    var rangeUpdater = Deps.autorun(function (c) {                                                      // 313
      var content = node();                                                                             // 314
      // normalize content a little, for easier comparison                                              // 315
      if (HTML.isNully(content))                                                                        // 316
        content = null;                                                                                 // 317
      else if ((content instanceof Array) && content.length === 1)                                      // 318
        content = content[0];                                                                           // 319
                                                                                                        // 320
      // update if content is different from last time                                                  // 321
      if (! contentEquals(content, lastContent)) {                                                      // 322
        lastContent = content;                                                                          // 323
                                                                                                        // 324
        if (! c.firstRun)                                                                               // 325
          range.removeAll();                                                                            // 326
                                                                                                        // 327
        Deps.nonreactive(function () {                                                                  // 328
          materialize(content, range, null, parentComponent);                                           // 329
        });                                                                                             // 330
      }                                                                                                 // 331
    });                                                                                                 // 332
    range.removed = function () {                                                                       // 333
      rangeUpdater.stop();                                                                              // 334
    };                                                                                                  // 335
    insert(range, parent, before);                                                                      // 336
  } else if (node instanceof HTML.Tag) {                                                                // 337
    var tagName = HTML.properCaseTagName(node.tagName);                                                 // 338
    var elem;                                                                                           // 339
    if (HTML.isKnownSVGElement(tagName) && (! HTML.isKnownElement(tagName)) &&                          // 340
        document.createElementNS) {                                                                     // 341
      elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);                           // 342
    } else {                                                                                            // 343
      elem = document.createElement(node.tagName);                                                      // 344
    }                                                                                                   // 345
                                                                                                        // 346
    var rawAttrs = node.attrs;                                                                          // 347
    var children = node.children;                                                                       // 348
    if (node.tagName === 'TEXTAREA') {                                                                  // 349
      rawAttrs = (rawAttrs || {});                                                                      // 350
      rawAttrs.value = children;                                                                        // 351
      children = [];                                                                                    // 352
    };                                                                                                  // 353
                                                                                                        // 354
    if (rawAttrs) {                                                                                     // 355
      var attrUpdater = Deps.autorun(function (c) {                                                     // 356
        if (! c.handlers)                                                                               // 357
          c.handlers = {};                                                                              // 358
                                                                                                        // 359
        try {                                                                                           // 360
          var attrs = HTML.evaluateAttributes(rawAttrs, parentComponent);                               // 361
          var stringAttrs = {};                                                                         // 362
          if (attrs) {                                                                                  // 363
            for (var k in attrs) {                                                                      // 364
              stringAttrs[k] = HTML.toText(attrs[k], HTML.TEXTMODE.STRING,                              // 365
                                           parentComponent);                                            // 366
            }                                                                                           // 367
            updateAttributes(elem, stringAttrs, c.handlers);                                            // 368
          }                                                                                             // 369
        } catch (e) {                                                                                   // 370
          reportUIException(e);                                                                         // 371
        }                                                                                               // 372
      });                                                                                               // 373
      UI.DomBackend.onRemoveElement(elem, function () {                                                 // 374
        attrUpdater.stop();                                                                             // 375
      });                                                                                               // 376
    }                                                                                                   // 377
    materialize(children, elem, null, parentComponent);                                                 // 378
                                                                                                        // 379
    insert(elem, parent, before);                                                                       // 380
  } else if (typeof node.instantiate === 'function') {                                                  // 381
    // component                                                                                        // 382
    var instance = UI.render(node, parentComponent);                                                    // 383
                                                                                                        // 384
    insert(instance.dom, parent, before);                                                               // 385
  } else if (node instanceof HTML.CharRef) {                                                            // 386
    insert(document.createTextNode(node.str), parent, before);                                          // 387
  } else if (node instanceof HTML.Comment) {                                                            // 388
    insert(document.createComment(node.sanitizedValue), parent, before);                                // 389
  } else if (node instanceof HTML.Raw) {                                                                // 390
    // Get an array of DOM nodes by using the browser's HTML parser                                     // 391
    // (like innerHTML).                                                                                // 392
    var htmlNodes = UI.DomBackend.parseHTML(node.value);                                                // 393
    for (var i = 0; i < htmlNodes.length; i++)                                                          // 394
      insert(htmlNodes[i], parent, before);                                                             // 395
  } else if (HTML.Special && (node instanceof HTML.Special)) {                                          // 396
    throw new Error("Can't materialize Special tag, it's just an intermediate rep");                    // 397
  } else if (node instanceof UI.InTemplateScope) {                                                      // 398
    materialize(node.content, parent, before, node.parentPtr);                                          // 399
  } else {                                                                                              // 400
    // can't get here                                                                                   // 401
    throw new Error("Unexpected node in htmljs: " + node);                                              // 402
  }                                                                                                     // 403
};                                                                                                      // 404
                                                                                                        // 405
                                                                                                        // 406
                                                                                                        // 407
// XXX figure out the right names, and namespace, for these.                                            // 408
// for example, maybe some of them go in the HTML package.                                              // 409
UI.materialize = materialize;                                                                           // 410
                                                                                                        // 411
UI.body = UI.Component.extend({                                                                         // 412
  kind: 'body',                                                                                         // 413
  contentParts: [],                                                                                     // 414
  render: function () {                                                                                 // 415
    return this.contentParts;                                                                           // 416
  },                                                                                                    // 417
  // XXX revisit how body works.                                                                        // 418
  INSTANTIATED: false                                                                                   // 419
});                                                                                                     // 420
                                                                                                        // 421
UI.block = function (renderFunc) {                                                                      // 422
  return UI.Component.extend({ render: renderFunc });                                                   // 423
};                                                                                                      // 424
                                                                                                        // 425
UI.toHTML = function (content, parentComponent) {                                                       // 426
  return HTML.toHTML(content, parentComponent);                                                         // 427
};                                                                                                      // 428
                                                                                                        // 429
UI.toRawText = function (content, parentComponent) {                                                    // 430
  return HTML.toText(content, HTML.TEXTMODE.STRING, parentComponent);                                   // 431
};                                                                                                      // 432
                                                                                                        // 433
//////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                      //
// packages/ui/builtins.js                                                                              //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                        //
                                                                                                        // 1
UI.If = function (argFunc, contentBlock, elseContentBlock) {                                            // 2
  checkBlockHelperArguments('If', argFunc, contentBlock, elseContentBlock);                             // 3
                                                                                                        // 4
  return function () {                                                                                  // 5
    if (getCondition(argFunc))                                                                          // 6
      return contentBlock;                                                                              // 7
    else                                                                                                // 8
      return elseContentBlock || null;                                                                  // 9
  };                                                                                                    // 10
};                                                                                                      // 11
                                                                                                        // 12
                                                                                                        // 13
UI.Unless = function (argFunc, contentBlock, elseContentBlock) {                                        // 14
  checkBlockHelperArguments('Unless', argFunc, contentBlock, elseContentBlock);                         // 15
                                                                                                        // 16
  return function () {                                                                                  // 17
    if (! getCondition(argFunc))                                                                        // 18
      return contentBlock;                                                                              // 19
    else                                                                                                // 20
      return elseContentBlock || null;                                                                  // 21
  };                                                                                                    // 22
};                                                                                                      // 23
                                                                                                        // 24
// Returns true if `a` and `b` are `===`, unless they are of a mutable type.                            // 25
// (Because then, they may be equal references to an object that was mutated,                           // 26
// and we'll never know.  We save only a reference to the old object; we don't                          // 27
// do any deep-copying or diffing.)                                                                     // 28
var safeEquals = function (a, b) {                                                                      // 29
  if (a !== b)                                                                                          // 30
    return false;                                                                                       // 31
  else                                                                                                  // 32
    return ((!a) || (typeof a === 'number') || (typeof a === 'boolean') ||                              // 33
            (typeof a === 'string'));                                                                   // 34
};                                                                                                      // 35
                                                                                                        // 36
// Unlike Spacebars.With, there's no else case and no conditional logic.                                // 37
//                                                                                                      // 38
// We don't do any reactive emboxing of `argFunc` here; it should be done                               // 39
// by the caller if efficiency and/or number of calls to the data source                                // 40
// is important.                                                                                        // 41
UI.With = function (argFunc, contentBlock) {                                                            // 42
  checkBlockHelperArguments('With', argFunc, contentBlock);                                             // 43
                                                                                                        // 44
  var block = contentBlock;                                                                             // 45
  if ('data' in block) {                                                                                // 46
    // XXX TODO: get religion about where `data` property goes                                          // 47
    block = UI.block(function () {                                                                      // 48
      return contentBlock;                                                                              // 49
    });                                                                                                 // 50
  }                                                                                                     // 51
  block.data = UI.emboxValue(argFunc, safeEquals);                                                      // 52
                                                                                                        // 53
  return block;                                                                                         // 54
};                                                                                                      // 55
                                                                                                        // 56
UI.Each = function (argFunc, contentBlock, elseContentBlock) {                                          // 57
  checkBlockHelperArguments('Each', argFunc, contentBlock, elseContentBlock);                           // 58
                                                                                                        // 59
  return UI.EachImpl.extend({                                                                           // 60
    __sequence: argFunc,                                                                                // 61
    __content: contentBlock,                                                                            // 62
    __elseContent: elseContentBlock                                                                     // 63
  });                                                                                                   // 64
};                                                                                                      // 65
                                                                                                        // 66
var checkBlockHelperArguments = function (which, argFunc, contentBlock, elseContentBlock) {             // 67
  if (typeof argFunc !== 'function')                                                                    // 68
    throw new Error('First argument to ' + which + ' must be a function');                              // 69
  if (! UI.isComponent(contentBlock))                                                                   // 70
    throw new Error('Second argument to ' + which + ' must be a template or UI.block');                 // 71
  if (elseContentBlock && ! UI.isComponent(elseContentBlock))                                           // 72
    throw new Error('Third argument to ' + which + ' must be a template or UI.block if present');       // 73
};                                                                                                      // 74
                                                                                                        // 75
// Acts like `!! conditionFunc()` except:                                                               // 76
//                                                                                                      // 77
// - Empty array is considered falsy                                                                    // 78
// - The result is Deps.isolated (doesn't trigger invalidation                                          // 79
//   as long as the condition stays truthy or stays falsy                                               // 80
var getCondition = function (conditionFunc) {                                                           // 81
  return Deps.isolateValue(function () {                                                                // 82
    // `condition` is emboxed; it is always a function,                                                 // 83
    // and it only triggers invalidation if its return                                                  // 84
    // value actually changes.  We still need to isolate                                                // 85
    // the calculation of whether it is truthy or falsy                                                 // 86
    // in order to not re-render if it changes from one                                                 // 87
    // truthy or falsy value to another.                                                                // 88
    var cond = conditionFunc();                                                                         // 89
                                                                                                        // 90
    // empty arrays are treated as falsey values                                                        // 91
    if (cond instanceof Array && cond.length === 0)                                                     // 92
      return false;                                                                                     // 93
    else                                                                                                // 94
      return !! cond;                                                                                   // 95
  });                                                                                                   // 96
};                                                                                                      // 97
                                                                                                        // 98
//////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                      //
// packages/ui/each.js                                                                                  //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                        //
UI.EachImpl = Component.extend({                                                                        // 1
  typeName: 'Each',                                                                                     // 2
  render: function (modeHint) {                                                                         // 3
    var self = this;                                                                                    // 4
    var content = self.__content;                                                                       // 5
    var elseContent = self.__elseContent;                                                               // 6
                                                                                                        // 7
    if (modeHint === 'STATIC') {                                                                        // 8
      // This is a hack.  The caller gives us a hint if the                                             // 9
      // value we return will be static (in HTML or text)                                               // 10
      // or dynamic (materialized DOM).  The dynamic path                                               // 11
      // returns `null` and then we populate the DOM from                                               // 12
      // the `parented` callback.                                                                       // 13
      //                                                                                                // 14
      // It would be much cleaner to always return the same                                             // 15
      // value here, and to have that value be some special                                             // 16
      // object that encapsulates the logic for populating                                              // 17
      // the #each using a mode-agnostic interface that                                                 // 18
      // works for HTML, text, and DOM.  Alternatively, we                                              // 19
      // could formalize the current pattern, e.g. defining                                             // 20
      // a method like component.populate(domRange) and one                                             // 21
      // like renderStatic() or even renderHTML / renderText.                                           // 22
      var parts = _.map(                                                                                // 23
        ObserveSequence.fetch(self.__sequence()),                                                       // 24
        function (item) {                                                                               // 25
          return content.extend({data: function () {                                                    // 26
            return item;                                                                                // 27
          }});                                                                                          // 28
        });                                                                                             // 29
                                                                                                        // 30
      if (parts.length) {                                                                               // 31
        return parts;                                                                                   // 32
      } else {                                                                                          // 33
        return elseContent;                                                                             // 34
      }                                                                                                 // 35
      return parts;                                                                                     // 36
    } else {                                                                                            // 37
      return null;                                                                                      // 38
    }                                                                                                   // 39
  },                                                                                                    // 40
  parented: function () {                                                                               // 41
    var self = this.__component__;                                                                      // 42
                                                                                                        // 43
    var range = self.dom;                                                                               // 44
                                                                                                        // 45
    var content = self.__content;                                                                       // 46
    var elseContent = self.__elseContent;                                                               // 47
                                                                                                        // 48
    // if there is an else clause, keep track of the number of                                          // 49
    // rendered items.  use this to display the else clause when count                                  // 50
    // becomes zero, and remove it when count becomes positive.                                         // 51
    var itemCount = 0;                                                                                  // 52
    var addToCount = function(delta) {                                                                  // 53
      if (!elseContent) // if no else, no need to keep track of count                                   // 54
        return;                                                                                         // 55
                                                                                                        // 56
      if (itemCount + delta < 0)                                                                        // 57
        throw new Error("count should never become negative");                                          // 58
                                                                                                        // 59
      if (itemCount === 0) {                                                                            // 60
        // remove else clause                                                                           // 61
        range.removeAll();                                                                              // 62
      }                                                                                                 // 63
      itemCount += delta;                                                                               // 64
      if (itemCount === 0) {                                                                            // 65
        UI.materialize(elseContent, range, null, self);                                                 // 66
      }                                                                                                 // 67
    };                                                                                                  // 68
                                                                                                        // 69
    this.observeHandle = ObserveSequence.observe(function () {                                          // 70
      return self.__sequence();                                                                         // 71
    }, {                                                                                                // 72
      addedAt: function (id, item, i, beforeId) {                                                       // 73
        addToCount(1);                                                                                  // 74
        id = LocalCollection._idStringify(id);                                                          // 75
                                                                                                        // 76
        var data = item;                                                                                // 77
        var dep = new Deps.Dependency;                                                                  // 78
                                                                                                        // 79
        // function to become `comp.data`                                                               // 80
        var dataFunc = function () {                                                                    // 81
          dep.depend();                                                                                 // 82
          return data;                                                                                  // 83
        };                                                                                              // 84
        // Storing `$set` on `comp.data` lets us                                                        // 85
        // access it from `changed`.                                                                    // 86
        dataFunc.$set = function (v) {                                                                  // 87
          data = v;                                                                                     // 88
          dep.changed();                                                                                // 89
        };                                                                                              // 90
                                                                                                        // 91
        if (beforeId)                                                                                   // 92
          beforeId = LocalCollection._idStringify(beforeId);                                            // 93
                                                                                                        // 94
        var renderedItem = UI.render(content.extend({data: dataFunc}), self);                           // 95
        range.add(id, renderedItem.dom, beforeId);                                                      // 96
      },                                                                                                // 97
      removed: function (id, item) {                                                                    // 98
        addToCount(-1);                                                                                 // 99
        range.remove(LocalCollection._idStringify(id));                                                 // 100
      },                                                                                                // 101
      movedTo: function (id, item, i, j, beforeId) {                                                    // 102
        range.moveBefore(                                                                               // 103
          LocalCollection._idStringify(id),                                                             // 104
          beforeId && LocalCollection._idStringify(beforeId));                                          // 105
      },                                                                                                // 106
      changed: function (id, newItem) {                                                                 // 107
        range.get(LocalCollection._idStringify(id)).component.data.$set(newItem);                       // 108
      }                                                                                                 // 109
    });                                                                                                 // 110
                                                                                                        // 111
      // on initial render, display the else clause if no items                                         // 112
      addToCount(0);                                                                                    // 113
  },                                                                                                    // 114
  destroyed: function () {                                                                              // 115
    if (this.observeHandle)                                                                             // 116
      this.observeHandle.stop();                                                                        // 117
  }                                                                                                     // 118
});                                                                                                     // 119
                                                                                                        // 120
//////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                      //
// packages/ui/fields.js                                                                                //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                        //
                                                                                                        // 1
var global = (function () { return this; })();                                                          // 2
                                                                                                        // 3
// Searches for the given property in `comp` or a parent,                                               // 4
// and returns it as is (without call it if it's a function).                                           // 5
var lookupComponentProp = function (comp, prop) {                                                       // 6
  comp = findComponentWithProp(prop, comp);                                                             // 7
  var result = (comp ? comp.data : null);                                                               // 8
  if (typeof result === 'function')                                                                     // 9
    result = _.bind(result, comp);                                                                      // 10
  return result;                                                                                        // 11
};                                                                                                      // 12
                                                                                                        // 13
// Component that's a no-op when used as a block helper like                                            // 14
// `{{#foo}}...{{/foo}}`.                                                                               // 15
var noOpComponent = Component.extend({                                                                  // 16
  kind: 'NoOp',                                                                                         // 17
  render: function () {                                                                                 // 18
    return this.__content;                                                                              // 19
  }                                                                                                     // 20
});                                                                                                     // 21
                                                                                                        // 22
// This map is searched first when you do something like `{{#foo}}` in                                  // 23
// a template.                                                                                          // 24
var builtInComponents = {                                                                               // 25
  // for past compat:                                                                                   // 26
  'constant': noOpComponent,                                                                            // 27
  'isolate': noOpComponent                                                                              // 28
};                                                                                                      // 29
                                                                                                        // 30
_extend(UI.Component, {                                                                                 // 31
  // Options:                                                                                           // 32
  //                                                                                                    // 33
  // - template {Boolean} If true, look at the list of templates after                                  // 34
  //   helpers and before data context.                                                                 // 35
  lookup: function (id, opts) {                                                                         // 36
    var self = this;                                                                                    // 37
    var template = opts && opts.template;                                                               // 38
    var result;                                                                                         // 39
    var comp;                                                                                           // 40
                                                                                                        // 41
    if (!id)                                                                                            // 42
      throw new Error("must pass id to lookup");                                                        // 43
                                                                                                        // 44
    if (/^\./.test(id)) {                                                                               // 45
      // starts with a dot. must be a series of dots which maps to an                                   // 46
      // ancestor of the appropriate height.                                                            // 47
      if (!/^(\.)+$/.test(id)) {                                                                        // 48
        throw new Error("id starting with dot must be a series of dots");                               // 49
      }                                                                                                 // 50
                                                                                                        // 51
      var compWithData = findComponentWithProp('data', self);                                           // 52
      for (var i = 1; i < id.length; i++) {                                                             // 53
        compWithData = compWithData ? findComponentWithProp('data', compWithData.parent) : null;        // 54
      }                                                                                                 // 55
                                                                                                        // 56
      return (compWithData ? compWithData.data : null);                                                 // 57
                                                                                                        // 58
    } else if ((comp = findComponentWithProp(id, self))) {                                              // 59
      // found a property or method of a component                                                      // 60
      // (`self` or one of its ancestors)                                                               // 61
      var result = comp[id];                                                                            // 62
                                                                                                        // 63
    } else if (_.has(builtInComponents, id)) {                                                          // 64
      return builtInComponents[id];                                                                     // 65
                                                                                                        // 66
    // Code to search the global namespace for capitalized names                                        // 67
    // like component classes, `Template`, `StringUtils.foo`,                                           // 68
    // etc.                                                                                             // 69
    //                                                                                                  // 70
    // } else if (/^[A-Z]/.test(id) && (id in global)) {                                                // 71
    //   // Only look for a global identifier if `id` is                                                // 72
    //   // capitalized.  This avoids having `{{name}}` mean                                            // 73
    //   // `window.name`.                                                                              // 74
    //   result = global[id];                                                                           // 75
    //   return function (/*arguments*/) {                                                              // 76
    //     var data = getComponentData(self);                                                           // 77
    //     if (typeof result === 'function')                                                            // 78
    //       return result.apply(data, arguments);                                                      // 79
    //     return result;                                                                               // 80
    //   };                                                                                             // 81
    } else if (template && _.has(Template, id)) {                                                       // 82
      return Template[id];                                                                              // 83
                                                                                                        // 84
    } else if (Handlebars._globalHelpers[id]) {                                                         // 85
      // Backwards compatibility for helpers defined with                                               // 86
      // `Handlebars.registerHelper`. XXX what is the future pattern                                    // 87
      // for this? We should definitely not put it on the Handlebars                                    // 88
      // namespace.                                                                                     // 89
      result = Handlebars._globalHelpers[id];                                                           // 90
                                                                                                        // 91
    } else {                                                                                            // 92
      // Resolve id `foo` as `data.foo` (with a "soft dot").                                            // 93
      return function (/*arguments*/) {                                                                 // 94
        var data = getComponentData(self);                                                              // 95
        if (! data)                                                                                     // 96
          return data;                                                                                  // 97
        var result = data[id];                                                                          // 98
        if (typeof result === 'function')                                                               // 99
          return result.apply(data, arguments);                                                         // 100
        return result;                                                                                  // 101
      };                                                                                                // 102
    }                                                                                                   // 103
                                                                                                        // 104
    if (typeof result === 'function' && ! result._isEmboxedConstant) {                                  // 105
      // Wrap the function `result`, binding `this` to `getComponentData(self)`.                        // 106
      // This creates a dependency when the result function is called.                                  // 107
      // Don't do this if the function is really just an emboxed constant.                              // 108
      return function (/*arguments*/) {                                                                 // 109
        var data = getComponentData(self);                                                              // 110
        return result.apply(data, arguments);                                                           // 111
      };                                                                                                // 112
    } else {                                                                                            // 113
      return result;                                                                                    // 114
    };                                                                                                  // 115
  },                                                                                                    // 116
  lookupTemplate: function (id) {                                                                       // 117
    return this.lookup(id, {template: true});                                                           // 118
  },                                                                                                    // 119
  get: function (id) {                                                                                  // 120
    // support `this.get()` to get the data context.                                                    // 121
    if (id === undefined)                                                                               // 122
      id = ".";                                                                                         // 123
                                                                                                        // 124
    var result = this.lookup(id);                                                                       // 125
    return (typeof result === 'function' ? result() : result);                                          // 126
  },                                                                                                    // 127
  set: function (id, value) {                                                                           // 128
    var comp = findComponentWithProp(id, this);                                                         // 129
    if (! comp || ! comp[id])                                                                           // 130
      throw new Error("Can't find field: " + id);                                                       // 131
    if (typeof comp[id] !== 'function')                                                                 // 132
      throw new Error("Not a settable field: " + id);                                                   // 133
    comp[id](value);                                                                                    // 134
  }                                                                                                     // 135
});                                                                                                     // 136
                                                                                                        // 137
//////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                      //
// packages/ui/handlebars_backcompat.js                                                                 //
//                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                        //
Handlebars = {                                                                                          // 1
  _globalHelpers: {},                                                                                   // 2
                                                                                                        // 3
  registerHelper: function (name, func) {                                                               // 4
    this._globalHelpers[name] = func;                                                                   // 5
  }                                                                                                     // 6
};                                                                                                      // 7
                                                                                                        // 8
// Utility to HTML-escape a string.                                                                     // 9
Handlebars._escape = (function() {                                                                      // 10
  var escape_map = {                                                                                    // 11
    "<": "&lt;",                                                                                        // 12
    ">": "&gt;",                                                                                        // 13
    '"': "&quot;",                                                                                      // 14
    "'": "&#x27;",                                                                                      // 15
    "`": "&#x60;", /* IE allows backtick-delimited attributes?? */                                      // 16
    "&": "&amp;"                                                                                        // 17
  };                                                                                                    // 18
  var escape_one = function(c) {                                                                        // 19
    return escape_map[c];                                                                               // 20
  };                                                                                                    // 21
                                                                                                        // 22
  return function (x) {                                                                                 // 23
    return x.replace(/[&<>"'`]/g, escape_one);                                                          // 24
  };                                                                                                    // 25
})();                                                                                                   // 26
                                                                                                        // 27
// Return these from {{...}} helpers to achieve the same as returning                                   // 28
// strings from {{{...}}} helpers                                                                       // 29
Handlebars.SafeString = function(string) {                                                              // 30
  this.string = string;                                                                                 // 31
};                                                                                                      // 32
Handlebars.SafeString.prototype.toString = function() {                                                 // 33
  return this.string.toString();                                                                        // 34
};                                                                                                      // 35
                                                                                                        // 36
//////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.ui = {
  UI: UI,
  Handlebars: Handlebars
};

})();

//# sourceMappingURL=5baf55ad8663a34f1ab3011566a91336f56d26ca.map


//--------- spacebars.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var HTML = Package.htmljs.HTML;
var UI = Package.ui.UI;
var Handlebars = Package.ui.Handlebars;

/* Package-scope variables */
var Spacebars;

(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                          //
// packages/spacebars/spacebars-runtime.js                                                                  //
//                                                                                                          //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                            //
Spacebars = {};                                                                                             // 1
                                                                                                            // 2
// * `templateOrFunction` - template (component) or function returning a template                           // 3
// or null                                                                                                  // 4
Spacebars.include = function (templateOrFunction, contentBlock, elseContentBlock) {                         // 5
  if (contentBlock && ! UI.isComponent(contentBlock))                                                       // 6
    throw new Error('Second argument to Spacebars.include must be a template or UI.block if present');      // 7
  if (elseContentBlock && ! UI.isComponent(elseContentBlock))                                               // 8
    throw new Error('Third argument to Spacebars.include must be a template or UI.block if present');       // 9
                                                                                                            // 10
  var props = null;                                                                                         // 11
  if (contentBlock) {                                                                                       // 12
    props = (props || {});                                                                                  // 13
    props.__content = contentBlock;                                                                         // 14
  }                                                                                                         // 15
  if (elseContentBlock) {                                                                                   // 16
    props = (props || {});                                                                                  // 17
    props.__elseContent = elseContentBlock;                                                                 // 18
  }                                                                                                         // 19
                                                                                                            // 20
  if (UI.isComponent(templateOrFunction))                                                                   // 21
    return templateOrFunction.extend(props);                                                                // 22
                                                                                                            // 23
  var func = templateOrFunction;                                                                            // 24
                                                                                                            // 25
  return function () {                                                                                      // 26
    var tmpl = Deps.isolateValue(func);                                                                     // 27
                                                                                                            // 28
    if (tmpl === null)                                                                                      // 29
      return null;                                                                                          // 30
    if (! UI.isComponent(tmpl))                                                                             // 31
      throw new Error("Expected null or template in return value from inclusion function, found: " + tmpl); // 32
                                                                                                            // 33
    return tmpl.extend(props);                                                                              // 34
  };                                                                                                        // 35
};                                                                                                          // 36
                                                                                                            // 37
// Executes `{{foo bar baz}}` when called on `(foo, bar, baz)`.                                             // 38
// If `bar` and `baz` are functions, they are called before                                                 // 39
// `foo` is called on them.                                                                                 // 40
//                                                                                                          // 41
// This is the shared part of Spacebars.mustache and                                                        // 42
// Spacebars.attrMustache, which differ in how they post-process the                                        // 43
// result.                                                                                                  // 44
Spacebars.mustacheImpl = function (value/*, args*/) {                                                       // 45
  var args = arguments;                                                                                     // 46
  // if we have any arguments (pos or kw), add an options argument                                          // 47
  // if there isn't one.                                                                                    // 48
  if (args.length > 1) {                                                                                    // 49
    var kw = args[args.length - 1];                                                                         // 50
    if (! (kw instanceof Spacebars.kw)) {                                                                   // 51
      kw = Spacebars.kw();                                                                                  // 52
      // clone arguments into an actual array, then push                                                    // 53
      // the empty kw object.                                                                               // 54
      args = Array.prototype.slice.call(arguments);                                                         // 55
      args.push(kw);                                                                                        // 56
    } else {                                                                                                // 57
      // For each keyword arg, call it if it's a function                                                   // 58
      var newHash = {};                                                                                     // 59
      for (var k in kw.hash) {                                                                              // 60
        var v = kw.hash[k];                                                                                 // 61
        newHash[k] = (typeof v === 'function' ? v() : v);                                                   // 62
      }                                                                                                     // 63
      args[args.length - 1] = Spacebars.kw(newHash);                                                        // 64
    }                                                                                                       // 65
  }                                                                                                         // 66
                                                                                                            // 67
  return Spacebars.call.apply(null, args);                                                                  // 68
};                                                                                                          // 69
                                                                                                            // 70
Spacebars.mustache = function (value/*, args*/) {                                                           // 71
  var result = Spacebars.mustacheImpl.apply(null, arguments);                                               // 72
                                                                                                            // 73
  if (result instanceof Handlebars.SafeString)                                                              // 74
    return HTML.Raw(result.toString());                                                                     // 75
  else                                                                                                      // 76
    // map `null`, `undefined`, and `false` to null, which is important                                     // 77
    // so that attributes with nully values are considered absent.                                          // 78
    // stringify anything else (e.g. strings, booleans, numbers including 0).                               // 79
    return (result == null || result === false) ? null : String(result);                                    // 80
};                                                                                                          // 81
                                                                                                            // 82
Spacebars.attrMustache = function (value/*, args*/) {                                                       // 83
  var result = Spacebars.mustacheImpl.apply(null, arguments);                                               // 84
                                                                                                            // 85
  if (result == null || result === '') {                                                                    // 86
    return null;                                                                                            // 87
  } else if (typeof result === 'object') {                                                                  // 88
    return result;                                                                                          // 89
  } else if (typeof result === 'string' && HTML.isValidAttributeName(result)) {                             // 90
    var obj = {};                                                                                           // 91
    obj[result] = '';                                                                                       // 92
    return obj;                                                                                             // 93
  } else {                                                                                                  // 94
    throw new Error("Expected valid attribute name, '', null, or object");                                  // 95
  }                                                                                                         // 96
};                                                                                                          // 97
                                                                                                            // 98
Spacebars.dataMustache = function (value/*, args*/) {                                                       // 99
  var result = Spacebars.mustacheImpl.apply(null, arguments);                                               // 100
                                                                                                            // 101
  return result;                                                                                            // 102
};                                                                                                          // 103
                                                                                                            // 104
// Idempotently wrap in `HTML.Raw`.                                                                         // 105
//                                                                                                          // 106
// Called on the return value from `Spacebars.mustache` in case the                                         // 107
// template uses triple-stache (`{{{foo bar baz}}}`).                                                       // 108
Spacebars.makeRaw = function (value) {                                                                      // 109
  if (value == null) // null or undefined                                                                   // 110
    return null;                                                                                            // 111
  else if (value instanceof HTML.Raw)                                                                       // 112
    return value;                                                                                           // 113
  else                                                                                                      // 114
    return HTML.Raw(value);                                                                                 // 115
};                                                                                                          // 116
                                                                                                            // 117
// If `value` is a function, called it on the `args`, after                                                 // 118
// evaluating the args themselves (by calling them if they are                                              // 119
// functions).  Otherwise, simply return `value` (and assert that                                           // 120
// there are no args).                                                                                      // 121
Spacebars.call = function (value/*, args*/) {                                                               // 122
  if (typeof value === 'function') {                                                                        // 123
    // evaluate arguments if they are functions (by calling them)                                           // 124
    var newArgs = [];                                                                                       // 125
    for (var i = 1; i < arguments.length; i++) {                                                            // 126
      var arg = arguments[i];                                                                               // 127
      newArgs[i-1] = (typeof arg === 'function' ? arg() : arg);                                             // 128
    }                                                                                                       // 129
                                                                                                            // 130
    return value.apply(null, newArgs);                                                                      // 131
  } else {                                                                                                  // 132
    if (arguments.length > 1)                                                                               // 133
      throw new Error("Can't call non-function: " + value);                                                 // 134
                                                                                                            // 135
    return value;                                                                                           // 136
  }                                                                                                         // 137
};                                                                                                          // 138
                                                                                                            // 139
// Call this as `Spacebars.kw({ ... })`.  The return value                                                  // 140
// is `instanceof Spacebars.kw`.                                                                            // 141
Spacebars.kw = function (hash) {                                                                            // 142
  if (! (this instanceof Spacebars.kw))                                                                     // 143
    // called without new; call with new                                                                    // 144
    return new Spacebars.kw(hash);                                                                          // 145
                                                                                                            // 146
  this.hash = hash || {};                                                                                   // 147
};                                                                                                          // 148
                                                                                                            // 149
// Call this as `Spacebars.SafeString("some HTML")`.  The return value                                      // 150
// is `instanceof Spacebars.SafeString` (and `instanceof Handlebars.SafeString).                            // 151
Spacebars.SafeString = function (html) {                                                                    // 152
  if (! (this instanceof Spacebars.SafeString))                                                             // 153
    // called without new; call with new                                                                    // 154
    return new Spacebars.SafeString(html);                                                                  // 155
                                                                                                            // 156
  return new Handlebars.SafeString(html);                                                                   // 157
};                                                                                                          // 158
Spacebars.SafeString.prototype = Handlebars.SafeString.prototype;                                           // 159
                                                                                                            // 160
// `Spacebars.dot(foo, "bar", "baz")` performs a special kind                                               // 161
// of `foo.bar.baz` that allows safe indexing of `null` and                                                 // 162
// indexing of functions (which calls the function).  If the                                                // 163
// result is a function, it is always a bound function (e.g.                                                // 164
// a wrapped version of `baz` that always uses `foo.bar` as                                                 // 165
// `this`).                                                                                                 // 166
//                                                                                                          // 167
// In `Spacebars.dot(foo, "bar")`, `foo` is assumed to be either                                            // 168
// a non-function value or a "fully-bound" function wrapping a value,                                       // 169
// where fully-bound means it takes no arguments and ignores `this`.                                        // 170
//                                                                                                          // 171
// `Spacebars.dot(foo, "bar")` performs the following steps:                                                // 172
//                                                                                                          // 173
// * If `foo` is falsy, return `foo`.                                                                       // 174
//                                                                                                          // 175
// * If `foo` is a function, call it (set `foo` to `foo()`).                                                // 176
//                                                                                                          // 177
// * If `foo` is falsy now, return `foo`.                                                                   // 178
//                                                                                                          // 179
// * Return `foo.bar`, binding it to `foo` if it's a function.                                              // 180
Spacebars.dot = function (value, id1/*, id2, ...*/) {                                                       // 181
  if (arguments.length > 2) {                                                                               // 182
    // Note: doing this recursively is probably less efficient than                                         // 183
    // doing it in an iterative loop.                                                                       // 184
    var argsForRecurse = [];                                                                                // 185
    argsForRecurse.push(Spacebars.dot(value, id1));                                                         // 186
    argsForRecurse.push.apply(argsForRecurse,                                                               // 187
                              Array.prototype.slice.call(arguments, 2));                                    // 188
    return Spacebars.dot.apply(null, argsForRecurse);                                                       // 189
  }                                                                                                         // 190
                                                                                                            // 191
  if (typeof value === 'function')                                                                          // 192
    value = value();                                                                                        // 193
                                                                                                            // 194
  if (! value)                                                                                              // 195
    return value; // falsy, don't index, pass through                                                       // 196
                                                                                                            // 197
  var result = value[id1];                                                                                  // 198
  if (typeof result !== 'function')                                                                         // 199
    return result;                                                                                          // 200
  // `value[id1]` (or `value()[id1]`) is a function.                                                        // 201
  // Bind it so that when called, `value` will be placed in `this`.                                         // 202
  return function (/*arguments*/) {                                                                         // 203
    return result.apply(value, arguments);                                                                  // 204
  };                                                                                                        // 205
};                                                                                                          // 206
                                                                                                            // 207
// Implement Spacebars's #with, which renders its else case (or nothing)                                    // 208
// if the argument is falsy.                                                                                // 209
Spacebars.With = function (argFunc, contentBlock, elseContentBlock) {                                       // 210
  // UI.With emboxes argFunc, and then we want to be sure to only call                                      // 211
  // argFunc that way so we don't call it any extra times.                                                  // 212
  var w = UI.With(argFunc, contentBlock);                                                                   // 213
  return UI.If(w.data, w, elseContentBlock);                                                                // 214
};                                                                                                          // 215
                                                                                                            // 216
Spacebars.TemplateWith = function (argFunc, contentBlock) {                                                 // 217
  var w = UI.With(argFunc, contentBlock);                                                                   // 218
  w.__isTemplateWith = true;                                                                                // 219
  return w;                                                                                                 // 220
};                                                                                                          // 221
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.spacebars = {
  Spacebars: Spacebars
};

})();

//# sourceMappingURL=dad2d487bcc43e537226e528539ce6389ad6ca4e.map


//--------- templating.js-----------
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var UI = Package.ui.UI;
var Handlebars = Package.ui.Handlebars;
var HTML = Package.htmljs.HTML;

/* Package-scope variables */
var Template;

(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
// packages/templating/global_template_object.js                                                                      //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                      //
// Create an empty template object. Packages and apps add templates on                                                // 1
// to this object.                                                                                                    // 2
Template = {};                                                                                                        // 3
                                                                                                                      // 4
Template.__define__ = function (templateName, renderFunc) {                                                           // 5
  if (Template.hasOwnProperty(templateName))                                                                          // 6
    throw new Error("There are multiple templates named '" + templateName + "'. Each template needs a unique name."); // 7
                                                                                                                      // 8
  Template[templateName] = UI.Component.extend({                                                                      // 9
    kind: "Template_" + templateName,                                                                                 // 10
    render: renderFunc                                                                                                // 11
  });                                                                                                                 // 12
};                                                                                                                    // 13
                                                                                                                      // 14
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.templating = {
  Template: Template
};

})();

//# sourceMappingURL=50df2690cc171e5e336786cd849707a03f3f1da7.map


//--------- global-imports.js-----------
/* Imports for global scope */

Meteor = Package.meteor.Meteor;
WebApp = Package.webapp.WebApp;
Log = Package.logging.Log;
Deps = Package.deps.Deps;
Session = Package.session.Session;
UI = Package.ui.UI;
Handlebars = Package.ui.Handlebars;
Spacebars = Package.spacebars.Spacebars;
Template = Package.templating.Template;
check = Package.check.check;
Match = Package.check.Match;
_ = Package.underscore._;
$ = Package.jquery.$;
jQuery = Package.jquery.jQuery;
Random = Package.random.Random;
EJSON = Package.ejson.EJSON;
HTML = Package.htmljs.HTML;



//-------------html-tools/parse.js----------

HTML.Special = function (value) {
  if (! (this instanceof HTML.Special))
    // called without `new`
    return new HTML.Special(value);

  this.value = value;
};
HTML.Special.prototype.toJS = function (options) {
  // XXX this is weird because toJS is defined in spacebars-compiler.
  // Think about where HTML.Special and toJS should go.
  return HTML.Tag.prototype.toJS.call({tagName: 'Special',
                                       attrs: this.value,
                                       children: []},
                                      options);
};

parseFragment = function (input, options) {
  var scanner;
  if (typeof input === 'string')
    scanner = new Scanner(input);
  else
    // input can be a scanner.  We'd better not have a different
    // value for the "getSpecialTag" option as when the scanner
    // was created, because we don't do anything special to reset
    // the value (which is attached to the scanner).
    scanner = input;

  // ```
  // { getSpecialTag: function (scanner, templateTagPosition) {
  //     if (templateTagPosition === HTML.TEMPLATE_TAG_POSITION.ELEMENT) {
  //       ...
  // ```
  if (options && options.getSpecialTag)
    scanner.getSpecialTag = options.getSpecialTag;

  // function (scanner) -> boolean
  var shouldStop = options && options.shouldStop;

  var result;
  if (options && options.textMode) {
    if (options.textMode === HTML.TEXTMODE.STRING) {
      result = getRawText(scanner, null, shouldStop);
    } else if (options.textMode === HTML.TEXTMODE.RCDATA) {
      result = getRCData(scanner, null, shouldStop);
    } else {
      throw new Error("Unsupported textMode: " + options.textMode);
    }
  } else {
    result = getContent(scanner, shouldStop);
  }
  if (! scanner.isEOF()) {
    // XXX we make some assumptions about shouldStop here, like that it
    // won't tell us to stop at an HTML end tag.  Should refactor
    // `shouldStop` into something more suitable.
    if (scanner.rest().slice(0, 2) === '</') {
      var closeTag = scanner.rest().slice(2).match(/^[a-z]*/i)[0];
      var isVoidElement = HTML.isVoidElement(closeTag);
      scanner.fatal("Unexpected HTML close tag" +
                    (isVoidElement ?
                     '.  <' + closeTag + '> should have no close tag.' : ''));
    }
    if (! shouldStop)
      scanner.fatal("Expected EOF");
  }

  return result;
};

// Take a numeric Unicode code point, which may be larger than 16 bits,
// and encode it as a JavaScript UTF-16 string.
//
// Adapted from
// http://stackoverflow.com/questions/7126384/expressing-utf-16-unicode-characters-in-javascript/7126661.
codePointToString = function(cp) {
  if (cp >= 0 && cp <= 0xD7FF || cp >= 0xE000 && cp <= 0xFFFF) {
    return String.fromCharCode(cp);
  } else if (cp >= 0x10000 && cp <= 0x10FFFF) {

    // we substract 0x10000 from cp to get a 20-bit number
    // in the range 0..0xFFFF
    cp -= 0x10000;

    // we add 0xD800 to the number formed by the first 10 bits
    // to give the first byte
    var first = ((0xffc00 & cp) >> 10) + 0xD800;

    // we add 0xDC00 to the number formed by the low 10 bits
    // to give the second byte
    var second = (0x3ff & cp) + 0xDC00;

    return String.fromCharCode(first) + String.fromCharCode(second);
  } else {
    return '';
  }
};

getContent = function (scanner, shouldStopFunc) {
  var items = [];

  while (! scanner.isEOF()) {
    // Stop at any top-level end tag.  We could use the tokenizer
    // but these two characters are a giveaway.
    if (scanner.rest().slice(0, 2) === '</')
      break;

    if (shouldStopFunc && shouldStopFunc(scanner))
      break;

    var token = getHTMLToken(scanner);
    if (! token)
      // tokenizer reached EOF on its own, e.g. while scanning
      // template comments like `{{! foo}}`.
      continue;

    if (token.t === 'Doctype') {
      scanner.fatal("Unexpected Doctype");
    } else if (token.t === 'Chars') {
      pushOrAppendString(items, token.v);
    } else if (token.t === 'CharRef') {
      items.push(convertCharRef(token));
    } else if (token.t === 'Comment') {
      items.push(HTML.Comment(token.v));
    } else if (token.t === 'Special') {
      // token.v is an object `{ ... }`
      items.push(HTML.Special(token.v));
    } else if (token.t === 'Tag') {
      if (token.isEnd)
        // we've already screened for `</` so this shouldn't be
        // possible.
        scanner.fatal("Assertion failed: didn't expect end tag");

      var tagName = token.n;
      // is this an element with no close tag (a BR, HR, IMG, etc.) based
      // on its name?
      var isVoid = HTML.isVoidElement(tagName);
      if (token.isSelfClosing) {
        if (! (isVoid || HTML.isKnownSVGElement(tagName)))
          scanner.fatal('Only certain elements like BR, HR, IMG, etc. (and foreign elements like SVG) are allowed to self-close');
      }

      // may be null
      var attrs = parseAttrs(token.attrs);

      var tagFunc = HTML.getTag(tagName);
      if (isVoid || token.isSelfClosing) {
        items.push(attrs ? tagFunc(attrs) : tagFunc());
      } else {
        // parse HTMl tag contents.

        // HTML treats a final `/` in a tag as part of an attribute, as in `<a href=/foo/>`, but the template author who writes `<circle r={{r}}/>`, say, may not be thinking about that, so generate a good error message in the "looks like self-close" case.
        var looksLikeSelfClose = (scanner.input.substr(scanner.pos - 2, 2) === '/>');

        var content;
        if (token.n === 'textarea') {
          if (scanner.peek() === '\n')
            scanner.pos++;
          content = getRCData(scanner, token.n, shouldStopFunc);
        } else {
          content = getContent(scanner, shouldStopFunc);
        }

        if (scanner.rest().slice(0, 2) !== '</') {
          scanner.fatal('Expected "' + tagName + '" end tag' + (looksLikeSelfClose ? ' -- if the "<' + token.n + ' />" tag was supposed to self-close, try adding a space before the "/"' : ''));
        }

        var endTag = getTagToken(scanner);

        if (! (endTag.t === 'Tag' && endTag.isEnd))
          // we've already seen `</` so this shouldn't be possible
          // without erroring.
          scanner.fatal("Assertion failed: expected end tag");

        // XXX support implied end tags in cases allowed by the spec
        if (endTag.n !== tagName) {
          scanner.fatal('Expected "' + tagName + '" end tag, found "' + endTag.n + '"' + (looksLikeSelfClose ? ' -- if the "<' + token.n + ' />" tag was supposed to self-close, try adding a space before the "/"' : ''));
        }

        // make `content` into an array suitable for applying tag constructor
        // as in `FOO.apply(null, content)`.
        if (content == null)
          content = [];
        else if (! (content instanceof Array))
          content = [content];

        items.push(HTML.getTag(tagName).apply(
          null, (attrs ? [attrs] : []).concat(content)));
      }
    } else {
      scanner.fatal("Unknown token type: " + token.t);
    }
  }

  if (items.length === 0)
    return null;
  else if (items.length === 1)
    return items[0];
  else
    return items;
};

var pushOrAppendString = function (items, string) {
  if (items.length &&
      typeof items[items.length - 1] === 'string')
    items[items.length - 1] += string;
  else
    items.push(string);
};

// get RCDATA to go in the lowercase tagName (e.g. "textarea")
getRCData = function (scanner, tagName, shouldStopFunc) {
  var items = [];

  while (! scanner.isEOF()) {
    // break at appropriate end tag
    if (tagName && isLookingAtEndTag(scanner, tagName))
      break;

    if (shouldStopFunc && shouldStopFunc(scanner))
      break;

    var token = getHTMLToken(scanner, 'rcdata');
    if (! token)
      // tokenizer reached EOF on its own, e.g. while scanning
      // template comments like `{{! foo}}`.
      continue;

    if (token.t === 'Chars') {
      pushOrAppendString(items, token.v);
    } else if (token.t === 'CharRef') {
      items.push(convertCharRef(token));
    } else if (token.t === 'Special') {
      // token.v is an object `{ ... }`
      items.push(HTML.Special(token.v));
    } else {
      // (can't happen)
      scanner.fatal("Unknown or unexpected token type: " + token.t);
    }
  }

  if (items.length === 0)
    return null;
  else if (items.length === 1)
    return items[0];
  else
    return items;
};

var getRawText = function (scanner, tagName, shouldStopFunc) {
  var items = [];

  while (! scanner.isEOF()) {
    // break at appropriate end tag
    if (tagName && isLookingAtEndTag(scanner, tagName))
      break;

    if (shouldStopFunc && shouldStopFunc(scanner))
      break;

    var token = getHTMLToken(scanner, 'rawtext');
    if (! token)
      // tokenizer reached EOF on its own, e.g. while scanning
      // template comments like `{{! foo}}`.
      continue;

    if (token.t === 'Chars') {
      pushOrAppendString(items, token.v);
    } else if (token.t === 'Special') {
      // token.v is an object `{ ... }`
      items.push(HTML.Special(token.v));
    } else {
      // (can't happen)
      scanner.fatal("Unknown or unexpected token type: " + token.t);
    }
  }

  if (items.length === 0)
    return null;
  else if (items.length === 1)
    return items[0];
  else
    return items;
};

// Input: A token like `{ t: 'CharRef', v: '&amp;', cp: [38] }`.
//
// Output: A tag like `HTML.CharRef({ html: '&amp;', str: '&' })`.
var convertCharRef = function (token) {
  var codePoints = token.cp;
  var str = '';
  for (var i = 0; i < codePoints.length; i++)
    str += codePointToString(codePoints[i]);
  return HTML.CharRef({ html: token.v, str: str });
};

// Input is always a dictionary (even if zero attributes) and each
// value in the dictionary is an array of `Chars`, `CharRef`,
// and maybe `Special` tokens.
//
// Output is null if there are zero attributes, and otherwise a
// dictionary.  Each value in the dictionary is HTMLjs (e.g. a
// string or an array of `Chars`, `CharRef`, and `Special`
// nodes).
//
// An attribute value with no input tokens is represented as "",
// not an empty array, in order to prop open empty attributes
// with no template tags.
var parseAttrs = function (attrs) {
  var result = null;

  for (var k in attrs) {
    if (! result)
      result = {};

    var inValue = attrs[k];
    var outParts = [];
    for (var i = 0; i < inValue.length; i++) {
      var token = inValue[i];
      if (token.t === 'CharRef') {
        outParts.push(convertCharRef(token));
      } else if (token.t === 'Special') {
        outParts.push(HTML.Special(token.v));
      } else if (token.t === 'Chars') {
        pushOrAppendString(outParts, token.v);
      }
    }

    if (k === '$specials') {
      // the `$specials` pseudo-attribute should always get an
      // array, even if there is only one Special.
      result[k] = outParts;
    } else {
      var outValue = (inValue.length === 0 ? '' :
                      (outParts.length === 1 ? outParts[0] : outParts));
      var properKey = HTML.properCaseAttributeName(k);
      result[properKey] = outValue;
    }
  }

  return result;
};

//-------------html-tools/scanner.js----------
// This is a Scanner class suitable for any parser/lexer/tokenizer.
//
// A Scanner has an immutable source document (string) `input` and a current
// position `pos`, an index into the string, which can be set at will.
//
// * `new Scanner(input)` - constructs a Scanner with source string `input`
// * `scanner.rest()` - returns the rest of the input after `pos`
// * `scanner.peek()` - returns the character at `pos`
// * `scanner.isEOF()` - true if `pos` is at or beyond the end of `input`
// * `scanner.fatal(msg)` - throw an error indicating a problem at `pos`

Scanner = function (input) {
  this.input = input; // public, read-only
  this.pos = 0; // public, read-write
};

Scanner.prototype.rest = function () {
  // Slicing a string is O(1) in modern JavaScript VMs (including old IE).
  return this.input.slice(this.pos);
};

Scanner.prototype.isEOF = function () {
  return this.pos >= this.input.length;
};

Scanner.prototype.fatal = function (msg) {
  // despite this default, you should always provide a message!
  msg = (msg || "Parse error");

  var CONTEXT_AMOUNT = 20;

  var input = this.input;
  var pos = this.pos;
  var pastInput = input.substring(pos - CONTEXT_AMOUNT - 1, pos);
  if (pastInput.length > CONTEXT_AMOUNT)
    pastInput = '...' + pastInput.substring(-CONTEXT_AMOUNT);

  var upcomingInput = input.substring(pos, pos + CONTEXT_AMOUNT + 1);
  if (upcomingInput.length > CONTEXT_AMOUNT)
    upcomingInput = upcomingInput.substring(0, CONTEXT_AMOUNT) + '...';

  var positionDisplay = ((pastInput + upcomingInput).replace(/\n/g, ' ') + '\n' +
                         (new Array(pastInput.length + 1).join(' ')) + "^");

  var e = new Error(msg + "\n" + positionDisplay);

  e.offset = pos;
  var allPastInput = input.substring(0, pos);
  e.line = (1 + (allPastInput.match(/\n/g) || []).length);
  e.col = (1 + pos - allPastInput.lastIndexOf('\n'));
  e.scanner = this;

  throw e;
};

// Peek at the next character.
//
// If `isEOF`, returns an empty string.
Scanner.prototype.peek = function () {
  return this.input.charAt(this.pos);
};

// Constructs a `getFoo` function where `foo` is specified with a regex.
// The regex should start with `^`.  The constructed function will return
// match group 1, if it exists and matches a non-empty string, or else
// the entire matched string (or null if there is no match).
//
// A `getFoo` function tries to match and consume a foo.  If it succeeds,
// the current position of the scanner is advanced.  If it fails, the
// current position is not advanced and a falsy value (typically null)
// is returned.
makeRegexMatcher = function (regex) {
  return function (scanner) {
    var match = regex.exec(scanner.rest());

    if (! match)
      return null;

    scanner.pos += match[0].length;
    return match[1] || match[0];
  };
};


//-------------html-tools/charref.js----------

// http://www.whatwg.org/specs/web-apps/current-work/multipage/entities.json


// Note that some entities don't have a final semicolon!  These are used to
// make `&lt` (for example) with no semicolon a parse error but `&abcde` not.

var ENTITIES = {
  "&Aacute;": { "codepoints": [193], "characters": "\u00C1" },
  "&Aacute": { "codepoints": [193], "characters": "\u00C1" },
  "&aacute;": { "codepoints": [225], "characters": "\u00E1" },
  "&aacute": { "codepoints": [225], "characters": "\u00E1" },
  "&Abreve;": { "codepoints": [258], "characters": "\u0102" },
  "&abreve;": { "codepoints": [259], "characters": "\u0103" },
  "&ac;": { "codepoints": [8766], "characters": "\u223E" },
  "&acd;": { "codepoints": [8767], "characters": "\u223F" },
  "&acE;": { "codepoints": [8766, 819], "characters": "\u223E\u0333" },
  "&Acirc;": { "codepoints": [194], "characters": "\u00C2" },
  "&Acirc": { "codepoints": [194], "characters": "\u00C2" },
  "&acirc;": { "codepoints": [226], "characters": "\u00E2" },
  "&acirc": { "codepoints": [226], "characters": "\u00E2" },
  "&acute;": { "codepoints": [180], "characters": "\u00B4" },
  "&acute": { "codepoints": [180], "characters": "\u00B4" },
  "&Acy;": { "codepoints": [1040], "characters": "\u0410" },
  "&acy;": { "codepoints": [1072], "characters": "\u0430" },
  "&AElig;": { "codepoints": [198], "characters": "\u00C6" },
  "&AElig": { "codepoints": [198], "characters": "\u00C6" },
  "&aelig;": { "codepoints": [230], "characters": "\u00E6" },
  "&aelig": { "codepoints": [230], "characters": "\u00E6" },
  "&af;": { "codepoints": [8289], "characters": "\u2061" },
  "&Afr;": { "codepoints": [120068], "characters": "\uD835\uDD04" },
  "&afr;": { "codepoints": [120094], "characters": "\uD835\uDD1E" },
  "&Agrave;": { "codepoints": [192], "characters": "\u00C0" },
  "&Agrave": { "codepoints": [192], "characters": "\u00C0" },
  "&agrave;": { "codepoints": [224], "characters": "\u00E0" },
  "&agrave": { "codepoints": [224], "characters": "\u00E0" },
  "&alefsym;": { "codepoints": [8501], "characters": "\u2135" },
  "&aleph;": { "codepoints": [8501], "characters": "\u2135" },
  "&Alpha;": { "codepoints": [913], "characters": "\u0391" },
  "&alpha;": { "codepoints": [945], "characters": "\u03B1" },
  "&Amacr;": { "codepoints": [256], "characters": "\u0100" },
  "&amacr;": { "codepoints": [257], "characters": "\u0101" },
  "&amalg;": { "codepoints": [10815], "characters": "\u2A3F" },
  "&amp;": { "codepoints": [38], "characters": "\u0026" },
  "&amp": { "codepoints": [38], "characters": "\u0026" },
  "&AMP;": { "codepoints": [38], "characters": "\u0026" },
  "&AMP": { "codepoints": [38], "characters": "\u0026" },
  "&andand;": { "codepoints": [10837], "characters": "\u2A55" },
  "&And;": { "codepoints": [10835], "characters": "\u2A53" },
  "&and;": { "codepoints": [8743], "characters": "\u2227" },
  "&andd;": { "codepoints": [10844], "characters": "\u2A5C" },
  "&andslope;": { "codepoints": [10840], "characters": "\u2A58" },
  "&andv;": { "codepoints": [10842], "characters": "\u2A5A" },
  "&ang;": { "codepoints": [8736], "characters": "\u2220" },
  "&ange;": { "codepoints": [10660], "characters": "\u29A4" },
  "&angle;": { "codepoints": [8736], "characters": "\u2220" },
  "&angmsdaa;": { "codepoints": [10664], "characters": "\u29A8" },
  "&angmsdab;": { "codepoints": [10665], "characters": "\u29A9" },
  "&angmsdac;": { "codepoints": [10666], "characters": "\u29AA" },
  "&angmsdad;": { "codepoints": [10667], "characters": "\u29AB" },
  "&angmsdae;": { "codepoints": [10668], "characters": "\u29AC" },
  "&angmsdaf;": { "codepoints": [10669], "characters": "\u29AD" },
  "&angmsdag;": { "codepoints": [10670], "characters": "\u29AE" },
  "&angmsdah;": { "codepoints": [10671], "characters": "\u29AF" },
  "&angmsd;": { "codepoints": [8737], "characters": "\u2221" },
  "&angrt;": { "codepoints": [8735], "characters": "\u221F" },
  "&angrtvb;": { "codepoints": [8894], "characters": "\u22BE" },
  "&angrtvbd;": { "codepoints": [10653], "characters": "\u299D" },
  "&angsph;": { "codepoints": [8738], "characters": "\u2222" },
  "&angst;": { "codepoints": [197], "characters": "\u00C5" },
  "&angzarr;": { "codepoints": [9084], "characters": "\u237C" },
  "&Aogon;": { "codepoints": [260], "characters": "\u0104" },
  "&aogon;": { "codepoints": [261], "characters": "\u0105" },
  "&Aopf;": { "codepoints": [120120], "characters": "\uD835\uDD38" },
  "&aopf;": { "codepoints": [120146], "characters": "\uD835\uDD52" },
  "&apacir;": { "codepoints": [10863], "characters": "\u2A6F" },
  "&ap;": { "codepoints": [8776], "characters": "\u2248" },
  "&apE;": { "codepoints": [10864], "characters": "\u2A70" },
  "&ape;": { "codepoints": [8778], "characters": "\u224A" },
  "&apid;": { "codepoints": [8779], "characters": "\u224B" },
  "&apos;": { "codepoints": [39], "characters": "\u0027" },
  "&ApplyFunction;": { "codepoints": [8289], "characters": "\u2061" },
  "&approx;": { "codepoints": [8776], "characters": "\u2248" },
  "&approxeq;": { "codepoints": [8778], "characters": "\u224A" },
  "&Aring;": { "codepoints": [197], "characters": "\u00C5" },
  "&Aring": { "codepoints": [197], "characters": "\u00C5" },
  "&aring;": { "codepoints": [229], "characters": "\u00E5" },
  "&aring": { "codepoints": [229], "characters": "\u00E5" },
  "&Ascr;": { "codepoints": [119964], "characters": "\uD835\uDC9C" },
  "&ascr;": { "codepoints": [119990], "characters": "\uD835\uDCB6" },
  "&Assign;": { "codepoints": [8788], "characters": "\u2254" },
  "&ast;": { "codepoints": [42], "characters": "\u002A" },
  "&asymp;": { "codepoints": [8776], "characters": "\u2248" },
  "&asympeq;": { "codepoints": [8781], "characters": "\u224D" },
  "&Atilde;": { "codepoints": [195], "characters": "\u00C3" },
  "&Atilde": { "codepoints": [195], "characters": "\u00C3" },
  "&atilde;": { "codepoints": [227], "characters": "\u00E3" },
  "&atilde": { "codepoints": [227], "characters": "\u00E3" },
  "&Auml;": { "codepoints": [196], "characters": "\u00C4" },
  "&Auml": { "codepoints": [196], "characters": "\u00C4" },
  "&auml;": { "codepoints": [228], "characters": "\u00E4" },
  "&auml": { "codepoints": [228], "characters": "\u00E4" },
  "&awconint;": { "codepoints": [8755], "characters": "\u2233" },
  "&awint;": { "codepoints": [10769], "characters": "\u2A11" },
  "&backcong;": { "codepoints": [8780], "characters": "\u224C" },
  "&backepsilon;": { "codepoints": [1014], "characters": "\u03F6" },
  "&backprime;": { "codepoints": [8245], "characters": "\u2035" },
  "&backsim;": { "codepoints": [8765], "characters": "\u223D" },
  "&backsimeq;": { "codepoints": [8909], "characters": "\u22CD" },
  "&Backslash;": { "codepoints": [8726], "characters": "\u2216" },
  "&Barv;": { "codepoints": [10983], "characters": "\u2AE7" },
  "&barvee;": { "codepoints": [8893], "characters": "\u22BD" },
  "&barwed;": { "codepoints": [8965], "characters": "\u2305" },
  "&Barwed;": { "codepoints": [8966], "characters": "\u2306" },
  "&barwedge;": { "codepoints": [8965], "characters": "\u2305" },
  "&bbrk;": { "codepoints": [9141], "characters": "\u23B5" },
  "&bbrktbrk;": { "codepoints": [9142], "characters": "\u23B6" },
  "&bcong;": { "codepoints": [8780], "characters": "\u224C" },
  "&Bcy;": { "codepoints": [1041], "characters": "\u0411" },
  "&bcy;": { "codepoints": [1073], "characters": "\u0431" },
  "&bdquo;": { "codepoints": [8222], "characters": "\u201E" },
  "&becaus;": { "codepoints": [8757], "characters": "\u2235" },
  "&because;": { "codepoints": [8757], "characters": "\u2235" },
  "&Because;": { "codepoints": [8757], "characters": "\u2235" },
  "&bemptyv;": { "codepoints": [10672], "characters": "\u29B0" },
  "&bepsi;": { "codepoints": [1014], "characters": "\u03F6" },
  "&bernou;": { "codepoints": [8492], "characters": "\u212C" },
  "&Bernoullis;": { "codepoints": [8492], "characters": "\u212C" },
  "&Beta;": { "codepoints": [914], "characters": "\u0392" },
  "&beta;": { "codepoints": [946], "characters": "\u03B2" },
  "&beth;": { "codepoints": [8502], "characters": "\u2136" },
  "&between;": { "codepoints": [8812], "characters": "\u226C" },
  "&Bfr;": { "codepoints": [120069], "characters": "\uD835\uDD05" },
  "&bfr;": { "codepoints": [120095], "characters": "\uD835\uDD1F" },
  "&bigcap;": { "codepoints": [8898], "characters": "\u22C2" },
  "&bigcirc;": { "codepoints": [9711], "characters": "\u25EF" },
  "&bigcup;": { "codepoints": [8899], "characters": "\u22C3" },
  "&bigodot;": { "codepoints": [10752], "characters": "\u2A00" },
  "&bigoplus;": { "codepoints": [10753], "characters": "\u2A01" },
  "&bigotimes;": { "codepoints": [10754], "characters": "\u2A02" },
  "&bigsqcup;": { "codepoints": [10758], "characters": "\u2A06" },
  "&bigstar;": { "codepoints": [9733], "characters": "\u2605" },
  "&bigtriangledown;": { "codepoints": [9661], "characters": "\u25BD" },
  "&bigtriangleup;": { "codepoints": [9651], "characters": "\u25B3" },
  "&biguplus;": { "codepoints": [10756], "characters": "\u2A04" },
  "&bigvee;": { "codepoints": [8897], "characters": "\u22C1" },
  "&bigwedge;": { "codepoints": [8896], "characters": "\u22C0" },
  "&bkarow;": { "codepoints": [10509], "characters": "\u290D" },
  "&blacklozenge;": { "codepoints": [10731], "characters": "\u29EB" },
  "&blacksquare;": { "codepoints": [9642], "characters": "\u25AA" },
  "&blacktriangle;": { "codepoints": [9652], "characters": "\u25B4" },
  "&blacktriangledown;": { "codepoints": [9662], "characters": "\u25BE" },
  "&blacktriangleleft;": { "codepoints": [9666], "characters": "\u25C2" },
  "&blacktriangleright;": { "codepoints": [9656], "characters": "\u25B8" },
  "&blank;": { "codepoints": [9251], "characters": "\u2423" },
  "&blk12;": { "codepoints": [9618], "characters": "\u2592" },
  "&blk14;": { "codepoints": [9617], "characters": "\u2591" },
  "&blk34;": { "codepoints": [9619], "characters": "\u2593" },
  "&block;": { "codepoints": [9608], "characters": "\u2588" },
  "&bne;": { "codepoints": [61, 8421], "characters": "\u003D\u20E5" },
  "&bnequiv;": { "codepoints": [8801, 8421], "characters": "\u2261\u20E5" },
  "&bNot;": { "codepoints": [10989], "characters": "\u2AED" },
  "&bnot;": { "codepoints": [8976], "characters": "\u2310" },
  "&Bopf;": { "codepoints": [120121], "characters": "\uD835\uDD39" },
  "&bopf;": { "codepoints": [120147], "characters": "\uD835\uDD53" },
  "&bot;": { "codepoints": [8869], "characters": "\u22A5" },
  "&bottom;": { "codepoints": [8869], "characters": "\u22A5" },
  "&bowtie;": { "codepoints": [8904], "characters": "\u22C8" },
  "&boxbox;": { "codepoints": [10697], "characters": "\u29C9" },
  "&boxdl;": { "codepoints": [9488], "characters": "\u2510" },
  "&boxdL;": { "codepoints": [9557], "characters": "\u2555" },
  "&boxDl;": { "codepoints": [9558], "characters": "\u2556" },
  "&boxDL;": { "codepoints": [9559], "characters": "\u2557" },
  "&boxdr;": { "codepoints": [9484], "characters": "\u250C" },
  "&boxdR;": { "codepoints": [9554], "characters": "\u2552" },
  "&boxDr;": { "codepoints": [9555], "characters": "\u2553" },
  "&boxDR;": { "codepoints": [9556], "characters": "\u2554" },
  "&boxh;": { "codepoints": [9472], "characters": "\u2500" },
  "&boxH;": { "codepoints": [9552], "characters": "\u2550" },
  "&boxhd;": { "codepoints": [9516], "characters": "\u252C" },
  "&boxHd;": { "codepoints": [9572], "characters": "\u2564" },
  "&boxhD;": { "codepoints": [9573], "characters": "\u2565" },
  "&boxHD;": { "codepoints": [9574], "characters": "\u2566" },
  "&boxhu;": { "codepoints": [9524], "characters": "\u2534" },
  "&boxHu;": { "codepoints": [9575], "characters": "\u2567" },
  "&boxhU;": { "codepoints": [9576], "characters": "\u2568" },
  "&boxHU;": { "codepoints": [9577], "characters": "\u2569" },
  "&boxminus;": { "codepoints": [8863], "characters": "\u229F" },
  "&boxplus;": { "codepoints": [8862], "characters": "\u229E" },
  "&boxtimes;": { "codepoints": [8864], "characters": "\u22A0" },
  "&boxul;": { "codepoints": [9496], "characters": "\u2518" },
  "&boxuL;": { "codepoints": [9563], "characters": "\u255B" },
  "&boxUl;": { "codepoints": [9564], "characters": "\u255C" },
  "&boxUL;": { "codepoints": [9565], "characters": "\u255D" },
  "&boxur;": { "codepoints": [9492], "characters": "\u2514" },
  "&boxuR;": { "codepoints": [9560], "characters": "\u2558" },
  "&boxUr;": { "codepoints": [9561], "characters": "\u2559" },
  "&boxUR;": { "codepoints": [9562], "characters": "\u255A" },
  "&boxv;": { "codepoints": [9474], "characters": "\u2502" },
  "&boxV;": { "codepoints": [9553], "characters": "\u2551" },
  "&boxvh;": { "codepoints": [9532], "characters": "\u253C" },
  "&boxvH;": { "codepoints": [9578], "characters": "\u256A" },
  "&boxVh;": { "codepoints": [9579], "characters": "\u256B" },
  "&boxVH;": { "codepoints": [9580], "characters": "\u256C" },
  "&boxvl;": { "codepoints": [9508], "characters": "\u2524" },
  "&boxvL;": { "codepoints": [9569], "characters": "\u2561" },
  "&boxVl;": { "codepoints": [9570], "characters": "\u2562" },
  "&boxVL;": { "codepoints": [9571], "characters": "\u2563" },
  "&boxvr;": { "codepoints": [9500], "characters": "\u251C" },
  "&boxvR;": { "codepoints": [9566], "characters": "\u255E" },
  "&boxVr;": { "codepoints": [9567], "characters": "\u255F" },
  "&boxVR;": { "codepoints": [9568], "characters": "\u2560" },
  "&bprime;": { "codepoints": [8245], "characters": "\u2035" },
  "&breve;": { "codepoints": [728], "characters": "\u02D8" },
  "&Breve;": { "codepoints": [728], "characters": "\u02D8" },
  "&brvbar;": { "codepoints": [166], "characters": "\u00A6" },
  "&brvbar": { "codepoints": [166], "characters": "\u00A6" },
  "&bscr;": { "codepoints": [119991], "characters": "\uD835\uDCB7" },
  "&Bscr;": { "codepoints": [8492], "characters": "\u212C" },
  "&bsemi;": { "codepoints": [8271], "characters": "\u204F" },
  "&bsim;": { "codepoints": [8765], "characters": "\u223D" },
  "&bsime;": { "codepoints": [8909], "characters": "\u22CD" },
  "&bsolb;": { "codepoints": [10693], "characters": "\u29C5" },
  "&bsol;": { "codepoints": [92], "characters": "\u005C" },
  "&bsolhsub;": { "codepoints": [10184], "characters": "\u27C8" },
  "&bull;": { "codepoints": [8226], "characters": "\u2022" },
  "&bullet;": { "codepoints": [8226], "characters": "\u2022" },
  "&bump;": { "codepoints": [8782], "characters": "\u224E" },
  "&bumpE;": { "codepoints": [10926], "characters": "\u2AAE" },
  "&bumpe;": { "codepoints": [8783], "characters": "\u224F" },
  "&Bumpeq;": { "codepoints": [8782], "characters": "\u224E" },
  "&bumpeq;": { "codepoints": [8783], "characters": "\u224F" },
  "&Cacute;": { "codepoints": [262], "characters": "\u0106" },
  "&cacute;": { "codepoints": [263], "characters": "\u0107" },
  "&capand;": { "codepoints": [10820], "characters": "\u2A44" },
  "&capbrcup;": { "codepoints": [10825], "characters": "\u2A49" },
  "&capcap;": { "codepoints": [10827], "characters": "\u2A4B" },
  "&cap;": { "codepoints": [8745], "characters": "\u2229" },
  "&Cap;": { "codepoints": [8914], "characters": "\u22D2" },
  "&capcup;": { "codepoints": [10823], "characters": "\u2A47" },
  "&capdot;": { "codepoints": [10816], "characters": "\u2A40" },
  "&CapitalDifferentialD;": { "codepoints": [8517], "characters": "\u2145" },
  "&caps;": { "codepoints": [8745, 65024], "characters": "\u2229\uFE00" },
  "&caret;": { "codepoints": [8257], "characters": "\u2041" },
  "&caron;": { "codepoints": [711], "characters": "\u02C7" },
  "&Cayleys;": { "codepoints": [8493], "characters": "\u212D" },
  "&ccaps;": { "codepoints": [10829], "characters": "\u2A4D" },
  "&Ccaron;": { "codepoints": [268], "characters": "\u010C" },
  "&ccaron;": { "codepoints": [269], "characters": "\u010D" },
  "&Ccedil;": { "codepoints": [199], "characters": "\u00C7" },
  "&Ccedil": { "codepoints": [199], "characters": "\u00C7" },
  "&ccedil;": { "codepoints": [231], "characters": "\u00E7" },
  "&ccedil": { "codepoints": [231], "characters": "\u00E7" },
  "&Ccirc;": { "codepoints": [264], "characters": "\u0108" },
  "&ccirc;": { "codepoints": [265], "characters": "\u0109" },
  "&Cconint;": { "codepoints": [8752], "characters": "\u2230" },
  "&ccups;": { "codepoints": [10828], "characters": "\u2A4C" },
  "&ccupssm;": { "codepoints": [10832], "characters": "\u2A50" },
  "&Cdot;": { "codepoints": [266], "characters": "\u010A" },
  "&cdot;": { "codepoints": [267], "characters": "\u010B" },
  "&cedil;": { "codepoints": [184], "characters": "\u00B8" },
  "&cedil": { "codepoints": [184], "characters": "\u00B8" },
  "&Cedilla;": { "codepoints": [184], "characters": "\u00B8" },
  "&cemptyv;": { "codepoints": [10674], "characters": "\u29B2" },
  "&cent;": { "codepoints": [162], "characters": "\u00A2" },
  "&cent": { "codepoints": [162], "characters": "\u00A2" },
  "&centerdot;": { "codepoints": [183], "characters": "\u00B7" },
  "&CenterDot;": { "codepoints": [183], "characters": "\u00B7" },
  "&cfr;": { "codepoints": [120096], "characters": "\uD835\uDD20" },
  "&Cfr;": { "codepoints": [8493], "characters": "\u212D" },
  "&CHcy;": { "codepoints": [1063], "characters": "\u0427" },
  "&chcy;": { "codepoints": [1095], "characters": "\u0447" },
  "&check;": { "codepoints": [10003], "characters": "\u2713" },
  "&checkmark;": { "codepoints": [10003], "characters": "\u2713" },
  "&Chi;": { "codepoints": [935], "characters": "\u03A7" },
  "&chi;": { "codepoints": [967], "characters": "\u03C7" },
  "&circ;": { "codepoints": [710], "characters": "\u02C6" },
  "&circeq;": { "codepoints": [8791], "characters": "\u2257" },
  "&circlearrowleft;": { "codepoints": [8634], "characters": "\u21BA" },
  "&circlearrowright;": { "codepoints": [8635], "characters": "\u21BB" },
  "&circledast;": { "codepoints": [8859], "characters": "\u229B" },
  "&circledcirc;": { "codepoints": [8858], "characters": "\u229A" },
  "&circleddash;": { "codepoints": [8861], "characters": "\u229D" },
  "&CircleDot;": { "codepoints": [8857], "characters": "\u2299" },
  "&circledR;": { "codepoints": [174], "characters": "\u00AE" },
  "&circledS;": { "codepoints": [9416], "characters": "\u24C8" },
  "&CircleMinus;": { "codepoints": [8854], "characters": "\u2296" },
  "&CirclePlus;": { "codepoints": [8853], "characters": "\u2295" },
  "&CircleTimes;": { "codepoints": [8855], "characters": "\u2297" },
  "&cir;": { "codepoints": [9675], "characters": "\u25CB" },
  "&cirE;": { "codepoints": [10691], "characters": "\u29C3" },
  "&cire;": { "codepoints": [8791], "characters": "\u2257" },
  "&cirfnint;": { "codepoints": [10768], "characters": "\u2A10" },
  "&cirmid;": { "codepoints": [10991], "characters": "\u2AEF" },
  "&cirscir;": { "codepoints": [10690], "characters": "\u29C2" },
  "&ClockwiseContourIntegral;": { "codepoints": [8754], "characters": "\u2232" },
  "&CloseCurlyDoubleQuote;": { "codepoints": [8221], "characters": "\u201D" },
  "&CloseCurlyQuote;": { "codepoints": [8217], "characters": "\u2019" },
  "&clubs;": { "codepoints": [9827], "characters": "\u2663" },
  "&clubsuit;": { "codepoints": [9827], "characters": "\u2663" },
  "&colon;": { "codepoints": [58], "characters": "\u003A" },
  "&Colon;": { "codepoints": [8759], "characters": "\u2237" },
  "&Colone;": { "codepoints": [10868], "characters": "\u2A74" },
  "&colone;": { "codepoints": [8788], "characters": "\u2254" },
  "&coloneq;": { "codepoints": [8788], "characters": "\u2254" },
  "&comma;": { "codepoints": [44], "characters": "\u002C" },
  "&commat;": { "codepoints": [64], "characters": "\u0040" },
  "&comp;": { "codepoints": [8705], "characters": "\u2201" },
  "&compfn;": { "codepoints": [8728], "characters": "\u2218" },
  "&complement;": { "codepoints": [8705], "characters": "\u2201" },
  "&complexes;": { "codepoints": [8450], "characters": "\u2102" },
  "&cong;": { "codepoints": [8773], "characters": "\u2245" },
  "&congdot;": { "codepoints": [10861], "characters": "\u2A6D" },
  "&Congruent;": { "codepoints": [8801], "characters": "\u2261" },
  "&conint;": { "codepoints": [8750], "characters": "\u222E" },
  "&Conint;": { "codepoints": [8751], "characters": "\u222F" },
  "&ContourIntegral;": { "codepoints": [8750], "characters": "\u222E" },
  "&copf;": { "codepoints": [120148], "characters": "\uD835\uDD54" },
  "&Copf;": { "codepoints": [8450], "characters": "\u2102" },
  "&coprod;": { "codepoints": [8720], "characters": "\u2210" },
  "&Coproduct;": { "codepoints": [8720], "characters": "\u2210" },
  "&copy;": { "codepoints": [169], "characters": "\u00A9" },
  "&copy": { "codepoints": [169], "characters": "\u00A9" },
  "&COPY;": { "codepoints": [169], "characters": "\u00A9" },
  "&COPY": { "codepoints": [169], "characters": "\u00A9" },
  "&copysr;": { "codepoints": [8471], "characters": "\u2117" },
  "&CounterClockwiseContourIntegral;": { "codepoints": [8755], "characters": "\u2233" },
  "&crarr;": { "codepoints": [8629], "characters": "\u21B5" },
  "&cross;": { "codepoints": [10007], "characters": "\u2717" },
  "&Cross;": { "codepoints": [10799], "characters": "\u2A2F" },
  "&Cscr;": { "codepoints": [119966], "characters": "\uD835\uDC9E" },
  "&cscr;": { "codepoints": [119992], "characters": "\uD835\uDCB8" },
  "&csub;": { "codepoints": [10959], "characters": "\u2ACF" },
  "&csube;": { "codepoints": [10961], "characters": "\u2AD1" },
  "&csup;": { "codepoints": [10960], "characters": "\u2AD0" },
  "&csupe;": { "codepoints": [10962], "characters": "\u2AD2" },
  "&ctdot;": { "codepoints": [8943], "characters": "\u22EF" },
  "&cudarrl;": { "codepoints": [10552], "characters": "\u2938" },
  "&cudarrr;": { "codepoints": [10549], "characters": "\u2935" },
  "&cuepr;": { "codepoints": [8926], "characters": "\u22DE" },
  "&cuesc;": { "codepoints": [8927], "characters": "\u22DF" },
  "&cularr;": { "codepoints": [8630], "characters": "\u21B6" },
  "&cularrp;": { "codepoints": [10557], "characters": "\u293D" },
  "&cupbrcap;": { "codepoints": [10824], "characters": "\u2A48" },
  "&cupcap;": { "codepoints": [10822], "characters": "\u2A46" },
  "&CupCap;": { "codepoints": [8781], "characters": "\u224D" },
  "&cup;": { "codepoints": [8746], "characters": "\u222A" },
  "&Cup;": { "codepoints": [8915], "characters": "\u22D3" },
  "&cupcup;": { "codepoints": [10826], "characters": "\u2A4A" },
  "&cupdot;": { "codepoints": [8845], "characters": "\u228D" },
  "&cupor;": { "codepoints": [10821], "characters": "\u2A45" },
  "&cups;": { "codepoints": [8746, 65024], "characters": "\u222A\uFE00" },
  "&curarr;": { "codepoints": [8631], "characters": "\u21B7" },
  "&curarrm;": { "codepoints": [10556], "characters": "\u293C" },
  "&curlyeqprec;": { "codepoints": [8926], "characters": "\u22DE" },
  "&curlyeqsucc;": { "codepoints": [8927], "characters": "\u22DF" },
  "&curlyvee;": { "codepoints": [8910], "characters": "\u22CE" },
  "&curlywedge;": { "codepoints": [8911], "characters": "\u22CF" },
  "&curren;": { "codepoints": [164], "characters": "\u00A4" },
  "&curren": { "codepoints": [164], "characters": "\u00A4" },
  "&curvearrowleft;": { "codepoints": [8630], "characters": "\u21B6" },
  "&curvearrowright;": { "codepoints": [8631], "characters": "\u21B7" },
  "&cuvee;": { "codepoints": [8910], "characters": "\u22CE" },
  "&cuwed;": { "codepoints": [8911], "characters": "\u22CF" },
  "&cwconint;": { "codepoints": [8754], "characters": "\u2232" },
  "&cwint;": { "codepoints": [8753], "characters": "\u2231" },
  "&cylcty;": { "codepoints": [9005], "characters": "\u232D" },
  "&dagger;": { "codepoints": [8224], "characters": "\u2020" },
  "&Dagger;": { "codepoints": [8225], "characters": "\u2021" },
  "&daleth;": { "codepoints": [8504], "characters": "\u2138" },
  "&darr;": { "codepoints": [8595], "characters": "\u2193" },
  "&Darr;": { "codepoints": [8609], "characters": "\u21A1" },
  "&dArr;": { "codepoints": [8659], "characters": "\u21D3" },
  "&dash;": { "codepoints": [8208], "characters": "\u2010" },
  "&Dashv;": { "codepoints": [10980], "characters": "\u2AE4" },
  "&dashv;": { "codepoints": [8867], "characters": "\u22A3" },
  "&dbkarow;": { "codepoints": [10511], "characters": "\u290F" },
  "&dblac;": { "codepoints": [733], "characters": "\u02DD" },
  "&Dcaron;": { "codepoints": [270], "characters": "\u010E" },
  "&dcaron;": { "codepoints": [271], "characters": "\u010F" },
  "&Dcy;": { "codepoints": [1044], "characters": "\u0414" },
  "&dcy;": { "codepoints": [1076], "characters": "\u0434" },
  "&ddagger;": { "codepoints": [8225], "characters": "\u2021" },
  "&ddarr;": { "codepoints": [8650], "characters": "\u21CA" },
  "&DD;": { "codepoints": [8517], "characters": "\u2145" },
  "&dd;": { "codepoints": [8518], "characters": "\u2146" },
  "&DDotrahd;": { "codepoints": [10513], "characters": "\u2911" },
  "&ddotseq;": { "codepoints": [10871], "characters": "\u2A77" },
  "&deg;": { "codepoints": [176], "characters": "\u00B0" },
  "&deg": { "codepoints": [176], "characters": "\u00B0" },
  "&Del;": { "codepoints": [8711], "characters": "\u2207" },
  "&Delta;": { "codepoints": [916], "characters": "\u0394" },
  "&delta;": { "codepoints": [948], "characters": "\u03B4" },
  "&demptyv;": { "codepoints": [10673], "characters": "\u29B1" },
  "&dfisht;": { "codepoints": [10623], "characters": "\u297F" },
  "&Dfr;": { "codepoints": [120071], "characters": "\uD835\uDD07" },
  "&dfr;": { "codepoints": [120097], "characters": "\uD835\uDD21" },
  "&dHar;": { "codepoints": [10597], "characters": "\u2965" },
  "&dharl;": { "codepoints": [8643], "characters": "\u21C3" },
  "&dharr;": { "codepoints": [8642], "characters": "\u21C2" },
  "&DiacriticalAcute;": { "codepoints": [180], "characters": "\u00B4" },
  "&DiacriticalDot;": { "codepoints": [729], "characters": "\u02D9" },
  "&DiacriticalDoubleAcute;": { "codepoints": [733], "characters": "\u02DD" },
  "&DiacriticalGrave;": { "codepoints": [96], "characters": "\u0060" },
  "&DiacriticalTilde;": { "codepoints": [732], "characters": "\u02DC" },
  "&diam;": { "codepoints": [8900], "characters": "\u22C4" },
  "&diamond;": { "codepoints": [8900], "characters": "\u22C4" },
  "&Diamond;": { "codepoints": [8900], "characters": "\u22C4" },
  "&diamondsuit;": { "codepoints": [9830], "characters": "\u2666" },
  "&diams;": { "codepoints": [9830], "characters": "\u2666" },
  "&die;": { "codepoints": [168], "characters": "\u00A8" },
  "&DifferentialD;": { "codepoints": [8518], "characters": "\u2146" },
  "&digamma;": { "codepoints": [989], "characters": "\u03DD" },
  "&disin;": { "codepoints": [8946], "characters": "\u22F2" },
  "&div;": { "codepoints": [247], "characters": "\u00F7" },
  "&divide;": { "codepoints": [247], "characters": "\u00F7" },
  "&divide": { "codepoints": [247], "characters": "\u00F7" },
  "&divideontimes;": { "codepoints": [8903], "characters": "\u22C7" },
  "&divonx;": { "codepoints": [8903], "characters": "\u22C7" },
  "&DJcy;": { "codepoints": [1026], "characters": "\u0402" },
  "&djcy;": { "codepoints": [1106], "characters": "\u0452" },
  "&dlcorn;": { "codepoints": [8990], "characters": "\u231E" },
  "&dlcrop;": { "codepoints": [8973], "characters": "\u230D" },
  "&dollar;": { "codepoints": [36], "characters": "\u0024" },
  "&Dopf;": { "codepoints": [120123], "characters": "\uD835\uDD3B" },
  "&dopf;": { "codepoints": [120149], "characters": "\uD835\uDD55" },
  "&Dot;": { "codepoints": [168], "characters": "\u00A8" },
  "&dot;": { "codepoints": [729], "characters": "\u02D9" },
  "&DotDot;": { "codepoints": [8412], "characters": "\u20DC" },
  "&doteq;": { "codepoints": [8784], "characters": "\u2250" },
  "&doteqdot;": { "codepoints": [8785], "characters": "\u2251" },
  "&DotEqual;": { "codepoints": [8784], "characters": "\u2250" },
  "&dotminus;": { "codepoints": [8760], "characters": "\u2238" },
  "&dotplus;": { "codepoints": [8724], "characters": "\u2214" },
  "&dotsquare;": { "codepoints": [8865], "characters": "\u22A1" },
  "&doublebarwedge;": { "codepoints": [8966], "characters": "\u2306" },
  "&DoubleContourIntegral;": { "codepoints": [8751], "characters": "\u222F" },
  "&DoubleDot;": { "codepoints": [168], "characters": "\u00A8" },
  "&DoubleDownArrow;": { "codepoints": [8659], "characters": "\u21D3" },
  "&DoubleLeftArrow;": { "codepoints": [8656], "characters": "\u21D0" },
  "&DoubleLeftRightArrow;": { "codepoints": [8660], "characters": "\u21D4" },
  "&DoubleLeftTee;": { "codepoints": [10980], "characters": "\u2AE4" },
  "&DoubleLongLeftArrow;": { "codepoints": [10232], "characters": "\u27F8" },
  "&DoubleLongLeftRightArrow;": { "codepoints": [10234], "characters": "\u27FA" },
  "&DoubleLongRightArrow;": { "codepoints": [10233], "characters": "\u27F9" },
  "&DoubleRightArrow;": { "codepoints": [8658], "characters": "\u21D2" },
  "&DoubleRightTee;": { "codepoints": [8872], "characters": "\u22A8" },
  "&DoubleUpArrow;": { "codepoints": [8657], "characters": "\u21D1" },
  "&DoubleUpDownArrow;": { "codepoints": [8661], "characters": "\u21D5" },
  "&DoubleVerticalBar;": { "codepoints": [8741], "characters": "\u2225" },
  "&DownArrowBar;": { "codepoints": [10515], "characters": "\u2913" },
  "&downarrow;": { "codepoints": [8595], "characters": "\u2193" },
  "&DownArrow;": { "codepoints": [8595], "characters": "\u2193" },
  "&Downarrow;": { "codepoints": [8659], "characters": "\u21D3" },
  "&DownArrowUpArrow;": { "codepoints": [8693], "characters": "\u21F5" },
  "&DownBreve;": { "codepoints": [785], "characters": "\u0311" },
  "&downdownarrows;": { "codepoints": [8650], "characters": "\u21CA" },
  "&downharpoonleft;": { "codepoints": [8643], "characters": "\u21C3" },
  "&downharpoonright;": { "codepoints": [8642], "characters": "\u21C2" },
  "&DownLeftRightVector;": { "codepoints": [10576], "characters": "\u2950" },
  "&DownLeftTeeVector;": { "codepoints": [10590], "characters": "\u295E" },
  "&DownLeftVectorBar;": { "codepoints": [10582], "characters": "\u2956" },
  "&DownLeftVector;": { "codepoints": [8637], "characters": "\u21BD" },
  "&DownRightTeeVector;": { "codepoints": [10591], "characters": "\u295F" },
  "&DownRightVectorBar;": { "codepoints": [10583], "characters": "\u2957" },
  "&DownRightVector;": { "codepoints": [8641], "characters": "\u21C1" },
  "&DownTeeArrow;": { "codepoints": [8615], "characters": "\u21A7" },
  "&DownTee;": { "codepoints": [8868], "characters": "\u22A4" },
  "&drbkarow;": { "codepoints": [10512], "characters": "\u2910" },
  "&drcorn;": { "codepoints": [8991], "characters": "\u231F" },
  "&drcrop;": { "codepoints": [8972], "characters": "\u230C" },
  "&Dscr;": { "codepoints": [119967], "characters": "\uD835\uDC9F" },
  "&dscr;": { "codepoints": [119993], "characters": "\uD835\uDCB9" },
  "&DScy;": { "codepoints": [1029], "characters": "\u0405" },
  "&dscy;": { "codepoints": [1109], "characters": "\u0455" },
  "&dsol;": { "codepoints": [10742], "characters": "\u29F6" },
  "&Dstrok;": { "codepoints": [272], "characters": "\u0110" },
  "&dstrok;": { "codepoints": [273], "characters": "\u0111" },
  "&dtdot;": { "codepoints": [8945], "characters": "\u22F1" },
  "&dtri;": { "codepoints": [9663], "characters": "\u25BF" },
  "&dtrif;": { "codepoints": [9662], "characters": "\u25BE" },
  "&duarr;": { "codepoints": [8693], "characters": "\u21F5" },
  "&duhar;": { "codepoints": [10607], "characters": "\u296F" },
  "&dwangle;": { "codepoints": [10662], "characters": "\u29A6" },
  "&DZcy;": { "codepoints": [1039], "characters": "\u040F" },
  "&dzcy;": { "codepoints": [1119], "characters": "\u045F" },
  "&dzigrarr;": { "codepoints": [10239], "characters": "\u27FF" },
  "&Eacute;": { "codepoints": [201], "characters": "\u00C9" },
  "&Eacute": { "codepoints": [201], "characters": "\u00C9" },
  "&eacute;": { "codepoints": [233], "characters": "\u00E9" },
  "&eacute": { "codepoints": [233], "characters": "\u00E9" },
  "&easter;": { "codepoints": [10862], "characters": "\u2A6E" },
  "&Ecaron;": { "codepoints": [282], "characters": "\u011A" },
  "&ecaron;": { "codepoints": [283], "characters": "\u011B" },
  "&Ecirc;": { "codepoints": [202], "characters": "\u00CA" },
  "&Ecirc": { "codepoints": [202], "characters": "\u00CA" },
  "&ecirc;": { "codepoints": [234], "characters": "\u00EA" },
  "&ecirc": { "codepoints": [234], "characters": "\u00EA" },
  "&ecir;": { "codepoints": [8790], "characters": "\u2256" },
  "&ecolon;": { "codepoints": [8789], "characters": "\u2255" },
  "&Ecy;": { "codepoints": [1069], "characters": "\u042D" },
  "&ecy;": { "codepoints": [1101], "characters": "\u044D" },
  "&eDDot;": { "codepoints": [10871], "characters": "\u2A77" },
  "&Edot;": { "codepoints": [278], "characters": "\u0116" },
  "&edot;": { "codepoints": [279], "characters": "\u0117" },
  "&eDot;": { "codepoints": [8785], "characters": "\u2251" },
  "&ee;": { "codepoints": [8519], "characters": "\u2147" },
  "&efDot;": { "codepoints": [8786], "characters": "\u2252" },
  "&Efr;": { "codepoints": [120072], "characters": "\uD835\uDD08" },
  "&efr;": { "codepoints": [120098], "characters": "\uD835\uDD22" },
  "&eg;": { "codepoints": [10906], "characters": "\u2A9A" },
  "&Egrave;": { "codepoints": [200], "characters": "\u00C8" },
  "&Egrave": { "codepoints": [200], "characters": "\u00C8" },
  "&egrave;": { "codepoints": [232], "characters": "\u00E8" },
  "&egrave": { "codepoints": [232], "characters": "\u00E8" },
  "&egs;": { "codepoints": [10902], "characters": "\u2A96" },
  "&egsdot;": { "codepoints": [10904], "characters": "\u2A98" },
  "&el;": { "codepoints": [10905], "characters": "\u2A99" },
  "&Element;": { "codepoints": [8712], "characters": "\u2208" },
  "&elinters;": { "codepoints": [9191], "characters": "\u23E7" },
  "&ell;": { "codepoints": [8467], "characters": "\u2113" },
  "&els;": { "codepoints": [10901], "characters": "\u2A95" },
  "&elsdot;": { "codepoints": [10903], "characters": "\u2A97" },
  "&Emacr;": { "codepoints": [274], "characters": "\u0112" },
  "&emacr;": { "codepoints": [275], "characters": "\u0113" },
  "&empty;": { "codepoints": [8709], "characters": "\u2205" },
  "&emptyset;": { "codepoints": [8709], "characters": "\u2205" },
  "&EmptySmallSquare;": { "codepoints": [9723], "characters": "\u25FB" },
  "&emptyv;": { "codepoints": [8709], "characters": "\u2205" },
  "&EmptyVerySmallSquare;": { "codepoints": [9643], "characters": "\u25AB" },
  "&emsp13;": { "codepoints": [8196], "characters": "\u2004" },
  "&emsp14;": { "codepoints": [8197], "characters": "\u2005" },
  "&emsp;": { "codepoints": [8195], "characters": "\u2003" },
  "&ENG;": { "codepoints": [330], "characters": "\u014A" },
  "&eng;": { "codepoints": [331], "characters": "\u014B" },
  "&ensp;": { "codepoints": [8194], "characters": "\u2002" },
  "&Eogon;": { "codepoints": [280], "characters": "\u0118" },
  "&eogon;": { "codepoints": [281], "characters": "\u0119" },
  "&Eopf;": { "codepoints": [120124], "characters": "\uD835\uDD3C" },
  "&eopf;": { "codepoints": [120150], "characters": "\uD835\uDD56" },
  "&epar;": { "codepoints": [8917], "characters": "\u22D5" },
  "&eparsl;": { "codepoints": [10723], "characters": "\u29E3" },
  "&eplus;": { "codepoints": [10865], "characters": "\u2A71" },
  "&epsi;": { "codepoints": [949], "characters": "\u03B5" },
  "&Epsilon;": { "codepoints": [917], "characters": "\u0395" },
  "&epsilon;": { "codepoints": [949], "characters": "\u03B5" },
  "&epsiv;": { "codepoints": [1013], "characters": "\u03F5" },
  "&eqcirc;": { "codepoints": [8790], "characters": "\u2256" },
  "&eqcolon;": { "codepoints": [8789], "characters": "\u2255" },
  "&eqsim;": { "codepoints": [8770], "characters": "\u2242" },
  "&eqslantgtr;": { "codepoints": [10902], "characters": "\u2A96" },
  "&eqslantless;": { "codepoints": [10901], "characters": "\u2A95" },
  "&Equal;": { "codepoints": [10869], "characters": "\u2A75" },
  "&equals;": { "codepoints": [61], "characters": "\u003D" },
  "&EqualTilde;": { "codepoints": [8770], "characters": "\u2242" },
  "&equest;": { "codepoints": [8799], "characters": "\u225F" },
  "&Equilibrium;": { "codepoints": [8652], "characters": "\u21CC" },
  "&equiv;": { "codepoints": [8801], "characters": "\u2261" },
  "&equivDD;": { "codepoints": [10872], "characters": "\u2A78" },
  "&eqvparsl;": { "codepoints": [10725], "characters": "\u29E5" },
  "&erarr;": { "codepoints": [10609], "characters": "\u2971" },
  "&erDot;": { "codepoints": [8787], "characters": "\u2253" },
  "&escr;": { "codepoints": [8495], "characters": "\u212F" },
  "&Escr;": { "codepoints": [8496], "characters": "\u2130" },
  "&esdot;": { "codepoints": [8784], "characters": "\u2250" },
  "&Esim;": { "codepoints": [10867], "characters": "\u2A73" },
  "&esim;": { "codepoints": [8770], "characters": "\u2242" },
  "&Eta;": { "codepoints": [919], "characters": "\u0397" },
  "&eta;": { "codepoints": [951], "characters": "\u03B7" },
  "&ETH;": { "codepoints": [208], "characters": "\u00D0" },
  "&ETH": { "codepoints": [208], "characters": "\u00D0" },
  "&eth;": { "codepoints": [240], "characters": "\u00F0" },
  "&eth": { "codepoints": [240], "characters": "\u00F0" },
  "&Euml;": { "codepoints": [203], "characters": "\u00CB" },
  "&Euml": { "codepoints": [203], "characters": "\u00CB" },
  "&euml;": { "codepoints": [235], "characters": "\u00EB" },
  "&euml": { "codepoints": [235], "characters": "\u00EB" },
  "&euro;": { "codepoints": [8364], "characters": "\u20AC" },
  "&excl;": { "codepoints": [33], "characters": "\u0021" },
  "&exist;": { "codepoints": [8707], "characters": "\u2203" },
  "&Exists;": { "codepoints": [8707], "characters": "\u2203" },
  "&expectation;": { "codepoints": [8496], "characters": "\u2130" },
  "&exponentiale;": { "codepoints": [8519], "characters": "\u2147" },
  "&ExponentialE;": { "codepoints": [8519], "characters": "\u2147" },
  "&fallingdotseq;": { "codepoints": [8786], "characters": "\u2252" },
  "&Fcy;": { "codepoints": [1060], "characters": "\u0424" },
  "&fcy;": { "codepoints": [1092], "characters": "\u0444" },
  "&female;": { "codepoints": [9792], "characters": "\u2640" },
  "&ffilig;": { "codepoints": [64259], "characters": "\uFB03" },
  "&fflig;": { "codepoints": [64256], "characters": "\uFB00" },
  "&ffllig;": { "codepoints": [64260], "characters": "\uFB04" },
  "&Ffr;": { "codepoints": [120073], "characters": "\uD835\uDD09" },
  "&ffr;": { "codepoints": [120099], "characters": "\uD835\uDD23" },
  "&filig;": { "codepoints": [64257], "characters": "\uFB01" },
  "&FilledSmallSquare;": { "codepoints": [9724], "characters": "\u25FC" },
  "&FilledVerySmallSquare;": { "codepoints": [9642], "characters": "\u25AA" },
  "&fjlig;": { "codepoints": [102, 106], "characters": "\u0066\u006A" },
  "&flat;": { "codepoints": [9837], "characters": "\u266D" },
  "&fllig;": { "codepoints": [64258], "characters": "\uFB02" },
  "&fltns;": { "codepoints": [9649], "characters": "\u25B1" },
  "&fnof;": { "codepoints": [402], "characters": "\u0192" },
  "&Fopf;": { "codepoints": [120125], "characters": "\uD835\uDD3D" },
  "&fopf;": { "codepoints": [120151], "characters": "\uD835\uDD57" },
  "&forall;": { "codepoints": [8704], "characters": "\u2200" },
  "&ForAll;": { "codepoints": [8704], "characters": "\u2200" },
  "&fork;": { "codepoints": [8916], "characters": "\u22D4" },
  "&forkv;": { "codepoints": [10969], "characters": "\u2AD9" },
  "&Fouriertrf;": { "codepoints": [8497], "characters": "\u2131" },
  "&fpartint;": { "codepoints": [10765], "characters": "\u2A0D" },
  "&frac12;": { "codepoints": [189], "characters": "\u00BD" },
  "&frac12": { "codepoints": [189], "characters": "\u00BD" },
  "&frac13;": { "codepoints": [8531], "characters": "\u2153" },
  "&frac14;": { "codepoints": [188], "characters": "\u00BC" },
  "&frac14": { "codepoints": [188], "characters": "\u00BC" },
  "&frac15;": { "codepoints": [8533], "characters": "\u2155" },
  "&frac16;": { "codepoints": [8537], "characters": "\u2159" },
  "&frac18;": { "codepoints": [8539], "characters": "\u215B" },
  "&frac23;": { "codepoints": [8532], "characters": "\u2154" },
  "&frac25;": { "codepoints": [8534], "characters": "\u2156" },
  "&frac34;": { "codepoints": [190], "characters": "\u00BE" },
  "&frac34": { "codepoints": [190], "characters": "\u00BE" },
  "&frac35;": { "codepoints": [8535], "characters": "\u2157" },
  "&frac38;": { "codepoints": [8540], "characters": "\u215C" },
  "&frac45;": { "codepoints": [8536], "characters": "\u2158" },
  "&frac56;": { "codepoints": [8538], "characters": "\u215A" },
  "&frac58;": { "codepoints": [8541], "characters": "\u215D" },
  "&frac78;": { "codepoints": [8542], "characters": "\u215E" },
  "&frasl;": { "codepoints": [8260], "characters": "\u2044" },
  "&frown;": { "codepoints": [8994], "characters": "\u2322" },
  "&fscr;": { "codepoints": [119995], "characters": "\uD835\uDCBB" },
  "&Fscr;": { "codepoints": [8497], "characters": "\u2131" },
  "&gacute;": { "codepoints": [501], "characters": "\u01F5" },
  "&Gamma;": { "codepoints": [915], "characters": "\u0393" },
  "&gamma;": { "codepoints": [947], "characters": "\u03B3" },
  "&Gammad;": { "codepoints": [988], "characters": "\u03DC" },
  "&gammad;": { "codepoints": [989], "characters": "\u03DD" },
  "&gap;": { "codepoints": [10886], "characters": "\u2A86" },
  "&Gbreve;": { "codepoints": [286], "characters": "\u011E" },
  "&gbreve;": { "codepoints": [287], "characters": "\u011F" },
  "&Gcedil;": { "codepoints": [290], "characters": "\u0122" },
  "&Gcirc;": { "codepoints": [284], "characters": "\u011C" },
  "&gcirc;": { "codepoints": [285], "characters": "\u011D" },
  "&Gcy;": { "codepoints": [1043], "characters": "\u0413" },
  "&gcy;": { "codepoints": [1075], "characters": "\u0433" },
  "&Gdot;": { "codepoints": [288], "characters": "\u0120" },
  "&gdot;": { "codepoints": [289], "characters": "\u0121" },
  "&ge;": { "codepoints": [8805], "characters": "\u2265" },
  "&gE;": { "codepoints": [8807], "characters": "\u2267" },
  "&gEl;": { "codepoints": [10892], "characters": "\u2A8C" },
  "&gel;": { "codepoints": [8923], "characters": "\u22DB" },
  "&geq;": { "codepoints": [8805], "characters": "\u2265" },
  "&geqq;": { "codepoints": [8807], "characters": "\u2267" },
  "&geqslant;": { "codepoints": [10878], "characters": "\u2A7E" },
  "&gescc;": { "codepoints": [10921], "characters": "\u2AA9" },
  "&ges;": { "codepoints": [10878], "characters": "\u2A7E" },
  "&gesdot;": { "codepoints": [10880], "characters": "\u2A80" },
  "&gesdoto;": { "codepoints": [10882], "characters": "\u2A82" },
  "&gesdotol;": { "codepoints": [10884], "characters": "\u2A84" },
  "&gesl;": { "codepoints": [8923, 65024], "characters": "\u22DB\uFE00" },
  "&gesles;": { "codepoints": [10900], "characters": "\u2A94" },
  "&Gfr;": { "codepoints": [120074], "characters": "\uD835\uDD0A" },
  "&gfr;": { "codepoints": [120100], "characters": "\uD835\uDD24" },
  "&gg;": { "codepoints": [8811], "characters": "\u226B" },
  "&Gg;": { "codepoints": [8921], "characters": "\u22D9" },
  "&ggg;": { "codepoints": [8921], "characters": "\u22D9" },
  "&gimel;": { "codepoints": [8503], "characters": "\u2137" },
  "&GJcy;": { "codepoints": [1027], "characters": "\u0403" },
  "&gjcy;": { "codepoints": [1107], "characters": "\u0453" },
  "&gla;": { "codepoints": [10917], "characters": "\u2AA5" },
  "&gl;": { "codepoints": [8823], "characters": "\u2277" },
  "&glE;": { "codepoints": [10898], "characters": "\u2A92" },
  "&glj;": { "codepoints": [10916], "characters": "\u2AA4" },
  "&gnap;": { "codepoints": [10890], "characters": "\u2A8A" },
  "&gnapprox;": { "codepoints": [10890], "characters": "\u2A8A" },
  "&gne;": { "codepoints": [10888], "characters": "\u2A88" },
  "&gnE;": { "codepoints": [8809], "characters": "\u2269" },
  "&gneq;": { "codepoints": [10888], "characters": "\u2A88" },
  "&gneqq;": { "codepoints": [8809], "characters": "\u2269" },
  "&gnsim;": { "codepoints": [8935], "characters": "\u22E7" },
  "&Gopf;": { "codepoints": [120126], "characters": "\uD835\uDD3E" },
  "&gopf;": { "codepoints": [120152], "characters": "\uD835\uDD58" },
  "&grave;": { "codepoints": [96], "characters": "\u0060" },
  "&GreaterEqual;": { "codepoints": [8805], "characters": "\u2265" },
  "&GreaterEqualLess;": { "codepoints": [8923], "characters": "\u22DB" },
  "&GreaterFullEqual;": { "codepoints": [8807], "characters": "\u2267" },
  "&GreaterGreater;": { "codepoints": [10914], "characters": "\u2AA2" },
  "&GreaterLess;": { "codepoints": [8823], "characters": "\u2277" },
  "&GreaterSlantEqual;": { "codepoints": [10878], "characters": "\u2A7E" },
  "&GreaterTilde;": { "codepoints": [8819], "characters": "\u2273" },
  "&Gscr;": { "codepoints": [119970], "characters": "\uD835\uDCA2" },
  "&gscr;": { "codepoints": [8458], "characters": "\u210A" },
  "&gsim;": { "codepoints": [8819], "characters": "\u2273" },
  "&gsime;": { "codepoints": [10894], "characters": "\u2A8E" },
  "&gsiml;": { "codepoints": [10896], "characters": "\u2A90" },
  "&gtcc;": { "codepoints": [10919], "characters": "\u2AA7" },
  "&gtcir;": { "codepoints": [10874], "characters": "\u2A7A" },
  "&gt;": { "codepoints": [62], "characters": "\u003E" },
  "&gt": { "codepoints": [62], "characters": "\u003E" },
  "&GT;": { "codepoints": [62], "characters": "\u003E" },
  "&GT": { "codepoints": [62], "characters": "\u003E" },
  "&Gt;": { "codepoints": [8811], "characters": "\u226B" },
  "&gtdot;": { "codepoints": [8919], "characters": "\u22D7" },
  "&gtlPar;": { "codepoints": [10645], "characters": "\u2995" },
  "&gtquest;": { "codepoints": [10876], "characters": "\u2A7C" },
  "&gtrapprox;": { "codepoints": [10886], "characters": "\u2A86" },
  "&gtrarr;": { "codepoints": [10616], "characters": "\u2978" },
  "&gtrdot;": { "codepoints": [8919], "characters": "\u22D7" },
  "&gtreqless;": { "codepoints": [8923], "characters": "\u22DB" },
  "&gtreqqless;": { "codepoints": [10892], "characters": "\u2A8C" },
  "&gtrless;": { "codepoints": [8823], "characters": "\u2277" },
  "&gtrsim;": { "codepoints": [8819], "characters": "\u2273" },
  "&gvertneqq;": { "codepoints": [8809, 65024], "characters": "\u2269\uFE00" },
  "&gvnE;": { "codepoints": [8809, 65024], "characters": "\u2269\uFE00" },
  "&Hacek;": { "codepoints": [711], "characters": "\u02C7" },
  "&hairsp;": { "codepoints": [8202], "characters": "\u200A" },
  "&half;": { "codepoints": [189], "characters": "\u00BD" },
  "&hamilt;": { "codepoints": [8459], "characters": "\u210B" },
  "&HARDcy;": { "codepoints": [1066], "characters": "\u042A" },
  "&hardcy;": { "codepoints": [1098], "characters": "\u044A" },
  "&harrcir;": { "codepoints": [10568], "characters": "\u2948" },
  "&harr;": { "codepoints": [8596], "characters": "\u2194" },
  "&hArr;": { "codepoints": [8660], "characters": "\u21D4" },
  "&harrw;": { "codepoints": [8621], "characters": "\u21AD" },
  "&Hat;": { "codepoints": [94], "characters": "\u005E" },
  "&hbar;": { "codepoints": [8463], "characters": "\u210F" },
  "&Hcirc;": { "codepoints": [292], "characters": "\u0124" },
  "&hcirc;": { "codepoints": [293], "characters": "\u0125" },
  "&hearts;": { "codepoints": [9829], "characters": "\u2665" },
  "&heartsuit;": { "codepoints": [9829], "characters": "\u2665" },
  "&hellip;": { "codepoints": [8230], "characters": "\u2026" },
  "&hercon;": { "codepoints": [8889], "characters": "\u22B9" },
  "&hfr;": { "codepoints": [120101], "characters": "\uD835\uDD25" },
  "&Hfr;": { "codepoints": [8460], "characters": "\u210C" },
  "&HilbertSpace;": { "codepoints": [8459], "characters": "\u210B" },
  "&hksearow;": { "codepoints": [10533], "characters": "\u2925" },
  "&hkswarow;": { "codepoints": [10534], "characters": "\u2926" },
  "&hoarr;": { "codepoints": [8703], "characters": "\u21FF" },
  "&homtht;": { "codepoints": [8763], "characters": "\u223B" },
  "&hookleftarrow;": { "codepoints": [8617], "characters": "\u21A9" },
  "&hookrightarrow;": { "codepoints": [8618], "characters": "\u21AA" },
  "&hopf;": { "codepoints": [120153], "characters": "\uD835\uDD59" },
  "&Hopf;": { "codepoints": [8461], "characters": "\u210D" },
  "&horbar;": { "codepoints": [8213], "characters": "\u2015" },
  "&HorizontalLine;": { "codepoints": [9472], "characters": "\u2500" },
  "&hscr;": { "codepoints": [119997], "characters": "\uD835\uDCBD" },
  "&Hscr;": { "codepoints": [8459], "characters": "\u210B" },
  "&hslash;": { "codepoints": [8463], "characters": "\u210F" },
  "&Hstrok;": { "codepoints": [294], "characters": "\u0126" },
  "&hstrok;": { "codepoints": [295], "characters": "\u0127" },
  "&HumpDownHump;": { "codepoints": [8782], "characters": "\u224E" },
  "&HumpEqual;": { "codepoints": [8783], "characters": "\u224F" },
  "&hybull;": { "codepoints": [8259], "characters": "\u2043" },
  "&hyphen;": { "codepoints": [8208], "characters": "\u2010" },
  "&Iacute;": { "codepoints": [205], "characters": "\u00CD" },
  "&Iacute": { "codepoints": [205], "characters": "\u00CD" },
  "&iacute;": { "codepoints": [237], "characters": "\u00ED" },
  "&iacute": { "codepoints": [237], "characters": "\u00ED" },
  "&ic;": { "codepoints": [8291], "characters": "\u2063" },
  "&Icirc;": { "codepoints": [206], "characters": "\u00CE" },
  "&Icirc": { "codepoints": [206], "characters": "\u00CE" },
  "&icirc;": { "codepoints": [238], "characters": "\u00EE" },
  "&icirc": { "codepoints": [238], "characters": "\u00EE" },
  "&Icy;": { "codepoints": [1048], "characters": "\u0418" },
  "&icy;": { "codepoints": [1080], "characters": "\u0438" },
  "&Idot;": { "codepoints": [304], "characters": "\u0130" },
  "&IEcy;": { "codepoints": [1045], "characters": "\u0415" },
  "&iecy;": { "codepoints": [1077], "characters": "\u0435" },
  "&iexcl;": { "codepoints": [161], "characters": "\u00A1" },
  "&iexcl": { "codepoints": [161], "characters": "\u00A1" },
  "&iff;": { "codepoints": [8660], "characters": "\u21D4" },
  "&ifr;": { "codepoints": [120102], "characters": "\uD835\uDD26" },
  "&Ifr;": { "codepoints": [8465], "characters": "\u2111" },
  "&Igrave;": { "codepoints": [204], "characters": "\u00CC" },
  "&Igrave": { "codepoints": [204], "characters": "\u00CC" },
  "&igrave;": { "codepoints": [236], "characters": "\u00EC" },
  "&igrave": { "codepoints": [236], "characters": "\u00EC" },
  "&ii;": { "codepoints": [8520], "characters": "\u2148" },
  "&iiiint;": { "codepoints": [10764], "characters": "\u2A0C" },
  "&iiint;": { "codepoints": [8749], "characters": "\u222D" },
  "&iinfin;": { "codepoints": [10716], "characters": "\u29DC" },
  "&iiota;": { "codepoints": [8489], "characters": "\u2129" },
  "&IJlig;": { "codepoints": [306], "characters": "\u0132" },
  "&ijlig;": { "codepoints": [307], "characters": "\u0133" },
  "&Imacr;": { "codepoints": [298], "characters": "\u012A" },
  "&imacr;": { "codepoints": [299], "characters": "\u012B" },
  "&image;": { "codepoints": [8465], "characters": "\u2111" },
  "&ImaginaryI;": { "codepoints": [8520], "characters": "\u2148" },
  "&imagline;": { "codepoints": [8464], "characters": "\u2110" },
  "&imagpart;": { "codepoints": [8465], "characters": "\u2111" },
  "&imath;": { "codepoints": [305], "characters": "\u0131" },
  "&Im;": { "codepoints": [8465], "characters": "\u2111" },
  "&imof;": { "codepoints": [8887], "characters": "\u22B7" },
  "&imped;": { "codepoints": [437], "characters": "\u01B5" },
  "&Implies;": { "codepoints": [8658], "characters": "\u21D2" },
  "&incare;": { "codepoints": [8453], "characters": "\u2105" },
  "&in;": { "codepoints": [8712], "characters": "\u2208" },
  "&infin;": { "codepoints": [8734], "characters": "\u221E" },
  "&infintie;": { "codepoints": [10717], "characters": "\u29DD" },
  "&inodot;": { "codepoints": [305], "characters": "\u0131" },
  "&intcal;": { "codepoints": [8890], "characters": "\u22BA" },
  "&int;": { "codepoints": [8747], "characters": "\u222B" },
  "&Int;": { "codepoints": [8748], "characters": "\u222C" },
  "&integers;": { "codepoints": [8484], "characters": "\u2124" },
  "&Integral;": { "codepoints": [8747], "characters": "\u222B" },
  "&intercal;": { "codepoints": [8890], "characters": "\u22BA" },
  "&Intersection;": { "codepoints": [8898], "characters": "\u22C2" },
  "&intlarhk;": { "codepoints": [10775], "characters": "\u2A17" },
  "&intprod;": { "codepoints": [10812], "characters": "\u2A3C" },
  "&InvisibleComma;": { "codepoints": [8291], "characters": "\u2063" },
  "&InvisibleTimes;": { "codepoints": [8290], "characters": "\u2062" },
  "&IOcy;": { "codepoints": [1025], "characters": "\u0401" },
  "&iocy;": { "codepoints": [1105], "characters": "\u0451" },
  "&Iogon;": { "codepoints": [302], "characters": "\u012E" },
  "&iogon;": { "codepoints": [303], "characters": "\u012F" },
  "&Iopf;": { "codepoints": [120128], "characters": "\uD835\uDD40" },
  "&iopf;": { "codepoints": [120154], "characters": "\uD835\uDD5A" },
  "&Iota;": { "codepoints": [921], "characters": "\u0399" },
  "&iota;": { "codepoints": [953], "characters": "\u03B9" },
  "&iprod;": { "codepoints": [10812], "characters": "\u2A3C" },
  "&iquest;": { "codepoints": [191], "characters": "\u00BF" },
  "&iquest": { "codepoints": [191], "characters": "\u00BF" },
  "&iscr;": { "codepoints": [119998], "characters": "\uD835\uDCBE" },
  "&Iscr;": { "codepoints": [8464], "characters": "\u2110" },
  "&isin;": { "codepoints": [8712], "characters": "\u2208" },
  "&isindot;": { "codepoints": [8949], "characters": "\u22F5" },
  "&isinE;": { "codepoints": [8953], "characters": "\u22F9" },
  "&isins;": { "codepoints": [8948], "characters": "\u22F4" },
  "&isinsv;": { "codepoints": [8947], "characters": "\u22F3" },
  "&isinv;": { "codepoints": [8712], "characters": "\u2208" },
  "&it;": { "codepoints": [8290], "characters": "\u2062" },
  "&Itilde;": { "codepoints": [296], "characters": "\u0128" },
  "&itilde;": { "codepoints": [297], "characters": "\u0129" },
  "&Iukcy;": { "codepoints": [1030], "characters": "\u0406" },
  "&iukcy;": { "codepoints": [1110], "characters": "\u0456" },
  "&Iuml;": { "codepoints": [207], "characters": "\u00CF" },
  "&Iuml": { "codepoints": [207], "characters": "\u00CF" },
  "&iuml;": { "codepoints": [239], "characters": "\u00EF" },
  "&iuml": { "codepoints": [239], "characters": "\u00EF" },
  "&Jcirc;": { "codepoints": [308], "characters": "\u0134" },
  "&jcirc;": { "codepoints": [309], "characters": "\u0135" },
  "&Jcy;": { "codepoints": [1049], "characters": "\u0419" },
  "&jcy;": { "codepoints": [1081], "characters": "\u0439" },
  "&Jfr;": { "codepoints": [120077], "characters": "\uD835\uDD0D" },
  "&jfr;": { "codepoints": [120103], "characters": "\uD835\uDD27" },
  "&jmath;": { "codepoints": [567], "characters": "\u0237" },
  "&Jopf;": { "codepoints": [120129], "characters": "\uD835\uDD41" },
  "&jopf;": { "codepoints": [120155], "characters": "\uD835\uDD5B" },
  "&Jscr;": { "codepoints": [119973], "characters": "\uD835\uDCA5" },
  "&jscr;": { "codepoints": [119999], "characters": "\uD835\uDCBF" },
  "&Jsercy;": { "codepoints": [1032], "characters": "\u0408" },
  "&jsercy;": { "codepoints": [1112], "characters": "\u0458" },
  "&Jukcy;": { "codepoints": [1028], "characters": "\u0404" },
  "&jukcy;": { "codepoints": [1108], "characters": "\u0454" },
  "&Kappa;": { "codepoints": [922], "characters": "\u039A" },
  "&kappa;": { "codepoints": [954], "characters": "\u03BA" },
  "&kappav;": { "codepoints": [1008], "characters": "\u03F0" },
  "&Kcedil;": { "codepoints": [310], "characters": "\u0136" },
  "&kcedil;": { "codepoints": [311], "characters": "\u0137" },
  "&Kcy;": { "codepoints": [1050], "characters": "\u041A" },
  "&kcy;": { "codepoints": [1082], "characters": "\u043A" },
  "&Kfr;": { "codepoints": [120078], "characters": "\uD835\uDD0E" },
  "&kfr;": { "codepoints": [120104], "characters": "\uD835\uDD28" },
  "&kgreen;": { "codepoints": [312], "characters": "\u0138" },
  "&KHcy;": { "codepoints": [1061], "characters": "\u0425" },
  "&khcy;": { "codepoints": [1093], "characters": "\u0445" },
  "&KJcy;": { "codepoints": [1036], "characters": "\u040C" },
  "&kjcy;": { "codepoints": [1116], "characters": "\u045C" },
  "&Kopf;": { "codepoints": [120130], "characters": "\uD835\uDD42" },
  "&kopf;": { "codepoints": [120156], "characters": "\uD835\uDD5C" },
  "&Kscr;": { "codepoints": [119974], "characters": "\uD835\uDCA6" },
  "&kscr;": { "codepoints": [120000], "characters": "\uD835\uDCC0" },
  "&lAarr;": { "codepoints": [8666], "characters": "\u21DA" },
  "&Lacute;": { "codepoints": [313], "characters": "\u0139" },
  "&lacute;": { "codepoints": [314], "characters": "\u013A" },
  "&laemptyv;": { "codepoints": [10676], "characters": "\u29B4" },
  "&lagran;": { "codepoints": [8466], "characters": "\u2112" },
  "&Lambda;": { "codepoints": [923], "characters": "\u039B" },
  "&lambda;": { "codepoints": [955], "characters": "\u03BB" },
  "&lang;": { "codepoints": [10216], "characters": "\u27E8" },
  "&Lang;": { "codepoints": [10218], "characters": "\u27EA" },
  "&langd;": { "codepoints": [10641], "characters": "\u2991" },
  "&langle;": { "codepoints": [10216], "characters": "\u27E8" },
  "&lap;": { "codepoints": [10885], "characters": "\u2A85" },
  "&Laplacetrf;": { "codepoints": [8466], "characters": "\u2112" },
  "&laquo;": { "codepoints": [171], "characters": "\u00AB" },
  "&laquo": { "codepoints": [171], "characters": "\u00AB" },
  "&larrb;": { "codepoints": [8676], "characters": "\u21E4" },
  "&larrbfs;": { "codepoints": [10527], "characters": "\u291F" },
  "&larr;": { "codepoints": [8592], "characters": "\u2190" },
  "&Larr;": { "codepoints": [8606], "characters": "\u219E" },
  "&lArr;": { "codepoints": [8656], "characters": "\u21D0" },
  "&larrfs;": { "codepoints": [10525], "characters": "\u291D" },
  "&larrhk;": { "codepoints": [8617], "characters": "\u21A9" },
  "&larrlp;": { "codepoints": [8619], "characters": "\u21AB" },
  "&larrpl;": { "codepoints": [10553], "characters": "\u2939" },
  "&larrsim;": { "codepoints": [10611], "characters": "\u2973" },
  "&larrtl;": { "codepoints": [8610], "characters": "\u21A2" },
  "&latail;": { "codepoints": [10521], "characters": "\u2919" },
  "&lAtail;": { "codepoints": [10523], "characters": "\u291B" },
  "&lat;": { "codepoints": [10923], "characters": "\u2AAB" },
  "&late;": { "codepoints": [10925], "characters": "\u2AAD" },
  "&lates;": { "codepoints": [10925, 65024], "characters": "\u2AAD\uFE00" },
  "&lbarr;": { "codepoints": [10508], "characters": "\u290C" },
  "&lBarr;": { "codepoints": [10510], "characters": "\u290E" },
  "&lbbrk;": { "codepoints": [10098], "characters": "\u2772" },
  "&lbrace;": { "codepoints": [123], "characters": "\u007B" },
  "&lbrack;": { "codepoints": [91], "characters": "\u005B" },
  "&lbrke;": { "codepoints": [10635], "characters": "\u298B" },
  "&lbrksld;": { "codepoints": [10639], "characters": "\u298F" },
  "&lbrkslu;": { "codepoints": [10637], "characters": "\u298D" },
  "&Lcaron;": { "codepoints": [317], "characters": "\u013D" },
  "&lcaron;": { "codepoints": [318], "characters": "\u013E" },
  "&Lcedil;": { "codepoints": [315], "characters": "\u013B" },
  "&lcedil;": { "codepoints": [316], "characters": "\u013C" },
  "&lceil;": { "codepoints": [8968], "characters": "\u2308" },
  "&lcub;": { "codepoints": [123], "characters": "\u007B" },
  "&Lcy;": { "codepoints": [1051], "characters": "\u041B" },
  "&lcy;": { "codepoints": [1083], "characters": "\u043B" },
  "&ldca;": { "codepoints": [10550], "characters": "\u2936" },
  "&ldquo;": { "codepoints": [8220], "characters": "\u201C" },
  "&ldquor;": { "codepoints": [8222], "characters": "\u201E" },
  "&ldrdhar;": { "codepoints": [10599], "characters": "\u2967" },
  "&ldrushar;": { "codepoints": [10571], "characters": "\u294B" },
  "&ldsh;": { "codepoints": [8626], "characters": "\u21B2" },
  "&le;": { "codepoints": [8804], "characters": "\u2264" },
  "&lE;": { "codepoints": [8806], "characters": "\u2266" },
  "&LeftAngleBracket;": { "codepoints": [10216], "characters": "\u27E8" },
  "&LeftArrowBar;": { "codepoints": [8676], "characters": "\u21E4" },
  "&leftarrow;": { "codepoints": [8592], "characters": "\u2190" },
  "&LeftArrow;": { "codepoints": [8592], "characters": "\u2190" },
  "&Leftarrow;": { "codepoints": [8656], "characters": "\u21D0" },
  "&LeftArrowRightArrow;": { "codepoints": [8646], "characters": "\u21C6" },
  "&leftarrowtail;": { "codepoints": [8610], "characters": "\u21A2" },
  "&LeftCeiling;": { "codepoints": [8968], "characters": "\u2308" },
  "&LeftDoubleBracket;": { "codepoints": [10214], "characters": "\u27E6" },
  "&LeftDownTeeVector;": { "codepoints": [10593], "characters": "\u2961" },
  "&LeftDownVectorBar;": { "codepoints": [10585], "characters": "\u2959" },
  "&LeftDownVector;": { "codepoints": [8643], "characters": "\u21C3" },
  "&LeftFloor;": { "codepoints": [8970], "characters": "\u230A" },
  "&leftharpoondown;": { "codepoints": [8637], "characters": "\u21BD" },
  "&leftharpoonup;": { "codepoints": [8636], "characters": "\u21BC" },
  "&leftleftarrows;": { "codepoints": [8647], "characters": "\u21C7" },
  "&leftrightarrow;": { "codepoints": [8596], "characters": "\u2194" },
  "&LeftRightArrow;": { "codepoints": [8596], "characters": "\u2194" },
  "&Leftrightarrow;": { "codepoints": [8660], "characters": "\u21D4" },
  "&leftrightarrows;": { "codepoints": [8646], "characters": "\u21C6" },
  "&leftrightharpoons;": { "codepoints": [8651], "characters": "\u21CB" },
  "&leftrightsquigarrow;": { "codepoints": [8621], "characters": "\u21AD" },
  "&LeftRightVector;": { "codepoints": [10574], "characters": "\u294E" },
  "&LeftTeeArrow;": { "codepoints": [8612], "characters": "\u21A4" },
  "&LeftTee;": { "codepoints": [8867], "characters": "\u22A3" },
  "&LeftTeeVector;": { "codepoints": [10586], "characters": "\u295A" },
  "&leftthreetimes;": { "codepoints": [8907], "characters": "\u22CB" },
  "&LeftTriangleBar;": { "codepoints": [10703], "characters": "\u29CF" },
  "&LeftTriangle;": { "codepoints": [8882], "characters": "\u22B2" },
  "&LeftTriangleEqual;": { "codepoints": [8884], "characters": "\u22B4" },
  "&LeftUpDownVector;": { "codepoints": [10577], "characters": "\u2951" },
  "&LeftUpTeeVector;": { "codepoints": [10592], "characters": "\u2960" },
  "&LeftUpVectorBar;": { "codepoints": [10584], "characters": "\u2958" },
  "&LeftUpVector;": { "codepoints": [8639], "characters": "\u21BF" },
  "&LeftVectorBar;": { "codepoints": [10578], "characters": "\u2952" },
  "&LeftVector;": { "codepoints": [8636], "characters": "\u21BC" },
  "&lEg;": { "codepoints": [10891], "characters": "\u2A8B" },
  "&leg;": { "codepoints": [8922], "characters": "\u22DA" },
  "&leq;": { "codepoints": [8804], "characters": "\u2264" },
  "&leqq;": { "codepoints": [8806], "characters": "\u2266" },
  "&leqslant;": { "codepoints": [10877], "characters": "\u2A7D" },
  "&lescc;": { "codepoints": [10920], "characters": "\u2AA8" },
  "&les;": { "codepoints": [10877], "characters": "\u2A7D" },
  "&lesdot;": { "codepoints": [10879], "characters": "\u2A7F" },
  "&lesdoto;": { "codepoints": [10881], "characters": "\u2A81" },
  "&lesdotor;": { "codepoints": [10883], "characters": "\u2A83" },
  "&lesg;": { "codepoints": [8922, 65024], "characters": "\u22DA\uFE00" },
  "&lesges;": { "codepoints": [10899], "characters": "\u2A93" },
  "&lessapprox;": { "codepoints": [10885], "characters": "\u2A85" },
  "&lessdot;": { "codepoints": [8918], "characters": "\u22D6" },
  "&lesseqgtr;": { "codepoints": [8922], "characters": "\u22DA" },
  "&lesseqqgtr;": { "codepoints": [10891], "characters": "\u2A8B" },
  "&LessEqualGreater;": { "codepoints": [8922], "characters": "\u22DA" },
  "&LessFullEqual;": { "codepoints": [8806], "characters": "\u2266" },
  "&LessGreater;": { "codepoints": [8822], "characters": "\u2276" },
  "&lessgtr;": { "codepoints": [8822], "characters": "\u2276" },
  "&LessLess;": { "codepoints": [10913], "characters": "\u2AA1" },
  "&lesssim;": { "codepoints": [8818], "characters": "\u2272" },
  "&LessSlantEqual;": { "codepoints": [10877], "characters": "\u2A7D" },
  "&LessTilde;": { "codepoints": [8818], "characters": "\u2272" },
  "&lfisht;": { "codepoints": [10620], "characters": "\u297C" },
  "&lfloor;": { "codepoints": [8970], "characters": "\u230A" },
  "&Lfr;": { "codepoints": [120079], "characters": "\uD835\uDD0F" },
  "&lfr;": { "codepoints": [120105], "characters": "\uD835\uDD29" },
  "&lg;": { "codepoints": [8822], "characters": "\u2276" },
  "&lgE;": { "codepoints": [10897], "characters": "\u2A91" },
  "&lHar;": { "codepoints": [10594], "characters": "\u2962" },
  "&lhard;": { "codepoints": [8637], "characters": "\u21BD" },
  "&lharu;": { "codepoints": [8636], "characters": "\u21BC" },
  "&lharul;": { "codepoints": [10602], "characters": "\u296A" },
  "&lhblk;": { "codepoints": [9604], "characters": "\u2584" },
  "&LJcy;": { "codepoints": [1033], "characters": "\u0409" },
  "&ljcy;": { "codepoints": [1113], "characters": "\u0459" },
  "&llarr;": { "codepoints": [8647], "characters": "\u21C7" },
  "&ll;": { "codepoints": [8810], "characters": "\u226A" },
  "&Ll;": { "codepoints": [8920], "characters": "\u22D8" },
  "&llcorner;": { "codepoints": [8990], "characters": "\u231E" },
  "&Lleftarrow;": { "codepoints": [8666], "characters": "\u21DA" },
  "&llhard;": { "codepoints": [10603], "characters": "\u296B" },
  "&lltri;": { "codepoints": [9722], "characters": "\u25FA" },
  "&Lmidot;": { "codepoints": [319], "characters": "\u013F" },
  "&lmidot;": { "codepoints": [320], "characters": "\u0140" },
  "&lmoustache;": { "codepoints": [9136], "characters": "\u23B0" },
  "&lmoust;": { "codepoints": [9136], "characters": "\u23B0" },
  "&lnap;": { "codepoints": [10889], "characters": "\u2A89" },
  "&lnapprox;": { "codepoints": [10889], "characters": "\u2A89" },
  "&lne;": { "codepoints": [10887], "characters": "\u2A87" },
  "&lnE;": { "codepoints": [8808], "characters": "\u2268" },
  "&lneq;": { "codepoints": [10887], "characters": "\u2A87" },
  "&lneqq;": { "codepoints": [8808], "characters": "\u2268" },
  "&lnsim;": { "codepoints": [8934], "characters": "\u22E6" },
  "&loang;": { "codepoints": [10220], "characters": "\u27EC" },
  "&loarr;": { "codepoints": [8701], "characters": "\u21FD" },
  "&lobrk;": { "codepoints": [10214], "characters": "\u27E6" },
  "&longleftarrow;": { "codepoints": [10229], "characters": "\u27F5" },
  "&LongLeftArrow;": { "codepoints": [10229], "characters": "\u27F5" },
  "&Longleftarrow;": { "codepoints": [10232], "characters": "\u27F8" },
  "&longleftrightarrow;": { "codepoints": [10231], "characters": "\u27F7" },
  "&LongLeftRightArrow;": { "codepoints": [10231], "characters": "\u27F7" },
  "&Longleftrightarrow;": { "codepoints": [10234], "characters": "\u27FA" },
  "&longmapsto;": { "codepoints": [10236], "characters": "\u27FC" },
  "&longrightarrow;": { "codepoints": [10230], "characters": "\u27F6" },
  "&LongRightArrow;": { "codepoints": [10230], "characters": "\u27F6" },
  "&Longrightarrow;": { "codepoints": [10233], "characters": "\u27F9" },
  "&looparrowleft;": { "codepoints": [8619], "characters": "\u21AB" },
  "&looparrowright;": { "codepoints": [8620], "characters": "\u21AC" },
  "&lopar;": { "codepoints": [10629], "characters": "\u2985" },
  "&Lopf;": { "codepoints": [120131], "characters": "\uD835\uDD43" },
  "&lopf;": { "codepoints": [120157], "characters": "\uD835\uDD5D" },
  "&loplus;": { "codepoints": [10797], "characters": "\u2A2D" },
  "&lotimes;": { "codepoints": [10804], "characters": "\u2A34" },
  "&lowast;": { "codepoints": [8727], "characters": "\u2217" },
  "&lowbar;": { "codepoints": [95], "characters": "\u005F" },
  "&LowerLeftArrow;": { "codepoints": [8601], "characters": "\u2199" },
  "&LowerRightArrow;": { "codepoints": [8600], "characters": "\u2198" },
  "&loz;": { "codepoints": [9674], "characters": "\u25CA" },
  "&lozenge;": { "codepoints": [9674], "characters": "\u25CA" },
  "&lozf;": { "codepoints": [10731], "characters": "\u29EB" },
  "&lpar;": { "codepoints": [40], "characters": "\u0028" },
  "&lparlt;": { "codepoints": [10643], "characters": "\u2993" },
  "&lrarr;": { "codepoints": [8646], "characters": "\u21C6" },
  "&lrcorner;": { "codepoints": [8991], "characters": "\u231F" },
  "&lrhar;": { "codepoints": [8651], "characters": "\u21CB" },
  "&lrhard;": { "codepoints": [10605], "characters": "\u296D" },
  "&lrm;": { "codepoints": [8206], "characters": "\u200E" },
  "&lrtri;": { "codepoints": [8895], "characters": "\u22BF" },
  "&lsaquo;": { "codepoints": [8249], "characters": "\u2039" },
  "&lscr;": { "codepoints": [120001], "characters": "\uD835\uDCC1" },
  "&Lscr;": { "codepoints": [8466], "characters": "\u2112" },
  "&lsh;": { "codepoints": [8624], "characters": "\u21B0" },
  "&Lsh;": { "codepoints": [8624], "characters": "\u21B0" },
  "&lsim;": { "codepoints": [8818], "characters": "\u2272" },
  "&lsime;": { "codepoints": [10893], "characters": "\u2A8D" },
  "&lsimg;": { "codepoints": [10895], "characters": "\u2A8F" },
  "&lsqb;": { "codepoints": [91], "characters": "\u005B" },
  "&lsquo;": { "codepoints": [8216], "characters": "\u2018" },
  "&lsquor;": { "codepoints": [8218], "characters": "\u201A" },
  "&Lstrok;": { "codepoints": [321], "characters": "\u0141" },
  "&lstrok;": { "codepoints": [322], "characters": "\u0142" },
  "&ltcc;": { "codepoints": [10918], "characters": "\u2AA6" },
  "&ltcir;": { "codepoints": [10873], "characters": "\u2A79" },
  "&lt;": { "codepoints": [60], "characters": "\u003C" },
  "&lt": { "codepoints": [60], "characters": "\u003C" },
  "&LT;": { "codepoints": [60], "characters": "\u003C" },
  "&LT": { "codepoints": [60], "characters": "\u003C" },
  "&Lt;": { "codepoints": [8810], "characters": "\u226A" },
  "&ltdot;": { "codepoints": [8918], "characters": "\u22D6" },
  "&lthree;": { "codepoints": [8907], "characters": "\u22CB" },
  "&ltimes;": { "codepoints": [8905], "characters": "\u22C9" },
  "&ltlarr;": { "codepoints": [10614], "characters": "\u2976" },
  "&ltquest;": { "codepoints": [10875], "characters": "\u2A7B" },
  "&ltri;": { "codepoints": [9667], "characters": "\u25C3" },
  "&ltrie;": { "codepoints": [8884], "characters": "\u22B4" },
  "&ltrif;": { "codepoints": [9666], "characters": "\u25C2" },
  "&ltrPar;": { "codepoints": [10646], "characters": "\u2996" },
  "&lurdshar;": { "codepoints": [10570], "characters": "\u294A" },
  "&luruhar;": { "codepoints": [10598], "characters": "\u2966" },
  "&lvertneqq;": { "codepoints": [8808, 65024], "characters": "\u2268\uFE00" },
  "&lvnE;": { "codepoints": [8808, 65024], "characters": "\u2268\uFE00" },
  "&macr;": { "codepoints": [175], "characters": "\u00AF" },
  "&macr": { "codepoints": [175], "characters": "\u00AF" },
  "&male;": { "codepoints": [9794], "characters": "\u2642" },
  "&malt;": { "codepoints": [10016], "characters": "\u2720" },
  "&maltese;": { "codepoints": [10016], "characters": "\u2720" },
  "&Map;": { "codepoints": [10501], "characters": "\u2905" },
  "&map;": { "codepoints": [8614], "characters": "\u21A6" },
  "&mapsto;": { "codepoints": [8614], "characters": "\u21A6" },
  "&mapstodown;": { "codepoints": [8615], "characters": "\u21A7" },
  "&mapstoleft;": { "codepoints": [8612], "characters": "\u21A4" },
  "&mapstoup;": { "codepoints": [8613], "characters": "\u21A5" },
  "&marker;": { "codepoints": [9646], "characters": "\u25AE" },
  "&mcomma;": { "codepoints": [10793], "characters": "\u2A29" },
  "&Mcy;": { "codepoints": [1052], "characters": "\u041C" },
  "&mcy;": { "codepoints": [1084], "characters": "\u043C" },
  "&mdash;": { "codepoints": [8212], "characters": "\u2014" },
  "&mDDot;": { "codepoints": [8762], "characters": "\u223A" },
  "&measuredangle;": { "codepoints": [8737], "characters": "\u2221" },
  "&MediumSpace;": { "codepoints": [8287], "characters": "\u205F" },
  "&Mellintrf;": { "codepoints": [8499], "characters": "\u2133" },
  "&Mfr;": { "codepoints": [120080], "characters": "\uD835\uDD10" },
  "&mfr;": { "codepoints": [120106], "characters": "\uD835\uDD2A" },
  "&mho;": { "codepoints": [8487], "characters": "\u2127" },
  "&micro;": { "codepoints": [181], "characters": "\u00B5" },
  "&micro": { "codepoints": [181], "characters": "\u00B5" },
  "&midast;": { "codepoints": [42], "characters": "\u002A" },
  "&midcir;": { "codepoints": [10992], "characters": "\u2AF0" },
  "&mid;": { "codepoints": [8739], "characters": "\u2223" },
  "&middot;": { "codepoints": [183], "characters": "\u00B7" },
  "&middot": { "codepoints": [183], "characters": "\u00B7" },
  "&minusb;": { "codepoints": [8863], "characters": "\u229F" },
  "&minus;": { "codepoints": [8722], "characters": "\u2212" },
  "&minusd;": { "codepoints": [8760], "characters": "\u2238" },
  "&minusdu;": { "codepoints": [10794], "characters": "\u2A2A" },
  "&MinusPlus;": { "codepoints": [8723], "characters": "\u2213" },
  "&mlcp;": { "codepoints": [10971], "characters": "\u2ADB" },
  "&mldr;": { "codepoints": [8230], "characters": "\u2026" },
  "&mnplus;": { "codepoints": [8723], "characters": "\u2213" },
  "&models;": { "codepoints": [8871], "characters": "\u22A7" },
  "&Mopf;": { "codepoints": [120132], "characters": "\uD835\uDD44" },
  "&mopf;": { "codepoints": [120158], "characters": "\uD835\uDD5E" },
  "&mp;": { "codepoints": [8723], "characters": "\u2213" },
  "&mscr;": { "codepoints": [120002], "characters": "\uD835\uDCC2" },
  "&Mscr;": { "codepoints": [8499], "characters": "\u2133" },
  "&mstpos;": { "codepoints": [8766], "characters": "\u223E" },
  "&Mu;": { "codepoints": [924], "characters": "\u039C" },
  "&mu;": { "codepoints": [956], "characters": "\u03BC" },
  "&multimap;": { "codepoints": [8888], "characters": "\u22B8" },
  "&mumap;": { "codepoints": [8888], "characters": "\u22B8" },
  "&nabla;": { "codepoints": [8711], "characters": "\u2207" },
  "&Nacute;": { "codepoints": [323], "characters": "\u0143" },
  "&nacute;": { "codepoints": [324], "characters": "\u0144" },
  "&nang;": { "codepoints": [8736, 8402], "characters": "\u2220\u20D2" },
  "&nap;": { "codepoints": [8777], "characters": "\u2249" },
  "&napE;": { "codepoints": [10864, 824], "characters": "\u2A70\u0338" },
  "&napid;": { "codepoints": [8779, 824], "characters": "\u224B\u0338" },
  "&napos;": { "codepoints": [329], "characters": "\u0149" },
  "&napprox;": { "codepoints": [8777], "characters": "\u2249" },
  "&natural;": { "codepoints": [9838], "characters": "\u266E" },
  "&naturals;": { "codepoints": [8469], "characters": "\u2115" },
  "&natur;": { "codepoints": [9838], "characters": "\u266E" },
  "&nbsp;": { "codepoints": [160], "characters": "\u00A0" },
  "&nbsp": { "codepoints": [160], "characters": "\u00A0" },
  "&nbump;": { "codepoints": [8782, 824], "characters": "\u224E\u0338" },
  "&nbumpe;": { "codepoints": [8783, 824], "characters": "\u224F\u0338" },
  "&ncap;": { "codepoints": [10819], "characters": "\u2A43" },
  "&Ncaron;": { "codepoints": [327], "characters": "\u0147" },
  "&ncaron;": { "codepoints": [328], "characters": "\u0148" },
  "&Ncedil;": { "codepoints": [325], "characters": "\u0145" },
  "&ncedil;": { "codepoints": [326], "characters": "\u0146" },
  "&ncong;": { "codepoints": [8775], "characters": "\u2247" },
  "&ncongdot;": { "codepoints": [10861, 824], "characters": "\u2A6D\u0338" },
  "&ncup;": { "codepoints": [10818], "characters": "\u2A42" },
  "&Ncy;": { "codepoints": [1053], "characters": "\u041D" },
  "&ncy;": { "codepoints": [1085], "characters": "\u043D" },
  "&ndash;": { "codepoints": [8211], "characters": "\u2013" },
  "&nearhk;": { "codepoints": [10532], "characters": "\u2924" },
  "&nearr;": { "codepoints": [8599], "characters": "\u2197" },
  "&neArr;": { "codepoints": [8663], "characters": "\u21D7" },
  "&nearrow;": { "codepoints": [8599], "characters": "\u2197" },
  "&ne;": { "codepoints": [8800], "characters": "\u2260" },
  "&nedot;": { "codepoints": [8784, 824], "characters": "\u2250\u0338" },
  "&NegativeMediumSpace;": { "codepoints": [8203], "characters": "\u200B" },
  "&NegativeThickSpace;": { "codepoints": [8203], "characters": "\u200B" },
  "&NegativeThinSpace;": { "codepoints": [8203], "characters": "\u200B" },
  "&NegativeVeryThinSpace;": { "codepoints": [8203], "characters": "\u200B" },
  "&nequiv;": { "codepoints": [8802], "characters": "\u2262" },
  "&nesear;": { "codepoints": [10536], "characters": "\u2928" },
  "&nesim;": { "codepoints": [8770, 824], "characters": "\u2242\u0338" },
  "&NestedGreaterGreater;": { "codepoints": [8811], "characters": "\u226B" },
  "&NestedLessLess;": { "codepoints": [8810], "characters": "\u226A" },
  "&NewLine;": { "codepoints": [10], "characters": "\u000A" },
  "&nexist;": { "codepoints": [8708], "characters": "\u2204" },
  "&nexists;": { "codepoints": [8708], "characters": "\u2204" },
  "&Nfr;": { "codepoints": [120081], "characters": "\uD835\uDD11" },
  "&nfr;": { "codepoints": [120107], "characters": "\uD835\uDD2B" },
  "&ngE;": { "codepoints": [8807, 824], "characters": "\u2267\u0338" },
  "&nge;": { "codepoints": [8817], "characters": "\u2271" },
  "&ngeq;": { "codepoints": [8817], "characters": "\u2271" },
  "&ngeqq;": { "codepoints": [8807, 824], "characters": "\u2267\u0338" },
  "&ngeqslant;": { "codepoints": [10878, 824], "characters": "\u2A7E\u0338" },
  "&nges;": { "codepoints": [10878, 824], "characters": "\u2A7E\u0338" },
  "&nGg;": { "codepoints": [8921, 824], "characters": "\u22D9\u0338" },
  "&ngsim;": { "codepoints": [8821], "characters": "\u2275" },
  "&nGt;": { "codepoints": [8811, 8402], "characters": "\u226B\u20D2" },
  "&ngt;": { "codepoints": [8815], "characters": "\u226F" },
  "&ngtr;": { "codepoints": [8815], "characters": "\u226F" },
  "&nGtv;": { "codepoints": [8811, 824], "characters": "\u226B\u0338" },
  "&nharr;": { "codepoints": [8622], "characters": "\u21AE" },
  "&nhArr;": { "codepoints": [8654], "characters": "\u21CE" },
  "&nhpar;": { "codepoints": [10994], "characters": "\u2AF2" },
  "&ni;": { "codepoints": [8715], "characters": "\u220B" },
  "&nis;": { "codepoints": [8956], "characters": "\u22FC" },
  "&nisd;": { "codepoints": [8954], "characters": "\u22FA" },
  "&niv;": { "codepoints": [8715], "characters": "\u220B" },
  "&NJcy;": { "codepoints": [1034], "characters": "\u040A" },
  "&njcy;": { "codepoints": [1114], "characters": "\u045A" },
  "&nlarr;": { "codepoints": [8602], "characters": "\u219A" },
  "&nlArr;": { "codepoints": [8653], "characters": "\u21CD" },
  "&nldr;": { "codepoints": [8229], "characters": "\u2025" },
  "&nlE;": { "codepoints": [8806, 824], "characters": "\u2266\u0338" },
  "&nle;": { "codepoints": [8816], "characters": "\u2270" },
  "&nleftarrow;": { "codepoints": [8602], "characters": "\u219A" },
  "&nLeftarrow;": { "codepoints": [8653], "characters": "\u21CD" },
  "&nleftrightarrow;": { "codepoints": [8622], "characters": "\u21AE" },
  "&nLeftrightarrow;": { "codepoints": [8654], "characters": "\u21CE" },
  "&nleq;": { "codepoints": [8816], "characters": "\u2270" },
  "&nleqq;": { "codepoints": [8806, 824], "characters": "\u2266\u0338" },
  "&nleqslant;": { "codepoints": [10877, 824], "characters": "\u2A7D\u0338" },
  "&nles;": { "codepoints": [10877, 824], "characters": "\u2A7D\u0338" },
  "&nless;": { "codepoints": [8814], "characters": "\u226E" },
  "&nLl;": { "codepoints": [8920, 824], "characters": "\u22D8\u0338" },
  "&nlsim;": { "codepoints": [8820], "characters": "\u2274" },
  "&nLt;": { "codepoints": [8810, 8402], "characters": "\u226A\u20D2" },
  "&nlt;": { "codepoints": [8814], "characters": "\u226E" },
  "&nltri;": { "codepoints": [8938], "characters": "\u22EA" },
  "&nltrie;": { "codepoints": [8940], "characters": "\u22EC" },
  "&nLtv;": { "codepoints": [8810, 824], "characters": "\u226A\u0338" },
  "&nmid;": { "codepoints": [8740], "characters": "\u2224" },
  "&NoBreak;": { "codepoints": [8288], "characters": "\u2060" },
  "&NonBreakingSpace;": { "codepoints": [160], "characters": "\u00A0" },
  "&nopf;": { "codepoints": [120159], "characters": "\uD835\uDD5F" },
  "&Nopf;": { "codepoints": [8469], "characters": "\u2115" },
  "&Not;": { "codepoints": [10988], "characters": "\u2AEC" },
  "&not;": { "codepoints": [172], "characters": "\u00AC" },
  "&not": { "codepoints": [172], "characters": "\u00AC" },
  "&NotCongruent;": { "codepoints": [8802], "characters": "\u2262" },
  "&NotCupCap;": { "codepoints": [8813], "characters": "\u226D" },
  "&NotDoubleVerticalBar;": { "codepoints": [8742], "characters": "\u2226" },
  "&NotElement;": { "codepoints": [8713], "characters": "\u2209" },
  "&NotEqual;": { "codepoints": [8800], "characters": "\u2260" },
  "&NotEqualTilde;": { "codepoints": [8770, 824], "characters": "\u2242\u0338" },
  "&NotExists;": { "codepoints": [8708], "characters": "\u2204" },
  "&NotGreater;": { "codepoints": [8815], "characters": "\u226F" },
  "&NotGreaterEqual;": { "codepoints": [8817], "characters": "\u2271" },
  "&NotGreaterFullEqual;": { "codepoints": [8807, 824], "characters": "\u2267\u0338" },
  "&NotGreaterGreater;": { "codepoints": [8811, 824], "characters": "\u226B\u0338" },
  "&NotGreaterLess;": { "codepoints": [8825], "characters": "\u2279" },
  "&NotGreaterSlantEqual;": { "codepoints": [10878, 824], "characters": "\u2A7E\u0338" },
  "&NotGreaterTilde;": { "codepoints": [8821], "characters": "\u2275" },
  "&NotHumpDownHump;": { "codepoints": [8782, 824], "characters": "\u224E\u0338" },
  "&NotHumpEqual;": { "codepoints": [8783, 824], "characters": "\u224F\u0338" },
  "&notin;": { "codepoints": [8713], "characters": "\u2209" },
  "&notindot;": { "codepoints": [8949, 824], "characters": "\u22F5\u0338" },
  "&notinE;": { "codepoints": [8953, 824], "characters": "\u22F9\u0338" },
  "&notinva;": { "codepoints": [8713], "characters": "\u2209" },
  "&notinvb;": { "codepoints": [8951], "characters": "\u22F7" },
  "&notinvc;": { "codepoints": [8950], "characters": "\u22F6" },
  "&NotLeftTriangleBar;": { "codepoints": [10703, 824], "characters": "\u29CF\u0338" },
  "&NotLeftTriangle;": { "codepoints": [8938], "characters": "\u22EA" },
  "&NotLeftTriangleEqual;": { "codepoints": [8940], "characters": "\u22EC" },
  "&NotLess;": { "codepoints": [8814], "characters": "\u226E" },
  "&NotLessEqual;": { "codepoints": [8816], "characters": "\u2270" },
  "&NotLessGreater;": { "codepoints": [8824], "characters": "\u2278" },
  "&NotLessLess;": { "codepoints": [8810, 824], "characters": "\u226A\u0338" },
  "&NotLessSlantEqual;": { "codepoints": [10877, 824], "characters": "\u2A7D\u0338" },
  "&NotLessTilde;": { "codepoints": [8820], "characters": "\u2274" },
  "&NotNestedGreaterGreater;": { "codepoints": [10914, 824], "characters": "\u2AA2\u0338" },
  "&NotNestedLessLess;": { "codepoints": [10913, 824], "characters": "\u2AA1\u0338" },
  "&notni;": { "codepoints": [8716], "characters": "\u220C" },
  "&notniva;": { "codepoints": [8716], "characters": "\u220C" },
  "&notnivb;": { "codepoints": [8958], "characters": "\u22FE" },
  "&notnivc;": { "codepoints": [8957], "characters": "\u22FD" },
  "&NotPrecedes;": { "codepoints": [8832], "characters": "\u2280" },
  "&NotPrecedesEqual;": { "codepoints": [10927, 824], "characters": "\u2AAF\u0338" },
  "&NotPrecedesSlantEqual;": { "codepoints": [8928], "characters": "\u22E0" },
  "&NotReverseElement;": { "codepoints": [8716], "characters": "\u220C" },
  "&NotRightTriangleBar;": { "codepoints": [10704, 824], "characters": "\u29D0\u0338" },
  "&NotRightTriangle;": { "codepoints": [8939], "characters": "\u22EB" },
  "&NotRightTriangleEqual;": { "codepoints": [8941], "characters": "\u22ED" },
  "&NotSquareSubset;": { "codepoints": [8847, 824], "characters": "\u228F\u0338" },
  "&NotSquareSubsetEqual;": { "codepoints": [8930], "characters": "\u22E2" },
  "&NotSquareSuperset;": { "codepoints": [8848, 824], "characters": "\u2290\u0338" },
  "&NotSquareSupersetEqual;": { "codepoints": [8931], "characters": "\u22E3" },
  "&NotSubset;": { "codepoints": [8834, 8402], "characters": "\u2282\u20D2" },
  "&NotSubsetEqual;": { "codepoints": [8840], "characters": "\u2288" },
  "&NotSucceeds;": { "codepoints": [8833], "characters": "\u2281" },
  "&NotSucceedsEqual;": { "codepoints": [10928, 824], "characters": "\u2AB0\u0338" },
  "&NotSucceedsSlantEqual;": { "codepoints": [8929], "characters": "\u22E1" },
  "&NotSucceedsTilde;": { "codepoints": [8831, 824], "characters": "\u227F\u0338" },
  "&NotSuperset;": { "codepoints": [8835, 8402], "characters": "\u2283\u20D2" },
  "&NotSupersetEqual;": { "codepoints": [8841], "characters": "\u2289" },
  "&NotTilde;": { "codepoints": [8769], "characters": "\u2241" },
  "&NotTildeEqual;": { "codepoints": [8772], "characters": "\u2244" },
  "&NotTildeFullEqual;": { "codepoints": [8775], "characters": "\u2247" },
  "&NotTildeTilde;": { "codepoints": [8777], "characters": "\u2249" },
  "&NotVerticalBar;": { "codepoints": [8740], "characters": "\u2224" },
  "&nparallel;": { "codepoints": [8742], "characters": "\u2226" },
  "&npar;": { "codepoints": [8742], "characters": "\u2226" },
  "&nparsl;": { "codepoints": [11005, 8421], "characters": "\u2AFD\u20E5" },
  "&npart;": { "codepoints": [8706, 824], "characters": "\u2202\u0338" },
  "&npolint;": { "codepoints": [10772], "characters": "\u2A14" },
  "&npr;": { "codepoints": [8832], "characters": "\u2280" },
  "&nprcue;": { "codepoints": [8928], "characters": "\u22E0" },
  "&nprec;": { "codepoints": [8832], "characters": "\u2280" },
  "&npreceq;": { "codepoints": [10927, 824], "characters": "\u2AAF\u0338" },
  "&npre;": { "codepoints": [10927, 824], "characters": "\u2AAF\u0338" },
  "&nrarrc;": { "codepoints": [10547, 824], "characters": "\u2933\u0338" },
  "&nrarr;": { "codepoints": [8603], "characters": "\u219B" },
  "&nrArr;": { "codepoints": [8655], "characters": "\u21CF" },
  "&nrarrw;": { "codepoints": [8605, 824], "characters": "\u219D\u0338" },
  "&nrightarrow;": { "codepoints": [8603], "characters": "\u219B" },
  "&nRightarrow;": { "codepoints": [8655], "characters": "\u21CF" },
  "&nrtri;": { "codepoints": [8939], "characters": "\u22EB" },
  "&nrtrie;": { "codepoints": [8941], "characters": "\u22ED" },
  "&nsc;": { "codepoints": [8833], "characters": "\u2281" },
  "&nsccue;": { "codepoints": [8929], "characters": "\u22E1" },
  "&nsce;": { "codepoints": [10928, 824], "characters": "\u2AB0\u0338" },
  "&Nscr;": { "codepoints": [119977], "characters": "\uD835\uDCA9" },
  "&nscr;": { "codepoints": [120003], "characters": "\uD835\uDCC3" },
  "&nshortmid;": { "codepoints": [8740], "characters": "\u2224" },
  "&nshortparallel;": { "codepoints": [8742], "characters": "\u2226" },
  "&nsim;": { "codepoints": [8769], "characters": "\u2241" },
  "&nsime;": { "codepoints": [8772], "characters": "\u2244" },
  "&nsimeq;": { "codepoints": [8772], "characters": "\u2244" },
  "&nsmid;": { "codepoints": [8740], "characters": "\u2224" },
  "&nspar;": { "codepoints": [8742], "characters": "\u2226" },
  "&nsqsube;": { "codepoints": [8930], "characters": "\u22E2" },
  "&nsqsupe;": { "codepoints": [8931], "characters": "\u22E3" },
  "&nsub;": { "codepoints": [8836], "characters": "\u2284" },
  "&nsubE;": { "codepoints": [10949, 824], "characters": "\u2AC5\u0338" },
  "&nsube;": { "codepoints": [8840], "characters": "\u2288" },
  "&nsubset;": { "codepoints": [8834, 8402], "characters": "\u2282\u20D2" },
  "&nsubseteq;": { "codepoints": [8840], "characters": "\u2288" },
  "&nsubseteqq;": { "codepoints": [10949, 824], "characters": "\u2AC5\u0338" },
  "&nsucc;": { "codepoints": [8833], "characters": "\u2281" },
  "&nsucceq;": { "codepoints": [10928, 824], "characters": "\u2AB0\u0338" },
  "&nsup;": { "codepoints": [8837], "characters": "\u2285" },
  "&nsupE;": { "codepoints": [10950, 824], "characters": "\u2AC6\u0338" },
  "&nsupe;": { "codepoints": [8841], "characters": "\u2289" },
  "&nsupset;": { "codepoints": [8835, 8402], "characters": "\u2283\u20D2" },
  "&nsupseteq;": { "codepoints": [8841], "characters": "\u2289" },
  "&nsupseteqq;": { "codepoints": [10950, 824], "characters": "\u2AC6\u0338" },
  "&ntgl;": { "codepoints": [8825], "characters": "\u2279" },
  "&Ntilde;": { "codepoints": [209], "characters": "\u00D1" },
  "&Ntilde": { "codepoints": [209], "characters": "\u00D1" },
  "&ntilde;": { "codepoints": [241], "characters": "\u00F1" },
  "&ntilde": { "codepoints": [241], "characters": "\u00F1" },
  "&ntlg;": { "codepoints": [8824], "characters": "\u2278" },
  "&ntriangleleft;": { "codepoints": [8938], "characters": "\u22EA" },
  "&ntrianglelefteq;": { "codepoints": [8940], "characters": "\u22EC" },
  "&ntriangleright;": { "codepoints": [8939], "characters": "\u22EB" },
  "&ntrianglerighteq;": { "codepoints": [8941], "characters": "\u22ED" },
  "&Nu;": { "codepoints": [925], "characters": "\u039D" },
  "&nu;": { "codepoints": [957], "characters": "\u03BD" },
  "&num;": { "codepoints": [35], "characters": "\u0023" },
  "&numero;": { "codepoints": [8470], "characters": "\u2116" },
  "&numsp;": { "codepoints": [8199], "characters": "\u2007" },
  "&nvap;": { "codepoints": [8781, 8402], "characters": "\u224D\u20D2" },
  "&nvdash;": { "codepoints": [8876], "characters": "\u22AC" },
  "&nvDash;": { "codepoints": [8877], "characters": "\u22AD" },
  "&nVdash;": { "codepoints": [8878], "characters": "\u22AE" },
  "&nVDash;": { "codepoints": [8879], "characters": "\u22AF" },
  "&nvge;": { "codepoints": [8805, 8402], "characters": "\u2265\u20D2" },
  "&nvgt;": { "codepoints": [62, 8402], "characters": "\u003E\u20D2" },
  "&nvHarr;": { "codepoints": [10500], "characters": "\u2904" },
  "&nvinfin;": { "codepoints": [10718], "characters": "\u29DE" },
  "&nvlArr;": { "codepoints": [10498], "characters": "\u2902" },
  "&nvle;": { "codepoints": [8804, 8402], "characters": "\u2264\u20D2" },
  "&nvlt;": { "codepoints": [60, 8402], "characters": "\u003C\u20D2" },
  "&nvltrie;": { "codepoints": [8884, 8402], "characters": "\u22B4\u20D2" },
  "&nvrArr;": { "codepoints": [10499], "characters": "\u2903" },
  "&nvrtrie;": { "codepoints": [8885, 8402], "characters": "\u22B5\u20D2" },
  "&nvsim;": { "codepoints": [8764, 8402], "characters": "\u223C\u20D2" },
  "&nwarhk;": { "codepoints": [10531], "characters": "\u2923" },
  "&nwarr;": { "codepoints": [8598], "characters": "\u2196" },
  "&nwArr;": { "codepoints": [8662], "characters": "\u21D6" },
  "&nwarrow;": { "codepoints": [8598], "characters": "\u2196" },
  "&nwnear;": { "codepoints": [10535], "characters": "\u2927" },
  "&Oacute;": { "codepoints": [211], "characters": "\u00D3" },
  "&Oacute": { "codepoints": [211], "characters": "\u00D3" },
  "&oacute;": { "codepoints": [243], "characters": "\u00F3" },
  "&oacute": { "codepoints": [243], "characters": "\u00F3" },
  "&oast;": { "codepoints": [8859], "characters": "\u229B" },
  "&Ocirc;": { "codepoints": [212], "characters": "\u00D4" },
  "&Ocirc": { "codepoints": [212], "characters": "\u00D4" },
  "&ocirc;": { "codepoints": [244], "characters": "\u00F4" },
  "&ocirc": { "codepoints": [244], "characters": "\u00F4" },
  "&ocir;": { "codepoints": [8858], "characters": "\u229A" },
  "&Ocy;": { "codepoints": [1054], "characters": "\u041E" },
  "&ocy;": { "codepoints": [1086], "characters": "\u043E" },
  "&odash;": { "codepoints": [8861], "characters": "\u229D" },
  "&Odblac;": { "codepoints": [336], "characters": "\u0150" },
  "&odblac;": { "codepoints": [337], "characters": "\u0151" },
  "&odiv;": { "codepoints": [10808], "characters": "\u2A38" },
  "&odot;": { "codepoints": [8857], "characters": "\u2299" },
  "&odsold;": { "codepoints": [10684], "characters": "\u29BC" },
  "&OElig;": { "codepoints": [338], "characters": "\u0152" },
  "&oelig;": { "codepoints": [339], "characters": "\u0153" },
  "&ofcir;": { "codepoints": [10687], "characters": "\u29BF" },
  "&Ofr;": { "codepoints": [120082], "characters": "\uD835\uDD12" },
  "&ofr;": { "codepoints": [120108], "characters": "\uD835\uDD2C" },
  "&ogon;": { "codepoints": [731], "characters": "\u02DB" },
  "&Ograve;": { "codepoints": [210], "characters": "\u00D2" },
  "&Ograve": { "codepoints": [210], "characters": "\u00D2" },
  "&ograve;": { "codepoints": [242], "characters": "\u00F2" },
  "&ograve": { "codepoints": [242], "characters": "\u00F2" },
  "&ogt;": { "codepoints": [10689], "characters": "\u29C1" },
  "&ohbar;": { "codepoints": [10677], "characters": "\u29B5" },
  "&ohm;": { "codepoints": [937], "characters": "\u03A9" },
  "&oint;": { "codepoints": [8750], "characters": "\u222E" },
  "&olarr;": { "codepoints": [8634], "characters": "\u21BA" },
  "&olcir;": { "codepoints": [10686], "characters": "\u29BE" },
  "&olcross;": { "codepoints": [10683], "characters": "\u29BB" },
  "&oline;": { "codepoints": [8254], "characters": "\u203E" },
  "&olt;": { "codepoints": [10688], "characters": "\u29C0" },
  "&Omacr;": { "codepoints": [332], "characters": "\u014C" },
  "&omacr;": { "codepoints": [333], "characters": "\u014D" },
  "&Omega;": { "codepoints": [937], "characters": "\u03A9" },
  "&omega;": { "codepoints": [969], "characters": "\u03C9" },
  "&Omicron;": { "codepoints": [927], "characters": "\u039F" },
  "&omicron;": { "codepoints": [959], "characters": "\u03BF" },
  "&omid;": { "codepoints": [10678], "characters": "\u29B6" },
  "&ominus;": { "codepoints": [8854], "characters": "\u2296" },
  "&Oopf;": { "codepoints": [120134], "characters": "\uD835\uDD46" },
  "&oopf;": { "codepoints": [120160], "characters": "\uD835\uDD60" },
  "&opar;": { "codepoints": [10679], "characters": "\u29B7" },
  "&OpenCurlyDoubleQuote;": { "codepoints": [8220], "characters": "\u201C" },
  "&OpenCurlyQuote;": { "codepoints": [8216], "characters": "\u2018" },
  "&operp;": { "codepoints": [10681], "characters": "\u29B9" },
  "&oplus;": { "codepoints": [8853], "characters": "\u2295" },
  "&orarr;": { "codepoints": [8635], "characters": "\u21BB" },
  "&Or;": { "codepoints": [10836], "characters": "\u2A54" },
  "&or;": { "codepoints": [8744], "characters": "\u2228" },
  "&ord;": { "codepoints": [10845], "characters": "\u2A5D" },
  "&order;": { "codepoints": [8500], "characters": "\u2134" },
  "&orderof;": { "codepoints": [8500], "characters": "\u2134" },
  "&ordf;": { "codepoints": [170], "characters": "\u00AA" },
  "&ordf": { "codepoints": [170], "characters": "\u00AA" },
  "&ordm;": { "codepoints": [186], "characters": "\u00BA" },
  "&ordm": { "codepoints": [186], "characters": "\u00BA" },
  "&origof;": { "codepoints": [8886], "characters": "\u22B6" },
  "&oror;": { "codepoints": [10838], "characters": "\u2A56" },
  "&orslope;": { "codepoints": [10839], "characters": "\u2A57" },
  "&orv;": { "codepoints": [10843], "characters": "\u2A5B" },
  "&oS;": { "codepoints": [9416], "characters": "\u24C8" },
  "&Oscr;": { "codepoints": [119978], "characters": "\uD835\uDCAA" },
  "&oscr;": { "codepoints": [8500], "characters": "\u2134" },
  "&Oslash;": { "codepoints": [216], "characters": "\u00D8" },
  "&Oslash": { "codepoints": [216], "characters": "\u00D8" },
  "&oslash;": { "codepoints": [248], "characters": "\u00F8" },
  "&oslash": { "codepoints": [248], "characters": "\u00F8" },
  "&osol;": { "codepoints": [8856], "characters": "\u2298" },
  "&Otilde;": { "codepoints": [213], "characters": "\u00D5" },
  "&Otilde": { "codepoints": [213], "characters": "\u00D5" },
  "&otilde;": { "codepoints": [245], "characters": "\u00F5" },
  "&otilde": { "codepoints": [245], "characters": "\u00F5" },
  "&otimesas;": { "codepoints": [10806], "characters": "\u2A36" },
  "&Otimes;": { "codepoints": [10807], "characters": "\u2A37" },
  "&otimes;": { "codepoints": [8855], "characters": "\u2297" },
  "&Ouml;": { "codepoints": [214], "characters": "\u00D6" },
  "&Ouml": { "codepoints": [214], "characters": "\u00D6" },
  "&ouml;": { "codepoints": [246], "characters": "\u00F6" },
  "&ouml": { "codepoints": [246], "characters": "\u00F6" },
  "&ovbar;": { "codepoints": [9021], "characters": "\u233D" },
  "&OverBar;": { "codepoints": [8254], "characters": "\u203E" },
  "&OverBrace;": { "codepoints": [9182], "characters": "\u23DE" },
  "&OverBracket;": { "codepoints": [9140], "characters": "\u23B4" },
  "&OverParenthesis;": { "codepoints": [9180], "characters": "\u23DC" },
  "&para;": { "codepoints": [182], "characters": "\u00B6" },
  "&para": { "codepoints": [182], "characters": "\u00B6" },
  "&parallel;": { "codepoints": [8741], "characters": "\u2225" },
  "&par;": { "codepoints": [8741], "characters": "\u2225" },
  "&parsim;": { "codepoints": [10995], "characters": "\u2AF3" },
  "&parsl;": { "codepoints": [11005], "characters": "\u2AFD" },
  "&part;": { "codepoints": [8706], "characters": "\u2202" },
  "&PartialD;": { "codepoints": [8706], "characters": "\u2202" },
  "&Pcy;": { "codepoints": [1055], "characters": "\u041F" },
  "&pcy;": { "codepoints": [1087], "characters": "\u043F" },
  "&percnt;": { "codepoints": [37], "characters": "\u0025" },
  "&period;": { "codepoints": [46], "characters": "\u002E" },
  "&permil;": { "codepoints": [8240], "characters": "\u2030" },
  "&perp;": { "codepoints": [8869], "characters": "\u22A5" },
  "&pertenk;": { "codepoints": [8241], "characters": "\u2031" },
  "&Pfr;": { "codepoints": [120083], "characters": "\uD835\uDD13" },
  "&pfr;": { "codepoints": [120109], "characters": "\uD835\uDD2D" },
  "&Phi;": { "codepoints": [934], "characters": "\u03A6" },
  "&phi;": { "codepoints": [966], "characters": "\u03C6" },
  "&phiv;": { "codepoints": [981], "characters": "\u03D5" },
  "&phmmat;": { "codepoints": [8499], "characters": "\u2133" },
  "&phone;": { "codepoints": [9742], "characters": "\u260E" },
  "&Pi;": { "codepoints": [928], "characters": "\u03A0" },
  "&pi;": { "codepoints": [960], "characters": "\u03C0" },
  "&pitchfork;": { "codepoints": [8916], "characters": "\u22D4" },
  "&piv;": { "codepoints": [982], "characters": "\u03D6" },
  "&planck;": { "codepoints": [8463], "characters": "\u210F" },
  "&planckh;": { "codepoints": [8462], "characters": "\u210E" },
  "&plankv;": { "codepoints": [8463], "characters": "\u210F" },
  "&plusacir;": { "codepoints": [10787], "characters": "\u2A23" },
  "&plusb;": { "codepoints": [8862], "characters": "\u229E" },
  "&pluscir;": { "codepoints": [10786], "characters": "\u2A22" },
  "&plus;": { "codepoints": [43], "characters": "\u002B" },
  "&plusdo;": { "codepoints": [8724], "characters": "\u2214" },
  "&plusdu;": { "codepoints": [10789], "characters": "\u2A25" },
  "&pluse;": { "codepoints": [10866], "characters": "\u2A72" },
  "&PlusMinus;": { "codepoints": [177], "characters": "\u00B1" },
  "&plusmn;": { "codepoints": [177], "characters": "\u00B1" },
  "&plusmn": { "codepoints": [177], "characters": "\u00B1" },
  "&plussim;": { "codepoints": [10790], "characters": "\u2A26" },
  "&plustwo;": { "codepoints": [10791], "characters": "\u2A27" },
  "&pm;": { "codepoints": [177], "characters": "\u00B1" },
  "&Poincareplane;": { "codepoints": [8460], "characters": "\u210C" },
  "&pointint;": { "codepoints": [10773], "characters": "\u2A15" },
  "&popf;": { "codepoints": [120161], "characters": "\uD835\uDD61" },
  "&Popf;": { "codepoints": [8473], "characters": "\u2119" },
  "&pound;": { "codepoints": [163], "characters": "\u00A3" },
  "&pound": { "codepoints": [163], "characters": "\u00A3" },
  "&prap;": { "codepoints": [10935], "characters": "\u2AB7" },
  "&Pr;": { "codepoints": [10939], "characters": "\u2ABB" },
  "&pr;": { "codepoints": [8826], "characters": "\u227A" },
  "&prcue;": { "codepoints": [8828], "characters": "\u227C" },
  "&precapprox;": { "codepoints": [10935], "characters": "\u2AB7" },
  "&prec;": { "codepoints": [8826], "characters": "\u227A" },
  "&preccurlyeq;": { "codepoints": [8828], "characters": "\u227C" },
  "&Precedes;": { "codepoints": [8826], "characters": "\u227A" },
  "&PrecedesEqual;": { "codepoints": [10927], "characters": "\u2AAF" },
  "&PrecedesSlantEqual;": { "codepoints": [8828], "characters": "\u227C" },
  "&PrecedesTilde;": { "codepoints": [8830], "characters": "\u227E" },
  "&preceq;": { "codepoints": [10927], "characters": "\u2AAF" },
  "&precnapprox;": { "codepoints": [10937], "characters": "\u2AB9" },
  "&precneqq;": { "codepoints": [10933], "characters": "\u2AB5" },
  "&precnsim;": { "codepoints": [8936], "characters": "\u22E8" },
  "&pre;": { "codepoints": [10927], "characters": "\u2AAF" },
  "&prE;": { "codepoints": [10931], "characters": "\u2AB3" },
  "&precsim;": { "codepoints": [8830], "characters": "\u227E" },
  "&prime;": { "codepoints": [8242], "characters": "\u2032" },
  "&Prime;": { "codepoints": [8243], "characters": "\u2033" },
  "&primes;": { "codepoints": [8473], "characters": "\u2119" },
  "&prnap;": { "codepoints": [10937], "characters": "\u2AB9" },
  "&prnE;": { "codepoints": [10933], "characters": "\u2AB5" },
  "&prnsim;": { "codepoints": [8936], "characters": "\u22E8" },
  "&prod;": { "codepoints": [8719], "characters": "\u220F" },
  "&Product;": { "codepoints": [8719], "characters": "\u220F" },
  "&profalar;": { "codepoints": [9006], "characters": "\u232E" },
  "&profline;": { "codepoints": [8978], "characters": "\u2312" },
  "&profsurf;": { "codepoints": [8979], "characters": "\u2313" },
  "&prop;": { "codepoints": [8733], "characters": "\u221D" },
  "&Proportional;": { "codepoints": [8733], "characters": "\u221D" },
  "&Proportion;": { "codepoints": [8759], "characters": "\u2237" },
  "&propto;": { "codepoints": [8733], "characters": "\u221D" },
  "&prsim;": { "codepoints": [8830], "characters": "\u227E" },
  "&prurel;": { "codepoints": [8880], "characters": "\u22B0" },
  "&Pscr;": { "codepoints": [119979], "characters": "\uD835\uDCAB" },
  "&pscr;": { "codepoints": [120005], "characters": "\uD835\uDCC5" },
  "&Psi;": { "codepoints": [936], "characters": "\u03A8" },
  "&psi;": { "codepoints": [968], "characters": "\u03C8" },
  "&puncsp;": { "codepoints": [8200], "characters": "\u2008" },
  "&Qfr;": { "codepoints": [120084], "characters": "\uD835\uDD14" },
  "&qfr;": { "codepoints": [120110], "characters": "\uD835\uDD2E" },
  "&qint;": { "codepoints": [10764], "characters": "\u2A0C" },
  "&qopf;": { "codepoints": [120162], "characters": "\uD835\uDD62" },
  "&Qopf;": { "codepoints": [8474], "characters": "\u211A" },
  "&qprime;": { "codepoints": [8279], "characters": "\u2057" },
  "&Qscr;": { "codepoints": [119980], "characters": "\uD835\uDCAC" },
  "&qscr;": { "codepoints": [120006], "characters": "\uD835\uDCC6" },
  "&quaternions;": { "codepoints": [8461], "characters": "\u210D" },
  "&quatint;": { "codepoints": [10774], "characters": "\u2A16" },
  "&quest;": { "codepoints": [63], "characters": "\u003F" },
  "&questeq;": { "codepoints": [8799], "characters": "\u225F" },
  "&quot;": { "codepoints": [34], "characters": "\u0022" },
  "&quot": { "codepoints": [34], "characters": "\u0022" },
  "&QUOT;": { "codepoints": [34], "characters": "\u0022" },
  "&QUOT": { "codepoints": [34], "characters": "\u0022" },
  "&rAarr;": { "codepoints": [8667], "characters": "\u21DB" },
  "&race;": { "codepoints": [8765, 817], "characters": "\u223D\u0331" },
  "&Racute;": { "codepoints": [340], "characters": "\u0154" },
  "&racute;": { "codepoints": [341], "characters": "\u0155" },
  "&radic;": { "codepoints": [8730], "characters": "\u221A" },
  "&raemptyv;": { "codepoints": [10675], "characters": "\u29B3" },
  "&rang;": { "codepoints": [10217], "characters": "\u27E9" },
  "&Rang;": { "codepoints": [10219], "characters": "\u27EB" },
  "&rangd;": { "codepoints": [10642], "characters": "\u2992" },
  "&range;": { "codepoints": [10661], "characters": "\u29A5" },
  "&rangle;": { "codepoints": [10217], "characters": "\u27E9" },
  "&raquo;": { "codepoints": [187], "characters": "\u00BB" },
  "&raquo": { "codepoints": [187], "characters": "\u00BB" },
  "&rarrap;": { "codepoints": [10613], "characters": "\u2975" },
  "&rarrb;": { "codepoints": [8677], "characters": "\u21E5" },
  "&rarrbfs;": { "codepoints": [10528], "characters": "\u2920" },
  "&rarrc;": { "codepoints": [10547], "characters": "\u2933" },
  "&rarr;": { "codepoints": [8594], "characters": "\u2192" },
  "&Rarr;": { "codepoints": [8608], "characters": "\u21A0" },
  "&rArr;": { "codepoints": [8658], "characters": "\u21D2" },
  "&rarrfs;": { "codepoints": [10526], "characters": "\u291E" },
  "&rarrhk;": { "codepoints": [8618], "characters": "\u21AA" },
  "&rarrlp;": { "codepoints": [8620], "characters": "\u21AC" },
  "&rarrpl;": { "codepoints": [10565], "characters": "\u2945" },
  "&rarrsim;": { "codepoints": [10612], "characters": "\u2974" },
  "&Rarrtl;": { "codepoints": [10518], "characters": "\u2916" },
  "&rarrtl;": { "codepoints": [8611], "characters": "\u21A3" },
  "&rarrw;": { "codepoints": [8605], "characters": "\u219D" },
  "&ratail;": { "codepoints": [10522], "characters": "\u291A" },
  "&rAtail;": { "codepoints": [10524], "characters": "\u291C" },
  "&ratio;": { "codepoints": [8758], "characters": "\u2236" },
  "&rationals;": { "codepoints": [8474], "characters": "\u211A" },
  "&rbarr;": { "codepoints": [10509], "characters": "\u290D" },
  "&rBarr;": { "codepoints": [10511], "characters": "\u290F" },
  "&RBarr;": { "codepoints": [10512], "characters": "\u2910" },
  "&rbbrk;": { "codepoints": [10099], "characters": "\u2773" },
  "&rbrace;": { "codepoints": [125], "characters": "\u007D" },
  "&rbrack;": { "codepoints": [93], "characters": "\u005D" },
  "&rbrke;": { "codepoints": [10636], "characters": "\u298C" },
  "&rbrksld;": { "codepoints": [10638], "characters": "\u298E" },
  "&rbrkslu;": { "codepoints": [10640], "characters": "\u2990" },
  "&Rcaron;": { "codepoints": [344], "characters": "\u0158" },
  "&rcaron;": { "codepoints": [345], "characters": "\u0159" },
  "&Rcedil;": { "codepoints": [342], "characters": "\u0156" },
  "&rcedil;": { "codepoints": [343], "characters": "\u0157" },
  "&rceil;": { "codepoints": [8969], "characters": "\u2309" },
  "&rcub;": { "codepoints": [125], "characters": "\u007D" },
  "&Rcy;": { "codepoints": [1056], "characters": "\u0420" },
  "&rcy;": { "codepoints": [1088], "characters": "\u0440" },
  "&rdca;": { "codepoints": [10551], "characters": "\u2937" },
  "&rdldhar;": { "codepoints": [10601], "characters": "\u2969" },
  "&rdquo;": { "codepoints": [8221], "characters": "\u201D" },
  "&rdquor;": { "codepoints": [8221], "characters": "\u201D" },
  "&rdsh;": { "codepoints": [8627], "characters": "\u21B3" },
  "&real;": { "codepoints": [8476], "characters": "\u211C" },
  "&realine;": { "codepoints": [8475], "characters": "\u211B" },
  "&realpart;": { "codepoints": [8476], "characters": "\u211C" },
  "&reals;": { "codepoints": [8477], "characters": "\u211D" },
  "&Re;": { "codepoints": [8476], "characters": "\u211C" },
  "&rect;": { "codepoints": [9645], "characters": "\u25AD" },
  "&reg;": { "codepoints": [174], "characters": "\u00AE" },
  "&reg": { "codepoints": [174], "characters": "\u00AE" },
  "&REG;": { "codepoints": [174], "characters": "\u00AE" },
  "&REG": { "codepoints": [174], "characters": "\u00AE" },
  "&ReverseElement;": { "codepoints": [8715], "characters": "\u220B" },
  "&ReverseEquilibrium;": { "codepoints": [8651], "characters": "\u21CB" },
  "&ReverseUpEquilibrium;": { "codepoints": [10607], "characters": "\u296F" },
  "&rfisht;": { "codepoints": [10621], "characters": "\u297D" },
  "&rfloor;": { "codepoints": [8971], "characters": "\u230B" },
  "&rfr;": { "codepoints": [120111], "characters": "\uD835\uDD2F" },
  "&Rfr;": { "codepoints": [8476], "characters": "\u211C" },
  "&rHar;": { "codepoints": [10596], "characters": "\u2964" },
  "&rhard;": { "codepoints": [8641], "characters": "\u21C1" },
  "&rharu;": { "codepoints": [8640], "characters": "\u21C0" },
  "&rharul;": { "codepoints": [10604], "characters": "\u296C" },
  "&Rho;": { "codepoints": [929], "characters": "\u03A1" },
  "&rho;": { "codepoints": [961], "characters": "\u03C1" },
  "&rhov;": { "codepoints": [1009], "characters": "\u03F1" },
  "&RightAngleBracket;": { "codepoints": [10217], "characters": "\u27E9" },
  "&RightArrowBar;": { "codepoints": [8677], "characters": "\u21E5" },
  "&rightarrow;": { "codepoints": [8594], "characters": "\u2192" },
  "&RightArrow;": { "codepoints": [8594], "characters": "\u2192" },
  "&Rightarrow;": { "codepoints": [8658], "characters": "\u21D2" },
  "&RightArrowLeftArrow;": { "codepoints": [8644], "characters": "\u21C4" },
  "&rightarrowtail;": { "codepoints": [8611], "characters": "\u21A3" },
  "&RightCeiling;": { "codepoints": [8969], "characters": "\u2309" },
  "&RightDoubleBracket;": { "codepoints": [10215], "characters": "\u27E7" },
  "&RightDownTeeVector;": { "codepoints": [10589], "characters": "\u295D" },
  "&RightDownVectorBar;": { "codepoints": [10581], "characters": "\u2955" },
  "&RightDownVector;": { "codepoints": [8642], "characters": "\u21C2" },
  "&RightFloor;": { "codepoints": [8971], "characters": "\u230B" },
  "&rightharpoondown;": { "codepoints": [8641], "characters": "\u21C1" },
  "&rightharpoonup;": { "codepoints": [8640], "characters": "\u21C0" },
  "&rightleftarrows;": { "codepoints": [8644], "characters": "\u21C4" },
  "&rightleftharpoons;": { "codepoints": [8652], "characters": "\u21CC" },
  "&rightrightarrows;": { "codepoints": [8649], "characters": "\u21C9" },
  "&rightsquigarrow;": { "codepoints": [8605], "characters": "\u219D" },
  "&RightTeeArrow;": { "codepoints": [8614], "characters": "\u21A6" },
  "&RightTee;": { "codepoints": [8866], "characters": "\u22A2" },
  "&RightTeeVector;": { "codepoints": [10587], "characters": "\u295B" },
  "&rightthreetimes;": { "codepoints": [8908], "characters": "\u22CC" },
  "&RightTriangleBar;": { "codepoints": [10704], "characters": "\u29D0" },
  "&RightTriangle;": { "codepoints": [8883], "characters": "\u22B3" },
  "&RightTriangleEqual;": { "codepoints": [8885], "characters": "\u22B5" },
  "&RightUpDownVector;": { "codepoints": [10575], "characters": "\u294F" },
  "&RightUpTeeVector;": { "codepoints": [10588], "characters": "\u295C" },
  "&RightUpVectorBar;": { "codepoints": [10580], "characters": "\u2954" },
  "&RightUpVector;": { "codepoints": [8638], "characters": "\u21BE" },
  "&RightVectorBar;": { "codepoints": [10579], "characters": "\u2953" },
  "&RightVector;": { "codepoints": [8640], "characters": "\u21C0" },
  "&ring;": { "codepoints": [730], "characters": "\u02DA" },
  "&risingdotseq;": { "codepoints": [8787], "characters": "\u2253" },
  "&rlarr;": { "codepoints": [8644], "characters": "\u21C4" },
  "&rlhar;": { "codepoints": [8652], "characters": "\u21CC" },
  "&rlm;": { "codepoints": [8207], "characters": "\u200F" },
  "&rmoustache;": { "codepoints": [9137], "characters": "\u23B1" },
  "&rmoust;": { "codepoints": [9137], "characters": "\u23B1" },
  "&rnmid;": { "codepoints": [10990], "characters": "\u2AEE" },
  "&roang;": { "codepoints": [10221], "characters": "\u27ED" },
  "&roarr;": { "codepoints": [8702], "characters": "\u21FE" },
  "&robrk;": { "codepoints": [10215], "characters": "\u27E7" },
  "&ropar;": { "codepoints": [10630], "characters": "\u2986" },
  "&ropf;": { "codepoints": [120163], "characters": "\uD835\uDD63" },
  "&Ropf;": { "codepoints": [8477], "characters": "\u211D" },
  "&roplus;": { "codepoints": [10798], "characters": "\u2A2E" },
  "&rotimes;": { "codepoints": [10805], "characters": "\u2A35" },
  "&RoundImplies;": { "codepoints": [10608], "characters": "\u2970" },
  "&rpar;": { "codepoints": [41], "characters": "\u0029" },
  "&rpargt;": { "codepoints": [10644], "characters": "\u2994" },
  "&rppolint;": { "codepoints": [10770], "characters": "\u2A12" },
  "&rrarr;": { "codepoints": [8649], "characters": "\u21C9" },
  "&Rrightarrow;": { "codepoints": [8667], "characters": "\u21DB" },
  "&rsaquo;": { "codepoints": [8250], "characters": "\u203A" },
  "&rscr;": { "codepoints": [120007], "characters": "\uD835\uDCC7" },
  "&Rscr;": { "codepoints": [8475], "characters": "\u211B" },
  "&rsh;": { "codepoints": [8625], "characters": "\u21B1" },
  "&Rsh;": { "codepoints": [8625], "characters": "\u21B1" },
  "&rsqb;": { "codepoints": [93], "characters": "\u005D" },
  "&rsquo;": { "codepoints": [8217], "characters": "\u2019" },
  "&rsquor;": { "codepoints": [8217], "characters": "\u2019" },
  "&rthree;": { "codepoints": [8908], "characters": "\u22CC" },
  "&rtimes;": { "codepoints": [8906], "characters": "\u22CA" },
  "&rtri;": { "codepoints": [9657], "characters": "\u25B9" },
  "&rtrie;": { "codepoints": [8885], "characters": "\u22B5" },
  "&rtrif;": { "codepoints": [9656], "characters": "\u25B8" },
  "&rtriltri;": { "codepoints": [10702], "characters": "\u29CE" },
  "&RuleDelayed;": { "codepoints": [10740], "characters": "\u29F4" },
  "&ruluhar;": { "codepoints": [10600], "characters": "\u2968" },
  "&rx;": { "codepoints": [8478], "characters": "\u211E" },
  "&Sacute;": { "codepoints": [346], "characters": "\u015A" },
  "&sacute;": { "codepoints": [347], "characters": "\u015B" },
  "&sbquo;": { "codepoints": [8218], "characters": "\u201A" },
  "&scap;": { "codepoints": [10936], "characters": "\u2AB8" },
  "&Scaron;": { "codepoints": [352], "characters": "\u0160" },
  "&scaron;": { "codepoints": [353], "characters": "\u0161" },
  "&Sc;": { "codepoints": [10940], "characters": "\u2ABC" },
  "&sc;": { "codepoints": [8827], "characters": "\u227B" },
  "&sccue;": { "codepoints": [8829], "characters": "\u227D" },
  "&sce;": { "codepoints": [10928], "characters": "\u2AB0" },
  "&scE;": { "codepoints": [10932], "characters": "\u2AB4" },
  "&Scedil;": { "codepoints": [350], "characters": "\u015E" },
  "&scedil;": { "codepoints": [351], "characters": "\u015F" },
  "&Scirc;": { "codepoints": [348], "characters": "\u015C" },
  "&scirc;": { "codepoints": [349], "characters": "\u015D" },
  "&scnap;": { "codepoints": [10938], "characters": "\u2ABA" },
  "&scnE;": { "codepoints": [10934], "characters": "\u2AB6" },
  "&scnsim;": { "codepoints": [8937], "characters": "\u22E9" },
  "&scpolint;": { "codepoints": [10771], "characters": "\u2A13" },
  "&scsim;": { "codepoints": [8831], "characters": "\u227F" },
  "&Scy;": { "codepoints": [1057], "characters": "\u0421" },
  "&scy;": { "codepoints": [1089], "characters": "\u0441" },
  "&sdotb;": { "codepoints": [8865], "characters": "\u22A1" },
  "&sdot;": { "codepoints": [8901], "characters": "\u22C5" },
  "&sdote;": { "codepoints": [10854], "characters": "\u2A66" },
  "&searhk;": { "codepoints": [10533], "characters": "\u2925" },
  "&searr;": { "codepoints": [8600], "characters": "\u2198" },
  "&seArr;": { "codepoints": [8664], "characters": "\u21D8" },
  "&searrow;": { "codepoints": [8600], "characters": "\u2198" },
  "&sect;": { "codepoints": [167], "characters": "\u00A7" },
  "&sect": { "codepoints": [167], "characters": "\u00A7" },
  "&semi;": { "codepoints": [59], "characters": "\u003B" },
  "&seswar;": { "codepoints": [10537], "characters": "\u2929" },
  "&setminus;": { "codepoints": [8726], "characters": "\u2216" },
  "&setmn;": { "codepoints": [8726], "characters": "\u2216" },
  "&sext;": { "codepoints": [10038], "characters": "\u2736" },
  "&Sfr;": { "codepoints": [120086], "characters": "\uD835\uDD16" },
  "&sfr;": { "codepoints": [120112], "characters": "\uD835\uDD30" },
  "&sfrown;": { "codepoints": [8994], "characters": "\u2322" },
  "&sharp;": { "codepoints": [9839], "characters": "\u266F" },
  "&SHCHcy;": { "codepoints": [1065], "characters": "\u0429" },
  "&shchcy;": { "codepoints": [1097], "characters": "\u0449" },
  "&SHcy;": { "codepoints": [1064], "characters": "\u0428" },
  "&shcy;": { "codepoints": [1096], "characters": "\u0448" },
  "&ShortDownArrow;": { "codepoints": [8595], "characters": "\u2193" },
  "&ShortLeftArrow;": { "codepoints": [8592], "characters": "\u2190" },
  "&shortmid;": { "codepoints": [8739], "characters": "\u2223" },
  "&shortparallel;": { "codepoints": [8741], "characters": "\u2225" },
  "&ShortRightArrow;": { "codepoints": [8594], "characters": "\u2192" },
  "&ShortUpArrow;": { "codepoints": [8593], "characters": "\u2191" },
  "&shy;": { "codepoints": [173], "characters": "\u00AD" },
  "&shy": { "codepoints": [173], "characters": "\u00AD" },
  "&Sigma;": { "codepoints": [931], "characters": "\u03A3" },
  "&sigma;": { "codepoints": [963], "characters": "\u03C3" },
  "&sigmaf;": { "codepoints": [962], "characters": "\u03C2" },
  "&sigmav;": { "codepoints": [962], "characters": "\u03C2" },
  "&sim;": { "codepoints": [8764], "characters": "\u223C" },
  "&simdot;": { "codepoints": [10858], "characters": "\u2A6A" },
  "&sime;": { "codepoints": [8771], "characters": "\u2243" },
  "&simeq;": { "codepoints": [8771], "characters": "\u2243" },
  "&simg;": { "codepoints": [10910], "characters": "\u2A9E" },
  "&simgE;": { "codepoints": [10912], "characters": "\u2AA0" },
  "&siml;": { "codepoints": [10909], "characters": "\u2A9D" },
  "&simlE;": { "codepoints": [10911], "characters": "\u2A9F" },
  "&simne;": { "codepoints": [8774], "characters": "\u2246" },
  "&simplus;": { "codepoints": [10788], "characters": "\u2A24" },
  "&simrarr;": { "codepoints": [10610], "characters": "\u2972" },
  "&slarr;": { "codepoints": [8592], "characters": "\u2190" },
  "&SmallCircle;": { "codepoints": [8728], "characters": "\u2218" },
  "&smallsetminus;": { "codepoints": [8726], "characters": "\u2216" },
  "&smashp;": { "codepoints": [10803], "characters": "\u2A33" },
  "&smeparsl;": { "codepoints": [10724], "characters": "\u29E4" },
  "&smid;": { "codepoints": [8739], "characters": "\u2223" },
  "&smile;": { "codepoints": [8995], "characters": "\u2323" },
  "&smt;": { "codepoints": [10922], "characters": "\u2AAA" },
  "&smte;": { "codepoints": [10924], "characters": "\u2AAC" },
  "&smtes;": { "codepoints": [10924, 65024], "characters": "\u2AAC\uFE00" },
  "&SOFTcy;": { "codepoints": [1068], "characters": "\u042C" },
  "&softcy;": { "codepoints": [1100], "characters": "\u044C" },
  "&solbar;": { "codepoints": [9023], "characters": "\u233F" },
  "&solb;": { "codepoints": [10692], "characters": "\u29C4" },
  "&sol;": { "codepoints": [47], "characters": "\u002F" },
  "&Sopf;": { "codepoints": [120138], "characters": "\uD835\uDD4A" },
  "&sopf;": { "codepoints": [120164], "characters": "\uD835\uDD64" },
  "&spades;": { "codepoints": [9824], "characters": "\u2660" },
  "&spadesuit;": { "codepoints": [9824], "characters": "\u2660" },
  "&spar;": { "codepoints": [8741], "characters": "\u2225" },
  "&sqcap;": { "codepoints": [8851], "characters": "\u2293" },
  "&sqcaps;": { "codepoints": [8851, 65024], "characters": "\u2293\uFE00" },
  "&sqcup;": { "codepoints": [8852], "characters": "\u2294" },
  "&sqcups;": { "codepoints": [8852, 65024], "characters": "\u2294\uFE00" },
  "&Sqrt;": { "codepoints": [8730], "characters": "\u221A" },
  "&sqsub;": { "codepoints": [8847], "characters": "\u228F" },
  "&sqsube;": { "codepoints": [8849], "characters": "\u2291" },
  "&sqsubset;": { "codepoints": [8847], "characters": "\u228F" },
  "&sqsubseteq;": { "codepoints": [8849], "characters": "\u2291" },
  "&sqsup;": { "codepoints": [8848], "characters": "\u2290" },
  "&sqsupe;": { "codepoints": [8850], "characters": "\u2292" },
  "&sqsupset;": { "codepoints": [8848], "characters": "\u2290" },
  "&sqsupseteq;": { "codepoints": [8850], "characters": "\u2292" },
  "&square;": { "codepoints": [9633], "characters": "\u25A1" },
  "&Square;": { "codepoints": [9633], "characters": "\u25A1" },
  "&SquareIntersection;": { "codepoints": [8851], "characters": "\u2293" },
  "&SquareSubset;": { "codepoints": [8847], "characters": "\u228F" },
  "&SquareSubsetEqual;": { "codepoints": [8849], "characters": "\u2291" },
  "&SquareSuperset;": { "codepoints": [8848], "characters": "\u2290" },
  "&SquareSupersetEqual;": { "codepoints": [8850], "characters": "\u2292" },
  "&SquareUnion;": { "codepoints": [8852], "characters": "\u2294" },
  "&squarf;": { "codepoints": [9642], "characters": "\u25AA" },
  "&squ;": { "codepoints": [9633], "characters": "\u25A1" },
  "&squf;": { "codepoints": [9642], "characters": "\u25AA" },
  "&srarr;": { "codepoints": [8594], "characters": "\u2192" },
  "&Sscr;": { "codepoints": [119982], "characters": "\uD835\uDCAE" },
  "&sscr;": { "codepoints": [120008], "characters": "\uD835\uDCC8" },
  "&ssetmn;": { "codepoints": [8726], "characters": "\u2216" },
  "&ssmile;": { "codepoints": [8995], "characters": "\u2323" },
  "&sstarf;": { "codepoints": [8902], "characters": "\u22C6" },
  "&Star;": { "codepoints": [8902], "characters": "\u22C6" },
  "&star;": { "codepoints": [9734], "characters": "\u2606" },
  "&starf;": { "codepoints": [9733], "characters": "\u2605" },
  "&straightepsilon;": { "codepoints": [1013], "characters": "\u03F5" },
  "&straightphi;": { "codepoints": [981], "characters": "\u03D5" },
  "&strns;": { "codepoints": [175], "characters": "\u00AF" },
  "&sub;": { "codepoints": [8834], "characters": "\u2282" },
  "&Sub;": { "codepoints": [8912], "characters": "\u22D0" },
  "&subdot;": { "codepoints": [10941], "characters": "\u2ABD" },
  "&subE;": { "codepoints": [10949], "characters": "\u2AC5" },
  "&sube;": { "codepoints": [8838], "characters": "\u2286" },
  "&subedot;": { "codepoints": [10947], "characters": "\u2AC3" },
  "&submult;": { "codepoints": [10945], "characters": "\u2AC1" },
  "&subnE;": { "codepoints": [10955], "characters": "\u2ACB" },
  "&subne;": { "codepoints": [8842], "characters": "\u228A" },
  "&subplus;": { "codepoints": [10943], "characters": "\u2ABF" },
  "&subrarr;": { "codepoints": [10617], "characters": "\u2979" },
  "&subset;": { "codepoints": [8834], "characters": "\u2282" },
  "&Subset;": { "codepoints": [8912], "characters": "\u22D0" },
  "&subseteq;": { "codepoints": [8838], "characters": "\u2286" },
  "&subseteqq;": { "codepoints": [10949], "characters": "\u2AC5" },
  "&SubsetEqual;": { "codepoints": [8838], "characters": "\u2286" },
  "&subsetneq;": { "codepoints": [8842], "characters": "\u228A" },
  "&subsetneqq;": { "codepoints": [10955], "characters": "\u2ACB" },
  "&subsim;": { "codepoints": [10951], "characters": "\u2AC7" },
  "&subsub;": { "codepoints": [10965], "characters": "\u2AD5" },
  "&subsup;": { "codepoints": [10963], "characters": "\u2AD3" },
  "&succapprox;": { "codepoints": [10936], "characters": "\u2AB8" },
  "&succ;": { "codepoints": [8827], "characters": "\u227B" },
  "&succcurlyeq;": { "codepoints": [8829], "characters": "\u227D" },
  "&Succeeds;": { "codepoints": [8827], "characters": "\u227B" },
  "&SucceedsEqual;": { "codepoints": [10928], "characters": "\u2AB0" },
  "&SucceedsSlantEqual;": { "codepoints": [8829], "characters": "\u227D" },
  "&SucceedsTilde;": { "codepoints": [8831], "characters": "\u227F" },
  "&succeq;": { "codepoints": [10928], "characters": "\u2AB0" },
  "&succnapprox;": { "codepoints": [10938], "characters": "\u2ABA" },
  "&succneqq;": { "codepoints": [10934], "characters": "\u2AB6" },
  "&succnsim;": { "codepoints": [8937], "characters": "\u22E9" },
  "&succsim;": { "codepoints": [8831], "characters": "\u227F" },
  "&SuchThat;": { "codepoints": [8715], "characters": "\u220B" },
  "&sum;": { "codepoints": [8721], "characters": "\u2211" },
  "&Sum;": { "codepoints": [8721], "characters": "\u2211" },
  "&sung;": { "codepoints": [9834], "characters": "\u266A" },
  "&sup1;": { "codepoints": [185], "characters": "\u00B9" },
  "&sup1": { "codepoints": [185], "characters": "\u00B9" },
  "&sup2;": { "codepoints": [178], "characters": "\u00B2" },
  "&sup2": { "codepoints": [178], "characters": "\u00B2" },
  "&sup3;": { "codepoints": [179], "characters": "\u00B3" },
  "&sup3": { "codepoints": [179], "characters": "\u00B3" },
  "&sup;": { "codepoints": [8835], "characters": "\u2283" },
  "&Sup;": { "codepoints": [8913], "characters": "\u22D1" },
  "&supdot;": { "codepoints": [10942], "characters": "\u2ABE" },
  "&supdsub;": { "codepoints": [10968], "characters": "\u2AD8" },
  "&supE;": { "codepoints": [10950], "characters": "\u2AC6" },
  "&supe;": { "codepoints": [8839], "characters": "\u2287" },
  "&supedot;": { "codepoints": [10948], "characters": "\u2AC4" },
  "&Superset;": { "codepoints": [8835], "characters": "\u2283" },
  "&SupersetEqual;": { "codepoints": [8839], "characters": "\u2287" },
  "&suphsol;": { "codepoints": [10185], "characters": "\u27C9" },
  "&suphsub;": { "codepoints": [10967], "characters": "\u2AD7" },
  "&suplarr;": { "codepoints": [10619], "characters": "\u297B" },
  "&supmult;": { "codepoints": [10946], "characters": "\u2AC2" },
  "&supnE;": { "codepoints": [10956], "characters": "\u2ACC" },
  "&supne;": { "codepoints": [8843], "characters": "\u228B" },
  "&supplus;": { "codepoints": [10944], "characters": "\u2AC0" },
  "&supset;": { "codepoints": [8835], "characters": "\u2283" },
  "&Supset;": { "codepoints": [8913], "characters": "\u22D1" },
  "&supseteq;": { "codepoints": [8839], "characters": "\u2287" },
  "&supseteqq;": { "codepoints": [10950], "characters": "\u2AC6" },
  "&supsetneq;": { "codepoints": [8843], "characters": "\u228B" },
  "&supsetneqq;": { "codepoints": [10956], "characters": "\u2ACC" },
  "&supsim;": { "codepoints": [10952], "characters": "\u2AC8" },
  "&supsub;": { "codepoints": [10964], "characters": "\u2AD4" },
  "&supsup;": { "codepoints": [10966], "characters": "\u2AD6" },
  "&swarhk;": { "codepoints": [10534], "characters": "\u2926" },
  "&swarr;": { "codepoints": [8601], "characters": "\u2199" },
  "&swArr;": { "codepoints": [8665], "characters": "\u21D9" },
  "&swarrow;": { "codepoints": [8601], "characters": "\u2199" },
  "&swnwar;": { "codepoints": [10538], "characters": "\u292A" },
  "&szlig;": { "codepoints": [223], "characters": "\u00DF" },
  "&szlig": { "codepoints": [223], "characters": "\u00DF" },
  "&Tab;": { "codepoints": [9], "characters": "\u0009" },
  "&target;": { "codepoints": [8982], "characters": "\u2316" },
  "&Tau;": { "codepoints": [932], "characters": "\u03A4" },
  "&tau;": { "codepoints": [964], "characters": "\u03C4" },
  "&tbrk;": { "codepoints": [9140], "characters": "\u23B4" },
  "&Tcaron;": { "codepoints": [356], "characters": "\u0164" },
  "&tcaron;": { "codepoints": [357], "characters": "\u0165" },
  "&Tcedil;": { "codepoints": [354], "characters": "\u0162" },
  "&tcedil;": { "codepoints": [355], "characters": "\u0163" },
  "&Tcy;": { "codepoints": [1058], "characters": "\u0422" },
  "&tcy;": { "codepoints": [1090], "characters": "\u0442" },
  "&tdot;": { "codepoints": [8411], "characters": "\u20DB" },
  "&telrec;": { "codepoints": [8981], "characters": "\u2315" },
  "&Tfr;": { "codepoints": [120087], "characters": "\uD835\uDD17" },
  "&tfr;": { "codepoints": [120113], "characters": "\uD835\uDD31" },
  "&there4;": { "codepoints": [8756], "characters": "\u2234" },
  "&therefore;": { "codepoints": [8756], "characters": "\u2234" },
  "&Therefore;": { "codepoints": [8756], "characters": "\u2234" },
  "&Theta;": { "codepoints": [920], "characters": "\u0398" },
  "&theta;": { "codepoints": [952], "characters": "\u03B8" },
  "&thetasym;": { "codepoints": [977], "characters": "\u03D1" },
  "&thetav;": { "codepoints": [977], "characters": "\u03D1" },
  "&thickapprox;": { "codepoints": [8776], "characters": "\u2248" },
  "&thicksim;": { "codepoints": [8764], "characters": "\u223C" },
  "&ThickSpace;": { "codepoints": [8287, 8202], "characters": "\u205F\u200A" },
  "&ThinSpace;": { "codepoints": [8201], "characters": "\u2009" },
  "&thinsp;": { "codepoints": [8201], "characters": "\u2009" },
  "&thkap;": { "codepoints": [8776], "characters": "\u2248" },
  "&thksim;": { "codepoints": [8764], "characters": "\u223C" },
  "&THORN;": { "codepoints": [222], "characters": "\u00DE" },
  "&THORN": { "codepoints": [222], "characters": "\u00DE" },
  "&thorn;": { "codepoints": [254], "characters": "\u00FE" },
  "&thorn": { "codepoints": [254], "characters": "\u00FE" },
  "&tilde;": { "codepoints": [732], "characters": "\u02DC" },
  "&Tilde;": { "codepoints": [8764], "characters": "\u223C" },
  "&TildeEqual;": { "codepoints": [8771], "characters": "\u2243" },
  "&TildeFullEqual;": { "codepoints": [8773], "characters": "\u2245" },
  "&TildeTilde;": { "codepoints": [8776], "characters": "\u2248" },
  "&timesbar;": { "codepoints": [10801], "characters": "\u2A31" },
  "&timesb;": { "codepoints": [8864], "characters": "\u22A0" },
  "&times;": { "codepoints": [215], "characters": "\u00D7" },
  "&times": { "codepoints": [215], "characters": "\u00D7" },
  "&timesd;": { "codepoints": [10800], "characters": "\u2A30" },
  "&tint;": { "codepoints": [8749], "characters": "\u222D" },
  "&toea;": { "codepoints": [10536], "characters": "\u2928" },
  "&topbot;": { "codepoints": [9014], "characters": "\u2336" },
  "&topcir;": { "codepoints": [10993], "characters": "\u2AF1" },
  "&top;": { "codepoints": [8868], "characters": "\u22A4" },
  "&Topf;": { "codepoints": [120139], "characters": "\uD835\uDD4B" },
  "&topf;": { "codepoints": [120165], "characters": "\uD835\uDD65" },
  "&topfork;": { "codepoints": [10970], "characters": "\u2ADA" },
  "&tosa;": { "codepoints": [10537], "characters": "\u2929" },
  "&tprime;": { "codepoints": [8244], "characters": "\u2034" },
  "&trade;": { "codepoints": [8482], "characters": "\u2122" },
  "&TRADE;": { "codepoints": [8482], "characters": "\u2122" },
  "&triangle;": { "codepoints": [9653], "characters": "\u25B5" },
  "&triangledown;": { "codepoints": [9663], "characters": "\u25BF" },
  "&triangleleft;": { "codepoints": [9667], "characters": "\u25C3" },
  "&trianglelefteq;": { "codepoints": [8884], "characters": "\u22B4" },
  "&triangleq;": { "codepoints": [8796], "characters": "\u225C" },
  "&triangleright;": { "codepoints": [9657], "characters": "\u25B9" },
  "&trianglerighteq;": { "codepoints": [8885], "characters": "\u22B5" },
  "&tridot;": { "codepoints": [9708], "characters": "\u25EC" },
  "&trie;": { "codepoints": [8796], "characters": "\u225C" },
  "&triminus;": { "codepoints": [10810], "characters": "\u2A3A" },
  "&TripleDot;": { "codepoints": [8411], "characters": "\u20DB" },
  "&triplus;": { "codepoints": [10809], "characters": "\u2A39" },
  "&trisb;": { "codepoints": [10701], "characters": "\u29CD" },
  "&tritime;": { "codepoints": [10811], "characters": "\u2A3B" },
  "&trpezium;": { "codepoints": [9186], "characters": "\u23E2" },
  "&Tscr;": { "codepoints": [119983], "characters": "\uD835\uDCAF" },
  "&tscr;": { "codepoints": [120009], "characters": "\uD835\uDCC9" },
  "&TScy;": { "codepoints": [1062], "characters": "\u0426" },
  "&tscy;": { "codepoints": [1094], "characters": "\u0446" },
  "&TSHcy;": { "codepoints": [1035], "characters": "\u040B" },
  "&tshcy;": { "codepoints": [1115], "characters": "\u045B" },
  "&Tstrok;": { "codepoints": [358], "characters": "\u0166" },
  "&tstrok;": { "codepoints": [359], "characters": "\u0167" },
  "&twixt;": { "codepoints": [8812], "characters": "\u226C" },
  "&twoheadleftarrow;": { "codepoints": [8606], "characters": "\u219E" },
  "&twoheadrightarrow;": { "codepoints": [8608], "characters": "\u21A0" },
  "&Uacute;": { "codepoints": [218], "characters": "\u00DA" },
  "&Uacute": { "codepoints": [218], "characters": "\u00DA" },
  "&uacute;": { "codepoints": [250], "characters": "\u00FA" },
  "&uacute": { "codepoints": [250], "characters": "\u00FA" },
  "&uarr;": { "codepoints": [8593], "characters": "\u2191" },
  "&Uarr;": { "codepoints": [8607], "characters": "\u219F" },
  "&uArr;": { "codepoints": [8657], "characters": "\u21D1" },
  "&Uarrocir;": { "codepoints": [10569], "characters": "\u2949" },
  "&Ubrcy;": { "codepoints": [1038], "characters": "\u040E" },
  "&ubrcy;": { "codepoints": [1118], "characters": "\u045E" },
  "&Ubreve;": { "codepoints": [364], "characters": "\u016C" },
  "&ubreve;": { "codepoints": [365], "characters": "\u016D" },
  "&Ucirc;": { "codepoints": [219], "characters": "\u00DB" },
  "&Ucirc": { "codepoints": [219], "characters": "\u00DB" },
  "&ucirc;": { "codepoints": [251], "characters": "\u00FB" },
  "&ucirc": { "codepoints": [251], "characters": "\u00FB" },
  "&Ucy;": { "codepoints": [1059], "characters": "\u0423" },
  "&ucy;": { "codepoints": [1091], "characters": "\u0443" },
  "&udarr;": { "codepoints": [8645], "characters": "\u21C5" },
  "&Udblac;": { "codepoints": [368], "characters": "\u0170" },
  "&udblac;": { "codepoints": [369], "characters": "\u0171" },
  "&udhar;": { "codepoints": [10606], "characters": "\u296E" },
  "&ufisht;": { "codepoints": [10622], "characters": "\u297E" },
  "&Ufr;": { "codepoints": [120088], "characters": "\uD835\uDD18" },
  "&ufr;": { "codepoints": [120114], "characters": "\uD835\uDD32" },
  "&Ugrave;": { "codepoints": [217], "characters": "\u00D9" },
  "&Ugrave": { "codepoints": [217], "characters": "\u00D9" },
  "&ugrave;": { "codepoints": [249], "characters": "\u00F9" },
  "&ugrave": { "codepoints": [249], "characters": "\u00F9" },
  "&uHar;": { "codepoints": [10595], "characters": "\u2963" },
  "&uharl;": { "codepoints": [8639], "characters": "\u21BF" },
  "&uharr;": { "codepoints": [8638], "characters": "\u21BE" },
  "&uhblk;": { "codepoints": [9600], "characters": "\u2580" },
  "&ulcorn;": { "codepoints": [8988], "characters": "\u231C" },
  "&ulcorner;": { "codepoints": [8988], "characters": "\u231C" },
  "&ulcrop;": { "codepoints": [8975], "characters": "\u230F" },
  "&ultri;": { "codepoints": [9720], "characters": "\u25F8" },
  "&Umacr;": { "codepoints": [362], "characters": "\u016A" },
  "&umacr;": { "codepoints": [363], "characters": "\u016B" },
  "&uml;": { "codepoints": [168], "characters": "\u00A8" },
  "&uml": { "codepoints": [168], "characters": "\u00A8" },
  "&UnderBar;": { "codepoints": [95], "characters": "\u005F" },
  "&UnderBrace;": { "codepoints": [9183], "characters": "\u23DF" },
  "&UnderBracket;": { "codepoints": [9141], "characters": "\u23B5" },
  "&UnderParenthesis;": { "codepoints": [9181], "characters": "\u23DD" },
  "&Union;": { "codepoints": [8899], "characters": "\u22C3" },
  "&UnionPlus;": { "codepoints": [8846], "characters": "\u228E" },
  "&Uogon;": { "codepoints": [370], "characters": "\u0172" },
  "&uogon;": { "codepoints": [371], "characters": "\u0173" },
  "&Uopf;": { "codepoints": [120140], "characters": "\uD835\uDD4C" },
  "&uopf;": { "codepoints": [120166], "characters": "\uD835\uDD66" },
  "&UpArrowBar;": { "codepoints": [10514], "characters": "\u2912" },
  "&uparrow;": { "codepoints": [8593], "characters": "\u2191" },
  "&UpArrow;": { "codepoints": [8593], "characters": "\u2191" },
  "&Uparrow;": { "codepoints": [8657], "characters": "\u21D1" },
  "&UpArrowDownArrow;": { "codepoints": [8645], "characters": "\u21C5" },
  "&updownarrow;": { "codepoints": [8597], "characters": "\u2195" },
  "&UpDownArrow;": { "codepoints": [8597], "characters": "\u2195" },
  "&Updownarrow;": { "codepoints": [8661], "characters": "\u21D5" },
  "&UpEquilibrium;": { "codepoints": [10606], "characters": "\u296E" },
  "&upharpoonleft;": { "codepoints": [8639], "characters": "\u21BF" },
  "&upharpoonright;": { "codepoints": [8638], "characters": "\u21BE" },
  "&uplus;": { "codepoints": [8846], "characters": "\u228E" },
  "&UpperLeftArrow;": { "codepoints": [8598], "characters": "\u2196" },
  "&UpperRightArrow;": { "codepoints": [8599], "characters": "\u2197" },
  "&upsi;": { "codepoints": [965], "characters": "\u03C5" },
  "&Upsi;": { "codepoints": [978], "characters": "\u03D2" },
  "&upsih;": { "codepoints": [978], "characters": "\u03D2" },
  "&Upsilon;": { "codepoints": [933], "characters": "\u03A5" },
  "&upsilon;": { "codepoints": [965], "characters": "\u03C5" },
  "&UpTeeArrow;": { "codepoints": [8613], "characters": "\u21A5" },
  "&UpTee;": { "codepoints": [8869], "characters": "\u22A5" },
  "&upuparrows;": { "codepoints": [8648], "characters": "\u21C8" },
  "&urcorn;": { "codepoints": [8989], "characters": "\u231D" },
  "&urcorner;": { "codepoints": [8989], "characters": "\u231D" },
  "&urcrop;": { "codepoints": [8974], "characters": "\u230E" },
  "&Uring;": { "codepoints": [366], "characters": "\u016E" },
  "&uring;": { "codepoints": [367], "characters": "\u016F" },
  "&urtri;": { "codepoints": [9721], "characters": "\u25F9" },
  "&Uscr;": { "codepoints": [119984], "characters": "\uD835\uDCB0" },
  "&uscr;": { "codepoints": [120010], "characters": "\uD835\uDCCA" },
  "&utdot;": { "codepoints": [8944], "characters": "\u22F0" },
  "&Utilde;": { "codepoints": [360], "characters": "\u0168" },
  "&utilde;": { "codepoints": [361], "characters": "\u0169" },
  "&utri;": { "codepoints": [9653], "characters": "\u25B5" },
  "&utrif;": { "codepoints": [9652], "characters": "\u25B4" },
  "&uuarr;": { "codepoints": [8648], "characters": "\u21C8" },
  "&Uuml;": { "codepoints": [220], "characters": "\u00DC" },
  "&Uuml": { "codepoints": [220], "characters": "\u00DC" },
  "&uuml;": { "codepoints": [252], "characters": "\u00FC" },
  "&uuml": { "codepoints": [252], "characters": "\u00FC" },
  "&uwangle;": { "codepoints": [10663], "characters": "\u29A7" },
  "&vangrt;": { "codepoints": [10652], "characters": "\u299C" },
  "&varepsilon;": { "codepoints": [1013], "characters": "\u03F5" },
  "&varkappa;": { "codepoints": [1008], "characters": "\u03F0" },
  "&varnothing;": { "codepoints": [8709], "characters": "\u2205" },
  "&varphi;": { "codepoints": [981], "characters": "\u03D5" },
  "&varpi;": { "codepoints": [982], "characters": "\u03D6" },
  "&varpropto;": { "codepoints": [8733], "characters": "\u221D" },
  "&varr;": { "codepoints": [8597], "characters": "\u2195" },
  "&vArr;": { "codepoints": [8661], "characters": "\u21D5" },
  "&varrho;": { "codepoints": [1009], "characters": "\u03F1" },
  "&varsigma;": { "codepoints": [962], "characters": "\u03C2" },
  "&varsubsetneq;": { "codepoints": [8842, 65024], "characters": "\u228A\uFE00" },
  "&varsubsetneqq;": { "codepoints": [10955, 65024], "characters": "\u2ACB\uFE00" },
  "&varsupsetneq;": { "codepoints": [8843, 65024], "characters": "\u228B\uFE00" },
  "&varsupsetneqq;": { "codepoints": [10956, 65024], "characters": "\u2ACC\uFE00" },
  "&vartheta;": { "codepoints": [977], "characters": "\u03D1" },
  "&vartriangleleft;": { "codepoints": [8882], "characters": "\u22B2" },
  "&vartriangleright;": { "codepoints": [8883], "characters": "\u22B3" },
  "&vBar;": { "codepoints": [10984], "characters": "\u2AE8" },
  "&Vbar;": { "codepoints": [10987], "characters": "\u2AEB" },
  "&vBarv;": { "codepoints": [10985], "characters": "\u2AE9" },
  "&Vcy;": { "codepoints": [1042], "characters": "\u0412" },
  "&vcy;": { "codepoints": [1074], "characters": "\u0432" },
  "&vdash;": { "codepoints": [8866], "characters": "\u22A2" },
  "&vDash;": { "codepoints": [8872], "characters": "\u22A8" },
  "&Vdash;": { "codepoints": [8873], "characters": "\u22A9" },
  "&VDash;": { "codepoints": [8875], "characters": "\u22AB" },
  "&Vdashl;": { "codepoints": [10982], "characters": "\u2AE6" },
  "&veebar;": { "codepoints": [8891], "characters": "\u22BB" },
  "&vee;": { "codepoints": [8744], "characters": "\u2228" },
  "&Vee;": { "codepoints": [8897], "characters": "\u22C1" },
  "&veeeq;": { "codepoints": [8794], "characters": "\u225A" },
  "&vellip;": { "codepoints": [8942], "characters": "\u22EE" },
  "&verbar;": { "codepoints": [124], "characters": "\u007C" },
  "&Verbar;": { "codepoints": [8214], "characters": "\u2016" },
  "&vert;": { "codepoints": [124], "characters": "\u007C" },
  "&Vert;": { "codepoints": [8214], "characters": "\u2016" },
  "&VerticalBar;": { "codepoints": [8739], "characters": "\u2223" },
  "&VerticalLine;": { "codepoints": [124], "characters": "\u007C" },
  "&VerticalSeparator;": { "codepoints": [10072], "characters": "\u2758" },
  "&VerticalTilde;": { "codepoints": [8768], "characters": "\u2240" },
  "&VeryThinSpace;": { "codepoints": [8202], "characters": "\u200A" },
  "&Vfr;": { "codepoints": [120089], "characters": "\uD835\uDD19" },
  "&vfr;": { "codepoints": [120115], "characters": "\uD835\uDD33" },
  "&vltri;": { "codepoints": [8882], "characters": "\u22B2" },
  "&vnsub;": { "codepoints": [8834, 8402], "characters": "\u2282\u20D2" },
  "&vnsup;": { "codepoints": [8835, 8402], "characters": "\u2283\u20D2" },
  "&Vopf;": { "codepoints": [120141], "characters": "\uD835\uDD4D" },
  "&vopf;": { "codepoints": [120167], "characters": "\uD835\uDD67" },
  "&vprop;": { "codepoints": [8733], "characters": "\u221D" },
  "&vrtri;": { "codepoints": [8883], "characters": "\u22B3" },
  "&Vscr;": { "codepoints": [119985], "characters": "\uD835\uDCB1" },
  "&vscr;": { "codepoints": [120011], "characters": "\uD835\uDCCB" },
  "&vsubnE;": { "codepoints": [10955, 65024], "characters": "\u2ACB\uFE00" },
  "&vsubne;": { "codepoints": [8842, 65024], "characters": "\u228A\uFE00" },
  "&vsupnE;": { "codepoints": [10956, 65024], "characters": "\u2ACC\uFE00" },
  "&vsupne;": { "codepoints": [8843, 65024], "characters": "\u228B\uFE00" },
  "&Vvdash;": { "codepoints": [8874], "characters": "\u22AA" },
  "&vzigzag;": { "codepoints": [10650], "characters": "\u299A" },
  "&Wcirc;": { "codepoints": [372], "characters": "\u0174" },
  "&wcirc;": { "codepoints": [373], "characters": "\u0175" },
  "&wedbar;": { "codepoints": [10847], "characters": "\u2A5F" },
  "&wedge;": { "codepoints": [8743], "characters": "\u2227" },
  "&Wedge;": { "codepoints": [8896], "characters": "\u22C0" },
  "&wedgeq;": { "codepoints": [8793], "characters": "\u2259" },
  "&weierp;": { "codepoints": [8472], "characters": "\u2118" },
  "&Wfr;": { "codepoints": [120090], "characters": "\uD835\uDD1A" },
  "&wfr;": { "codepoints": [120116], "characters": "\uD835\uDD34" },
  "&Wopf;": { "codepoints": [120142], "characters": "\uD835\uDD4E" },
  "&wopf;": { "codepoints": [120168], "characters": "\uD835\uDD68" },
  "&wp;": { "codepoints": [8472], "characters": "\u2118" },
  "&wr;": { "codepoints": [8768], "characters": "\u2240" },
  "&wreath;": { "codepoints": [8768], "characters": "\u2240" },
  "&Wscr;": { "codepoints": [119986], "characters": "\uD835\uDCB2" },
  "&wscr;": { "codepoints": [120012], "characters": "\uD835\uDCCC" },
  "&xcap;": { "codepoints": [8898], "characters": "\u22C2" },
  "&xcirc;": { "codepoints": [9711], "characters": "\u25EF" },
  "&xcup;": { "codepoints": [8899], "characters": "\u22C3" },
  "&xdtri;": { "codepoints": [9661], "characters": "\u25BD" },
  "&Xfr;": { "codepoints": [120091], "characters": "\uD835\uDD1B" },
  "&xfr;": { "codepoints": [120117], "characters": "\uD835\uDD35" },
  "&xharr;": { "codepoints": [10231], "characters": "\u27F7" },
  "&xhArr;": { "codepoints": [10234], "characters": "\u27FA" },
  "&Xi;": { "codepoints": [926], "characters": "\u039E" },
  "&xi;": { "codepoints": [958], "characters": "\u03BE" },
  "&xlarr;": { "codepoints": [10229], "characters": "\u27F5" },
  "&xlArr;": { "codepoints": [10232], "characters": "\u27F8" },
  "&xmap;": { "codepoints": [10236], "characters": "\u27FC" },
  "&xnis;": { "codepoints": [8955], "characters": "\u22FB" },
  "&xodot;": { "codepoints": [10752], "characters": "\u2A00" },
  "&Xopf;": { "codepoints": [120143], "characters": "\uD835\uDD4F" },
  "&xopf;": { "codepoints": [120169], "characters": "\uD835\uDD69" },
  "&xoplus;": { "codepoints": [10753], "characters": "\u2A01" },
  "&xotime;": { "codepoints": [10754], "characters": "\u2A02" },
  "&xrarr;": { "codepoints": [10230], "characters": "\u27F6" },
  "&xrArr;": { "codepoints": [10233], "characters": "\u27F9" },
  "&Xscr;": { "codepoints": [119987], "characters": "\uD835\uDCB3" },
  "&xscr;": { "codepoints": [120013], "characters": "\uD835\uDCCD" },
  "&xsqcup;": { "codepoints": [10758], "characters": "\u2A06" },
  "&xuplus;": { "codepoints": [10756], "characters": "\u2A04" },
  "&xutri;": { "codepoints": [9651], "characters": "\u25B3" },
  "&xvee;": { "codepoints": [8897], "characters": "\u22C1" },
  "&xwedge;": { "codepoints": [8896], "characters": "\u22C0" },
  "&Yacute;": { "codepoints": [221], "characters": "\u00DD" },
  "&Yacute": { "codepoints": [221], "characters": "\u00DD" },
  "&yacute;": { "codepoints": [253], "characters": "\u00FD" },
  "&yacute": { "codepoints": [253], "characters": "\u00FD" },
  "&YAcy;": { "codepoints": [1071], "characters": "\u042F" },
  "&yacy;": { "codepoints": [1103], "characters": "\u044F" },
  "&Ycirc;": { "codepoints": [374], "characters": "\u0176" },
  "&ycirc;": { "codepoints": [375], "characters": "\u0177" },
  "&Ycy;": { "codepoints": [1067], "characters": "\u042B" },
  "&ycy;": { "codepoints": [1099], "characters": "\u044B" },
  "&yen;": { "codepoints": [165], "characters": "\u00A5" },
  "&yen": { "codepoints": [165], "characters": "\u00A5" },
  "&Yfr;": { "codepoints": [120092], "characters": "\uD835\uDD1C" },
  "&yfr;": { "codepoints": [120118], "characters": "\uD835\uDD36" },
  "&YIcy;": { "codepoints": [1031], "characters": "\u0407" },
  "&yicy;": { "codepoints": [1111], "characters": "\u0457" },
  "&Yopf;": { "codepoints": [120144], "characters": "\uD835\uDD50" },
  "&yopf;": { "codepoints": [120170], "characters": "\uD835\uDD6A" },
  "&Yscr;": { "codepoints": [119988], "characters": "\uD835\uDCB4" },
  "&yscr;": { "codepoints": [120014], "characters": "\uD835\uDCCE" },
  "&YUcy;": { "codepoints": [1070], "characters": "\u042E" },
  "&yucy;": { "codepoints": [1102], "characters": "\u044E" },
  "&yuml;": { "codepoints": [255], "characters": "\u00FF" },
  "&yuml": { "codepoints": [255], "characters": "\u00FF" },
  "&Yuml;": { "codepoints": [376], "characters": "\u0178" },
  "&Zacute;": { "codepoints": [377], "characters": "\u0179" },
  "&zacute;": { "codepoints": [378], "characters": "\u017A" },
  "&Zcaron;": { "codepoints": [381], "characters": "\u017D" },
  "&zcaron;": { "codepoints": [382], "characters": "\u017E" },
  "&Zcy;": { "codepoints": [1047], "characters": "\u0417" },
  "&zcy;": { "codepoints": [1079], "characters": "\u0437" },
  "&Zdot;": { "codepoints": [379], "characters": "\u017B" },
  "&zdot;": { "codepoints": [380], "characters": "\u017C" },
  "&zeetrf;": { "codepoints": [8488], "characters": "\u2128" },
  "&ZeroWidthSpace;": { "codepoints": [8203], "characters": "\u200B" },
  "&Zeta;": { "codepoints": [918], "characters": "\u0396" },
  "&zeta;": { "codepoints": [950], "characters": "\u03B6" },
  "&zfr;": { "codepoints": [120119], "characters": "\uD835\uDD37" },
  "&Zfr;": { "codepoints": [8488], "characters": "\u2128" },
  "&ZHcy;": { "codepoints": [1046], "characters": "\u0416" },
  "&zhcy;": { "codepoints": [1078], "characters": "\u0436" },
  "&zigrarr;": { "codepoints": [8669], "characters": "\u21DD" },
  "&zopf;": { "codepoints": [120171], "characters": "\uD835\uDD6B" },
  "&Zopf;": { "codepoints": [8484], "characters": "\u2124" },
  "&Zscr;": { "codepoints": [119989], "characters": "\uD835\uDCB5" },
  "&zscr;": { "codepoints": [120015], "characters": "\uD835\uDCCF" },
  "&zwj;": { "codepoints": [8205], "characters": "\u200D" },
  "&zwnj;": { "codepoints": [8204], "characters": "\u200C" }
};

var ALPHANUMERIC = /^[a-zA-Z0-9]/;
var getPossibleNamedEntityStart = makeRegexMatcher(/^&[a-zA-Z0-9]/);
var getApparentNamedEntity = makeRegexMatcher(/^&[a-zA-Z0-9]+;/);

var getNamedEntityByFirstChar = {};
(function () {
  var namedEntitiesByFirstChar = {};
  for (var ent in ENTITIES) {
    var chr = ent.charAt(1);
    namedEntitiesByFirstChar[chr] = (namedEntitiesByFirstChar[chr] || []);
    namedEntitiesByFirstChar[chr].push(ent.slice(2));
  }
  for (var chr in namedEntitiesByFirstChar) {
    getNamedEntityByFirstChar[chr] = makeRegexMatcher(
      new RegExp('^&' + chr + '(?:' +
                 namedEntitiesByFirstChar[chr].join('|') + ')'));
  }
})();

// Run a provided "matcher" function but reset the current position afterwards.
// Fatal failure of the matcher is not suppressed.
var peekMatcher = function (scanner, matcher) {
  var start = scanner.pos;
  var result = matcher(scanner);
  scanner.pos = start;
  return result;
};

// Returns a string like "&amp;" or a falsy value if no match.  Fails fatally
// if something looks like a named entity but isn't.
var getNamedCharRef = function (scanner, inAttribute) {
  // look for `&` followed by alphanumeric
  if (! peekMatcher(scanner, getPossibleNamedEntityStart))
    return null;

  var matcher = getNamedEntityByFirstChar[scanner.rest().charAt(1)];
  var entity = null;
  if (matcher)
    entity = peekMatcher(scanner, matcher);

  if (entity) {
    if (entity.slice(-1) !== ';') {
      // Certain character references with no semi are an error, like `&lt`.
      // In attribute values, however, this is not fatal if the next character
      // is alphanumeric.
      //
      // This rule affects href attributes, for example, deeming "/?foo=bar&ltc=abc"
      // to be ok but "/?foo=bar&lt=abc" to not be.
      if (inAttribute && ALPHANUMERIC.test(scanner.rest().charAt(entity.length)))
        return null;
      scanner.fatal("Character reference requires semicolon: " + entity);
    } else {
      scanner.pos += entity.length;
      return entity;
    }
  } else {
    // we couldn't match any real entity, so see if this is a bad entity
    // or something we can overlook.
    var badEntity = peekMatcher(scanner, getApparentNamedEntity);
    if (badEntity)
      scanner.fatal("Invalid character reference: " + badEntity);
    // `&aaaa` is ok with no semicolon
    return null;
  }
};

// Returns the sequence of one or two codepoints making up an entity as an array.
// Codepoints in the array are integers and may be out of the single-char JavaScript
// range.
var getCodePoints = function (namedEntity) {
  return ENTITIES[namedEntity].codepoints;
};

var ALLOWED_AFTER_AMP = /^[\u0009\u000a\u000c <&]/;

var getCharRefNumber = makeRegexMatcher(/^(?:[xX][0-9a-fA-F]+|[0-9]+);/);

var BIG_BAD_CODEPOINTS = (function (obj) {
  var list = [0x1FFFE, 0x1FFFF, 0x2FFFE, 0x2FFFF, 0x3FFFE, 0x3FFFF,
              0x4FFFE, 0x4FFFF, 0x5FFFE, 0x5FFFF, 0x6FFFE, 0x6FFFF,
              0x7FFFE, 0x7FFFF, 0x8FFFE, 0x8FFFF, 0x9FFFE, 0x9FFFF,
              0xAFFFE, 0xAFFFF, 0xBFFFE, 0xBFFFF, 0xCFFFE, 0xCFFFF,
              0xDFFFE, 0xDFFFF, 0xEFFFE, 0xEFFFF, 0xFFFFE, 0xFFFFF,
              0x10FFFE, 0x10FFFF];
  for (var i = 0; i < list.length; i++)
    obj[list[i]] = true;

  return obj;
})({});

var isLegalCodepoint = function (cp) {
  if ((cp === 0) ||
      (cp >= 0x80 && cp <= 0x9f) ||
      (cp >= 0xd800 && cp <= 0xdfff) ||
      (cp >= 0x10ffff) ||
      (cp >= 0x1 && cp <= 0x8) ||
      (cp === 0xb) ||
      (cp >= 0xd && cp <= 0x1f) ||
      (cp >= 0x7f && cp <= 0x9f) ||
      (cp >= 0xfdd0 && cp <= 0xfdef) ||
      (cp === 0xfffe) ||
      (cp === 0xffff) ||
      (cp >= 0x10000 && BIG_BAD_CODEPOINTS[cp]))
    return false;

  return true;
};

// http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#consume-a-character-reference
//
// Matches a character reference if possible, including the initial `&`.
// Fails fatally in error cases (assuming an initial `&` is matched), like a disallowed codepoint
// number or a bad named character reference.
//
// `inAttribute` is truthy if we are in an attribute value.
//
// `allowedChar` is an optional character that,
// if found after the initial `&`, aborts parsing silently rather than failing fatally.  In real use it is
// either `"`, `'`, or `>` and is supplied when parsing attribute values.  NOTE: In the current spec, the
// value of `allowedChar` doesn't actually seem to end up mattering, but there is still some debate about
// the right approach to ampersands.
getCharacterReference = function (scanner, inAttribute, allowedChar) {
  if (scanner.peek() !== '&')
    // no ampersand
    return null;

  var afterAmp = scanner.rest().charAt(1);

  if (afterAmp === '#') {
    scanner.pos += 2;
    // refNumber includes possible initial `x` and final semicolon
    var refNumber = getCharRefNumber(scanner);
    // At this point we've consumed the input, so we're committed to returning
    // something or failing fatally.
    if (! refNumber)
      scanner.fatal("Invalid numerical character reference starting with &#");
    var codepoint;
    if (refNumber.charAt(0) === 'x' || refNumber.charAt(0) === 'X') {
      // hex
      var hex = refNumber.slice(1, -1);
      while (hex.charAt(0) === '0')
        hex = hex.slice(1);
      if (hex.length > 6)
        scanner.fatal("Numerical character reference too large: 0x" + hex);
      codepoint = parseInt(hex || "0", 16);
    } else {
      var dec = refNumber.slice(0, -1);
      while (dec.charAt(0) === '0')
        dec = dec.slice(1);
      if (dec.length > 7)
        scanner.fatal("Numerical character reference too large: " + dec);
      codepoint = parseInt(dec || "0", 10);
    }
    if (! isLegalCodepoint(codepoint))
      scanner.fatal("Illegal codepoint in numerical character reference: &#" + refNumber);
    return { t: 'CharRef',
             v: '&#' + refNumber,
             cp: [codepoint] };
  } else if ((! afterAmp) // EOF
             || (allowedChar && afterAmp === allowedChar)
             || ALLOWED_AFTER_AMP.test(afterAmp)) {
    return null;
  } else {
    var namedEntity = getNamedCharRef(scanner, inAttribute);
    if (namedEntity) {
      return { t: 'CharRef',
               v: namedEntity,
               cp: getCodePoints(namedEntity) };
    } else {
      return null;
    }
  }
};


//-------------html-tools/tokenize.js----------
// Token types:
//
// { t: 'Doctype',
//   v: String (entire Doctype declaration from the source),
//   name: String,
//   systemId: String (optional),
//   publicId: String (optional)
// }
//
// { t: 'Comment',
//   v: String (not including "<!--" and "-->")
// }
//
// { t: 'Chars',
//   v: String (pure text like you might pass to document.createTextNode,
//              no character references)
// }
//
// { t: 'Tag',
//   isEnd: Boolean (optional),
//   isSelfClosing: Boolean (optional),
//   n: String (tag name, ASCII-lowercased),
//   attrs: { String: [zero or more 'Chars' or 'CharRef' objects] }
//     (only for start tags; required)
// }
//
// { t: 'CharRef',
//   v: String (entire character reference from the source, e.g. "&amp;"),
//   cp: [Integer] (array of Unicode code point numbers it expands to)
// }
//
// We keep around both the original form of the character reference and its
// expansion so that subsequent processing steps have the option to
// re-emit it (if they are generating HTML) or interpret it.  Named and
// numerical code points may be more than 16 bits, in which case they
// need to passed through codePointToString to make a JavaScript string.
// Most named entities and all numeric character references are one codepoint
// (e.g. "&amp;" is [38]), but a few are two codepoints.
//
// { t: 'Special',
//   v: { ... anything ... }
// }

// The HTML tokenization spec says to preprocess the input stream to replace
// CR(LF)? with LF.  However, preprocessing `scanner` would complicate things
// by making indexes not match the input (e.g. for error messages), so we just
// keep in mind as we go along that an LF might be represented by CRLF or CR.
// In most cases, it doesn't actually matter what combination of whitespace
// characters are present (e.g. inside tags).
var HTML_SPACE = /^[\f\n\r\t ]/;

var convertCRLF = function (str) {
  return str.replace(/\r\n?/g, '\n');
};

getComment = function (scanner) {
  if (scanner.rest().slice(0, 4) !== '<!--')
    return null;
  scanner.pos += 4;

  // Valid comments are easy to parse; they end at the first `--`!
  // Our main job is throwing errors.

  var rest = scanner.rest();
  if (rest.charAt(0) === '>' || rest.slice(0, 2) === '->')
    scanner.fatal("HTML comment can't start with > or ->");

  var closePos = rest.indexOf('-->');
  if (closePos < 0)
    scanner.fatal("Unclosed HTML comment");

  var commentContents = rest.slice(0, closePos);
  if (commentContents.slice(-1) === '-')
    scanner.fatal("HTML comment must end at first `--`");
  if (commentContents.indexOf("--") >= 0)
    scanner.fatal("HTML comment cannot contain `--` anywhere");
  if (commentContents.indexOf('\u0000') >= 0)
    scanner.fatal("HTML comment cannot contain NULL");

  scanner.pos += closePos + 3;

  return { t: 'Comment',
           v: convertCRLF(commentContents) };
};

var skipSpaces = function (scanner) {
  while (HTML_SPACE.test(scanner.peek()))
    scanner.pos++;
};

var requireSpaces = function (scanner) {
  if (! HTML_SPACE.test(scanner.peek()))
    scanner.fatal("Expected space");
  skipSpaces(scanner);
};

var getDoctypeQuotedString = function (scanner) {
  var quote = scanner.peek();
  if (! (quote === '"' || quote === "'"))
    scanner.fatal("Expected single or double quote in DOCTYPE");
  scanner.pos++;

  if (scanner.peek() === quote)
    // prevent a falsy return value (empty string)
    scanner.fatal("Malformed DOCTYPE");

  var str = '';
  var ch;
  while ((ch = scanner.peek()), ch !== quote) {
    if ((! ch) || (ch === '\u0000') || (ch === '>'))
      scanner.fatal("Malformed DOCTYPE");
    str += ch;
    scanner.pos++;
  }

  scanner.pos++;

  return str;
};

// See http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#the-doctype.
//
// If `getDocType` sees "<!DOCTYPE" (case-insensitive), it will match or fail fatally.
getDoctype = function (scanner) {
  if (HTML.asciiLowerCase(scanner.rest().slice(0, 9)) !== '<!doctype')
    return null;
  var start = scanner.pos;
  scanner.pos += 9;

  requireSpaces(scanner);

  var ch = scanner.peek();
  if ((! ch) || (ch === '>') || (ch === '\u0000'))
    scanner.fatal('Malformed DOCTYPE');
  var name = ch;
  scanner.pos++;

  while ((ch = scanner.peek()), ! (HTML_SPACE.test(ch) || ch === '>')) {
    if ((! ch) || (ch === '\u0000'))
      scanner.fatal('Malformed DOCTYPE');
    name += ch;
    scanner.pos++;
  }
  name = HTML.asciiLowerCase(name);

  // Now we're looking at a space or a `>`.
  skipSpaces(scanner);

  var systemId = null;
  var publicId = null;

  if (scanner.peek() !== '>') {
    // Now we're essentially in the "After DOCTYPE name state" of the tokenizer,
    // but we're not looking at space or `>`.

    // this should be "public" or "system".
    var publicOrSystem = HTML.asciiLowerCase(scanner.rest().slice(0, 6));

    if (publicOrSystem === 'system') {
      scanner.pos += 6;
      requireSpaces(scanner);
      systemId = getDoctypeQuotedString(scanner);
      skipSpaces(scanner);
      if (scanner.peek() !== '>')
        scanner.fatal("Malformed DOCTYPE");
    } else if (publicOrSystem === 'public') {
      scanner.pos += 6;
      requireSpaces(scanner);
      publicId = getDoctypeQuotedString(scanner);
      if (scanner.peek() !== '>') {
        requireSpaces(scanner);
        if (scanner.peek() !== '>') {
          systemId = getDoctypeQuotedString(scanner);
          skipSpaces(scanner);
          if (scanner.peek() !== '>')
            scanner.fatal("Malformed DOCTYPE");
        }
      }
    } else {
      scanner.fatal("Expected PUBLIC or SYSTEM in DOCTYPE");
    }
  }

  // looking at `>`
  scanner.pos++;
  var result = { t: 'Doctype',
                 v: scanner.input.slice(start, scanner.pos),
                 name: name };

  if (systemId)
    result.systemId = systemId;
  if (publicId)
    result.publicId = publicId;

  return result;
};

// The special character `{` is only allowed as the first character
// of a Chars, so that we have a chance to detect template tags.
var getChars = makeRegexMatcher(/^[^&<\u0000][^&<\u0000{]*/);

// Returns the next HTML token, or `null` if we reach EOF.
//
// Note that if we have a `getSpecialTag` function that sometimes
// consumes characters and emits nothing (e.g. in the case of template
// comments), we may go from not-at-EOF to at-EOF and return `null`,
// while otherwise we always find some token to return.
getHTMLToken = function (scanner, dataMode) {
  var result = null;
  if (scanner.getSpecialTag) {
    var lastPos = -1;
    // Try to parse a "special tag" by calling out to the provided
    // `getSpecialTag` function.  If the function returns `null` but
    // consumes characters, it must have parsed a comment or something,
    // so we loop and try it again.  If it ever returns `null` without
    // consuming anything, that means it didn't see anything interesting
    // so we look for a normal token.  If it returns a truthy value,
    // the value must be an object.  We wrap it in a Special token.
    while ((! result) && scanner.pos > lastPos) {
      lastPos = scanner.pos;
      result = scanner.getSpecialTag(
        scanner,
        (dataMode === 'rcdata' ? TEMPLATE_TAG_POSITION.IN_RCDATA :
         (dataMode === 'rawtext' ? TEMPLATE_TAG_POSITION.IN_RAWTEXT :
          TEMPLATE_TAG_POSITION.ELEMENT)));
    }
    if (result)
      return { t: 'Special', v: result };
  }

  var chars = getChars(scanner);
  if (chars)
    return { t: 'Chars',
             v: convertCRLF(chars) };

  var ch = scanner.peek();
  if (! ch)
    return null; // EOF

  if (ch === '\u0000')
    scanner.fatal("Illegal NULL character");

  if (ch === '&') {
    if (dataMode !== 'rawtext') {
      var charRef = getCharacterReference(scanner);
      if (charRef)
        return charRef;
    }

    scanner.pos++;
    return { t: 'Chars',
             v: '&' };
  }

  // If we're here, we're looking at `<`.

  if (scanner.peek() === '<' && dataMode) {
    // don't interpret tags
    scanner.pos++;
    return { t: 'Chars',
             v: '<' };
  }

  // `getTag` will claim anything starting with `<` not followed by `!`.
  // `getComment` takes `<!--` and getDoctype takes `<!doctype`.
  result = (getTagToken(scanner) || getComment(scanner) || getDoctype(scanner));

  if (result)
    return result;

  scanner.fatal("Unexpected `<!` directive.");
};

var getTagName = makeRegexMatcher(/^[a-zA-Z][^\f\n\r\t />{]*/);
var getClangle = makeRegexMatcher(/^>/);
var getSlash = makeRegexMatcher(/^\//);
var getAttributeName = makeRegexMatcher(/^[^>/\u0000"'<=\f\n\r\t ][^\f\n\r\t /=>"'<\u0000]*/);

// Try to parse `>` or `/>`, mutating `tag` to be self-closing in the latter
// case (and failing fatally if `/` isn't followed by `>`).
// Return tag if successful.
var handleEndOfTag = function (scanner, tag) {
  if (getClangle(scanner))
    return tag;

  if (getSlash(scanner)) {
    if (! getClangle(scanner))
      scanner.fatal("Expected `>` after `/`");
    tag.isSelfClosing = true;
    return tag;
  }

  return null;
};

var getQuotedAttributeValue = function (scanner, quote) {
  if (scanner.peek() !== quote)
    return null;
  scanner.pos++;

  var tokens = [];
  var charsTokenToExtend = null;

  var charRef;
  while (true) {
    var ch = scanner.peek();
    var special;
    var curPos = scanner.pos;
    if (ch === quote) {
      scanner.pos++;
      return tokens;
    } else if (! ch) {
      scanner.fatal("Unclosed quoted attribute in tag");
    } else if (ch === '\u0000') {
      scanner.fatal("Unexpected NULL character in attribute value");
    } else if (ch === '&' && (charRef = getCharacterReference(scanner, true, quote))) {
      tokens.push(charRef);
      charsTokenToExtend = null;
    } else if (scanner.getSpecialTag &&
               ((special = scanner.getSpecialTag(scanner,
                                                 TEMPLATE_TAG_POSITION.IN_ATTRIBUTE)) ||
                scanner.pos > curPos /* `{{! comment}}` */)) {
      // note: this code is messy because it turns out to be annoying for getSpecialTag
      // to return `null` when it scans a comment.  Also, this code should be de-duped
      // with getUnquotedAttributeValue
      if (special) {
        tokens.push({t: 'Special', v: special});
        charsTokenToExtend = null;
      }
    } else {
      if (! charsTokenToExtend) {
        charsTokenToExtend = { t: 'Chars', v: '' };
        tokens.push(charsTokenToExtend);
      }
      charsTokenToExtend.v += (ch === '\r' ? '\n' : ch);
      scanner.pos++;
      if (ch === '\r' && scanner.peek() === '\n')
        scanner.pos++;
    }
  }
};

var getUnquotedAttributeValue = function (scanner) {
  var tokens = [];
  var charsTokenToExtend = null;

  var charRef;
  while (true) {
    var ch = scanner.peek();
    var special;
    var curPos = scanner.pos;
    if (HTML_SPACE.test(ch) || ch === '>') {
      return tokens;
    } else if (! ch) {
      scanner.fatal("Unclosed attribute in tag");
    } else if ('\u0000"\'<=`'.indexOf(ch) >= 0) {
      scanner.fatal("Unexpected character in attribute value");
    } else if (ch === '&' && (charRef = getCharacterReference(scanner, true, '>'))) {
      tokens.push(charRef);
      charsTokenToExtend = null;
    } else if (scanner.getSpecialTag &&
               ((special = scanner.getSpecialTag(scanner,
                                                 TEMPLATE_TAG_POSITION.IN_ATTRIBUTE)) ||
                scanner.pos > curPos /* `{{! comment}}` */)) {
      if (special) {
        tokens.push({t: 'Special', v: special});
        charsTokenToExtend = null;
      }
    } else {
      if (! charsTokenToExtend) {
        charsTokenToExtend = { t: 'Chars', v: '' };
        tokens.push(charsTokenToExtend);
      }
      charsTokenToExtend.v += ch;
      scanner.pos++;
    }
  }
};

getTagToken = function (scanner) {
  if (! (scanner.peek() === '<' && scanner.rest().charAt(1) !== '!'))
    return null;
  scanner.pos++;

  var tag = { t: 'Tag' };

  // now looking at the character after `<`, which is not a `!`
  if (scanner.peek() === '/') {
    tag.isEnd = true;
    scanner.pos++;
  }

  var tagName = getTagName(scanner);
  if (! tagName)
    scanner.fatal("Expected tag name after `<`");
  tag.n = HTML.asciiLowerCase(tagName);

  if (scanner.peek() === '/' && tag.isEnd)
    scanner.fatal("End tag can't have trailing slash");
  if (handleEndOfTag(scanner, tag))
    return tag;

  if (scanner.isEOF())
    scanner.fatal("Unclosed `<`");

  if (! HTML_SPACE.test(scanner.peek()))
    // e.g. `<a{{b}}>`
    scanner.fatal("Expected space after tag name");

  // we're now in "Before attribute name state" of the tokenizer
  skipSpaces(scanner);

  if (scanner.peek() === '/' && tag.isEnd)
    scanner.fatal("End tag can't have trailing slash");
  if (handleEndOfTag(scanner, tag))
    return tag;

  if (tag.isEnd)
    scanner.fatal("End tag can't have attributes");

  tag.attrs = {};

  while (true) {
    // Note: at the top of this loop, we've already skipped any spaces.

    // This will be set to true if after parsing the attribute, we should
    // require spaces (or else an end of tag, i.e. `>` or `/>`).
    var spacesRequiredAfter = false;

    // first, try for a special tag.
    var curPos = scanner.pos;
    var special = (scanner.getSpecialTag &&
                   scanner.getSpecialTag(scanner,
                                         TEMPLATE_TAG_POSITION.IN_START_TAG));
    if (special || (scanner.pos > curPos)) {
      if (special) {
        tag.attrs.$specials = (tag.attrs.$specials || []);
        tag.attrs.$specials.push({ t: 'Special', v: special });
      } // else, must have scanned a `{{! comment}}`

      spacesRequiredAfter = true;
    } else {

      var attributeName = getAttributeName(scanner);
      if (! attributeName)
        scanner.fatal("Expected attribute name in tag");
      // Throw error on `{` in attribute name.  This provides *some* error message
      // if someone writes `<a x{{y}}>` or `<a x{{y}}=z>`.  The HTML tokenization
      // spec doesn't say that `{` is invalid, but the DOM API (setAttribute) won't
      // allow it, so who cares.
      if (attributeName.indexOf('{') >= 0)
        scanner.fatal("Unexpected `{` in attribute name.");
      attributeName = HTML.asciiLowerCase(attributeName);

      if (tag.attrs.hasOwnProperty(attributeName))
        scanner.fatal("Duplicate attribute in tag: " + attributeName);

      tag.attrs[attributeName] = [];

      skipSpaces(scanner);

      if (handleEndOfTag(scanner, tag))
        return tag;

      var ch = scanner.peek();
      if (! ch)
        scanner.fatal("Unclosed <");
      if ('\u0000"\'<'.indexOf(ch) >= 0)
        scanner.fatal("Unexpected character after attribute name in tag");

      if (ch === '=') {
        scanner.pos++;

        skipSpaces(scanner);

        ch = scanner.peek();
        if (! ch)
          scanner.fatal("Unclosed <");
        if ('\u0000><=`'.indexOf(ch) >= 0)
          scanner.fatal("Unexpected character after = in tag");

        if ((ch === '"') || (ch === "'"))
          tag.attrs[attributeName] = getQuotedAttributeValue(scanner, ch);
        else
          tag.attrs[attributeName] = getUnquotedAttributeValue(scanner);

        spacesRequiredAfter = true;
      }
    }
    // now we are in the "post-attribute" position, whether it was a special attribute
    // (like `{{x}}`) or a normal one (like `x` or `x=y`).

    if (handleEndOfTag(scanner, tag))
      return tag;

    if (scanner.isEOF())
      scanner.fatal("Unclosed `<`");

    if (spacesRequiredAfter)
      requireSpaces(scanner);
    else
      skipSpaces(scanner);

    if (handleEndOfTag(scanner, tag))
      return tag;
  }
};

TEMPLATE_TAG_POSITION = {
  ELEMENT: 1,
  IN_START_TAG: 2,
  IN_ATTRIBUTE: 3,
  IN_RCDATA: 4,
  IN_RAWTEXT: 5
};

// tagName is lowercase
isLookingAtEndTag = function (scanner, tagName) {
  var rest = scanner.rest();
  var pos = 0; // into rest
  var firstPart = /^<\/([a-zA-Z]+)/.exec(rest);
  if (firstPart &&
      HTML.asciiLowerCase(firstPart[1]) === tagName) {
    // we've seen `</foo`, now see if the end tag continues
    pos += firstPart[0].length;
    while (pos < rest.length && HTML_SPACE.test(rest.charAt(pos)))
      pos++;
    if (pos < rest.length && rest.charAt(pos) === '>')
      return true;
  }
  return false;
};


//-------------html-tools/parse.js----------

HTML.Special = function (value) {
  if (! (this instanceof HTML.Special))
    // called without `new`
    return new HTML.Special(value);

  this.value = value;
};
HTML.Special.prototype.toJS = function (options) {
  // XXX this is weird because toJS is defined in spacebars-compiler.
  // Think about where HTML.Special and toJS should go.
  return HTML.Tag.prototype.toJS.call({tagName: 'Special',
                                       attrs: this.value,
                                       children: []},
                                      options);
};

parseFragment = function (input, options) {
  var scanner;
  if (typeof input === 'string')
    scanner = new Scanner(input);
  else
    // input can be a scanner.  We'd better not have a different
    // value for the "getSpecialTag" option as when the scanner
    // was created, because we don't do anything special to reset
    // the value (which is attached to the scanner).
    scanner = input;

  // ```
  // { getSpecialTag: function (scanner, templateTagPosition) {
  //     if (templateTagPosition === HTML.TEMPLATE_TAG_POSITION.ELEMENT) {
  //       ...
  // ```
  if (options && options.getSpecialTag)
    scanner.getSpecialTag = options.getSpecialTag;

  // function (scanner) -> boolean
  var shouldStop = options && options.shouldStop;

  var result;
  if (options && options.textMode) {
    if (options.textMode === HTML.TEXTMODE.STRING) {
      result = getRawText(scanner, null, shouldStop);
    } else if (options.textMode === HTML.TEXTMODE.RCDATA) {
      result = getRCData(scanner, null, shouldStop);
    } else {
      throw new Error("Unsupported textMode: " + options.textMode);
    }
  } else {
    result = getContent(scanner, shouldStop);
  }
  if (! scanner.isEOF()) {
    // XXX we make some assumptions about shouldStop here, like that it
    // won't tell us to stop at an HTML end tag.  Should refactor
    // `shouldStop` into something more suitable.
    if (scanner.rest().slice(0, 2) === '</') {
      var closeTag = scanner.rest().slice(2).match(/^[a-z]*/i)[0];
      var isVoidElement = HTML.isVoidElement(closeTag);
      scanner.fatal("Unexpected HTML close tag" +
                    (isVoidElement ?
                     '.  <' + closeTag + '> should have no close tag.' : ''));
    }
    if (! shouldStop)
      scanner.fatal("Expected EOF");
  }

  return result;
};

// Take a numeric Unicode code point, which may be larger than 16 bits,
// and encode it as a JavaScript UTF-16 string.
//
// Adapted from
// http://stackoverflow.com/questions/7126384/expressing-utf-16-unicode-characters-in-javascript/7126661.
codePointToString = function(cp) {
  if (cp >= 0 && cp <= 0xD7FF || cp >= 0xE000 && cp <= 0xFFFF) {
    return String.fromCharCode(cp);
  } else if (cp >= 0x10000 && cp <= 0x10FFFF) {

    // we substract 0x10000 from cp to get a 20-bit number
    // in the range 0..0xFFFF
    cp -= 0x10000;

    // we add 0xD800 to the number formed by the first 10 bits
    // to give the first byte
    var first = ((0xffc00 & cp) >> 10) + 0xD800;

    // we add 0xDC00 to the number formed by the low 10 bits
    // to give the second byte
    var second = (0x3ff & cp) + 0xDC00;

    return String.fromCharCode(first) + String.fromCharCode(second);
  } else {
    return '';
  }
};

getContent = function (scanner, shouldStopFunc) {
  var items = [];

  while (! scanner.isEOF()) {
    // Stop at any top-level end tag.  We could use the tokenizer
    // but these two characters are a giveaway.
    if (scanner.rest().slice(0, 2) === '</')
      break;

    if (shouldStopFunc && shouldStopFunc(scanner))
      break;

    var token = getHTMLToken(scanner);
    if (! token)
      // tokenizer reached EOF on its own, e.g. while scanning
      // template comments like `{{! foo}}`.
      continue;

    if (token.t === 'Doctype') {
      scanner.fatal("Unexpected Doctype");
    } else if (token.t === 'Chars') {
      pushOrAppendString(items, token.v);
    } else if (token.t === 'CharRef') {
      items.push(convertCharRef(token));
    } else if (token.t === 'Comment') {
      items.push(HTML.Comment(token.v));
    } else if (token.t === 'Special') {
      // token.v is an object `{ ... }`
      items.push(HTML.Special(token.v));
    } else if (token.t === 'Tag') {
      if (token.isEnd)
        // we've already screened for `</` so this shouldn't be
        // possible.
        scanner.fatal("Assertion failed: didn't expect end tag");

      var tagName = token.n;
      // is this an element with no close tag (a BR, HR, IMG, etc.) based
      // on its name?
      var isVoid = HTML.isVoidElement(tagName);
      if (token.isSelfClosing) {
        if (! (isVoid || HTML.isKnownSVGElement(tagName)))
          scanner.fatal('Only certain elements like BR, HR, IMG, etc. (and foreign elements like SVG) are allowed to self-close');
      }

      // may be null
      var attrs = parseAttrs(token.attrs);

      var tagFunc = HTML.getTag(tagName);
      if (isVoid || token.isSelfClosing) {
        items.push(attrs ? tagFunc(attrs) : tagFunc());
      } else {
        // parse HTMl tag contents.

        // HTML treats a final `/` in a tag as part of an attribute, as in `<a href=/foo/>`, but the template author who writes `<circle r={{r}}/>`, say, may not be thinking about that, so generate a good error message in the "looks like self-close" case.
        var looksLikeSelfClose = (scanner.input.substr(scanner.pos - 2, 2) === '/>');

        var content;
        if (token.n === 'textarea') {
          if (scanner.peek() === '\n')
            scanner.pos++;
          content = getRCData(scanner, token.n, shouldStopFunc);
        } else {
          content = getContent(scanner, shouldStopFunc);
        }

        if (scanner.rest().slice(0, 2) !== '</') {
          scanner.fatal('Expected "' + tagName + '" end tag' + (looksLikeSelfClose ? ' -- if the "<' + token.n + ' />" tag was supposed to self-close, try adding a space before the "/"' : ''));
        }

        var endTag = getTagToken(scanner);

        if (! (endTag.t === 'Tag' && endTag.isEnd))
          // we've already seen `</` so this shouldn't be possible
          // without erroring.
          scanner.fatal("Assertion failed: expected end tag");

        // XXX support implied end tags in cases allowed by the spec
        if (endTag.n !== tagName) {
          scanner.fatal('Expected "' + tagName + '" end tag, found "' + endTag.n + '"' + (looksLikeSelfClose ? ' -- if the "<' + token.n + ' />" tag was supposed to self-close, try adding a space before the "/"' : ''));
        }

        // make `content` into an array suitable for applying tag constructor
        // as in `FOO.apply(null, content)`.
        if (content == null)
          content = [];
        else if (! (content instanceof Array))
          content = [content];

        items.push(HTML.getTag(tagName).apply(
          null, (attrs ? [attrs] : []).concat(content)));
      }
    } else {
      scanner.fatal("Unknown token type: " + token.t);
    }
  }

  if (items.length === 0)
    return null;
  else if (items.length === 1)
    return items[0];
  else
    return items;
};

var pushOrAppendString = function (items, string) {
  if (items.length &&
      typeof items[items.length - 1] === 'string')
    items[items.length - 1] += string;
  else
    items.push(string);
};

// get RCDATA to go in the lowercase tagName (e.g. "textarea")
getRCData = function (scanner, tagName, shouldStopFunc) {
  var items = [];

  while (! scanner.isEOF()) {
    // break at appropriate end tag
    if (tagName && isLookingAtEndTag(scanner, tagName))
      break;

    if (shouldStopFunc && shouldStopFunc(scanner))
      break;

    var token = getHTMLToken(scanner, 'rcdata');
    if (! token)
      // tokenizer reached EOF on its own, e.g. while scanning
      // template comments like `{{! foo}}`.
      continue;

    if (token.t === 'Chars') {
      pushOrAppendString(items, token.v);
    } else if (token.t === 'CharRef') {
      items.push(convertCharRef(token));
    } else if (token.t === 'Special') {
      // token.v is an object `{ ... }`
      items.push(HTML.Special(token.v));
    } else {
      // (can't happen)
      scanner.fatal("Unknown or unexpected token type: " + token.t);
    }
  }

  if (items.length === 0)
    return null;
  else if (items.length === 1)
    return items[0];
  else
    return items;
};

var getRawText = function (scanner, tagName, shouldStopFunc) {
  var items = [];

  while (! scanner.isEOF()) {
    // break at appropriate end tag
    if (tagName && isLookingAtEndTag(scanner, tagName))
      break;

    if (shouldStopFunc && shouldStopFunc(scanner))
      break;

    var token = getHTMLToken(scanner, 'rawtext');
    if (! token)
      // tokenizer reached EOF on its own, e.g. while scanning
      // template comments like `{{! foo}}`.
      continue;

    if (token.t === 'Chars') {
      pushOrAppendString(items, token.v);
    } else if (token.t === 'Special') {
      // token.v is an object `{ ... }`
      items.push(HTML.Special(token.v));
    } else {
      // (can't happen)
      scanner.fatal("Unknown or unexpected token type: " + token.t);
    }
  }

  if (items.length === 0)
    return null;
  else if (items.length === 1)
    return items[0];
  else
    return items;
};

// Input: A token like `{ t: 'CharRef', v: '&amp;', cp: [38] }`.
//
// Output: A tag like `HTML.CharRef({ html: '&amp;', str: '&' })`.
var convertCharRef = function (token) {
  var codePoints = token.cp;
  var str = '';
  for (var i = 0; i < codePoints.length; i++)
    str += codePointToString(codePoints[i]);
  return HTML.CharRef({ html: token.v, str: str });
};

// Input is always a dictionary (even if zero attributes) and each
// value in the dictionary is an array of `Chars`, `CharRef`,
// and maybe `Special` tokens.
//
// Output is null if there are zero attributes, and otherwise a
// dictionary.  Each value in the dictionary is HTMLjs (e.g. a
// string or an array of `Chars`, `CharRef`, and `Special`
// nodes).
//
// An attribute value with no input tokens is represented as "",
// not an empty array, in order to prop open empty attributes
// with no template tags.
var parseAttrs = function (attrs) {
  var result = null;

  for (var k in attrs) {
    if (! result)
      result = {};

    var inValue = attrs[k];
    var outParts = [];
    for (var i = 0; i < inValue.length; i++) {
      var token = inValue[i];
      if (token.t === 'CharRef') {
        outParts.push(convertCharRef(token));
      } else if (token.t === 'Special') {
        outParts.push(HTML.Special(token.v));
      } else if (token.t === 'Chars') {
        pushOrAppendString(outParts, token.v);
      }
    }

    if (k === '$specials') {
      // the `$specials` pseudo-attribute should always get an
      // array, even if there is only one Special.
      result[k] = outParts;
    } else {
      var outValue = (inValue.length === 0 ? '' :
                      (outParts.length === 1 ? outParts[0] : outParts));
      var properKey = HTML.properCaseAttributeName(k);
      result[properKey] = outValue;
    }
  }

  return result;
};

//-------------html-tools/exports.js----------
HTML.parseFragment = parseFragment;


HTML.codePointToString = codePointToString;

HTML.TEMPLATE_TAG_POSITION = TEMPLATE_TAG_POSITION,

// Could move Scanner into its own package if use it for other stuff.
HTML.Scanner = Scanner;

HTML._$ = {
  // stuff exposed for testing
  Scanner: Scanner,
  getCharacterReference: getCharacterReference,
  getComment: getComment,
  getDoctype: getDoctype,
  getHTMLToken: getHTMLToken,
  getTag: getTagToken,
  getContent: getContent
};


//-------------templating/plugin/html_scanner.js----------
html_scanner = {
  // Scan a template file for <head>, <body>, and <template>
  // tags and extract their contents.
  //
  // This is a primitive, regex-based scanner.  It scans
  // top-level tags, which are allowed to have attributes,
  // and ignores top-level HTML comments.

  // Has fields 'message', 'line', 'file'
  ParseError: function () {
  },

  scan: function (contents, source_name) {
    var rest = contents;
    var index = 0;

    var advance = function(amount) {
      rest = rest.substring(amount);
      index += amount;
    };

    var throwParseError = function (msg, overrideIndex) {
      var ret = new html_scanner.ParseError;
      ret.message = msg || "bad formatting in HTML template";
      ret.file = source_name;
      var theIndex = (typeof overrideIndex === 'number' ? overrideIndex : index);
      ret.line = contents.substring(0, theIndex).split('\n').length;
      throw ret;
    };

    var results = html_scanner._initResults();
    var rOpenTag = /^((<(template|head|body)\b)|(<!--)|(<!DOCTYPE|{{!)|$)/i;

    while (rest) {
      // skip whitespace first (for better line numbers)
      advance(rest.match(/^\s*/)[0].length);

      var match = rOpenTag.exec(rest);
      if (! match)
        throwParseError(); // unknown text encountered

      var matchToken = match[1];
      var matchTokenTagName =  match[3];
      var matchTokenComment = match[4];
      var matchTokenUnsupported = match[5];

      var tagStartIndex = index;
      advance(match.index + match[0].length);

      if (! matchToken)
        break; // matched $ (end of file)
      if (matchTokenComment === '<!--') {
        // top-level HTML comment
        var commentEnd = /--\s*>/.exec(rest);
        if (! commentEnd)
          throwParseError("unclosed HTML comment");
        advance(commentEnd.index + commentEnd[0].length);
        continue;
      }
      if (matchTokenUnsupported) {
        switch (matchTokenUnsupported.toLowerCase()) {
        case '<!doctype':
          throwParseError(
            "Can't set DOCTYPE here.  (Meteor sets <!DOCTYPE html> for you)");
        case '{{!':
          throwParseError(
            "Can't use '{{! }}' outside a template.  Use '<!-- -->'.");
        }
        throwParseError();
      }

      // otherwise, a <tag>
      var tagName = matchTokenTagName.toLowerCase();
      var tagAttribs = {}; // bare name -> value dict
      var rTagPart = /^\s*((([a-zA-Z0-9:_-]+)\s*=\s*(["'])(.*?)\4)|(>))/;
      var attr;
      // read attributes
      while ((attr = rTagPart.exec(rest))) {
        var attrToken = attr[1];
        var attrKey = attr[3];
        var attrValue = attr[5];
        advance(attr.index + attr[0].length);
        if (attrToken === '>')
          break;
        // XXX we don't HTML unescape the attribute value
        // (e.g. to allow "abcd&quot;efg") or protect against
        // collisions with methods of tagAttribs (e.g. for
        // a property named toString)
        attrValue = attrValue.match(/^\s*([\s\S]*?)\s*$/)[1]; // trim
        tagAttribs[attrKey] = attrValue;
      }
      if (! attr) // didn't end on '>'
        throwParseError("Parse error in tag");
      // find </tag>
      var end = (new RegExp('</'+tagName+'\\s*>', 'i')).exec(rest);
      if (! end)
        throwParseError("unclosed <"+tagName+">");
      var tagContents = rest.slice(0, end.index);
      var contentsStartIndex = index;

      // act on the tag
      html_scanner._handleTag(results, tagName, tagAttribs, tagContents,
                              throwParseError, contentsStartIndex,
                              tagStartIndex);

      // advance afterwards, so that line numbers in errors are correct
      advance(end.index + end[0].length);
    }

    return results;
  },

  _initResults: function() {
    var results = {};
    results.head = '';
    results.body = '';
    results.js = '';
    return results;
  },

  _handleTag: function (results, tag, attribs, contents, throwParseError,
                        contentsStartIndex, tagStartIndex) {

    // trim the tag contents.
    // this is a courtesy and is also relied on by some unit tests.
    var m = contents.match(/^([ \t\r\n]*)([\s\S]*?)[ \t\r\n]*$/);
    contentsStartIndex += m[1].length;
    contents = m[2];

    // do we have 1 or more attribs?
    var hasAttribs = false;
    for(var k in attribs) {
      if (attribs.hasOwnProperty(k)) {
        hasAttribs = true;
        break;
      }
    }

    if (tag === "head") {
      if (hasAttribs)
        throwParseError("Attributes on <head> not supported");
      results.head += contents;
      return;
    }


    // <body> or <template>

    try {
      if (tag === "template") {
        var name = attribs.name;
        if (! name)
          throwParseError("Template has no 'name' attribute");

        if (Spacebars.isReservedName(name))
          throwParseError("Template can't be named \"" + name + "\"");

        var renderFuncCode = Spacebars.compile(
          contents, {
            isTemplate: true,
            sourceName: 'Template "' + name + '"'
          });

        results.js += "\nTemplate.__define__(" + JSON.stringify(name) +
          ", " + renderFuncCode + ");\n";
      } else {
        // <body>
        if (hasAttribs)
          throwParseError("Attributes on <body> not supported");

        var renderFuncCode = Spacebars.compile(
          contents, {
            isBody: true,
            sourceName: "<body>"
          });

        // We may be one of many `<body>` tags.
        results.js += "\nUI.body.contentParts.push(UI.Component.extend({render: " + renderFuncCode + "}));\nMeteor.startup(function () { if (! UI.body.INSTANTIATED) { UI.body.INSTANTIATED = true; UI.DomRange.insert(UI.render(UI.body).dom, document.body); } });\n";
      }
    } catch (e) {
      if (e.scanner) {
        // The error came from Spacebars
        throwParseError(e.message, contentsStartIndex + e.offset);
      } else {
        throw e;
      }
    }
  }
};


//-------------spacebars-compiler/templatetag.js----------
// A TemplateTag is the result of parsing a single `{{...}}` tag.
//
// The `.type` of a TemplateTag is one of:
//
// - `"DOUBLE"` - `{{foo}}`
// - `"TRIPLE"` - `{{{foo}}}`
// - `"COMMENT"` - `{{! foo}}`
// - `"INCLUSION"` - `{{> foo}}`
// - `"BLOCKOPEN"` - `{{#foo}}`
// - `"BLOCKCLOSE"` - `{{/foo}}`
// - `"ELSE"` - `{{else}}`
//
// Besides `type`, the mandatory properties of a TemplateTag are:
//
// - `path` - An array of one or more strings.  The path of `{{foo.bar}}`
//   is `["foo", "bar"]`.  Applies to DOUBLE, TRIPLE, INCLUSION, BLOCKOPEN,
//   and BLOCKCLOSE.
//
// - `args` - An array of zero or more argument specs.  An argument spec
//   is a two or three element array, consisting of a type, value, and
//   optional keyword name.  For example, the `args` of `{{foo "bar" x=3}}`
//   are `[["STRING", "bar"], ["NUMBER", 3, "x"]]`.  Applies to DOUBLE,
//   TRIPLE, INCLUSION, and BLOCKOPEN.
//
// - `value` - For COMMENT tags, a string of the comment's text.
//
// These additional are typically set during parsing:
//
// - `position` - The HTML.TEMPLATE_TAG_POSITION specifying at what sort
//   of site the TemplateTag was encountered (e.g. at element level or as
//   part of an attribute value). Its absence implies
//   HTML.TEMPLATE_TAG_POSITION.ELEMENT.
//
// - `content` and `elseContent` - When a BLOCKOPEN tag's contents are
//   parsed, they are put here.  `elseContent` will only be present if
//   an `{{else}}` was found.


TemplateTag = Spacebars.TemplateTag = function () {};

var makeStacheTagStartRegex = function (r) {
  return new RegExp(r.source + /(?![{>!#/])/.source,
                    r.ignoreCase ? 'i' : '');
};

var starts = {
  ELSE: makeStacheTagStartRegex(/^\{\{\s*else(?=[\s}])/i),
  DOUBLE: makeStacheTagStartRegex(/^\{\{\s*(?!\s)/),
  TRIPLE: makeStacheTagStartRegex(/^\{\{\{\s*(?!\s)/),
  COMMENT: makeStacheTagStartRegex(/^\{\{\s*!/),
  INCLUSION: makeStacheTagStartRegex(/^\{\{\s*>\s*(?!\s)/),
  BLOCKOPEN: makeStacheTagStartRegex(/^\{\{\s*#\s*(?!\s)/),
  BLOCKCLOSE: makeStacheTagStartRegex(/^\{\{\s*\/\s*(?!\s)/)
};

var ends = {
  DOUBLE: /^\s*\}\}/,
  TRIPLE: /^\s*\}\}\}/
};

// Parse a tag from the provided scanner or string.  If the input
// doesn't start with `{{`, returns null.  Otherwise, either succeeds
// and returns a Spacebars.TemplateTag, or throws an error (using
// `scanner.fatal` if a scanner is provided).
TemplateTag.parse = function (scannerOrString) {
  var scanner = scannerOrString;
  if (typeof scanner === 'string')
    scanner = new HTML.Scanner(scannerOrString);

  if (! (scanner.peek() === '{' &&
         (scanner.rest()).slice(0, 2) === '{{'))
    return null;

  var run = function (regex) {
    // regex is assumed to start with `^`
    var result = regex.exec(scanner.rest());
    if (! result)
      return null;
    var ret = result[0];
    scanner.pos += ret.length;
    return ret;
  };

  var advance = function (amount) {
    scanner.pos += amount;
  };

  var scanIdentifier = function (isFirstInPath) {
    var id = parseIdentifierName(scanner);
    if (! id)
      expected('IDENTIFIER');
    if (isFirstInPath &&
        (id === 'null' || id === 'true' || id === 'false'))
      scanner.fatal("Can't use null, true, or false, as an identifier at start of path");

    return id;
  };

  var scanPath = function () {
    var segments = [];

    // handle initial `.`, `..`, `./`, `../`, `../..`, `../../`, etc
    var dots;
    if ((dots = run(/^[\.\/]+/))) {
      var ancestorStr = '.'; // eg `../../..` maps to `....`
      var endsWithSlash = /\/$/.test(dots);

      if (endsWithSlash)
        dots = dots.slice(0, -1);

      _.each(dots.split('/'), function(dotClause, index) {
        if (index === 0) {
          if (dotClause !== '.' && dotClause !== '..')
            expected("`.`, `..`, `./` or `../`");
        } else {
          if (dotClause !== '..')
            expected("`..` or `../`");
        }

        if (dotClause === '..')
          ancestorStr += '.';
      });

      segments.push(ancestorStr);

      if (!endsWithSlash)
        return segments;
    }

    while (true) {
      // scan a path segment

      if (run(/^\[/)) {
        var seg = run(/^[\s\S]*?\]/);
        if (! seg)
          error("Unterminated path segment");
        seg = seg.slice(0, -1);
        if (! seg && ! segments.length)
          error("Path can't start with empty string");
        segments.push(seg);
      } else {
        var id = scanIdentifier(! segments.length);
        if (id === 'this' && ! segments.length) {
          // initial `this`
          segments.push('.');
        } else {
          segments.push(id);
        }
      }

      var sep = run(/^[\.\/]/);
      if (! sep)
        break;
    }

    return segments;
  };

  // scan an argument; succeeds or errors.
  // Result is an array of two or three items:
  // type , value, and (indicating a keyword argument)
  // keyword name.
  var scanArg = function (notKeyword) {
    var startPos = scanner.pos;
    var result;
    if ((result = parseNumber(scanner))) {
      return ['NUMBER', result.value];
    } else if ((result = parseStringLiteral(scanner))) {
      return ['STRING', result.value];
    } else if (/^[\.\[]/.test(scanner.peek())) {
      return ['PATH', scanPath()];
    } else if ((result = parseIdentifierName(scanner))) {
      var id = result;
      if (id === 'null') {
        return ['NULL', null];
      } else if (id === 'true' || id === 'false') {
        return ['BOOLEAN', id === 'true'];
      } else {
        if ((! notKeyword) &&
            /^\s*=/.test(scanner.rest())) {
          // it's a keyword argument!
          run(/^\s*=\s*/);
          // recurse to scan value, disallowing a second `=`.
          var arg = scanArg(true);
          arg.push(id); // add third element for key
          return arg;
        } else {
          scanner.pos = startPos; // unconsume `id`
          return ['PATH', scanPath()];
        }
      }
    } else {
      expected('identifier, number, string, boolean, or null');
    }
  };

  var type;

  var error = function (msg) {
    scanner.fatal(msg);
  };

  var expected = function (what) {
    error('Expected ' + what);
  };

  // must do ELSE first; order of others doesn't matter

  if (run(starts.ELSE)) type = 'ELSE';
  else if (run(starts.DOUBLE)) type = 'DOUBLE';
  else if (run(starts.TRIPLE)) type = 'TRIPLE';
  else if (run(starts.COMMENT)) type = 'COMMENT';
  else if (run(starts.INCLUSION)) type = 'INCLUSION';
  else if (run(starts.BLOCKOPEN)) type = 'BLOCKOPEN';
  else if (run(starts.BLOCKCLOSE)) type = 'BLOCKCLOSE';
  else
    error('Unknown stache tag');

  var tag = new TemplateTag;
  tag.type = type;

  if (type === 'COMMENT') {
    var result = run(/^[\s\S]*?\}\}/);
    if (! result)
      error("Unclosed comment");
    tag.value = result.slice(0, -2);
  } else if (type === 'BLOCKCLOSE') {
    tag.path = scanPath();
    if (! run(ends.DOUBLE))
      expected('`}}`');
  } else if (type === 'ELSE') {
    if (! run(ends.DOUBLE))
      expected('`}}`');
  } else {
    // DOUBLE, TRIPLE, BLOCKOPEN, INCLUSION
    tag.path = scanPath();
    tag.args = [];
    var foundKwArg = false;
    while (true) {
      run(/^\s*/);
      if (type === 'TRIPLE') {
        if (run(ends.TRIPLE))
          break;
        else if (scanner.peek() === '}')
          expected('`}}}`');
      } else {
        if (run(ends.DOUBLE))
          break;
        else if (scanner.peek() === '}')
          expected('`}}`');
      }
      var newArg = scanArg();
      if (newArg.length === 3) {
        foundKwArg = true;
      } else {
        if (foundKwArg)
          error("Can't have a non-keyword argument after a keyword argument");
      }
      tag.args.push(newArg);

      if (run(/^(?=[\s}])/) !== '')
        expected('space');
    }
  }

  return tag;
};

// Returns a Spacebars.TemplateTag parsed from `scanner`, leaving scanner
// at its original position.
//
// An error will still be thrown if there is not a valid template tag at
// the current position.
TemplateTag.peek = function (scanner) {
  var startPos = scanner.pos;
  var result = TemplateTag.parse(scanner);
  scanner.pos = startPos;
  return result;
};

// Like `TemplateTag.parse`, but in the case of blocks, parse the complete
// `{{#foo}}...{{/foo}}` with `content` and possible `elseContent`, rather
// than just the BLOCKOPEN tag.
//
// In addition:
//
// - Throws an error if `{{else}}` or `{{/foo}}` tag is encountered.
//
// - Returns `null` for a COMMENT.  (This case is distinguishable from
//   parsing no tag by the fact that the scanner is advanced.)
//
// - Takes an HTML.TEMPLATE_TAG_POSITION `position` and sets it as the
//   TemplateTag's `.position` property.
//
// - Validates the tag's well-formedness and legality at in its position.
TemplateTag.parseCompleteTag = function (scannerOrString, position) {
  var scanner = scannerOrString;
  if (typeof scanner === 'string')
    scanner = new HTML.Scanner(scannerOrString);

  var startPos = scanner.pos; // for error messages
  var result = TemplateTag.parse(scannerOrString);
  if (! result)
    return result;

  if (result.type === 'COMMENT')
    return null;

  if (result.type === 'ELSE')
    scanner.fatal("Unexpected {{else}}");

  if (result.type === 'BLOCKCLOSE')
    scanner.fatal("Unexpected closing template tag");

  position = (position || HTML.TEMPLATE_TAG_POSITION.ELEMENT);
  if (position !== HTML.TEMPLATE_TAG_POSITION.ELEMENT)
    result.position = position;

  if (result.type === 'BLOCKOPEN') {
    // parse block contents

    // Construct a string version of `.path` for comparing start and
    // end tags.  For example, `foo/[0]` was parsed into `["foo", "0"]`
    // and now becomes `foo,0`.  This form may also show up in error
    // messages.
    var blockName = result.path.join(',');

    var textMode = null;
      if (blockName === 'markdown' ||
          position === HTML.TEMPLATE_TAG_POSITION.IN_RAWTEXT) {
        textMode = HTML.TEXTMODE.STRING;
      } else if (position === HTML.TEMPLATE_TAG_POSITION.IN_RCDATA ||
                 position === HTML.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {
        textMode = HTML.TEXTMODE.RCDATA;
      }
      var parserOptions = {
        getSpecialTag: TemplateTag.parseCompleteTag,
        shouldStop: isAtBlockCloseOrElse,
        textMode: textMode
      };
    result.content = HTML.parseFragment(scanner, parserOptions);

    if (scanner.rest().slice(0, 2) !== '{{')
      scanner.fatal("Expected {{else}} or block close for " + blockName);

    var lastPos = scanner.pos; // save for error messages
    var tmplTag = TemplateTag.parse(scanner); // {{else}} or {{/foo}}

    if (tmplTag.type === 'ELSE') {
      // parse {{else}} and content up to close tag
      result.elseContent = HTML.parseFragment(scanner, parserOptions);

      if (scanner.rest().slice(0, 2) !== '{{')
        scanner.fatal("Expected block close for " + blockName);

      lastPos = scanner.pos;
      tmplTag = TemplateTag.parse(scanner);
    }

    if (tmplTag.type === 'BLOCKCLOSE') {
      var blockName2 = tmplTag.path.join(',');
      if (blockName !== blockName2) {
        scanner.pos = lastPos;
        scanner.fatal('Expected tag to close ' + blockName + ', found ' +
                      blockName2);
      }
    } else {
      scanner.pos = lastPos;
      scanner.fatal('Expected tag to close ' + blockName + ', found ' +
                    tmplTag.type);
    }
  }

  var finalPos = scanner.pos;
  scanner.pos = startPos;
  validateTag(result, scanner);
  scanner.pos = finalPos;

  return result;
};

var isAtBlockCloseOrElse = function (scanner) {
  // Detect `{{else}}` or `{{/foo}}`.
  //
  // We do as much work ourselves before deferring to `TemplateTag.peek`,
  // for efficiency (we're called for every input token) and to be
  // less obtrusive, because `TemplateTag.peek` will throw an error if it
  // sees `{{` followed by a malformed tag.
  var rest, type;
  return (scanner.peek() === '{' &&
          (rest = scanner.rest()).slice(0, 2) === '{{' &&
          /^\{\{\s*(\/|else\b)/.test(rest) &&
          (type = TemplateTag.peek(scanner).type) &&
          (type === 'BLOCKCLOSE' || type === 'ELSE'));
};

// Validate that `templateTag` is correctly formed and legal for its
// HTML position.  Use `scanner` to report errors. On success, does
// nothing.
var validateTag = function (ttag, scanner) {

  if (ttag.type === 'INCLUSION' || ttag.type === 'BLOCKOPEN') {
    var args = ttag.args;
    if (args.length > 1 && args[0].length === 2 && args[0][0] !== 'PATH') {
      // we have a positional argument that is not a PATH followed by
      // other arguments
      scanner.fatal("First argument must be a function, to be called on the rest of the arguments; found " + args[0][0]);
    }
  }

  var position = ttag.position || HTML.TEMPLATE_TAG_POSITION.ELEMENT;
  if (position === HTML.TEMPLATE_TAG_POSITION.IN_ATTRIBUTE) {
    if (ttag.type === 'DOUBLE') {
      return;
    } else if (ttag.type === 'BLOCKOPEN') {
      var path = ttag.path;
      var path0 = path[0];
      if (! (path.length === 1 && (path0 === 'if' ||
                                   path0 === 'unless' ||
                                   path0 === 'with' ||
                                   path0 === 'each'))) {
        scanner.fatal("Custom block helpers are not allowed in an HTML attribute, only built-in ones like #each and #if");
      }
    } else {
      scanner.fatal(ttag.type + " template tag is not allowed in an HTML attribute");
    }
  } else if (position === HTML.TEMPLATE_TAG_POSITION.IN_START_TAG) {
    if (! (ttag.type === 'DOUBLE')) {
      scanner.fatal("Reactive HTML attributes must either have a constant name or consist of a single {{helper}} providing a dictionary of names and values.  A template tag of type " + ttag.type + " is not allowed here.");
    }
    if (scanner.peek() === '=') {
      scanner.fatal("Template tags are not allowed in attribute names, only in attribute values or in the form of a single {{helper}} that evaluates to a dictionary of name=value pairs.");
    }
  }

};


//-------------spacebars-compiler/tojs.js----------

// Turns any JSONable value into a JavaScript literal.
toJSLiteral = function (obj) {
  // See <http://timelessrepo.com/json-isnt-a-javascript-subset> for `\u2028\u2029`.
  // Also escape Unicode surrogates.
  return (JSON.stringify(obj)
          .replace(/[\u2028\u2029\ud800-\udfff]/g, function (c) {
            return '\\u' + ('000' + c.charCodeAt(0).toString(16)).slice(-4);
          }));
};



var jsReservedWordSet = (function (set) {
  _.each("abstract else instanceof super boolean enum int switch break export interface synchronized byte extends let this case false long throw catch final native throws char finally new transient class float null true const for package try continue function private typeof debugger goto protected var default if public void delete implements return volatile do import short while double in static with".split(' '), function (w) {
    set[w] = 1;
  });
  return set;
})({});

toObjectLiteralKey = function (k) {
  if (/^[a-zA-Z$_][a-zA-Z$0-9_]*$/.test(k) && jsReservedWordSet[k] !== 1)
    return k;
  return toJSLiteral(k);
};

// This method is generic, i.e. it can be transplanted to non-Tags
// and it will still work by accessing `this.tagName`, `this.attrs`,
// and `this.children`.  It's ok if `this.attrs` has content that
// isn't allowed in an attribute (this feature is used by
// HTML.Special.prototype.toJS).
HTML.Tag.prototype.toJS = function (options) {
  var argStrs = [];
  if (this.attrs) {
    var kvStrs = [];
    for (var k in this.attrs) {
      if (! HTML.isNully(this.attrs[k]))
        kvStrs.push(toObjectLiteralKey(k) + ': ' +
                    HTML.toJS(this.attrs[k], options));
    }
    if (kvStrs.length)
      argStrs.push('{' + kvStrs.join(', ') + '}');
  }

  for (var i = 0; i < this.children.length; i++) {
    argStrs.push(HTML.toJS(this.children[i], options));
  }

  var tagSymbol = this.tagName;
  if ((this instanceof HTML.Tag) && ! HTML.isTagEnsured(tagSymbol))
    tagSymbol = 'HTML.getTag(' + toJSLiteral(tagSymbol) + ')';
  else
    tagSymbol = 'HTML.' + tagSymbol;

  return tagSymbol + '(' + argStrs.join(', ') + ')';
};

HTML.CharRef.prototype.toJS = function (options) {
  return HTML.Tag.prototype.toJS.call({tagName: "CharRef",
                                       attrs: {html: this.html,
                                               str: this.str},
                                       children: []},
                                      options);
};

HTML.Comment.prototype.toJS = function (options) {
  return HTML.Tag.prototype.toJS.call({tagName: "Comment",
                                       attrs: null,
                                       children: [this.value]},
                                      options);
};

HTML.Raw.prototype.toJS = function (options) {
  return HTML.Tag.prototype.toJS.call({tagName: "Raw",
                                       attrs: null,
                                       children: [this.value]},
                                      options);
};

HTML.EmitCode.prototype.toJS = function (options) {
  return this.value;
};

HTML.toJS = function (node, options) {
  if (node == null) {
    // null or undefined
    return 'null';
  } else if ((typeof node === 'string') || (typeof node === 'boolean') || (typeof node === 'number')) {
    // string (or something that will be rendered as a string)
    return toJSLiteral(node);
  } else if (node instanceof Array) {
    // array
    var parts = [];
    for (var i = 0; i < node.length; i++)
      parts.push(HTML.toJS(node[i], options));
    return '[' + parts.join(', ') + ']';
  } else if (node.toJS) {
    // Tag or something else
    return node.toJS(options);
  } else {
    throw new Error("Expected tag, string, array, null, undefined, or " +
                    "object with a toJS method; found: " + node);
  }
};


//-------------spacebars-compiler/tokens.js----------

// Adapted from source code of http://xregexp.com/plugins/#unicode
var unicodeCategories = {
  Ll: "0061-007A00B500DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F05210523052505270561-05871D00-1D2B1D6B-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7B2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2CF32D00-2D252D272D2DA641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA661A663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CA78EA791A793A7A1A7A3A7A5A7A7A7A9A7FAFB00-FB06FB13-FB17FF41-FF5A",
  Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D6A1D781D9B-1DBF2071207F2090-209C2C7C2C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A7F8A7F9A9CFAA70AADDAAF3AAF4FF70FF9EFF9F",
  Lo: "00AA00BA01BB01C0-01C3029405D0-05EA05F0-05F20620-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150840-085808A008A2-08AC0904-0939093D09500958-09610972-09770979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10CF10CF20D05-0D0C0D0E-0D100D12-0D3A0D3D0D4E0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC-0EDF0F000F40-0F470F49-0F6C0F88-0F8C1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA10FD-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1BBA-1BE51C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF11CF51CF62135-21382D30-2D672D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31BA31F0-31FF3400-4DB54E00-9FCCA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCAAE0-AAEAAAF2AB01-AB06AB09-AB0EAB11-AB16AB20-AB26AB28-AB2EABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
  Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
  Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E05200522052405260531-055610A0-10C510C710CD1E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CED2CF2A640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA660A662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BA78DA790A792A7A0A7A2A7A4A7A6A7A8A7AAFF21-FF3A",
  Mc: "0903093B093E-09400949-094C094E094F0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1BAC1BAD1BE71BEA-1BEC1BEE1BF21BF31C24-1C2B1C341C351CE11CF21CF3302E302FA823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BAAEBAAEEAAEFAAF5ABE3ABE4ABE6ABE7ABE9ABEAABEC",
  Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065F067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0859-085B08E4-08FE0900-0902093A093C0941-0948094D0951-095709620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F8D-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135D-135F1712-17141732-1734175217531772177317B417B517B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91BAB1BE61BE81BE91BED1BEF-1BF11C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1CF41DC0-1DE61DFC-1DFF20D0-20DC20E120E5-20F02CEF-2CF12D7F2DE0-2DFF302A-302D3099309AA66FA674-A67DA69FA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1AAECAAEDAAF6ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
  Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19D91A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
  Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
  Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F"
};

var unicodeClass = function (abbrev) {
  return '[' +
    unicodeCategories[abbrev].replace(/[0-9A-F]{4}/ig, "\\u$&") + ']';
};

// See ECMA-262 spec, 3rd edition, Section 7.6
// Match one or more characters that can start an identifier.
// This is IdentifierStart+.
var rIdentifierPrefix = new RegExp(
  "^([a-zA-Z$_]+|\\\\u[0-9a-fA-F]{4}|" +
    [unicodeClass('Lu'), unicodeClass('Ll'), unicodeClass('Lt'),
     unicodeClass('Lm'), unicodeClass('Lo'), unicodeClass('Nl')].join('|') +
    ")+");
// Match one or more characters that can continue an identifier.
// This is (IdentifierPart and not IdentifierStart)+.
// To match a full identifier, match rIdentifierPrefix, then
// match rIdentifierMiddle followed by rIdentifierPrefix until they both fail.
var rIdentifierMiddle = new RegExp(
  "^([0-9]|" + [unicodeClass('Mn'), unicodeClass('Mc'), unicodeClass('Nd'),
                unicodeClass('Pc')].join('|') + ")+");


// See ECMA-262 spec, 3rd edition, Section 7.8.3
var rHexLiteral = /^0[xX][0-9a-fA-F]+(?!\w)/;
var rDecLiteral =
      /^(((0|[1-9][0-9]*)(\.[0-9]*)?)|\.[0-9]+)([Ee][+-]?[0-9]+)?(?!\w)/;

// Section 7.8.4
var rStringQuote = /^["']/;
// Match one or more characters besides quotes, backslashes, or line ends
var rStringMiddle = /^(?=.)[^"'\\]+?((?!.)|(?=["'\\]))/;
// Match one escape sequence, including the backslash.
var rEscapeSequence =
      /^\\(['"\\bfnrtv]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;
// Match one ES5 line continuation
var rLineContinuation =
      /^\\(\r\n|[\u000A\u000D\u2028\u2029])/;


parseNumber = function (scanner) {
  var startPos = scanner.pos;

  var isNegative = false;
  if (scanner.peek() === '-') {
    scanner.pos++;
    isNegative = true;
  }
  // Note that we allow `"-0xa"`, unlike `Number(...)`.

  var rest = scanner.rest();
  var match = rDecLiteral.exec(rest) || rHexLiteral.exec(rest);
  if (! match) {
    scanner.pos = startPos;
    return null;
  }
  var matchText = match[0];
  scanner.pos += matchText.length;

  var text = (isNegative ? '-' : '') + matchText;
  var value = Number(matchText);
  value = (isNegative ? -value : value);
  return { text: text, value: value };
};

parseIdentifierName = function (scanner) {
  var startPos = scanner.pos;
  var rest = scanner.rest();
  var match = rIdentifierPrefix.exec(rest);
  if (! match)
    return null;
  scanner.pos += match[0].length;
  rest = scanner.rest();
  var foundMore = true;

  while (foundMore) {
    foundMore = false;

    match = rIdentifierMiddle.exec(rest);
    if (match) {
      foundMore = true;
      scanner.pos += match[0].length;
      rest = scanner.rest();
    }

    match = rIdentifierPrefix.exec(rest);
    if (match) {
      foundMore = true;
      scanner.pos += match[0].length;
      rest = scanner.rest();
    }
  }

  return scanner.input.substring(startPos, scanner.pos);
};

parseStringLiteral = function (scanner) {
  var startPos = scanner.pos;
  var rest = scanner.rest();
  var match = rStringQuote.exec(rest);
  if (! match)
    return null;

  var quote = match[0];
  scanner.pos++;
  rest = scanner.rest();

  var jsonLiteral = '"';

  while (match) {
    match = rStringMiddle.exec(rest);
    if (match) {
      jsonLiteral += match[0];
    } else {
      match = rEscapeSequence.exec(rest);
      if (match) {
        var esc = match[0];
        // Convert all string escapes to JSON-compatible string escapes, so we
        // can use JSON.parse for some of the work.  JSON strings are not the
        // same as JS strings.  They don't support `\0`, `\v`, `\'`, or hex
        // escapes.
        if (esc === '\\0')
          jsonLiteral += '\\u0000';
        else if (esc === '\\v')
          jsonLiteral += '\\u000b';
        else if (esc.charAt(1) === 'x')
          jsonLiteral += '\\u00' + esc.slice(2);
        else if (esc === '\\\'')
          jsonLiteral += "'";
        else
          jsonLiteral += esc;
      } else {
        match = rLineContinuation.exec(rest);
        if (! match) {
          match = rStringQuote.exec(rest);
          if (match) {
            var c = match[0];
            if (c !== quote) {
              if (c === '"')
                jsonLiteral += '\\';
              jsonLiteral += c;
            }
          }
        }
      }
    }
    if (match) {
      scanner.pos += match[0].length;
      rest = scanner.rest();
      if (match[0] === quote)
        break;
    }
  }

  if (match[0] !== quote)
    scanner.fatal("Unterminated string literal");

  jsonLiteral += '"';
  var text = scanner.input.substring(startPos, scanner.pos);
  var value = JSON.parse(jsonLiteral);
  return { text: text, value: value };
};

// expose for testing
Spacebars._$ = {
  parseNumber: parseNumber,
  parseIdentifierName: parseIdentifierName,
  parseStringLiteral: parseStringLiteral
};


//-------------spacebars-compiler/spacebars-compiler.js----------



Spacebars.parse = function (input) {

  var tree = HTML.parseFragment(
    input,
    { getSpecialTag: TemplateTag.parseCompleteTag });

  return tree;
};

// ============================================================
// Optimizer for optimizing HTMLjs into raw HTML string when
// it doesn't contain template tags.

var optimize = function (tree) {

  var pushRawHTML = function (array, html) {
    var N = array.length;
    if (N > 0 && (array[N-1] instanceof HTML.Raw)) {
      array[N-1] = HTML.Raw(array[N-1].value + html);
    } else {
      array.push(HTML.Raw(html));
    }
  };

  var isPureChars = function (html) {
    return (html.indexOf('&') < 0 && html.indexOf('<') < 0);
  };

  var optimizeArrayParts = function (array, optimizePartsFunc, forceOptimize) {
    var result = null;
    if (forceOptimize)
      result = [];
    for (var i = 0, N = array.length; i < N; i++) {
      var part = optimizePartsFunc(array[i]);
      if (part !== null) {
        // something special found
        if (result === null) {
          // This is our first special item.  Stringify the other parts.
          result = [];
          for (var j = 0; j < i; j++)
            pushRawHTML(result, HTML.toHTML(array[j]));
        }
        result.push(part);
      } else {
        // just plain HTML found
        if (result !== null) {
          // we've already found something special, so convert this to Raw
          pushRawHTML(result, HTML.toHTML(array[i]));
        }
      }
    }
    if (result !== null) {
      // clean up unnecessary HTML.Raw wrappers around pure character data
      for (var j = 0; j < result.length; j++) {
        if ((result[j] instanceof HTML.Raw) &&
            isPureChars(result[j].value))
          // replace HTML.Raw with simple string
          result[j] = result[j].value;
      }
    }
    return result;
  };

  var doesAttributeValueHaveSpecials = function (v) {
    if (v instanceof HTML.Special)
      return true;
    if (typeof v === 'function')
      return true;

    if (v instanceof Array) {
      for (var i = 0; i < v.length; i++)
        if (doesAttributeValueHaveSpecials(v[i]))
          return true;
      return false;
    }

    return false;
  };

  var optimizeParts = function (node) {
    // If we have nothing special going on, returns `null` (so that the
    // parent can optimize).  Otherwise returns a replacement for `node`
    // with optimized parts.
    if ((node == null) || (typeof node === 'string') ||
        (node instanceof HTML.CharRef) || (node instanceof HTML.Comment) ||
        (node instanceof HTML.Raw)) {
      // not special; let parent decide how whether to optimize
      return null;
    } else if (node instanceof HTML.Tag) {

      if (node.tagName === 'TEXTAREA' || (! HTML.isKnownElement(node.tagName))) {
        // optimizing into a TEXTAREA's RCDATA would require being a little
        // more clever.  foreign elements like SVG can't be stringified for
        // innerHTML.
        return node;
      }

      var mustOptimize = false;

      if (node.attrs) {
        var attrs = node.attrs;
        for (var k in attrs) {
          if (doesAttributeValueHaveSpecials(attrs[k])) {
            mustOptimize = true;
            break;
          }
        }
      }

      var newChildren = optimizeArrayParts(node.children, optimizeParts, mustOptimize);

      if (newChildren === null)
        return null;

      var newTag = HTML.getTag(node.tagName).apply(null, newChildren);
      newTag.attrs = node.attrs;

      return newTag;

    } else if (node instanceof Array) {
      return optimizeArrayParts(node, optimizeParts);
    } else {
      return node;
    }
  };

  var optTree = optimizeParts(tree);
  if (optTree !== null)
    // tree was optimized in parts
    return optTree;

  optTree = HTML.Raw(HTML.toHTML(tree));

  if (isPureChars(optTree.value))
    return optTree.value;

  return optTree;
};

// ============================================================
// Code-generation of template tags

var builtInBlockHelpers = {
  'if': 'UI.If',
  'unless': 'UI.Unless',
  'with': 'Spacebars.With',
  'each': 'UI.Each'
};

var builtInLexicals = {
  'content': 'template.__content',
  'elseContent': 'template.__elseContent'
};

Spacebars.isReservedName = function (name) {
  return builtInBlockHelpers.hasOwnProperty(name) ||
    builtInLexicals.hasOwnProperty(name);
};

var codeGenTemplateTag = function (tag) {
  if (tag.position === HTML.TEMPLATE_TAG_POSITION.IN_START_TAG) {
    // only `tag.type === 'DOUBLE'` allowed (by earlier validation)
    return HTML.EmitCode('function () { return ' +
                         codeGenMustache(tag.path, tag.args, 'attrMustache')
                         + '; }');
  } else {
    if (tag.type === 'DOUBLE') {
      return HTML.EmitCode('function () { return ' +
                           codeGenMustache(tag.path, tag.args) + '; }');
    } else if (tag.type === 'TRIPLE') {
      return HTML.EmitCode('function () { return Spacebars.makeRaw(' +
                           codeGenMustache(tag.path, tag.args) + '); }');
    } else if (tag.type === 'INCLUSION' || tag.type === 'BLOCKOPEN') {
      var path = tag.path;

      if (tag.type === 'BLOCKOPEN' &&
          builtInBlockHelpers.hasOwnProperty(path[0])) {
        // if, unless, with, each.
        //
        // If someone tries to do `{{> if}}`, we don't
        // get here, but an error is thrown when we try to codegen the path.

        // Note: If we caught these errors earlier, while scanning, we'd be able to
        // provide nice line numbers.
        if (path.length > 1)
          throw new Error("Unexpected dotted path beginning with " + path[0]);
        if (! tag.args.length)
          throw new Error("#" + path[0] + " requires an argument");

        var codeParts = codeGenInclusionParts(tag);
        var dataFunc = codeParts.dataFunc; // must exist (tag.args.length > 0)
        var contentBlock = codeParts.content; // must exist
        var elseContentBlock = codeParts.elseContent; // may not exist

        var callArgs = [dataFunc, contentBlock];
        if (elseContentBlock)
          callArgs.push(elseContentBlock);

        return HTML.EmitCode(
          builtInBlockHelpers[path[0]] + '(' + callArgs.join(', ') + ')');

      } else {
        var compCode = codeGenPath(path, {lookupTemplate: true});

        if (path.length !== 1) {
          // path code may be reactive; wrap it
          compCode = 'function () { return ' + compCode + '; }';
        }

        var codeParts = codeGenInclusionParts(tag);
        var dataFunc = codeParts.dataFunc;
        var content = codeParts.content;
        var elseContent = codeParts.elseContent;

        var includeArgs = [compCode];
        if (content) {
          includeArgs.push(content);
          if (elseContent)
            includeArgs.push(elseContent);
        }

        var includeCode =
              'Spacebars.include(' + includeArgs.join(', ') + ')';

        if (dataFunc) {
          includeCode =
            'Spacebars.TemplateWith(' + dataFunc + ', UI.block(' +
            Spacebars.codeGen(HTML.EmitCode(includeCode)) + '))';
        }

        if (path[0] === 'content' || path[0] === 'elseContent') {
          includeCode = 'UI.InTemplateScope(template, ' + includeCode + ')';
        }

        return HTML.EmitCode(includeCode);
      }
    } else {
      // Can't get here; TemplateTag validation should catch any
      // inappropriate tag types that might come out of the parser.
      throw new Error("Unexpected template tag type: " + tag.type);
    }
  }
};

var makeObjectLiteral = function (obj) {
  var parts = [];
  for (var k in obj)
    parts.push(toObjectLiteralKey(k) + ': ' + obj[k]);
  return '{' + parts.join(', ') + '}';
};

// `path` is an array of at least one string.
//
// If `path.length > 1`, the generated code may be reactive
// (i.e. it may invalidate the current computation).
//
// No code is generated to call the result if it's a function.
//
// Options:
//
// - lookupTemplate {Boolean} If true, generated code also looks in
//   the list of templates. (After helpers, before data context).
//   Used when generating code for `{{> foo}}` or `{{#foo}}`. Only
//   used for non-dotted paths.
var codeGenPath = function (path, opts) {
  if (builtInBlockHelpers.hasOwnProperty(path[0]))
    throw new Error("Can't use the built-in '" + path[0] + "' here");
  // Let `{{#if content}}` check whether this template was invoked via
  // inclusion or as a block helper, in addition to supporting
  // `{{> content}}`.
  if (builtInLexicals.hasOwnProperty(path[0])) {
    if (path.length > 1)
      throw new Error("Unexpected dotted path beginning with " + path[0]);
    return builtInLexicals[path[0]];
  }

  var args = [toJSLiteral(path[0])];
  var lookupMethod = 'lookup';
  if (opts && opts.lookupTemplate && path.length === 1)
    lookupMethod = 'lookupTemplate';
  var code = 'self.' + lookupMethod + '(' + args.join(', ') + ')';

  if (path.length > 1) {
    code = 'Spacebars.dot(' + code + ', ' +
      _.map(path.slice(1), toJSLiteral).join(', ') + ')';
  }

  return code;
};

// Generates code for an `[argType, argValue]` argument spec,
// ignoring the third element (keyword argument name) if present.
//
// The resulting code may be reactive (in the case of a PATH of
// more than one element) and is not wrapped in a closure.
var codeGenArgValue = function (arg) {
  var argType = arg[0];
  var argValue = arg[1];

  var argCode;
  switch (argType) {
  case 'STRING':
  case 'NUMBER':
  case 'BOOLEAN':
  case 'NULL':
    argCode = toJSLiteral(argValue);
    break;
  case 'PATH':
    argCode = codeGenPath(argValue);
    break;
  default:
    // can't get here
    throw new Error("Unexpected arg type: " + argType);
  }

  return argCode;
};

// Generates a call to `Spacebars.fooMustache` on evaluated arguments.
// The resulting code has no function literals and must be wrapped in
// one for fine-grained reactivity.
var codeGenMustache = function (path, args, mustacheType) {
  var nameCode = codeGenPath(path);
  var argCode = codeGenMustacheArgs(args);
  var mustache = (mustacheType || 'mustache');

  return 'Spacebars.' + mustache + '(' + nameCode +
    (argCode ? ', ' + argCode.join(', ') : '') + ')';
};

// returns: array of source strings, or null if no
// args at all.
var codeGenMustacheArgs = function (tagArgs) {
  var kwArgs = null; // source -> source
  var args = null; // [source]

  // tagArgs may be null
  _.each(tagArgs, function (arg) {
    var argCode = codeGenArgValue(arg);

    if (arg.length > 2) {
      // keyword argument (represented as [type, value, name])
      kwArgs = (kwArgs || {});
      kwArgs[arg[2]] = argCode;
    } else {
      // positional argument
      args = (args || []);
      args.push(argCode);
    }
  });

  // put kwArgs in options dictionary at end of args
  if (kwArgs) {
    args = (args || []);
    args.push('Spacebars.kw(' + makeObjectLiteral(kwArgs) + ')');
  }

  return args;
};

// Takes an inclusion tag and returns an object containing these properties,
// all optional, whose values are JS source code:
//
// - `dataFunc` - source code of a data function literal
// - `content` - source code of a content block
// - `elseContent` - source code of an elseContent block
//
// Implements the calling convention for inclusions.
var codeGenInclusionParts = function (tag) {
  var ret = {};

  if ('content' in tag) {
    ret.content = (
      'UI.block(' + Spacebars.codeGen(tag.content) + ')');
  }
  if ('elseContent' in tag) {
    ret.elseContent = (
      'UI.block(' + Spacebars.codeGen(tag.elseContent) + ')');
  }

  var dataFuncCode = null;

  var args = tag.args;
  if (! args.length) {
    // e.g. `{{#foo}}`
    return ret;
  } else if (args[0].length === 3) {
    // keyword arguments only, e.g. `{{> point x=1 y=2}}`
    var dataProps = {};
    _.each(args, function (arg) {
      var argKey = arg[2];
      dataProps[argKey] = 'Spacebars.call(' + codeGenArgValue(arg) + ')';
    });
    dataFuncCode = makeObjectLiteral(dataProps);
  } else if (args[0][0] !== 'PATH') {
    // literal first argument, e.g. `{{> foo "blah"}}`
    //
    // tag validation has confirmed, in this case, that there is only
    // one argument (`args.length === 1`)
    dataFuncCode = codeGenArgValue(args[0]);
  } else if (args.length === 1) {
    // one argument, must be a PATH
    dataFuncCode = 'Spacebars.call(' + codeGenPath(args[0][1]) + ')';
  } else {
    dataFuncCode = codeGenMustache(args[0][1], args.slice(1),
                                   'dataMustache');
  }

  ret.dataFunc = 'function () { return ' + dataFuncCode + '; }';

  return ret;
};


// ============================================================
// Main compiler

var replaceSpecials = function (node) {
  if (node instanceof HTML.Tag) {
    // potential optimization: don't always create a new tag
    var newChildren = _.map(node.children, replaceSpecials);
    var newTag = HTML.getTag(node.tagName).apply(null, newChildren);
    var oldAttrs = node.attrs;
    var newAttrs = null;

    if (oldAttrs) {
      _.each(oldAttrs, function (value, name) {
        if (name.charAt(0) !== '$') {
          newAttrs = (newAttrs || {});
          newAttrs[name] = replaceSpecials(value);
        }
      });

      if (oldAttrs.$specials && oldAttrs.$specials.length) {
        newAttrs = (newAttrs || {});
        newAttrs.$dynamic = _.map(oldAttrs.$specials, function (special) {
          return codeGenTemplateTag(special.value);
        });
      }
    }

    newTag.attrs = newAttrs;
    return newTag;
  } else if (node instanceof Array) {
    return _.map(node, replaceSpecials);
  } else if (node instanceof HTML.Special) {
    return codeGenTemplateTag(node.value);
  } else {
    return node;
  }
};

Spacebars.compile = function (input, options) {
  var tree = Spacebars.parse(input);
  return Spacebars.codeGen(tree, options);
};

Spacebars.codeGen = function (parseTree, options) {
  // is this a template, rather than a block passed to
  // a block helper, say
  var isTemplate = (options && options.isTemplate);

  var tree = parseTree;

  // The flags `isTemplate` and `isBody` are kind of a hack.
  if (isTemplate || (options && options.isBody)) {
    // optimizing fragments would require being smarter about whether we are
    // in a TEXTAREA, say.
    tree = optimize(tree);
  }

  tree = replaceSpecials(tree);

  var code = '(function () { var self = this; ';
  if (isTemplate) {
    // support `{{> content}}` and `{{> elseContent}}` with
    // lexical scope by creating a local variable in the
    // template's render function.
    code += 'var template = this; ';
  }
  code += 'return ';
  code += HTML.toJS(tree);
  code += '; })';

  code = beautify(code);

  return code;
};

var beautify = function (code) {
  if (Package.minifiers && Package.minifiers.UglifyJSMinify) {
    var result = UglifyJSMinify(code,
                                { fromString: true,
                                  mangle: false,
                                  compress: false,
                                  output: { beautify: true,
                                            indent_level: 2,
                                            width: 80 } });
    var output = result.code;
    // Uglify interprets our expression as a statement and may add a semicolon.
    // Strip trailing semicolon.
    output = output.replace(/;$/, '');
    return output;
  } else {
    // don't actually beautify; no UglifyJS
    return code;
  }
};

// expose for compiler output tests
Spacebars._beautify = beautify;


//---------------mbc.js------------
(function (global) {
    var MBC = global.MBC = {};

    MBC.renderTemplate = function (templateName, elOrSelector) {
        var el = _.isString(elOrSelector) ? $(elOrSelector).get(0) : elOrSelector;
        el && UI.DomRange.insert(UI.render(Template[templateName]).dom, el);
    };

    MBC.scanHtml = function(html) {
        var r = html_scanner.scan(html);
        r.js && eval(r.js);
    };

}(this));
