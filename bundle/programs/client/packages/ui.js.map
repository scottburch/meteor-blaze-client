)]}'
{"version":3,"file":"/packages/ui.js","sources":["ui/exceptions.js","ui/base.js","ui/dombackend.js","ui/domrange.js","ui/attrs.js","ui/render.js","ui/builtins.js","ui/each.js","ui/fields.js","ui/handlebars_backcompat.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,c;;AAEA,mF;AACA,8E;AACA,4E;AACA,sB;AACA,E;AACA,S;AACA,E;AACA,M;AACA,Q;AACA,yB;AACA,gB;AACA,0B;AACA,I;AACA,M;AACA,E;AACA,6D;;AAEA,uC;AACA,kB;AACA,wB;AACA,6B;AACA,6D;AACA,8E;AACA,gC;AACA,M;;AAEA,4E;AACA,gF;AACA,gE;AACA,sE;AACA,E;;;;;;;;;;;;;;;;;;;ACjCA,Q;;AAEA,2D;AACA,2D;AACA,iB;AACA,+B;AACA,oB;AACA,8B;AACA,sB;AACA,a;AACA,E;;AAEA,sD;AACA,Y;AACA,6C;AACA,iD;AACA,6C;AACA,mB;AACA,kD;AACA,O;AACA,qD;AACA,e;AACA,a;AACA,sB;AACA,G;AACA,a;AACA,E;;AAEA,4D;AACA,iE;AACA,4D;AACA,Q;AACA,4C;AACA,gE;AACA,qD;AACA,E;;AAEA,6D;AACA,iE;AACA,mE;AACA,qE;AACA,mD;AACA,c;;AAEA,4D;AACA,2D;AACA,8D;AACA,4D;AACA,iB;AACA,I;AACA,6D;AACA,8D;AACA,6D;AACA,4D;AACA,6B;AACA,qC;;AAEA,wD;AACA,4C;AACA,yD;AACA,uD;AACA,0D;AACA,sD;AACA,wD;AACA,gD;AACA,uB;AACA,yC;AACA,sC;AACA,a;AACA,8B;AACA,K;;AAEA,a;AACA,iC;;AAEA,+B;AACA,iD;AACA,I;AACA,yD;AACA,+C;AACA,gC;AACA,6B;AACA,e;AACA,kB;AACA,oB;AACA,mB;AACA,K;AACA,iB;AACA,I;AACA,uD;AACA,sD;AACA,iB;AACA,sC;AACA,sB;AACA,oF;AACA,I;AACA,gC;AACA,qB;AACA,4E;AACA,I;AACA,6B;AACA,gB;AACA,oF;AACA,G;AACA,G;;AAEA,yB;;AAEA,uB;AACA,2D;AACA,+D;AACA,2D;AACA,6D;AACA,4D;AACA,oC;AACA,I;AACA,qD;AACA,iD;AACA,6D;AACA,qD;AACA,qD;AACA,qD;AACA,4B;AACA,oB;AACA,Y;AACA,Y;AACA,yC;AACA,kB;AACA,+D;AACA,sB;AACA,qB;AACA,0D;AACA,iC;AACA,yC;AACA,e;;AAEA,yD;AACA,+C;AACA,4B;AACA,qD;AACA,2D;AACA,2B;;AAEA,sB;AACA,qD;AACA,0D;AACA,sD;AACA,wB;AACA,0D;;AAEA,e;AACA,2B;AACA,wD;AACA,oD;AACA,8B;AACA,4C;AACA,sD;AACA,oC;AACA,wB;AACA,Y;AACA,4B;AACA,K;;AAEA,yD;AACA,0D;AACA,uD;AACA,qD;AACA,4B;;AAEA,uB;AACA,mB;AACA,yB;;AAEA,c;AACA,wB;;AAEA,wD;AACA,sC;AACA,sC;AACA,mC;;AAEA,a;AACA,G;AACA,G;;AAEA,yD;AACA,wC;AACA,wD;AACA,0D;AACA,0D;AACA,sD;AACA,uC;AACA,oB;AACA,+D;AACA,E;AACA,sC;AACA,wC;AACA,I;;;AAGA,wE;AACA,sE;AACA,kB;AACA,qE;AACA,2C;AACA,2D;AACA,c;AACA,a;AACA,kC;AACA,yC;AACA,mD;AACA,U;AACA,8E;AACA,kF;AACA,sC;AACA,uC;AACA,e;AACA,oD;AACA,G;AACA,E;;AAEA,6C;AACA,gB;AACA,wC;AACA,kB;AACA,uB;AACA,G;AACA,c;AACA,E;;AAEA,oC;AACA,6C;AACA,gB;AACA,4C;AACA,qC;AACA,gB;AACA,E;;AAEA,0C;AACA,+D;AACA,e;AACA,mC;AACA,qC;;AAEA,sC;AACA,sD;AACA,uD;AACA,0D;AACA,yD;AACA,gC;AACA,sE;AACA,qC;AACA,U;AACA,qE;AACA,0B;AACA,yB;AACA,G;AACA,E;;AAEA,uB;AACA,iE;AACA,0B;AACA,4B;AACA,wB;AACA,I;AACA,2B;AACA,e;AACA,uC;AACA,4B;AACA,Q;AACA,mC;;AAEA,2C;AACA,uC;AACA,wE;AACA,yC;AACA,wC;AACA,+B;AACA,iB;;AAEA,sC;AACA,uC;AACA,uC;AACA,wC;AACA,wC;AACA,S;AACA,O;AACA,G;AACA,G;;AAEA,+D;AACA,uD;AACA,2C;AACA,kB;AACA,mD;AACA,0E;AACA,sD;AACA,0C;AACA,kE;AACA,mE;AACA,kE;AACA,gE;AACA,qE;AACA,iD;AACA,kD;AACA,4B;AACA,K;AACA,kE;AACA,iE;AACA,+D;AACA,2B;AACA,6C;AACA,2E;AACA,kD;AACA,qC;AACA,sC;AACA,wE;AACA,gE;AACA,4C;AACA,mE;AACA,sE;AACA,kD;AACA,+D;AACA,W;AACA,Q;;AAEA,4D;AACA,O;AACA,G;;AAEA,yC;AACA,sB;AACA,kC;AACA,mC;AACA,gD;AACA,O;AACA,G;;AAEA,sB;AACA,gD;AACA,iC;AACA,+B;AACA,qC;AACA,kD;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,c;AACA,uC;;;;;;;;;;;;;;;;;;;AC9VA,sB;;AAEA,0D;AACA,oD;AACA,sE;;AAEA,uB;AACA,mE;;AAEA,kC;;AAEA,sB;AACA,6B;;AAEA,+C;;AAEA,+C;AACA,qD;AACA,I;AACA,6D;AACA,qD;AACA,6D;AACA,U;;AAEA,sE;AACA,uE;AACA,4B;;AAEA,0E;AACA,wE;AACA,kE;AACA,sC;AACA,I;AACA,8E;AACA,wD;AACA,8C;AACA,uB;AACA,I;;AAEA,yE;AACA,0E;AACA,8E;AACA,gC;AACA,sD;AACA,kD;AACA,iD;;AAEA,+C;AACA,4D;AACA,K;;AAEA,qD;AACA,I;;AAEA,0D;AACA,0B;AACA,sB;AACA,4D;AACA,sB;AACA,kD;AACA,6B;AACA,qD;AACA,O;AACA,K;AACA,I;;AAEA,0C;AACA,gC;AACA,M;AACA,2D;AACA,6D;AACA,2C;AACA,qC;AACA,I;;AAEA,iD;AACA,uD;AACA,iD;AACA,4D;AACA,uC;AACA,I;;AAEA,iD;AACA,8C;AACA,8C;AACA,gB;AACA,kD;AACA,I;;AAEA,qD;AACA,4D;AACA,qC;AACA,wE;AACA,0C;AACA,I;;AAEA,gE;AACA,iC;AACA,I;;AAEA,2E;AACA,0B;;AAEA,oC;AACA,mC;AACA,yC;;AAEA,uE;AACA,wE;AACA,yE;AACA,mE;AACA,2E;AACA,4B;AACA,6C;AACA,2C;AACA,kC;AACA,M;;AAEA,wC;;AAEA,qC;AACA,qC;AACA,+C;AACA,I;;AAEA,mE;AACA,qC;AACA,oE;AACA,I;;AAEA,+C;AACA,2B;AACA,mC;AACA,oB;AACA,mC;AACA,gB;AACA,I;;AAEA,C;;;;;;;;;;;;;;;;;;AC1IA,O;AACA,2B;AACA,4B;AACA,8D;AACA,6B;AACA,+B;;AAEA,+B;;AAEA,+B;AACA,2B;AACA,qE;AACA,6C;AACA,Q;AACA,gC;AACA,E;;AAEA,6C;AACA,2B;AACA,yD;AACA,qD;AACA,Q;AACA,kE;AACA,uC;AACA,E;;AAEA,2C;AACA,2B;AACA,uD;AACA,mD;AACA,Q;AACA,kE;AACA,yC;AACA,E;;AAEA,2D;AACA,2D;AACA,iB;AACA,mC;AACA,oB;AACA,8B;AACA,sB;AACA,a;AACA,E;;AAEA,uC;AACA,a;AACA,iB;AACA,8C;AACA,yB;AACA,kB;AACA,e;AACA,E;;AAEA,4B;AACA,6C;AACA,kC;AACA,E;;AAEA,2C;AACA,6B;AACA,sC;AACA,+B;AACA,6B;AACA,yC;AACA,E;;AAEA,6B;AACA,6B;AACA,2C;AACA,W;AACA,2C;AACA,E;;AAEA,0C;AACA,uC;AACA,O;AACA,uB;AACA,gB;AACA,e;AACA,W;AACA,iB;AACA,G;AACA,K;;AAEA,wB;AACA,yB;AACA,yD;AACA,wD;;AAEA,sC;AACA,2B;AACA,4B;;AAEA,wB;AACA,kD;AACA,kD;AACA,gD;AACA,qD;AACA,gD;AACA,sD;AACA,mD;AACA,wD;AACA,0C;AACA,uB;AACA,gC;AACA,wC;AACA,wC;AACA,mC;;AAEA,wD;AACA,0D;AACA,4B;AACA,S;AACA,K;;AAEA,0D;AACA,uC;;AAEA,+B;AACA,gC;AACA,4B;AACA,2B;AACA,kC;AACA,2B;AACA,K;AACA,G;AACA,E;;AAEA,qC;AACA,0B;AACA,2B;;AAEA,yB;AACA,8C;;AAEA,wC;;AAEA,kC;AACA,sB;AACA,sB;;AAEA,0B;AACA,G;AACA,E;;AAEA,+C;AACA,uC;AACA,6C;AACA,iD;AACA,6B;;AAEA,qB;AACA,qC;AACA,G;AACA,E;;AAEA,uC;AACA,8B;AACA,0B;AACA,yB;AACA,gC;AACA,wB;AACA,Q;AACA,uB;AACA,G;AACA,E;;AAEA,iB;;AAEA,4B;AACA,iC;AACA,+B;AACA,sD;AACA,kC;;AAEA,qB;AACA,iB;AACA,mB;AACA,iB;;AAEA,oB;AACA,wB;AACA,oB;AACA,6B;AACA,yB;;AAEA,0B;AACA,yB;AACA,E;;AAEA,6B;AACA,yB;AACA,4B;AACA,gB;;AAEA,mB;;AAEA,yC;AACA,mB;AACA,4B;AACA,8B;AACA,2B;AACA,oB;AACA,iB;AACA,I;AACA,0B;AACA,4B;AACA,a;;AAEA,mB;;AAEA,0B;AACA,6B;AACA,mB;AACA,wC;AACA,8B;AACA,6B;AACA,0D;AACA,oB;AACA,K;AACA,iD;AACA,2B;;AAEA,yB;;AAEA,sB;AACA,I;AACA,4B;AACA,6D;AACA,+C;AACA,iC;AACA,wD;AACA,2D;AACA,mB;AACA,+C;AACA,kC;AACA,4B;AACA,gB;AACA,K;;AAEA,mE;AACA,4D;;AAEA,oC;AACA,0C;AACA,+C;AACA,c;AACA,uB;AACA,mF;AACA,qC;AACA,kE;AACA,qD;AACA,8C;AACA,wD;AACA,e;AACA,O;AACA,K;;AAEA,uC;AACA,qD;AACA,kC;AACA,qB;AACA,a;AACA,uD;AACA,2C;AACA,gC;AACA,sD;;AAEA,qC;AACA,qB;AACA,+B;AACA,Y;AACA,kB;AACA,oB;AACA,K;;AAEA,+B;AACA,qC;AACA,kC;AACA,0C;AACA,sC;AACA,iC;AACA,uD;AACA,6B;AACA,gC;AACA,iC;AACA,gB;AACA,mE;AACA,S;AACA,c;AACA,qC;AACA,gC;AACA,gD;AACA,+B;AACA,6B;AACA,gB;AACA,mE;AACA,S;AACA,O;AACA,K;;AAEA,wC;AACA,c;AACA,4B;AACA,yB;AACA,mC;;AAEA,4C;AACA,oD;AACA,iC;AACA,mD;;AAEA,8B;AACA,4C;AACA,mD;;AAEA,0B;AACA,6B;AACA,Y;AACA,a;AACA,iD;AACA,sD;AACA,2B;AACA,qD;AACA,qC;AACA,8B;AACA,wB;;AAEA,2C;AACA,oD;AACA,iC;AACA,mD;;AAEA,8B;AACA,6C;AACA,K;AACA,I;AACA,yB;AACA,qB;AACA,oB;AACA,uB;AACA,6B;AACA,2B;AACA,wB;AACA,yB;AACA,a;AACA,K;;AAEA,gB;AACA,kB;AACA,+B;AACA,+C;AACA,+B;AACA,uB;;AAEA,gC;AACA,iB;AACA,a;;AAEA,uC;AACA,qD;AACA,kC;AACA,qB;AACA,a;;AAEA,qC;AACA,c;AACA,yB;AACA,yB;AACA,oD;AACA,0C;AACA,gD;AACA,wB;AACA,Y;AACA,a;AACA,wB;AACA,qD;AACA,yC;AACA,yB;AACA,K;AACA,I;AACA,uC;AACA,oD;AACA,gB;AACA,kB;AACA,+B;AACA,gB;AACA,wC;AACA,wB;AACA,0C;AACA,iB;AACA,a;;AAEA,uC;AACA,qD;AACA,kC;AACA,qB;AACA,a;;AAEA,qC;AACA,c;AACA,yB;AACA,4D;AACA,kC;AACA,kD;AACA,wB;AACA,qC;AACA,8C;AACA,mD;AACA,O;AACA,Y;AACA,a;AACA,wB;AACA,2C;AACA,K;AACA,I;AACA,sB;AACA,gB;AACA,kB;AACA,+B;AACA,mC;AACA,yB;AACA,gB;AACA,I;AACA,2B;AACA,iC;AACA,I;AACA,0B;AACA,sB;AACA,I;AACA,wB;AACA,oB;AACA,I;AACA,8C;AACA,+B;AACA,uC;AACA,4B;AACA,uD;AACA,2B;AACA,oC;AACA,gB;AACA,wB;AACA,oD;AACA,uD;AACA,gB;AACA,6B;AACA,oC;AACA,8B;AACA,S;AACA,c;AACA,e;AACA,uB;AACA,6C;AACA,oD;AACA,gB;AACA,oC;AACA,4B;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,uD;;AAEA,iD;AACA,oD;AACA,mD;AACA,qD;AACA,oD;AACA,a;AACA,I;AACA,yD;AACA,0D;AACA,0D;AACA,uD;AACA,yD;AACA,qD;AACA,6C;AACA,I;AACA,8C;AACA,mD;AACA,+C;AACA,gD;AACA,oD;AACA,qD;AACA,oD;AACA,sD;AACA,iD;AACA,sD;AACA,qD;AACA,I;AACA,uD;AACA,uD;AACA,qD;AACA,iD;AACA,sD;AACA,0C;AACA,wB;;AAEA,uC;AACA,qB;AACA,a;;AAEA,6C;AACA,kC;AACA,0B;AACA,0C;AACA,kD;AACA,mD;AACA,mD;AACA,sB;AACA,wB;AACA,yB;AACA,uB;AACA,yB;AACA,qC;AACA,sB;AACA,mB;AACA,gC;AACA,sC;AACA,6B;AACA,O;AACA,yB;AACA,sB;AACA,wB;AACA,mB;AACA,O;;AAEA,yB;AACA,wB;;AAEA,2B;AACA,+B;AACA,kC;AACA,qB;AACA,6B;AACA,4B;AACA,6B;AACA,oC;AACA,iC;AACA,O;AACA,Y;AACA,+D;AACA,iE;AACA,gE;AACA,oD;AACA,Q;AACA,2D;AACA,uD;AACA,yD;AACA,wD;AACA,Q;AACA,8D;AACA,6D;AACA,iE;AACA,+D;AACA,4C;AACA,2C;;AAEA,sB;AACA,uB;AACA,qC;AACA,mC;AACA,oC;AACA,kC;AACA,yC;AACA,mC;AACA,yC;AACA,2C;AACA,yC;AACA,yD;AACA,kD;AACA,0B;AACA,qD;AACA,yD;AACA,sD;AACA,mD;AACA,8B;AACA,yC;AACA,oD;AACA,6D;AACA,6C;AACA,mC;AACA,6B;AACA,a;AACA,W;AACA,kC;AACA,mB;AACA,4C;AACA,4B;AACA,kB;AACA,oB;AACA,+C;AACA,kC;AACA,4C;AACA,gC;AACA,4B;AACA,W;AACA,S;AACA,O;AACA,K;AACA,oB;AACA,mD;AACA,kD;AACA,uB;AACA,iB;AACA,6C;AACA,sC;AACA,sC;AACA,sB;AACA,iB;AACA,wC;AACA,sC;AACA,sC;AACA,qB;AACA,sC;AACA,mC;AACA,8B;AACA,0C;AACA,gC;AACA,wC;AACA,uC;AACA,K;AACA,I;AACA,0C;AACA,+B;AACA,uC;;AAEA,qB;AACA,mD;AACA,mD;AACA,wD;AACA,mD;AACA,qD;AACA,6D;AACA,Q;AACA,gD;AACA,+C;AACA,kD;AACA,sB;AACA,K;;AAEA,sB;AACA,8B;AACA,gC;;AAEA,kC;AACA,c;AACA,sB;AACA,kD;AACA,sB;AACA,wB;AACA,2B;AACA,c;AACA,2B;AACA,4B;AACA,O;AACA,Y;AACA,a;AACA,qB;AACA,yC;AACA,mC;AACA,U;AACA,0B;AACA,K;;AAEA,wB;AACA,6B;AACA,uB;AACA,oB;AACA,G;AACA,G;;AAEA,oD;AACA,gC;AACA,mC;AACA,4B;AACA,2B;AACA,uB;AACA,8B;AACA,K;AACA,mB;AACA,E;;AAEA,sD;;AAEA,gD;AACA,+B;AACA,mD;AACA,8B;AACA,E;AACA,M;AACA,gB;AACA,U;AACA,gB;AACA,Y;AACA,M;AACA,E;AACA,iD;AACA,2D;AACA,uC;AACA,8C;;AAEA,+C;AACA,uB;AACA,E;;AAEA,6C;AACA,yB;AACA,kC;AACA,8B;AACA,qC;AACA,sB;AACA,gC;AACA,G;AACA,uB;AACA,E;;AAEA,kD;AACA,0D;AACA,+B;AACA,wC;AACA,uD;AACA,wC;AACA,+C;AACA,uB;AACA,E;;AAEA,sD;AACA,kC;AACA,iC;;AAEA,uC;;AAEA,iB;AACA,wB;AACA,6B;AACA,wB;AACA,G;AACA,c;AACA,E;;AAEA,8C;AACA,E;AACA,qD;AACA,yD;AACA,gE;AACA,4D;AACA,gB;AACA,E;AACA,yE;AACA,yD;AACA,kC;AACA,iB;;AAEA,iC;AACA,wB;AACA,6D;AACA,iC;AACA,oD;AACA,uB;AACA,c;AACA,O;AACA,K;AACA,kB;AACA,mB;AACA,U;AACA,4B;AACA,oD;AACA,mB;AACA,G;;AAEA,c;AACA,E;;AAEA,+C;AACA,mC;AACA,sD;AACA,gB;AACA,wD;AACA,6C;AACA,G;AACA,e;AACA,E;;AAEA,gD;AACA,qB;AACA,wB;;AAEA,iD;AACA,iD;AACA,qD;AACA,wC;AACA,gC;;AAEA,iD;AACA,4B;;AAEA,e;AACA,E;;AAEA,sB;;AAEA,qD;AACA,mB;AACA,kD;;AAEA,qC;AACA,mB;AACA,iB;;AAEA,Y;AACA,uC;AACA,gB;AACA,uB;AACA,gC;AACA,a;AACA,mB;AACA,oD;AACA,kB;AACA,0B;AACA,+B;AACA,uB;AACA,yC;AACA,sD;AACA,e;AACA,U;AACA,W;AACA,0B;AACA,4C;AACA,mB;;AAEA,0C;AACA,6B;;AAEA,qB;AACA,G;;AAEA,mD;AACA,6B;;AAEA,iC;AACA,wB;;AAEA,wB;AACA,E;;AAEA,4C;AACA,kB;;AAEA,qC;AACA,mB;AACA,wD;;AAEA,0D;AACA,0D;AACA,8D;AACA,wD;AACA,2D;AACA,0D;AACA,4B;;AAEA,4D;AACA,4C;AACA,0D;AACA,iC;AACA,6D;;AAEA,gE;;AAEA,4D;AACA,6D;AACA,sD;AACA,e;;;AAGA,0D;AACA,yD;AACA,kB;AACA,oC;AACA,0D;AACA,wD;AACA,iC;AACA,kB;;AAEA,+B;AACA,I;;AAEA,yB;AACA,iD;AACA,0C;AACA,wB;AACA,8C;AACA,yB;AACA,wB;AACA,2B;AACA,K;AACA,yB;AACA,U;AACA,mE;AACA,yC;AACA,G;;AAEA,iB;AACA,E;;;AAGA,Y;;AAEA,oD;AACA,oD;AACA,qD;AACA,kB;AACA,E;AACA,mC;AACA,sD;AACA,kD;AACA,wB;AACA,qD;AACA,kC;AACA,E;;AAEA,uB;AACA,4B;AACA,6B;;AAEA,gE;AACA,mB;AACA,mB;AACA,2B;AACA,yB;AACA,iB;;AAEA,6B;;AAEA,wD;AACA,0D;AACA,0B;AACA,I;AACA,wD;AACA,8C;AACA,yC;AACA,2B;AACA,6D;AACA,gD;AACA,e;AACA,8C;AACA,e;AACA,wC;AACA,M;AACA,W;;AAEA,oD;AACA,iC;AACA,wD;AACA,qD;AACA,qD;AACA,sD;AACA,8C;;AAEA,6C;AACA,2C;AACA,4C;;AAEA,qB;AACA,2C;AACA,6B;AACA,wC;AACA,6C;AACA,4B;AACA,mD;AACA,gC;AACA,yC;AACA,2C;AACA,kD;AACA,mB;AACA,kB;AACA,iD;AACA,mD;AACA,mC;AACA,0C;AACA,wC;AACA,kD;AACA,W;AACA,S;;AAEA,gC;AACA,Q;AACA,a;;AAEA,U;AACA,oC;AACA,G;AACA,E;;AAEA,yC;AACA,sE;AACA,gE;AACA,4D;AACA,0C;AACA,iC;AACA,iD;AACA,6B;AACA,G;;AAEA,yC;AACA,8B;AACA,2B;AACA,mD;AACA,E;;AAEA,2C;AACA,wC;AACA,wD;AACA,0D;;AAEA,yC;AACA,qD;AACA,uD;AACA,E;;;AAGA,0D;AACA,+D;AACA,8D;AACA,qC;AACA,mB;AACA,8C;AACA,W;AACA,kC;AACA,iC;AACA,qE;;AAEA,sB;AACA,0C;AACA,uB;AACA,K;;AAEA,sD;AACA,yB;AACA,uB;AACA,oB;AACA,0B;AACA,0B;AACA,oB;AACA,G;;AAEA,sD;AACA,6B;;AAEA,0C;AACA,oB;AACA,+C;;AAEA,+B;AACA,iB;AACA,kC;AACA,yB;AACA,K;AACA,oC;AACA,oC;AACA,iD;AACA,sB;AACA,iC;AACA,+C;AACA,8C;AACA,mC;AACA,8C;AACA,yB;AACA,+B;AACA,0B;AACA,qB;AACA,mB;AACA,4D;AACA,8B;AACA,6C;AACA,gD;AACA,S;AACA,O;AACA,K;AACA,G;AACA,E;;AAEA,iE;AACA,yC;AACA,oC;AACA,mB;AACA,gB;AACA,mB;;AAEA,oC;AACA,iD;AACA,Y;AACA,qE;AACA,gF;AACA,sE;AACA,+C;AACA,uB;AACA,+C;AACA,qB;AACA,kB;AACA,oB;;AAEA,2B;AACA,K;AACA,I;;;AAGA,uB;;;;;;;;;;;;;;;;;;;ACplCA,gF;AACA,kE;AACA,uE;AACA,sB;AACA,E;AACA,gD;AACA,uE;AACA,4E;AACA,yE;AACA,uE;AACA,0E;AACA,yE;AACA,wE;AACA,sE;AACA,0E;AACA,+B;AACA,E;AACA,2E;AACA,kE;AACA,E;AACA,4E;AACA,0D;;AAEA,2C;AACA,mB;AACA,qB;AACA,E;;AAEA,sC;AACA,+C;AACA,yB;AACA,4B;AACA,2C;AACA,Y;AACA,kD;AACA,K;AACA,G;AACA,G;;AAEA,8C;AACA,qB;AACA,iE;AACA,4C;AACA,I;AACA,kC;AACA,kC;AACA,c;AACA,yC;AACA,iB;AACA,E;;AAEA,0D;AACA,gD;AACA,+C;AACA,gD;AACA,2E;;AAEA,oE;AACA,8D;;AAEA,gE;AACA,sE;;AAEA,qE;AACA,qC;AACA,uC;AACA,wC;AACA,O;AACA,qC;AACA,yC;AACA,oC;AACA,wB;AACA,O;;AAEA,8C;AACA,G;AACA,G;;AAEA,4C;AACA,6B;AACA,uC;AACA,6B;AACA,I;AACA,2C;AACA,kC;AACA,G;AACA,G;;AAEA,+C;AACA,uC;AACA,qC;AACA,I;AACA,2C;AACA,6C;AACA,G;AACA,G;;AAEA,8C;AACA,+C;AACA,yB;AACA,wB;AACA,2B;AACA,8B;AACA,Y;AACA,2B;AACA,K;AACA,G;AACA,G;;AAEA,4C;AACA,+C;AACA,uD;;AAEA,iB;AACA,4B;AACA,G;AACA,G;;AAEA,mD;AACA,oC;AACA,mC;AACA,E;;AAEA,iE;AACA,qD;AACA,sE;AACA,kE;AACA,yB;AACA,6B;AACA,8C;AACA,Y;AACA,2C;AACA,K;AACA,yD;AACA,2C;AACA,sE;AACA,mC;AACA,8D;AACA,kC;AACA,yC;AACA,U;AACA,6C;AACA,G;;AAEA,gE;AACA,oC;AACA,E;;;;;;;;;;;;;;;;;;;;AClJA,8C;AACA,kB;;AAEA,oB;AACA,6B;AACA,sB;AACA,uE;AACA,U;AACA,+C;AACA,G;;AAEA,+C;AACA,uB;;AAEA,kC;AACA,2B;AACA,kC;AACA,2C;AACA,kC;AACA,M;AACA,+B;AACA,0C;AACA,+B;AACA,M;AACA,oB;AACA,mB;AACA,e;AACA,uB;AACA,I;;AAEA,iC;;AAEA,gB;AACA,gB;;AAEA,qB;AACA,iC;AACA,6C;AACA,G;;AAEA,c;AACA,E;;AAEA,mC;AACA,c;AACA,E;;;AAGA,8E;AACA,8E;AACA,oD;AACA,E;AACA,yE;AACA,yE;AACA,uE;AACA,0E;AACA,2E;AACA,yE;AACA,4E;AACA,kB;AACA,E;AACA,0E;AACA,0E;AACA,qE;AACA,sE;AACA,yE;AACA,8D;AACA,E;AACA,0E;AACA,oE;AACA,uE;AACA,wE;AACA,0E;AACA,2E;AACA,2E;AACA,4E;AACA,sD;AACA,E;AACA,4E;AACA,8E;AACA,E;AACA,gD;AACA,0C;AACA,2B;;AAEA,yB;AACA,uE;AACA,mE;AACA,qE;AACA,c;AACA,yB;AACA,2B;;AAEA,wB;AACA,0B;AACA,4B;AACA,0E;AACA,4D;AACA,wB;AACA,S;;AAEA,2E;AACA,6E;AACA,uC;AACA,wC;;AAEA,oD;AACA,4C;AACA,sC;AACA,+B;AACA,+B;AACA,4D;AACA,8C;AACA,oC;AACA,a;AACA,a;AACA,W;AACA,O;;AAEA,wB;AACA,uC;AACA,oB;AACA,+E;AACA,wE;AACA,yD;AACA,yC;AACA,2D;AACA,2C;AACA,8E;AACA,wE;AACA,qE;AACA,6C;AACA,iE;AACA,uC;AACA,uC;AACA,qC;AACA,mB;AACA,mB;AACA,iB;AACA,a;AACA,a;AACA,S;AACA,O;;AAEA,uB;AACA,M;;AAEA,U;AACA,4B;AACA,8B;AACA,mB;AACA,M;AACA,qC;AACA,kB;AACA,G;AACA,E;;;AAGA,wC;;AAEA,gE;AACA,E;AACA,gF;AACA,yC;AACA,iD;AACA,4C;AACA,E;AACA,+E;AACA,kC;AACA,qD;AACA,e;AACA,uD;;AAEA,sC;AACA,oC;AACA,kD;AACA,8C;AACA,oD;AACA,U;AACA,iD;AACA,sE;AACA,G;AACA,E;;AAEA,mE;AACA,iD;AACA,E;AACA,uE;AACA,sE;AACA,uC;AACA,2D;;AAEA,iB;AACA,6B;AACA,yC;AACA,+D;AACA,8D;AACA,2D;AACA,wD;AACA,8B;AACA,kC;AACA,qC;AACA,6B;AACA,6C;AACA,2B;AACA,O;AACA,K;AACA,G;;AAEA,2B;AACA,uB;AACA,iB;AACA,4B;AACA,yD;AACA,2B;AACA,2B;AACA,uD;AACA,qB;AACA,gC;AACA,wB;AACA,O;AACA,Y;AACA,4B;AACA,+B;AACA,K;AACA,wC;AACA,4B;AACA,4C;AACA,yB;AACA,2B;AACA,K;AACA,G;AACA,E;;AAEA,8C;AACA,oB;AACA,4E;AACA,+C;;AAEA,+C;;AAEA,8B;AACA,mB;AACA,yB;;AAEA,0C;;AAEA,+B;AACA,4B;AACA,yB;AACA,mC;AACA,iD;AACA,K;AACA,I;;AAEA,c;AACA,E;;AAEA,qC;AACA,8B;AACA,4D;AACA,yB;AACA,uB;AACA,U;AACA,uB;AACA,6D;AACA,gC;AACA,G;AACA,E;;AAEA,uD;AACA,6C;AACA,2B;AACA,yD;;AAEA,sC;AACA,iC;AACA,iC;;AAEA,6B;AACA,yB;AACA,E;;AAEA,kE;AACA,mD;AACA,E;;AAEA,4E;AACA,6D;AACA,E;;AAEA,uE;AACA,yE;AACA,oE;AACA,qF;AACA,oF;AACA,0E;;AAEA,qB;AACA,yB;AACA,mB;AACA,uG;AACA,wB;AACA,0D;AACA,qC;AACA,yC;AACA,4D;AACA,0C;;AAEA,gC;AACA,2B;AACA,kD;AACA,2B;AACA,0D;AACA,gC;AACA,uB;AACA,kE;AACA,6B;;AAEA,sD;AACA,kD;AACA,8B;;AAEA,yB;AACA,4B;;AAEA,sC;AACA,6D;AACA,W;AACA,O;AACA,O;AACA,iC;AACA,0B;AACA,M;AACA,kC;AACA,wC;AACA,uD;AACA,a;AACA,8E;AACA,mC;AACA,6E;AACA,Y;AACA,kD;AACA,K;;AAEA,8B;AACA,iC;AACA,sC;AACA,kC;AACA,gC;AACA,oB;AACA,M;;AAEA,mB;AACA,mD;AACA,yB;AACA,0B;;AAEA,a;AACA,yE;AACA,+B;AACA,sB;AACA,kC;AACA,0E;AACA,4D;AACA,a;AACA,4D;AACA,W;AACA,qB;AACA,+B;AACA,S;AACA,S;AACA,uD;AACA,2B;AACA,S;AACA,K;AACA,uD;;AAEA,iC;AACA,sD;AACA,gB;AACA,oD;;AAEA,yC;AACA,4C;AACA,8D;AACA,4C;AACA,wE;AACA,wC;AACA,mE;AACA,wB;AACA,wD;AACA,8C;AACA,2C;AACA,8D;AACA,oF;AACA,kD;AACA,8D;AACA,U;AACA,qB;AACA,0D;AACA,G;AACA,E;;;;AAIA,4D;AACA,0D;AACA,6B;;AAEA,+B;AACA,e;AACA,mB;AACA,uB;AACA,6B;AACA,I;AACA,gC;AACA,qB;AACA,G;;AAEA,kC;AACA,qD;AACA,E;;AAEA,iD;AACA,+C;AACA,E;;AAEA,oD;AACA,qE;AACA,E;;;;;;;;;;;;;;;;;;;;AC9aA,4D;AACA,2E;;AAEA,sB;AACA,8B;AACA,0B;AACA,Q;AACA,sC;AACA,I;AACA,E;;;AAGA,gE;AACA,+E;;AAEA,sB;AACA,gC;AACA,0B;AACA,Q;AACA,sC;AACA,I;AACA,E;;AAEA,4E;AACA,6E;AACA,8E;AACA,mC;AACA,kC;AACA,c;AACA,iB;AACA,M;AACA,0E;AACA,qC;AACA,E;;AAEA,wE;AACA,E;AACA,yE;AACA,wE;AACA,gB;AACA,4C;AACA,2D;;AAEA,2B;AACA,wB;AACA,8D;AACA,kC;AACA,0B;AACA,O;AACA,G;AACA,kD;;AAEA,e;AACA,E;;AAEA,8D;AACA,6E;;AAEA,6B;AACA,wB;AACA,4B;AACA,mC;AACA,K;AACA,E;;AAEA,2F;AACA,oC;AACA,0E;AACA,qC;AACA,uF;AACA,6D;AACA,iG;AACA,E;;AAEA,yC;AACA,E;AACA,oC;AACA,8D;AACA,yD;AACA,6C;AACA,wC;AACA,uD;AACA,sD;AACA,wD;AACA,uD;AACA,uD;AACA,wC;AACA,+B;;AAEA,gD;AACA,mD;AACA,mB;AACA,Q;AACA,qB;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AChGA,gC;AACA,mB;AACA,+B;AACA,oB;AACA,iC;AACA,yC;;AAEA,gC;AACA,2D;AACA,yD;AACA,yD;AACA,yD;AACA,iC;AACA,Q;AACA,2D;AACA,2D;AACA,0D;AACA,uD;AACA,0D;AACA,2D;AACA,2D;AACA,6D;AACA,wB;AACA,iD;AACA,yB;AACA,oD;AACA,wB;AACA,c;AACA,W;;AAEA,yB;AACA,qB;AACA,c;AACA,2B;AACA,O;AACA,mB;AACA,Y;AACA,kB;AACA,K;AACA,I;AACA,yB;AACA,kC;;AAEA,yB;;AAEA,iC;AACA,yC;;AAEA,8D;AACA,sE;AACA,+D;AACA,sB;AACA,sC;AACA,qE;AACA,e;;AAEA,gC;AACA,8D;;AAEA,4B;AACA,6B;AACA,0B;AACA,O;AACA,yB;AACA,4B;AACA,uD;AACA,O;AACA,M;;AAEA,8D;AACA,+B;AACA,Q;AACA,iD;AACA,sB;AACA,8C;;AAEA,wB;AACA,sC;;AAEA,yC;AACA,oC;AACA,uB;AACA,sB;AACA,U;AACA,gD;AACA,oC;AACA,sC;AACA,mB;AACA,wB;AACA,U;;AAEA,qB;AACA,4D;;AAEA,6E;AACA,kD;AACA,Q;AACA,oC;AACA,uB;AACA,uD;AACA,Q;AACA,oD;AACA,yB;AACA,2C;AACA,8D;AACA,Q;AACA,uC;AACA,iF;AACA,O;AACA,O;;AAEA,+D;AACA,oB;AACA,I;AACA,0B;AACA,2B;AACA,gC;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;;ACrHA,8C;;AAEA,yD;AACA,6D;AACA,iD;AACA,2C;AACA,yC;AACA,mC;AACA,kC;AACA,gB;AACA,E;;AAEA,4D;AACA,yB;AACA,sC;AACA,e;AACA,uB;AACA,0B;AACA,G;AACA,G;;AAEA,sE;AACA,c;AACA,yB;AACA,qB;AACA,4B;AACA,0B;AACA,E;;AAEA,uB;AACA,a;AACA,I;AACA,sE;AACA,uC;AACA,+B;AACA,oB;AACA,yC;AACA,e;AACA,a;;AAEA,Y;AACA,gD;;AAEA,yB;AACA,qE;AACA,4C;AACA,gC;AACA,yE;AACA,O;;AAEA,6D;AACA,2C;AACA,gG;AACA,O;;AAEA,uD;;AAEA,0D;AACA,kD;AACA,yC;AACA,4B;;AAEA,8C;AACA,mC;;AAEA,gE;AACA,6D;AACA,W;AACA,M;AACA,wD;AACA,wD;AACA,4D;AACA,0B;AACA,6B;AACA,0C;AACA,6C;AACA,4C;AACA,kD;AACA,yB;AACA,W;AACA,iD;AACA,0B;;AAEA,+C;AACA,yD;AACA,oE;AACA,oE;AACA,mB;AACA,6C;;AAEA,Y;AACA,4D;AACA,uC;AACA,0C;AACA,mB;AACA,sB;AACA,8B;AACA,yC;AACA,+C;AACA,sB;AACA,Q;AACA,K;;AAEA,sE;AACA,gF;AACA,sE;AACA,0E;AACA,uC;AACA,0C;AACA,6C;AACA,Q;AACA,Y;AACA,oB;AACA,M;AACA,I;AACA,iC;AACA,6C;AACA,I;AACA,sB;AACA,oD;AACA,yB;AACA,e;;AAEA,iC;AACA,8D;AACA,I;AACA,6B;AACA,+C;AACA,6B;AACA,iD;AACA,uC;AACA,qD;AACA,oB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACvIA,c;AACA,qB;;AAEA,yC;AACA,qC;AACA,G;AACA,E;;AAEA,mC;AACA,kC;AACA,oB;AACA,gB;AACA,gB;AACA,kB;AACA,kB;AACA,kE;AACA,gB;AACA,I;AACA,gC;AACA,yB;AACA,I;;AAEA,uB;AACA,8C;AACA,I;AACA,K;;AAEA,qE;AACA,iC;AACA,0C;AACA,uB;AACA,E;AACA,uD;AACA,gC;AACA,E","sourcesContent":["\nvar debugFunc;\n\n// Meteor UI calls into user code in many places, and it's nice to catch exceptions\n// propagated from user code immediately so that the whole system doesn't just\n// break.  Catching exceptions is easy; reporting them is hard.  This helper\n// reports exceptions.\n//\n// Usage:\n//\n// ```\n// try {\n//   // ... someStuff ...\n// } catch (e) {\n//   reportUIException(e);\n// }\n// ```\n//\n// An optional second argument overrides the default message.\n\nreportUIException = function (e, msg) {\n  if (! debugFunc)\n    // adapted from Deps\n    debugFunc = function () {\n      return (typeof Meteor !== \"undefined\" ? Meteor._debug :\n              ((typeof console !== \"undefined\") && console.log ? console.log :\n               function () {}));\n    };\n\n  // In Chrome, `e.stack` is a multiline string that starts with the message\n  // and contains a stack trace.  Furthermore, `console.log` makes it clickable.\n  // `console.log` supplies the space between the two arguments.\n  debugFunc()(msg || 'Exception in Meteor UI:', e.stack || e.message);\n};\n","UI = {};\n\n// A very basic operation like Underscore's `_.extend` that\n// copies `src`'s own, enumerable properties onto `tgt` and\n// returns `tgt`.\n_extend = function (tgt, src) {\n  for (var k in src)\n    if (src.hasOwnProperty(k))\n      tgt[k] = src[k];\n  return tgt;\n};\n\n// Defines a single non-enumerable, read-only property\n// on `tgt`.\n// It won't be non-enumerable in IE 8, so its\n// non-enumerability can't be relied on for logic\n// purposes, it just makes things prettier in\n// the dev console.\nvar _defineNonEnum = function (tgt, name, value) {\n  try {\n    Object.defineProperty(tgt, name, {value: value});\n  } catch (e) {\n    // IE < 9\n    tgt[name] = value;\n  }\n  return tgt;\n};\n\n// Make `typeName` a non-empty string starting with an ASCII\n// letter or underscore and containing only letters, underscores,\n// and numbers.  This makes it safe to insert into evaled JS\n// code.\nvar sanitizeTypeName = function (typeName) {\n  return String(typeName).replace(/^[^a-zA-Z_]|[^a-zA-Z_0-9]+/g,\n                                  '') || 'Component';\n};\n\n// Named function (like `function Component() {}` below) make\n// inspection in debuggers more descriptive. In IE, this sets the\n// value of the `Component` var in the function scope in which it's\n// executed. We already have a top-level `Component` var so we create\n// a new function scope to not write it over in IE.\n(function () {\n\n  // Components and Component kinds are the same thing, just\n  // objects; there are no constructor functions, no `new`,\n  // and no `instanceof`.  A Component object is like a class,\n  // until it is inited, at which point it becomes more like\n  // an instance.\n  //\n  // `y = x.extend({ ...new props })` creates a new Component\n  // `y` with `x` as its prototype, plus additional properties\n  // on `y` itself.  `extend` is used both to subclass and to\n  // create instances (and the hope is we can gloss over the\n  // difference in the docs).\n  UI.Component = (function (constr) {\n\n    // Make sure the \"class name\" that Chrome infers for\n    // UI.Component is \"Component\", and that\n    // `new UI.Component._constr` (which is what `extend`\n    // does) also produces objects whose inferred class\n    // name is \"Component\".  Chrome's name inference rules\n    // are a little mysterious, but a function name in\n    // the source code (as in `function Component() {}`)\n    // seems to be reliable and high precedence.\n    var C = new constr;\n    _defineNonEnum(C, '_constr', constr);\n    _defineNonEnum(C, '_super', null);\n    return C;\n  })(function Component() {});\n})();\n\n_extend(UI, {\n  nextGuid: 2, // Component is 1!\n\n  isComponent: function (obj) {\n    return obj && UI.isKindOf(obj, UI.Component);\n  },\n  // `UI.isKindOf(a, b)` where `a` and `b` are Components\n  // (or kinds) asks if `a` is or descends from\n  // (transitively extends) `b`.\n  isKindOf: function (a, b) {\n    while (a) {\n      if (a === b)\n        return true;\n      a = a._super;\n    }\n    return false;\n  },\n  // use these to produce error messages for developers\n  // (though throwing a more specific error message is\n  // even better)\n  _requireNotDestroyed: function (c) {\n    if (c.isDestroyed)\n      throw new Error(\"Component has been destroyed; can't perform this operation\");\n  },\n  _requireInited: function (c) {\n    if (! c.isInited)\n      throw new Error(\"Component must be inited to perform this operation\");\n  },\n  _requireDom: function (c) {\n    if (! c.dom)\n      throw new Error(\"Component must be built into DOM to perform this operation\");\n  }\n});\n\nComponent = UI.Component;\n\n_extend(UI.Component, {\n  // If a Component has a `kind` property set via `extend`,\n  // we make it use that name when printed in Chrome Dev Tools.\n  // If you then extend this Component and don't supply any\n  // new `kind`, it should use the same value of kind (or the\n  // most specific one in the case of an `extend` chain with\n  // `kind` set at multiple points).\n  //\n  // To accomplish this, keeping performance in mind,\n  // any Component where `kind` is explicitly set\n  // also has a function property `_constr` whose source-code\n  // name is `kind`.  `extend` creates this `_constr`\n  // function, which can then be used internally as a\n  // constructor to quickly create new instances that\n  // pretty-print correctly.\n  kind: \"Component\",\n  guid: \"1\",\n  dom: null,\n  // Has this Component ever been inited?\n  isInited: false,\n  // Has this Component been destroyed?  Only inited Components\n  // can be destroyed.\n  isDestroyed: false,\n  // Component that created this component (typically also\n  // the DOM containment parent).\n  // No child pointers (except in `dom`).\n  parent: null,\n\n  // create a new subkind or instance whose proto pointer\n  // points to this, with additional props set.\n  extend: function (props) {\n    // this function should never cause `props` to be\n    // mutated in case people want to reuse `props` objects\n    // in a mixin-like way.\n\n    if (this.isInited)\n      // Disallow extending inited Components so that\n      // inited Components don't inherit instance-specific\n      // properties from other inited Components, just\n      // default values.\n      throw new Error(\"Can't extend an inited Component\");\n\n    var constr;\n    var constrMade = false;\n    // Any Component with a kind of \"Foo\" (say) is given\n    // a `._constr` of the form `function Foo() {}`.\n    if (props && props.kind) {\n      constr = Function(\"return function \" +\n                        sanitizeTypeName(props.kind) +\n                        \"() {};\")();\n      constrMade = true;\n    } else {\n      constr = this._constr;\n    }\n\n    // We don't know where we're getting `constr` from --\n    // it might be from some supertype -- just that it has\n    // the right function name.  So set the `prototype`\n    // property each time we use it as a constructor.\n    constr.prototype = this;\n\n    var c = new constr;\n    if (constrMade)\n      c._constr = constr;\n\n    if (props)\n      _extend(c, props);\n\n    // for efficient Component instantiations, we assign\n    // as few things as possible here.\n    _defineNonEnum(c, '_super', this);\n    c.guid = String(UI.nextGuid++);\n\n    return c;\n  }\n});\n\n//callChainedCallback = function (comp, propName, orig) {\n  // Call `comp.foo`, `comp._super.foo`,\n  // `comp._super._super.foo`, and so on, but in reverse\n  // order, and only if `foo` is an \"own property\" in each\n  // case.  Furthermore, the passed value of `this` should\n  // remain `comp` for all calls (which is achieved by\n  // filling in `orig` when recursing).\n//  if (comp._super)\n//    callChainedCallback(comp._super, propName, orig || comp);\n//\n//  if (comp.hasOwnProperty(propName))\n//    comp[propName].call(orig || comp);\n//};\n\n\n// Returns 0 if the nodes are the same or either one contains the other;\n// otherwise, -1 if a comes before b, or else 1 if b comes before a in\n// document order.\n// Requires: `a` and `b` are element nodes in the same document tree.\nvar compareElementIndex = function (a, b) {\n  // See http://ejohn.org/blog/comparing-document-position/\n  if (a === b)\n    return 0;\n  if (a.compareDocumentPosition) {\n    var n = a.compareDocumentPosition(b);\n    return ((n & 0x18) ? 0 : ((n & 0x4) ? -1 : 1));\n  } else {\n    // Only old IE is known to not have compareDocumentPosition (though Safari\n    // originally lacked it).  Thankfully, IE gives us a way of comparing elements\n    // via the \"sourceIndex\" property.\n    if (a.contains(b) || b.contains(a))\n      return 0;\n    return (a.sourceIndex < b.sourceIndex ? -1 : 1);\n  }\n};\n\nfindComponentWithProp = function (id, comp) {\n  while (comp) {\n    if (typeof comp[id] !== 'undefined')\n      return comp;\n    comp = comp.parent;\n  }\n  return null;\n};\n\ngetComponentData = function (comp) {\n  comp = findComponentWithProp('data', comp);\n  return (comp ?\n          (typeof comp.data === 'function' ?\n           comp.data() : comp.data) :\n          null);\n};\n\nupdateTemplateInstance = function (comp) {\n  // Populate `comp.templateInstance.{firstNode,lastNode,data}`\n  // on demand.\n  var tmpl = comp.templateInstance;\n  tmpl.data = getComponentData(comp);\n\n  if (comp.dom && !comp.isDestroyed) {\n    tmpl.firstNode = comp.dom.startNode().nextSibling;\n    tmpl.lastNode = comp.dom.endNode().previousSibling;\n    // Catch the case where the DomRange is empty and we'd\n    // otherwise pass the out-of-order nodes (end, start)\n    // as (firstNode, lastNode).\n    if (tmpl.lastNode && tmpl.lastNode.nextSibling === tmpl.firstNode)\n      tmpl.lastNode = tmpl.firstNode;\n  } else {\n    // on 'created' or 'destroyed' callbacks we don't have a DomRange\n    tmpl.firstNode = null;\n    tmpl.lastNode = null;\n  }\n};\n\n_extend(UI.Component, {\n  // We implement the old APIs here, including how data is passed\n  // to helpers in `this`.\n  helpers: function (dict) {\n    _extend(this, dict);\n  },\n  events: function (dict) {\n    var events;\n    if (this.hasOwnProperty('_events'))\n      events = this._events;\n    else\n      events = (this._events = []);\n\n    _.each(dict, function (handler, spec) {\n      var clauses = spec.split(/,\\s+/);\n      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\n      _.each(clauses, function (clause) {\n        var parts = clause.split(/\\s+/);\n        if (parts.length === 0)\n          return;\n\n        var newEvents = parts.shift();\n        var selector = parts.join(' ');\n        events.push({events: newEvents,\n                     selector: selector,\n                     handler: handler});\n      });\n    });\n  }\n});\n\n// XXX we don't really want this to be a user-visible callback,\n// it's just a particular signal we need from DomRange.\nUI.Component.notifyParented = function () {\n  var self = this;\n  for (var comp = self; comp; comp = comp._super) {\n    var events = (comp.hasOwnProperty('_events') && comp._events) || null;\n    if ((! events) && comp.hasOwnProperty('events') &&\n        typeof comp.events === 'object') {\n      // Provide limited back-compat support for `.events = {...}`\n      // syntax.  Pass `comp.events` to the original `.events(...)`\n      // function.  This code must run only once per component, in\n      // order to not bind the handlers more than once, which is\n      // ensured by the fact that we only do this when `comp._events`\n      // is falsy, and we cause it to be set now.\n      UI.Component.events.call(comp, comp.events);\n      events = comp._events;\n    }\n    _.each(events, function (esh) { // {events, selector, handler}\n      // wrap the handler here, per instance of the template that\n      // declares the event map, so we can pass the instance to\n      // the event handler.\n      var wrappedHandler = function (event) {\n        var comp = UI.DomRange.getContainingComponent(event.currentTarget);\n        var data = comp && getComponentData(comp);\n        updateTemplateInstance(self);\n        Deps.nonreactive(function () {\n          // Don't want to be in a deps context, even if we were somehow\n          // triggered synchronously in an existing deps context\n          // (the `blur` event can do this).\n          // XXX we should probably do what Spark did and block all\n          // event handling during our DOM manip.  Many apps had weird\n          // unanticipated bugs until we did that.\n          esh.handler.call(data, event, self.templateInstance);\n        });\n      };\n\n      self.dom.on(esh.events, esh.selector, wrappedHandler);\n    });\n  }\n\n  // XXX this is an undocumented callback\n  if (self.parented) {\n    Deps.nonreactive(function () {\n      updateTemplateInstance(self);\n      self.parented.call(self.templateInstance);\n    });\n  }\n\n  if (self.rendered) {\n    // Defer rendered callback until flush time.\n    Deps.afterFlush(function () {\n      if (! self.isDestroyed) {\n        updateTemplateInstance(self);\n        self.rendered.call(self.templateInstance);\n      }\n    });\n  }\n};\n\n// past compat\nUI.Component.preserve = function () {};\n","if (Meteor.isClient) {\n\n  // XXX in the future, make the jQuery adapter a separate\n  // package and make the choice of back-end library\n  // configurable.  Adapters all expose the same DomBackend interface.\n\n  if (! Package.jquery)\n    throw new Error(\"Meteor UI jQuery adapter: jQuery not found.\");\n\n  var $jq = Package.jquery.jQuery;\n\n  var DomBackend = {};\n  UI.DomBackend = DomBackend;\n\n  ///// Removal detection and interoperability.\n\n  // For an explanation of this technique, see:\n  // http://bugs.jquery.com/ticket/12213#comment:23 .\n  //\n  // In short, an element is considered \"removed\" when jQuery\n  // cleans up its *private* userdata on the element,\n  // which we can detect using a custom event with a teardown\n  // hook.\n\n  var JQUERY_REMOVAL_WATCHER_EVENT_NAME = 'meteor_ui_removal_watcher';\n  var REMOVAL_CALLBACKS_PROPERTY_NAME = '$meteor_ui_removal_callbacks';\n  var NOOP = function () {};\n\n  // Causes `elem` (a DOM element) to be detached from its parent, if any.\n  // Whether or not `elem` was detached, causes any callbacks registered\n  // with `onRemoveElement` on `elem` and its descendants to fire.\n  // Not for use on non-element nodes.\n  //\n  // This method is modeled after the behavior of jQuery's `$(elem).remove()`,\n  // which causes teardown on the subtree being removed.\n  DomBackend.removeElement = function (elem) {\n    $jq(elem).remove();\n  };\n\n  // Registers a callback function to be called when the given element or\n  // one of its ancestors is removed from the DOM via the backend library.\n  // The callback function is called at most once, and it receives the element\n  // in question as an argument.\n  DomBackend.onRemoveElement = function (elem, func) {\n    if (! elem[REMOVAL_CALLBACKS_PROPERTY_NAME]) {\n      elem[REMOVAL_CALLBACKS_PROPERTY_NAME] = [];\n\n      // Set up the event, only the first time.\n      $jq(elem).on(JQUERY_REMOVAL_WATCHER_EVENT_NAME, NOOP);\n    }\n\n    elem[REMOVAL_CALLBACKS_PROPERTY_NAME].push(func);\n  };\n\n  $jq.event.special[JQUERY_REMOVAL_WATCHER_EVENT_NAME] = {\n    teardown: function() {\n      var elem = this;\n      var callbacks = elem[REMOVAL_CALLBACKS_PROPERTY_NAME];\n      if (callbacks) {\n        for (var i = 0; i < callbacks.length; i++)\n          callbacks[i](elem);\n        elem[REMOVAL_CALLBACKS_PROPERTY_NAME] = null;\n      }\n    }\n  };\n\n  DomBackend.parseHTML = function (html) {\n    // Return an array of nodes.\n    //\n    // jQuery does fancy stuff like creating an appropriate\n    // container element and setting innerHTML on it, as well\n    // as working around various IE quirks.\n    return $jq.parseHTML(html) || [];\n  };\n\n  // Must use jQuery semantics for `context`, not\n  // querySelectorAll's.  In other words, all the parts\n  // of `selector` must be found under `context`.\n  DomBackend.findBySelector = function (selector, context) {\n    return $jq.find(selector, context);\n  };\n\n  DomBackend.newFragment = function (nodeArray) {\n    // jQuery fragments are built specially in\n    // IE<9 so that they can safely hold HTML5\n    // elements.\n    return $jq.buildFragment(nodeArray, document);\n  };\n\n  // `selector` is non-null.  `type` is one type (but\n  // may be in backend-specific form, e.g. have namespaces).\n  // Order fired must be order bound.\n  DomBackend.delegateEvents = function (elem, type, selector, handler) {\n    $jq(elem).on(type, selector, handler);\n  };\n\n  DomBackend.undelegateEvents = function (elem, type, handler) {\n    $jq(elem).off(type, handler);\n  };\n\n  DomBackend.bindEventCapturer = function (elem, type, selector, handler) {\n    var $elem = $jq(elem);\n\n    var wrapper = function (event) {\n      event = $jq.event.fix(event);\n      event.currentTarget = event.target;\n\n      // Note: It might improve jQuery interop if we called into jQuery\n      // here somehow.  Since we don't use jQuery to dispatch the event,\n      // we don't fire any of jQuery's event hooks or anything.  However,\n      // since jQuery can't bind capturing handlers, it's not clear\n      // where we would hook in.  Internal jQuery functions like `dispatch`\n      // are too high-level.\n      var $target = $jq(event.currentTarget);\n      if ($target.is($elem.find(selector)))\n        handler.call(elem, event);\n    };\n\n    handler._meteorui_wrapper = wrapper;\n\n    type = this.parseEventType(type);\n    // add *capturing* event listener\n    elem.addEventListener(type, wrapper, true);\n  };\n\n  DomBackend.unbindEventCapturer = function (elem, type, handler) {\n    type = this.parseEventType(type);\n    elem.removeEventListener(type, handler._meteorui_wrapper, true);\n  };\n\n  DomBackend.parseEventType = function (type) {\n    // strip off namespaces\n    var dotLoc = type.indexOf('.');\n    if (dotLoc >= 0)\n      return type.slice(0, dotLoc);\n    return type;\n  };\n\n}","// TODO\n// - Lazy removal detection\n// - UI hooks (expose, test)\n// - Quick remove/add (mark \"leaving\" members; needs UI hooks)\n// - Event removal on removal\n// - Event moving on TBODY move\n\nvar DomBackend = UI.DomBackend;\n\nvar removeNode = function (n) {\n//  if (n.nodeType === 1 &&\n//      n.parentNode.$uihooks && n.parentNode.$uihooks.removeElement)\n//    n.parentNode.$uihooks.removeElement(n);\n//  else\n    n.parentNode.removeChild(n);\n};\n\nvar insertNode = function (n, parent, next) {\n//  if (n.nodeType === 1 &&\n//      parent.$uihooks && parent.$uihooks.insertElement)\n//    parent.$uihooks.insertElement(n, parent, next);\n//  else\n    // `|| null` because IE throws an error if 'next' is undefined\n  parent.insertBefore(n, next || null);\n};\n\nvar moveNode = function (n, parent, next) {\n//  if (n.nodeType === 1 &&\n//      parent.$uihooks && parent.$uihooks.moveElement)\n//    parent.$uihooks.moveElement(n, parent, next);\n//  else\n    // `|| null` because IE throws an error if 'next' is undefined\n    parent.insertBefore(n, next || null);\n};\n\n// A very basic operation like Underscore's `_.extend` that\n// copies `src`'s own, enumerable properties onto `tgt` and\n// returns `tgt`.\nvar _extend = function (tgt, src) {\n  for (var k in src)\n    if (src.hasOwnProperty(k))\n      tgt[k] = src[k];\n  return tgt;\n};\n\nvar _contains = function (list, item) {\n  if (! list)\n    return false;\n  for (var i = 0, N = list.length; i < N; i++)\n    if (list[i] === item)\n      return true;\n  return false;\n};\n\nvar isArray = function (x) {\n  return !!((typeof x.length === 'number') &&\n            (x.sort || x.splice));\n};\n\n// Text nodes consisting of only whitespace\n// are \"insignificant\" nodes.\nvar isSignificantNode = function (n) {\n  return ! (n.nodeType === 3 &&\n            (! n.nodeValue ||\n             /^\\s+$/.test(n.nodeValue)));\n};\n\nvar checkId = function (id) {\n  if (typeof id !== 'string')\n    throw new Error(\"id must be a string\");\n  if (! id)\n    throw new Error(\"id may not be empty\");\n};\n\nvar textExpandosSupported = (function () {\n  var tn = document.createTextNode('');\n  try {\n    tn.blahblah = true;\n    return true;\n  } catch (e) {\n    // IE 8\n    return false;\n  }\n})();\n\nvar createMarkerNode = (\n  textExpandosSupported ?\n    function () { return document.createTextNode(\"\"); } :\n  function () { return document.createComment(\"IE\"); });\n\nvar rangeParented = function (range) {\n  if (! range.isParented) {\n    range.isParented = true;\n\n    if (! range.owner) {\n      // top-level (unowned) ranges in an element,\n      // keep a pointer to the range on the parent\n      // element.  This is really just for IE 9+\n      // TextNode GC issues, but we can't do reliable\n      // feature detection (i.e. bug detection).\n      // Note that because we keep a direct pointer to\n      // `parentNode.$_uiranges`, it doesn't matter\n      // if we are reparented (e.g. wrapped in a TBODY).\n      var parentNode = range.parentNode();\n      var rangeDict = (\n        parentNode.$_uiranges ||\n          (parentNode.$_uiranges = {}));\n      rangeDict[range._rangeId] = range;\n      range._rangeDict = rangeDict;\n\n      // get jQuery to tell us when this node is removed\n      DomBackend.onRemoveElement(parentNode, function () {\n        rangeRemoved(range);\n      });\n    }\n\n    if (range.component && range.component.notifyParented)\n      range.component.notifyParented();\n\n    // recurse on member ranges\n    var members = range.members;\n    for (var k in members) {\n      var mem = members[k];\n      if (mem instanceof DomRange)\n        rangeParented(mem);\n    }\n  }\n};\n\nvar rangeRemoved = function (range) {\n  if (! range.isRemoved) {\n    range.isRemoved = true;\n\n    if (range._rangeDict)\n      delete range._rangeDict[range._rangeId];\n\n    // XXX clean up events in $_uievents\n\n    // notify component of removal\n    if (range.removed)\n      range.removed();\n\n    membersRemoved(range);\n  }\n};\n\nvar nodeRemoved = function (node, viaBackend) {\n  if (node.nodeType === 1) { // ELEMENT\n    var comps = DomRange.getComponents(node);\n    for (var i = 0, N = comps.length; i < N; i++)\n      rangeRemoved(comps[i]);\n\n    if (! viaBackend)\n      DomBackend.removeElement(node);\n  }\n};\n\nvar membersRemoved = function (range) {\n  var members = range.members;\n  for (var k in members) {\n    var mem = members[k];\n    if (mem instanceof DomRange)\n      rangeRemoved(mem);\n    else\n      nodeRemoved(mem);\n  }\n};\n\nvar nextGuid = 1;\n\nvar DomRange = function () {\n  var start = createMarkerNode();\n  var end = createMarkerNode();\n  var fragment = DomBackend.newFragment([start, end]);\n  fragment.$_uiIsOffscreen = true;\n\n  this.start = start;\n  this.end = end;\n  start.$ui = this;\n  end.$ui = this;\n\n  this.members = {};\n  this.nextMemberId = 1;\n  this.owner = null;\n  this._rangeId = nextGuid++;\n  this._rangeDict = null;\n\n  this.isParented = false;\n  this.isRemoved = false;\n};\n\n_extend(DomRange.prototype, {\n  getNodes: function () {\n    if (! this.parentNode())\n      return [];\n\n    this.refresh();\n\n    var afterNode = this.end.nextSibling;\n    var nodes = [];\n    for (var n = this.start;\n         n && n !== afterNode;\n         n = n.nextSibling)\n      nodes.push(n);\n    return nodes;\n  },\n  removeAll: function () {\n    if (! this.parentNode())\n      return;\n\n    this.refresh();\n\n    // leave start and end\n    var afterNode = this.end;\n    var nodes = [];\n    for (var n = this.start.nextSibling;\n         n && n !== afterNode;\n         n = n.nextSibling) {\n      // don't remove yet since then we'd lose nextSibling\n      nodes.push(n);\n    }\n    for (var i = 0, N = nodes.length; i < N; i++)\n      removeNode(nodes[i]);\n\n    membersRemoved(this);\n\n    this.members = {};\n  },\n  // (_nextNode is internal)\n  add: function (id, newMemberOrArray, beforeId, _nextNode) {\n    if (id != null && typeof id !== 'string') {\n      if (typeof id !== 'object')\n        // a non-object first argument is probably meant\n        // as an id, NOT a new member, so complain about it\n        // as such.\n        throw new Error(\"id must be a string\");\n      beforeId = newMemberOrArray;\n      newMemberOrArray = id;\n      id = null;\n    }\n\n    if (! newMemberOrArray || typeof newMemberOrArray !== 'object')\n      throw new Error(\"Expected component, node, or array\");\n\n    if (isArray(newMemberOrArray)) {\n      if (newMemberOrArray.length === 1) {\n        newMemberOrArray = newMemberOrArray[0];\n      } else {\n        if (id != null)\n          throw new Error(\"Can only add one node or one component if id is given\");\n        var array = newMemberOrArray;\n        // calculate `nextNode` once in case it involves a refresh\n        _nextNode = this.getInsertionPoint(beforeId);\n        for (var i = 0; i < array.length; i++)\n          this.add(null, array[i], beforeId, _nextNode);\n        return;\n      }\n    }\n\n    var parentNode = this.parentNode();\n    // Consider ourselves removed (and don't mind) if\n    // start marker has no parent.\n    if (! parentNode)\n      return;\n    // because this may call `refresh`, it must be done\n    // early, before we add the new member.\n    var nextNode = (_nextNode ||\n                    this.getInsertionPoint(beforeId));\n\n    var newMember = newMemberOrArray;\n    if (id == null) {\n      id = this.nextMemberId++;\n    } else {\n      checkId(id);\n      id = ' ' + id;\n    }\n\n    var members = this.members;\n    if (members.hasOwnProperty(id)) {\n      var oldMember = members[id];\n      if (oldMember instanceof DomRange) {\n        // range, does it still exist?\n        var oldRange = oldMember;\n        if (oldRange.start.parentNode !== parentNode) {\n          delete members[id];\n          oldRange.owner = null;\n          rangeRemoved(oldRange);\n        } else {\n          throw new Error(\"Member already exists: \" + id.slice(1));\n        }\n      } else {\n        // node, does it still exist?\n        var oldNode = oldMember;\n        if (oldNode.parentNode !== parentNode) {\n          nodeRemoved(oldNode);\n          delete members[id];\n        } else {\n          throw new Error(\"Member already exists: \" + id.slice(1));\n        }\n      }\n    }\n\n    if (newMember instanceof DomRange) {\n      // Range\n      var range = newMember;\n      range.owner = this;\n      var nodes = range.getNodes();\n\n      if (tbodyFixNeeded(nodes, parentNode))\n        // may cause a refresh(); important that the\n        // member isn't added yet\n        parentNode = moveWithOwnersIntoTbody(this);\n\n      members[id] = newMember;\n      for (var i = 0; i < nodes.length; i++)\n        insertNode(nodes[i], parentNode, nextNode);\n\n      if (this.isParented)\n        rangeParented(range);\n    } else {\n      // Node\n      if (typeof newMember.nodeType !== 'number')\n        throw new Error(\"Expected Component or Node\");\n      var node = newMember;\n      // can't attach `$ui` to a TextNode in IE 8, so\n      // don't bother on any browser.\n      if (node.nodeType !== 3)\n        node.$ui = this;\n\n      if (tbodyFixNeeded(node, parentNode))\n        // may cause a refresh(); important that the\n        // member isn't added yet\n        parentNode = moveWithOwnersIntoTbody(this);\n\n      members[id] = newMember;\n      insertNode(node, parentNode, nextNode);\n    }\n  },\n  remove: function (id) {\n    if (id == null) {\n      // remove self\n      this.removeAll();\n      removeNode(this.start);\n      removeNode(this.end);\n      this.owner = null;\n      rangeRemoved(this);\n      return;\n    }\n\n    checkId(id);\n    id = ' ' + id;\n    var members = this.members;\n    var member = (members.hasOwnProperty(id) &&\n                  members[id]);\n    delete members[id];\n\n    // Don't mind double-remove.\n    if (! member)\n      return;\n\n    var parentNode = this.parentNode();\n    // Consider ourselves removed (and don't mind) if\n    // start marker has no parent.\n    if (! parentNode)\n      return;\n\n    if (member instanceof DomRange) {\n      // Range\n      var range = member;\n      range.owner = null;\n      // Don't mind if range (specifically its start\n      // marker) has been removed already.\n      if (range.start.parentNode === parentNode)\n        member.remove();\n    } else {\n      // Node\n      var node = member;\n      // Don't mind if node has been removed already.\n      if (node.parentNode === parentNode)\n        removeNode(node);\n    }\n  },\n  moveBefore: function (id, beforeId) {\n    var nextNode = this.getInsertionPoint(beforeId);\n    checkId(id);\n    id = ' ' + id;\n    var members = this.members;\n    var member =\n          (members.hasOwnProperty(id) &&\n           members[id]);\n    // Don't mind if member doesn't exist.\n    if (! member)\n      return;\n\n    var parentNode = this.parentNode();\n    // Consider ourselves removed (and don't mind) if\n    // start marker has no parent.\n    if (! parentNode)\n      return;\n\n    if (member instanceof DomRange) {\n      // Range\n      var range = member;\n      // Don't mind if range (specifically its start marker)\n      // has been removed already.\n      if (range.start.parentNode === parentNode) {\n        range.refresh();\n        var nodes = range.getNodes();\n        for (var i = 0; i < nodes.length; i++)\n          moveNode(nodes[i], parentNode, nextNode);\n      }\n    } else {\n      // Node\n      var node = member;\n      moveNode(node, parentNode, nextNode);\n    }\n  },\n  get: function (id) {\n    checkId(id);\n    id = ' ' + id;\n    var members = this.members;\n    if (members.hasOwnProperty(id))\n      return members[id];\n    return null;\n  },\n  parentNode: function () {\n    return this.start.parentNode;\n  },\n  startNode: function () {\n    return this.start;\n  },\n  endNode: function () {\n    return this.end;\n  },\n  eachMember: function (nodeFunc, rangeFunc) {\n    var members = this.members;\n    var parentNode = this.parentNode();\n    for (var k in members) {\n      // mem is a component (hosting a Range) or a Node\n      var mem = members[k];\n      if (mem instanceof DomRange) {\n        // Range\n        var range = mem;\n        if (range.start.parentNode === parentNode) {\n          rangeFunc && rangeFunc(range); // still there\n        } else {\n          range.owner = null;\n          delete members[k]; // gone\n          rangeRemoved(range);\n        }\n      } else {\n        // Node\n        var node = mem;\n        if (node.parentNode === parentNode) {\n          nodeFunc && nodeFunc(node); // still there\n        } else {\n          delete members[k]; // gone\n          nodeRemoved(node);\n        }\n      }\n    }\n  },\n\n  ///////////// INTERNALS below this point, pretty much\n\n  // The purpose of \"refreshing\" a DomRange is to\n  // take into account any element removals or moves\n  // that may have occurred, and to \"fix\" the start\n  // and end markers before the entire range is moved\n  // or removed so that they bracket the appropriate\n  // content.\n  //\n  // For example, if a DomRange contains a single element\n  // node, and this node is moved using jQuery, refreshing\n  // the DomRange will look to the element as ground truth\n  // and move the start/end markers around the element.\n  // A refreshed DomRange's nodes may surround nodes from\n  // sibling DomRanges (including their marker nodes)\n  // until the sibling DomRange is refreshed.\n  //\n  // Specifically, `refresh` moves the `start`\n  // and `end` nodes to immediate before the first,\n  // and after the last, \"significant\" node the\n  // DomRange contains, where a significant node\n  // is any node except a whitespace-only text-node.\n  // All member ranges are refreshed first.  Adjacent\n  // insignificant member nodes are included between\n  // `start` and `end` as well, but it's possible that\n  // other insignificant nodes remain as siblings\n  // elsewhere.  Nodes with no DomRange owner that are\n  // found between this DomRange's nodes are adopted.\n  //\n  // Performing add/move/remove operations on an \"each\"\n  // shouldn't require refreshing the entire each, just\n  // the member in question.  (However, adding to the\n  // end may require refreshing the whole \"each\";\n  // see `getInsertionPoint`.  Adding multiple members\n  // at once using `add(array)` is faster.\n  refresh: function () {\n\n    var parentNode = this.parentNode();\n    if (! parentNode)\n      return;\n\n    // Using `eachMember`, do several things:\n    // - Refresh all member ranges\n    // - Count our members\n    // - If there's only one, get that one\n    // - Make a list of member TextNodes, which we\n    //   can't detect with a `$ui` property because\n    //   IE 8 doesn't allow user-defined properties\n    //   on TextNodes.\n    var someNode = null;\n    var someRange = null;\n    var numMembers = 0;\n    var textNodes = null;\n    this.eachMember(function (node) {\n      someNode = node;\n      numMembers++;\n      if (node.nodeType === 3) {\n        textNodes = (textNodes || []);\n        textNodes.push(node);\n      }\n    }, function (range) {\n      range.refresh();\n      someRange = range;\n      numMembers++;\n    });\n\n    var firstNode = null;\n    var lastNode = null;\n\n    if (numMembers === 0) {\n      // don't scan for members\n    } else if (numMembers === 1) {\n      if (someNode) {\n        firstNode = someNode;\n        lastNode = someNode;\n      } else if (someRange) {\n        firstNode = someRange.start;\n        lastNode = someRange.end;\n      }\n    } else {\n      // This loop is O(childNodes.length), even if our members\n      // are already consecutive.  This means refreshing just one\n      // item in a list is technically order of the total number\n      // of siblings, including in other list items.\n      //\n      // The root cause is we intentionally don't track the\n      // DOM order of our members, so finding the first\n      // and last in sibling order either involves a scan\n      // or a bunch of calls to compareDocumentPosition.\n      //\n      // Fortunately, the common cases of zero and one members\n      // are optimized.  Also, the scan is super-fast because\n      // no work is done for unknown nodes.  It could be possible\n      // to optimize this code further if it becomes a problem.\n      for (var node = parentNode.firstChild;\n           node; node = node.nextSibling) {\n\n        var nodeOwner;\n        if (node.$ui &&\n            (nodeOwner = node.$ui) &&\n            ((nodeOwner === this &&\n              node !== this.start &&\n              node !== this.end &&\n              isSignificantNode(node)) ||\n             (nodeOwner !== this &&\n              nodeOwner.owner === this &&\n              nodeOwner.start === node))) {\n          // found a member range or node\n          // (excluding \"insignificant\" empty text nodes,\n          // which won't be moved by, say, jQuery)\n          if (firstNode) {\n            // if we've already found a member in our\n            // scan, see if there are some easy ownerless\n            // nodes to \"adopt\" by scanning backwards.\n            for (var n = firstNode.previousSibling;\n                 n && ! n.$ui;\n                 n = n.previousSibling) {\n              this.members[this.nextMemberId++] = n;\n              // can't attach `$ui` to a TextNode in IE 8, so\n              // don't bother on any browser.\n              if (n.nodeType !== 3)\n                n.$ui = this;\n            }\n          }\n          if (node.$ui === this) {\n            // Node\n            firstNode = (firstNode || node);\n            lastNode = node;\n          } else {\n            // Range\n            // skip it and include its nodes in\n            // firstNode/lastNode.\n            firstNode = (firstNode || node);\n            node = node.$ui.end;\n            lastNode = node;\n          }\n        }\n      }\n    }\n    if (firstNode) {\n      // some member or significant node was found.\n      // expand to include our insigificant member\n      // nodes as well.\n      for (var n;\n           (n = firstNode.previousSibling) &&\n           (n.$ui && n.$ui === this ||\n            _contains(textNodes, n));)\n        firstNode = n;\n      for (var n;\n           (n = lastNode.nextSibling) &&\n           (n.$ui && n.$ui === this ||\n            _contains(textNodes, n));)\n        lastNode = n;\n      // adjust our start/end pointers\n      if (firstNode !== this.start)\n        insertNode(this.start,\n                   parentNode, firstNode);\n      if (lastNode !== this.end)\n        insertNode(this.end, parentNode,\n                 lastNode.nextSibling);\n    }\n  },\n  getInsertionPoint: function (beforeId) {\n    var members = this.members;\n    var parentNode = this.parentNode();\n\n    if (! beforeId) {\n      // Refreshing here is necessary if we want to\n      // allow elements to move around arbitrarily.\n      // If jQuery is used to reorder elements, it could\n      // easily make our `end` pointer meaningless,\n      // even though all our members continue to make\n      // good reference points as long as they are refreshed.\n      //\n      // However, a refresh is expensive!  Let's\n      // make the developer manually refresh if\n      // elements are being re-ordered externally.\n      return this.end;\n    }\n\n    checkId(beforeId);\n    beforeId = ' ' + beforeId;\n    var mem = members[beforeId];\n\n    if (mem instanceof DomRange) {\n      // Range\n      var range = mem;\n      if (range.start.parentNode === parentNode) {\n        // still there\n        range.refresh();\n        return range.start;\n      } else {\n        range.owner = null;\n        rangeRemoved(range);\n      }\n    } else {\n      // Node\n      var node = mem;\n      if (node.parentNode === parentNode)\n        return node; // still there\n      else\n        nodeRemoved(node);\n    }\n\n    // not there anymore\n    delete members[beforeId];\n    // no good position\n    return this.end;\n  }\n});\n\nDomRange.prototype.elements = function (intoArray) {\n  intoArray = (intoArray || []);\n  this.eachMember(function (node) {\n    if (node.nodeType === 1)\n      intoArray.push(node);\n  }, function (range) {\n    range.elements(intoArray);\n  });\n  return intoArray;\n};\n\n// XXX alias the below as `UI.refresh` and `UI.insert`\n\n// In a real-life case where you need a refresh,\n// you probably don't have easy\n// access to the appropriate DomRange or component,\n// just the enclosing element:\n//\n// ```\n// {{#Sortable}}\n//   <div>\n//     {{#each}}\n//       ...\n// ```\n//\n// In this case, Sortable wants to call `refresh`\n// on the div, not the each, so it would use this function.\nDomRange.refresh = function (element) {\n  var comps = DomRange.getComponents(element);\n\n  for (var i = 0, N = comps.length; i < N; i++)\n    comps[i].refresh();\n};\n\nDomRange.getComponents = function (element) {\n  var topLevelComps = [];\n  for (var n = element.firstChild;\n       n; n = n.nextSibling) {\n    if (n.$ui && n === n.$ui.start &&\n        ! n.$ui.owner)\n      topLevelComps.push(n.$ui);\n  }\n  return topLevelComps;\n};\n\n// `parentNode` must be an ELEMENT, not a fragment\nDomRange.insert = function (range, parentNode, nextNode) {\n  var nodes = range.getNodes();\n  if (tbodyFixNeeded(nodes, parentNode))\n    parentNode = makeOrFindTbody(parentNode, nextNode);\n  for (var i = 0; i < nodes.length; i++)\n    insertNode(nodes[i], parentNode, nextNode);\n  rangeParented(range);\n};\n\nDomRange.getContainingComponent = function (element) {\n  while (element && ! element.$ui)\n    element = element.parentNode;\n\n  var range = (element && element.$ui);\n\n  while (range) {\n    if (range.component)\n      return range.component;\n    range = range.owner;\n  }\n  return null;\n};\n\n///// TBODY FIX for compatibility with jQuery.\n//\n// Because people might use jQuery from UI hooks, and\n// jQuery is unable to do $(myTable).append(myTR) without\n// adding a TBODY (for historical reasons), we move any DomRange\n// that gains a TR, and its immediately enclosing DomRanges,\n// into a TBODY.\n//\n// See http://www.quora.com/David-Greenspan/Posts/The-Great-TBODY-Debacle\nvar tbodyFixNeeded = function (childOrChildren, parent) {\n  if (parent.nodeName !== 'TABLE')\n    return false;\n\n  if (isArray(childOrChildren)) {\n    var foundTR = false;\n    for (var i = 0, N = childOrChildren.length; i < N; i++) {\n      var n = childOrChildren[i];\n      if (n.nodeType === 1 && n.nodeName === 'TR') {\n        foundTR = true;\n        break;\n      }\n    }\n    if (! foundTR)\n      return false;\n  } else {\n    var n = childOrChildren;\n    if (! (n.nodeType === 1 && n.nodeName === 'TR'))\n      return false;\n  }\n\n  return true;\n};\n\nvar makeOrFindTbody = function (parent, next) {\n  // we have a TABLE > TR situation\n  var tbody = parent.getElementsByTagName('tbody')[0];\n  if (! tbody) {\n    tbody = parent.ownerDocument.createElement(\"tbody\");\n    parent.insertBefore(tbody, next || null);\n  }\n  return tbody;\n};\n\nvar moveWithOwnersIntoTbody = function (range) {\n  while (range.owner)\n    range = range.owner;\n\n  var nodes = range.getNodes(); // causes refresh\n  var tbody = makeOrFindTbody(range.parentNode(),\n                              range.end.nextSibling);\n  for (var i = 0; i < nodes.length; i++)\n    tbody.appendChild(nodes[i]);\n\n  // XXX complete the reparenting by moving event\n  // HandlerRecs of `range`.\n\n  return tbody;\n};\n\n///// FIND BY SELECTOR\n\nDomRange.prototype.contains = function (compOrNode) {\n  if (! compOrNode)\n    throw new Error(\"Expected Component or Node\");\n\n  var parentNode = this.parentNode();\n  if (! parentNode)\n    return false;\n\n  var range;\n  if (compOrNode instanceof DomRange) {\n    // Component\n    range = compOrNode;\n    var pn = range.parentNode();\n    if (! pn)\n      return false;\n    // If parentNode is different, it must be a node\n    // we contain.\n    if (pn !== parentNode)\n      return this.contains(pn);\n    if (range === this)\n      return false; // don't contain self\n    // Ok, `range` is a same-parent range to see if we\n    // contain.\n  } else {\n    // Node\n    var node = compOrNode;\n    if (! elementContains(parentNode, node))\n      return false;\n\n    while (node.parentNode !== parentNode)\n      node = node.parentNode;\n\n    range = node.$ui;\n  }\n\n  // Now see if `range` is truthy and either `this`\n  // or an immediate subrange\n\n  while (range && range !== this)\n    range = range.owner;\n\n  return range === this;\n};\n\nDomRange.prototype.$ = function (selector) {\n  var self = this;\n\n  var parentNode = this.parentNode();\n  if (! parentNode)\n    throw new Error(\"Can't select in removed DomRange\");\n\n  // Strategy: Find all selector matches under parentNode,\n  // then filter out the ones that aren't in this DomRange\n  // using upwards pointers ($ui, owner, parentNode).  This is\n  // asymptotically slow in the presence of O(N) sibling\n  // content that is under parentNode but not in our range,\n  // so if performance is an issue, the selector should be\n  // run on a child element.\n\n  // Since jQuery can't run selectors on a DocumentFragment,\n  // we don't expect findBySelector to work.\n  if (parentNode.nodeType === 11 /* DocumentFragment */ ||\n      parentNode.$_uiIsOffscreen)\n    throw new Error(\"Can't use $ on an offscreen component\");\n\n  var results = DomBackend.findBySelector(selector, parentNode);\n\n  // We don't assume `results` has jQuery API; a plain array\n  // should do just as well.  However, if we do have a jQuery\n  // array, we want to end up with one also, so we use\n  // `.filter`.\n\n\n  // Function that selects only elements that are actually\n  // in this DomRange, rather than simply descending from\n  // `parentNode`.\n  var filterFunc = function (elem) {\n    // handle jQuery's arguments to filter, where the node\n    // is in `this` and the index is the first argument.\n    if (typeof elem === 'number')\n      elem = this;\n\n    return self.contains(elem);\n  };\n\n  if (! results.filter) {\n    // not a jQuery array, and not a browser with\n    // Array.prototype.filter (e.g. IE <9)\n    var newResults = [];\n    for (var i = 0; i < results.length; i++) {\n      var x = results[i];\n      if (filterFunc(x))\n        newResults.push(x);\n    }\n    results = newResults;\n  } else {\n    // `results.filter` is either jQuery's or ECMAScript's `filter`\n    results = results.filter(filterFunc);\n  }\n\n  return results;\n};\n\n\n///// EVENTS\n\n// List of events to always delegate, never capture.\n// Since jQuery fakes bubbling for certain events in\n// certain browsers (like `submit`), we don't want to\n// get in its way.\n//\n// We could list all known bubbling\n// events here to avoid creating speculative capturers\n// for them, but it would only be an optimization.\nvar eventsToDelegate = {\n  blur: 1, change: 1, click: 1, focus: 1, focusin: 1,\n  focusout: 1, reset: 1, submit: 1\n};\n\nvar EVENT_MODE_TBD = 0;\nvar EVENT_MODE_BUBBLING = 1;\nvar EVENT_MODE_CAPTURING = 2;\n\nvar HandlerRec = function (elem, type, selector, handler, $ui) {\n  this.elem = elem;\n  this.type = type;\n  this.selector = selector;\n  this.handler = handler;\n  this.$ui = $ui;\n\n  this.mode = EVENT_MODE_TBD;\n\n  // It's important that delegatedHandler be a different\n  // instance for each handlerRecord, because its identity\n  // is used to remove it.\n  //\n  // It's also important that the closure have access to\n  // `this` when it is not called with it set.\n  this.delegatedHandler = (function (h) {\n    return function (evt) {\n      if ((! h.selector) && evt.currentTarget !== evt.target)\n        // no selector means only fire on target\n        return;\n      if (! h.$ui.contains(evt.currentTarget))\n        return;\n      return h.handler.call(h.$ui, evt);\n    };\n  })(this);\n\n  // WHY CAPTURE AND DELEGATE: jQuery can't delegate\n  // non-bubbling events, because\n  // event capture doesn't work in IE 8.  However, there\n  // are all sorts of new-fangled non-bubbling events\n  // like \"play\" and \"touchenter\".  We delegate these\n  // events using capture in all browsers except IE 8.\n  // IE 8 doesn't support these events anyway.\n\n  var tryCapturing = elem.addEventListener &&\n        (! eventsToDelegate.hasOwnProperty(\n          DomBackend.parseEventType(type)));\n\n  if (tryCapturing) {\n    this.capturingHandler = (function (h) {\n      return function (evt) {\n        if (h.mode === EVENT_MODE_TBD) {\n          // must be first time we're called.\n          if (evt.bubbles) {\n            // this type of event bubbles, so don't\n            // get called again.\n            h.mode = EVENT_MODE_BUBBLING;\n            DomBackend.unbindEventCapturer(\n              h.elem, h.type, h.capturingHandler);\n            return;\n          } else {\n            // this type of event doesn't bubble,\n            // so unbind the delegation, preventing\n            // it from ever firing.\n            h.mode = EVENT_MODE_CAPTURING;\n            DomBackend.undelegateEvents(\n              h.elem, h.type, h.delegatedHandler);\n          }\n        }\n\n        h.delegatedHandler(evt);\n      };\n    })(this);\n\n  } else {\n    this.mode = EVENT_MODE_BUBBLING;\n  }\n};\n\nHandlerRec.prototype.bind = function () {\n  // `this.mode` may be EVENT_MODE_TBD, in which case we bind both. in\n  // this case, 'capturingHandler' is in charge of detecting the\n  // correct mode and turning off one or the other handlers.\n  if (this.mode !== EVENT_MODE_BUBBLING) {\n    DomBackend.bindEventCapturer(\n      this.elem, this.type, this.selector || '*',\n      this.capturingHandler);\n  }\n\n  if (this.mode !== EVENT_MODE_CAPTURING)\n    DomBackend.delegateEvents(\n      this.elem, this.type,\n      this.selector || '*', this.delegatedHandler);\n};\n\nHandlerRec.prototype.unbind = function () {\n  if (this.mode !== EVENT_MODE_BUBBLING)\n    DomBackend.unbindEventCapturer(this.elem, this.type,\n                                   this.capturingHandler);\n\n  if (this.mode !== EVENT_MODE_CAPTURING)\n    DomBackend.undelegateEvents(this.elem, this.type,\n                                this.delegatedHandler);\n};\n\n\n// XXX could write the form of arguments for this function\n// in several different ways, including simply as an event map.\nDomRange.prototype.on = function (events, selector, handler) {\n  var parentNode = this.parentNode();\n  if (! parentNode)\n    // if we're not in the DOM, silently fail.\n    return;\n  // haven't been added yet; error\n  if (parentNode.$_uiIsOffscreen)\n    throw new Error(\"Can't bind events before DomRange is inserted\");\n\n  var eventTypes = [];\n  events.replace(/[^ /]+/g, function (e) {\n    eventTypes.push(e);\n  });\n\n  if (! handler && (typeof selector === 'function')) {\n    // omitted `selector`\n    handler = selector;\n    selector = null;\n  } else if (! selector) {\n    // take `\"\"` to `null`\n    selector = null;\n  }\n\n  for (var i = 0, N = eventTypes.length; i < N; i++) {\n    var type = eventTypes[i];\n\n    var eventDict = parentNode.$_uievents;\n    if (! eventDict)\n      eventDict = (parentNode.$_uievents = {});\n\n    var info = eventDict[type];\n    if (! info) {\n      info = eventDict[type] = {};\n      info.handlers = [];\n    }\n    var handlerList = info.handlers;\n    var handlerRec = new HandlerRec(\n      parentNode, type, selector, handler, this);\n    handlerRec.bind();\n    handlerList.push(handlerRec);\n    // move handlers of enclosing ranges to end\n    for (var r = this.owner; r; r = r.owner) {\n      // r is an enclosing DomRange\n      for (var j = 0, Nj = handlerList.length;\n           j < Nj; j++) {\n        var h = handlerList[j];\n        if (h.$ui === r) {\n          h.unbind();\n          h.bind();\n          handlerList.splice(j, 1); // remove handlerList[j]\n          handlerList.push(h);\n          j--; // account for removed handler\n          Nj--; // don't visit appended handlers\n        }\n      }\n    }\n  }\n};\n\n  // Returns true if element a contains node b and is not node b.\n  var elementContains = function (a, b) {\n    if (a.nodeType !== 1) // ELEMENT\n      return false;\n    if (a === b)\n      return false;\n\n    if (a.compareDocumentPosition) {\n      return a.compareDocumentPosition(b) & 0x10;\n    } else {\n          // Should be only old IE and maybe other old browsers here.\n          // Modern Safari has both functions but seems to get contains() wrong.\n          // IE can't handle b being a text node.  We work around this\n          // by doing a direct parent test now.\n      b = b.parentNode;\n      if (! (b && b.nodeType === 1)) // ELEMENT\n        return false;\n      if (a === b)\n        return true;\n\n      return a.contains(b);\n    }\n  };\n\n\nUI.DomRange = DomRange;","\n// An AttributeHandler object is responsible for updating a particular attribute\n// of a particular element.  AttributeHandler subclasses implement\n// browser-specific logic for dealing with particular attributes across\n// different browsers.\n//\n// To define a new type of AttributeHandler, use\n// `var FooHandler = AttributeHandler.extend({ update: function ... })`\n// where the `update` function takes arguments `(element, oldValue, value)`.\n// The `element` argument is always the same between calls to `update` on\n// the same instance.  `oldValue` and `value` are each either `null` or\n// a Unicode string of the type that might be passed to the value argument\n// of `setAttribute` (i.e. not an HTML string with character references).\n// When an AttributeHandler is installed, an initial call to `update` is\n// always made with `oldValue = null`.  The `update` method can access\n// `this.name` if the AttributeHandler class is a generic one that applies\n// to multiple attribute names.\n//\n// AttributeHandlers can store custom properties on `this`, as long as they\n// don't use the names `element`, `name`, `value`, and `oldValue`.\n//\n// AttributeHandlers can't influence how attributes appear in rendered HTML,\n// only how they are updated after materialization as DOM.\n\nAttributeHandler = function (name, value) {\n  this.name = name;\n  this.value = value;\n};\n\n_.extend(AttributeHandler.prototype, {\n  update: function (element, oldValue, value) {\n    if (value === null) {\n      if (oldValue !== null)\n        element.removeAttribute(this.name);\n    } else {\n      element.setAttribute(this.name, this.value);\n    }\n  }\n});\n\nAttributeHandler.extend = function (options) {\n  var curType = this;\n  var subType = function AttributeHandlerSubtype(/*arguments*/) {\n    AttributeHandler.apply(this, arguments);\n  };\n  subType.prototype = new curType;\n  subType.extend = curType.extend;\n  if (options)\n    _.extend(subType.prototype, options);\n  return subType;\n};\n\n// Extended below to support both regular and SVG elements\nvar BaseClassHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    if (!this.getCurrentValue || !this.setValue)\n      throw new Error(\"Missing methods in subclass of 'BaseClassHandler'\");\n\n    var oldClasses = oldValue ? _.compact(oldValue.split(' ')) : [];\n    var newClasses = value ? _.compact(value.split(' ')) : [];\n\n    // the current classes on the element, which we will mutate.\n    var classes = _.compact(this.getCurrentValue(element).split(' '));\n\n    // optimize this later (to be asymptotically faster) if necessary\n    _.each(oldClasses, function (c) {\n      if (_.indexOf(newClasses, c) < 0)\n        classes = _.without(classes, c);\n    });\n    _.each(newClasses, function (c) {\n      if (_.indexOf(oldClasses, c) < 0 &&\n          _.indexOf(classes, c) < 0)\n        classes.push(c);\n    });\n\n    this.setValue(element, classes.join(' '));\n  }\n});\n\nvar ClassHandler = BaseClassHandler.extend({\n  // @param rawValue {String}\n  getCurrentValue: function (element) {\n    return element.className;\n  },\n  setValue: function (element, className) {\n    element.className = className;\n  }\n});\n\nvar SVGClassHandler = BaseClassHandler.extend({\n  getCurrentValue: function (element) {\n    return element.className.baseVal;\n  },\n  setValue: function (element, className) {\n    element.setAttribute('class', className);\n  }\n});\n\nvar BooleanHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var name = this.name;\n    if (value == null) {\n      if (oldValue != null)\n        element[name] = false;\n    } else {\n      element[name] = true;\n    }\n  }\n});\n\nvar ValueHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var focused = (element === document.activeElement);\n\n    if (!focused)\n      element.value = value;\n  }\n});\n\n// cross-browser version of `instanceof SVGElement`\nvar isSVGElement = function (elem) {\n  return 'ownerSVGElement' in elem;\n};\n\n// XXX make it possible for users to register attribute handlers!\nmakeAttributeHandler = function (elem, name, value) {\n  // generally, use setAttribute but certain attributes need to be set\n  // by directly setting a JavaScript property on the DOM element.\n  if (name === 'class') {\n    if (isSVGElement(elem)) {\n      return new SVGClassHandler(name, value);\n    } else {\n      return new ClassHandler(name, value);\n    }\n  } else if (name === 'selected' || name === 'checked') {\n    return new BooleanHandler(name, value);\n  } else if ((elem.tagName === 'TEXTAREA' || elem.tagName === 'INPUT')\n             && name === 'value') {\n    // internally, TEXTAREAs tracks their value in the 'value'\n    // attribute just like INPUTs.\n    return new ValueHandler(name, value);\n  } else {\n    return new AttributeHandler(name, value);\n  }\n\n  // XXX will need one for 'style' on IE, though modern browsers\n  // seem to handle setAttribute ok.\n};\n","\nUI.Component.instantiate = function (parent) {\n  var kind = this;\n\n  // check arguments\n  if (UI.isComponent(kind)) {\n    if (kind.isInited)\n      throw new Error(\"A component kind is required, not an instance\");\n  } else {\n    throw new Error(\"Expected Component kind\");\n  }\n\n  var inst = kind.extend(); // XXX args go here\n  inst.isInited = true;\n\n  // XXX messy to define this here\n  inst.templateInstance = {\n    findAll: function (selector) {\n      // XXX check that `.dom` exists here?\n      return inst.dom.$(selector);\n    },\n    find: function (selector) {\n      var result = this.findAll(selector);\n      return result[0] || null;\n    },\n    firstNode: null,\n    lastNode: null,\n    data: null,\n    __component__: inst\n  };\n\n  inst.parent = (parent || null);\n\n  if (inst.init)\n    inst.init();\n\n  if (inst.created) {\n    updateTemplateInstance(inst);\n    inst.created.call(inst.templateInstance);\n  }\n\n  return inst;\n};\n\nUI.Component.render = function () {\n  return null;\n};\n\n\n// Takes a reactive function (call it `inner`) and returns a reactive function\n// `outer` which is equivalent except in its reactive behavior.  Specifically,\n// `outer` has the following two special properties:\n//\n// 1. Isolation:  An invocation of `outer()` only invalidates its context\n//    when the value of `inner()` changes.  For example, `inner` may be a\n//    function that gets one or more Session variables and calculates a\n//    true/false value.  `outer` blocks invalidation signals caused by the\n//    Session variables changing and sends a signal out only when the value\n//    changes between true and false (in this example).  The value can be\n//    of any type, and it is compared with `===` unless an `equals` function\n//    is provided.\n//\n// 2. Value Sharing:  The `outer` function returned by `emboxValue` can be\n//    shared between different contexts, for example by assigning it to an\n//    object as a method that can be accessed at any time, such as by\n//    different templates or different parts of a template.  No matter\n//    how many times `outer` is called, `inner` is only called once until\n//    it changes.  The most recent value is stored internally.\n//\n// Conceptually, an emboxed value is much like a Session variable which is\n// kept up to date by an autorun.  Session variables provide storage\n// (value sharing) and they don't notify their listeners unless a value\n// actually changes (isolation).  The biggest difference is that such an\n// autorun would never be stopped, and the Session variable would never be\n// deleted even if it wasn't used any more.  An emboxed value, on the other\n// hand, automatically stops computing when it's not being used, and starts\n// again when called from a reactive context.  This means that when it stops\n// being used, it can be completely garbage-collected.\n//\n// If a non-function value is supplied to `emboxValue` instead of a reactive\n// function, then `outer` is still a function but it simply returns the value.\n//\nUI.emboxValue = function (funcOrValue, equals) {\n  if (typeof funcOrValue === 'function') {\n    var func = funcOrValue;\n\n    var curResult = null;\n    // There's one shared Dependency and Computation for all callers of\n    // our box function.  It gets kicked off if necessary, and when\n    // there are no more dependents, it gets stopped to avoid leaking\n    // memory.\n    var resultDep = null;\n    var computation = null;\n\n    return function () {\n      if (! computation) {\n        if (! Deps.active) {\n          // Not in a reactive context.  Just call func, and don't start a\n          // computation if there isn't one running already.\n          return func();\n        }\n\n        // No running computation, so kick one off.  Since this computation\n        // will be shared, avoid any association with the current computation\n        // by using `Deps.nonreactive`.\n        resultDep = new Deps.Dependency;\n\n        computation = Deps.nonreactive(function () {\n          return Deps.autorun(function (c) {\n            var oldResult = curResult;\n            curResult = func();\n            if (! c.firstRun) {\n              if (! (equals ? equals(curResult, oldResult) :\n                     curResult === oldResult))\n                resultDep.changed();\n            }\n          });\n        });\n      }\n\n      if (Deps.active) {\n        var isNew = resultDep.depend();\n        if (isNew) {\n          // For each new dependent, schedule a task for after that dependent's\n          // invalidation time and the subsequent flush. The task checks\n          // whether the computation should be torn down.\n          Deps.onInvalidate(function () {\n            if (resultDep && ! resultDep.hasDependents()) {\n              Deps.afterFlush(function () {\n                // use a second afterFlush to bump ourselves to the END of the\n                // flush, after computation re-runs have had a chance to\n                // re-establish their connections to our computation.\n                Deps.afterFlush(function () {\n                  if (resultDep && ! resultDep.hasDependents()) {\n                    computation.stop();\n                    computation = null;\n                    resultDep = null;\n                  }\n                });\n              });\n            }\n          });\n        }\n      }\n\n      return curResult;\n    };\n\n  } else {\n    var value = funcOrValue;\n    var result = function () {\n      return value;\n    };\n    result._isEmboxedConstant = true;\n    return result;\n  }\n};\n\n\n////////////////////////////////////////\n\n// Insert a DOM node or DomRange into a DOM element or DomRange.\n//\n// One of three things happens depending on what needs to be inserted into what:\n// - `range.add` (anything into DomRange)\n// - `UI.DomRange.insert` (DomRange into element)\n// - `elem.insertBefore` (node into element)\n//\n// The optional `before` argument is an existing node or id to insert before in\n// the parent element or DomRange.\nvar insert = function (nodeOrRange, parent, before) {\n  if (! parent)\n    throw new Error(\"Materialization parent required\");\n\n  if (parent instanceof UI.DomRange) {\n    parent.add(nodeOrRange, before);\n  } else if (nodeOrRange instanceof UI.DomRange) {\n    // parent is an element; inserting a range\n    UI.DomRange.insert(nodeOrRange, parent, before);\n  } else {\n    // parent is an element; inserting an element\n    parent.insertBefore(nodeOrRange, before || null); // `null` for IE\n  }\n};\n\n// Update attributes on `elem` to the dictionary `attrs`, using the\n// dictionary of existing `handlers` if provided.\n//\n// Values in the `attrs` dictionary are in pseudo-DOM form -- a string,\n// CharRef, or array of strings and CharRefs -- but they are passed to\n// the AttributeHandler in string form.\nvar updateAttributes = function(elem, newAttrs, handlers) {\n\n  if (handlers) {\n    for (var k in handlers) {\n      if (! newAttrs.hasOwnProperty(k)) {\n        // remove attributes (and handlers) for attribute names\n        // that don't exist as keys of `newAttrs` and so won't\n        // be visited when traversing it.  (Attributes that\n        // exist in the `newAttrs` object but are `null`\n        // are handled later.)\n        var handler = handlers[k];\n        var oldValue = handler.value;\n        handler.value = null;\n        handler.update(elem, oldValue, null);\n        delete handlers[k];\n      }\n    }\n  }\n\n  for (var k in newAttrs) {\n    var handler = null;\n    var oldValue;\n    var value = newAttrs[k];\n    if ((! handlers) || (! handlers.hasOwnProperty(k))) {\n      if (value !== null) {\n        // make new handler\n        handler = makeAttributeHandler(elem, k, value);\n        if (handlers)\n          handlers[k] = handler;\n        oldValue = null;\n      }\n    } else {\n      handler = handlers[k];\n      oldValue = handler.value;\n    }\n    if (handler && oldValue !== value) {\n      handler.value = value;\n      handler.update(elem, oldValue, value);\n      if (value === null)\n        delete handlers[k];\n    }\n  }\n};\n\nUI.render = function (kind, parentComponent) {\n  if (kind.isInited)\n    throw new Error(\"Can't render component instance, only component kind\");\n  var inst = kind.instantiate(parentComponent);\n\n  var content = (inst.render && inst.render());\n\n  var range = new UI.DomRange;\n  inst.dom = range;\n  range.component = inst;\n\n  materialize(content, range, null, inst);\n\n  range.removed = function () {\n    inst.isDestroyed = true;\n    if (inst.destroyed) {\n      updateTemplateInstance(inst);\n      inst.destroyed.call(inst.templateInstance);\n    }\n  };\n\n  return inst;\n};\n\nvar contentEquals = function (a, b) {\n  if (a instanceof HTML.Raw) {\n    return (b instanceof HTML.Raw) && (a.value === b.value);\n  } else if (a == null) {\n    return (b == null);\n  } else {\n    return (a === b) &&\n      ((typeof a === 'number') || (typeof a === 'boolean') ||\n       (typeof a === 'string'));\n  }\n};\n\nUI.InTemplateScope = function (tmplInstance, content) {\n  if (! (this instanceof UI.InTemplateScope))\n    // called without `new`\n    return new UI.InTemplateScope(tmplInstance, content);\n\n  var parentPtr = tmplInstance.parent;\n  if (parentPtr.__isTemplateWith)\n    parentPtr = parentPtr.parent;\n\n  this.parentPtr = parentPtr;\n  this.content = content;\n};\n\nUI.InTemplateScope.prototype.toHTML = function (parentComponent) {\n  return HTML.toHTML(this.content, this.parentPtr);\n};\n\nUI.InTemplateScope.prototype.toText = function (textMode, parentComponent) {\n  return HTML.toText(this.content, textMode, this.parentPtr);\n};\n\n// Convert the pseudoDOM `node` into reactive DOM nodes and insert them\n// into the element or DomRange `parent`, before the node or id `before`.\nvar materialize = function (node, parent, before, parentComponent) {\n  // XXX should do more error-checking for the case where user is supplying the tags.\n  // For example, check that CharRef has `html` and `str` properties and no content.\n  // Check that Comment has a single string child and no attributes.  Etc.\n\n  if (node == null) {\n    // null or undefined.\n    // do nothinge.\n  } else if ((typeof node === 'string') || (typeof node === 'boolean') || (typeof node === 'number')) {\n    node = String(node);\n    insert(document.createTextNode(node), parent, before);\n  } else if (node instanceof Array) {\n    for (var i = 0; i < node.length; i++)\n      materialize(node[i], parent, before, parentComponent);\n  } else if (typeof node === 'function') {\n\n    var range = new UI.DomRange;\n    var lastContent = null;\n    var rangeUpdater = Deps.autorun(function (c) {\n      var content = node();\n      // normalize content a little, for easier comparison\n      if (HTML.isNully(content))\n        content = null;\n      else if ((content instanceof Array) && content.length === 1)\n        content = content[0];\n\n      // update if content is different from last time\n      if (! contentEquals(content, lastContent)) {\n        lastContent = content;\n\n        if (! c.firstRun)\n          range.removeAll();\n\n        Deps.nonreactive(function () {\n          materialize(content, range, null, parentComponent);\n        });\n      }\n    });\n    range.removed = function () {\n      rangeUpdater.stop();\n    };\n    insert(range, parent, before);\n  } else if (node instanceof HTML.Tag) {\n    var tagName = HTML.properCaseTagName(node.tagName);\n    var elem;\n    if (HTML.isKnownSVGElement(tagName) && (! HTML.isKnownElement(tagName)) &&\n        document.createElementNS) {\n      elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);\n    } else {\n      elem = document.createElement(node.tagName);\n    }\n\n    var rawAttrs = node.attrs;\n    var children = node.children;\n    if (node.tagName === 'TEXTAREA') {\n      rawAttrs = (rawAttrs || {});\n      rawAttrs.value = children;\n      children = [];\n    };\n\n    if (rawAttrs) {\n      var attrUpdater = Deps.autorun(function (c) {\n        if (! c.handlers)\n          c.handlers = {};\n\n        try {\n          var attrs = HTML.evaluateAttributes(rawAttrs, parentComponent);\n          var stringAttrs = {};\n          if (attrs) {\n            for (var k in attrs) {\n              stringAttrs[k] = HTML.toText(attrs[k], HTML.TEXTMODE.STRING,\n                                           parentComponent);\n            }\n            updateAttributes(elem, stringAttrs, c.handlers);\n          }\n        } catch (e) {\n          reportUIException(e);\n        }\n      });\n      UI.DomBackend.onRemoveElement(elem, function () {\n        attrUpdater.stop();\n      });\n    }\n    materialize(children, elem, null, parentComponent);\n\n    insert(elem, parent, before);\n  } else if (typeof node.instantiate === 'function') {\n    // component\n    var instance = UI.render(node, parentComponent);\n\n    insert(instance.dom, parent, before);\n  } else if (node instanceof HTML.CharRef) {\n    insert(document.createTextNode(node.str), parent, before);\n  } else if (node instanceof HTML.Comment) {\n    insert(document.createComment(node.sanitizedValue), parent, before);\n  } else if (node instanceof HTML.Raw) {\n    // Get an array of DOM nodes by using the browser's HTML parser\n    // (like innerHTML).\n    var htmlNodes = UI.DomBackend.parseHTML(node.value);\n    for (var i = 0; i < htmlNodes.length; i++)\n      insert(htmlNodes[i], parent, before);\n  } else if (HTML.Special && (node instanceof HTML.Special)) {\n    throw new Error(\"Can't materialize Special tag, it's just an intermediate rep\");\n  } else if (node instanceof UI.InTemplateScope) {\n    materialize(node.content, parent, before, node.parentPtr);\n  } else {\n    // can't get here\n    throw new Error(\"Unexpected node in htmljs: \" + node);\n  }\n};\n\n\n\n// XXX figure out the right names, and namespace, for these.\n// for example, maybe some of them go in the HTML package.\nUI.materialize = materialize;\n\nUI.body = UI.Component.extend({\n  kind: 'body',\n  contentParts: [],\n  render: function () {\n    return this.contentParts;\n  },\n  // XXX revisit how body works.\n  INSTANTIATED: false\n});\n\nUI.block = function (renderFunc) {\n  return UI.Component.extend({ render: renderFunc });\n};\n\nUI.toHTML = function (content, parentComponent) {\n  return HTML.toHTML(content, parentComponent);\n};\n\nUI.toRawText = function (content, parentComponent) {\n  return HTML.toText(content, HTML.TEXTMODE.STRING, parentComponent);\n};\n","\nUI.If = function (argFunc, contentBlock, elseContentBlock) {\n  checkBlockHelperArguments('If', argFunc, contentBlock, elseContentBlock);\n\n  return function () {\n    if (getCondition(argFunc))\n      return contentBlock;\n    else\n      return elseContentBlock || null;\n  };\n};\n\n\nUI.Unless = function (argFunc, contentBlock, elseContentBlock) {\n  checkBlockHelperArguments('Unless', argFunc, contentBlock, elseContentBlock);\n\n  return function () {\n    if (! getCondition(argFunc))\n      return contentBlock;\n    else\n      return elseContentBlock || null;\n  };\n};\n\n// Returns true if `a` and `b` are `===`, unless they are of a mutable type.\n// (Because then, they may be equal references to an object that was mutated,\n// and we'll never know.  We save only a reference to the old object; we don't\n// do any deep-copying or diffing.)\nvar safeEquals = function (a, b) {\n  if (a !== b)\n    return false;\n  else\n    return ((!a) || (typeof a === 'number') || (typeof a === 'boolean') ||\n            (typeof a === 'string'));\n};\n\n// Unlike Spacebars.With, there's no else case and no conditional logic.\n//\n// We don't do any reactive emboxing of `argFunc` here; it should be done\n// by the caller if efficiency and/or number of calls to the data source\n// is important.\nUI.With = function (argFunc, contentBlock) {\n  checkBlockHelperArguments('With', argFunc, contentBlock);\n\n  var block = contentBlock;\n  if ('data' in block) {\n    // XXX TODO: get religion about where `data` property goes\n    block = UI.block(function () {\n      return contentBlock;\n    });\n  }\n  block.data = UI.emboxValue(argFunc, safeEquals);\n\n  return block;\n};\n\nUI.Each = function (argFunc, contentBlock, elseContentBlock) {\n  checkBlockHelperArguments('Each', argFunc, contentBlock, elseContentBlock);\n\n  return UI.EachImpl.extend({\n    __sequence: argFunc,\n    __content: contentBlock,\n    __elseContent: elseContentBlock\n  });\n};\n\nvar checkBlockHelperArguments = function (which, argFunc, contentBlock, elseContentBlock) {\n  if (typeof argFunc !== 'function')\n    throw new Error('First argument to ' + which + ' must be a function');\n  if (! UI.isComponent(contentBlock))\n    throw new Error('Second argument to ' + which + ' must be a template or UI.block');\n  if (elseContentBlock && ! UI.isComponent(elseContentBlock))\n    throw new Error('Third argument to ' + which + ' must be a template or UI.block if present');\n};\n\n// Acts like `!! conditionFunc()` except:\n//\n// - Empty array is considered falsy\n// - The result is Deps.isolated (doesn't trigger invalidation\n//   as long as the condition stays truthy or stays falsy\nvar getCondition = function (conditionFunc) {\n  return Deps.isolateValue(function () {\n    // `condition` is emboxed; it is always a function,\n    // and it only triggers invalidation if its return\n    // value actually changes.  We still need to isolate\n    // the calculation of whether it is truthy or falsy\n    // in order to not re-render if it changes from one\n    // truthy or falsy value to another.\n    var cond = conditionFunc();\n\n    // empty arrays are treated as falsey values\n    if (cond instanceof Array && cond.length === 0)\n      return false;\n    else\n      return !! cond;\n  });\n};\n","UI.EachImpl = Component.extend({\n  typeName: 'Each',\n  render: function (modeHint) {\n    var self = this;\n    var content = self.__content;\n    var elseContent = self.__elseContent;\n\n    if (modeHint === 'STATIC') {\n      // This is a hack.  The caller gives us a hint if the\n      // value we return will be static (in HTML or text)\n      // or dynamic (materialized DOM).  The dynamic path\n      // returns `null` and then we populate the DOM from\n      // the `parented` callback.\n      //\n      // It would be much cleaner to always return the same\n      // value here, and to have that value be some special\n      // object that encapsulates the logic for populating\n      // the #each using a mode-agnostic interface that\n      // works for HTML, text, and DOM.  Alternatively, we\n      // could formalize the current pattern, e.g. defining\n      // a method like component.populate(domRange) and one\n      // like renderStatic() or even renderHTML / renderText.\n      var parts = _.map(\n        ObserveSequence.fetch(self.__sequence()),\n        function (item) {\n          return content.extend({data: function () {\n            return item;\n          }});\n        });\n\n      if (parts.length) {\n        return parts;\n      } else {\n        return elseContent;\n      }\n      return parts;\n    } else {\n      return null;\n    }\n  },\n  parented: function () {\n    var self = this.__component__;\n\n    var range = self.dom;\n\n    var content = self.__content;\n    var elseContent = self.__elseContent;\n\n    // if there is an else clause, keep track of the number of\n    // rendered items.  use this to display the else clause when count\n    // becomes zero, and remove it when count becomes positive.\n    var itemCount = 0;\n    var addToCount = function(delta) {\n      if (!elseContent) // if no else, no need to keep track of count\n        return;\n\n      if (itemCount + delta < 0)\n        throw new Error(\"count should never become negative\");\n\n      if (itemCount === 0) {\n        // remove else clause\n        range.removeAll();\n      }\n      itemCount += delta;\n      if (itemCount === 0) {\n        UI.materialize(elseContent, range, null, self);\n      }\n    };\n\n    this.observeHandle = ObserveSequence.observe(function () {\n      return self.__sequence();\n    }, {\n      addedAt: function (id, item, i, beforeId) {\n        addToCount(1);\n        id = LocalCollection._idStringify(id);\n\n        var data = item;\n        var dep = new Deps.Dependency;\n\n        // function to become `comp.data`\n        var dataFunc = function () {\n          dep.depend();\n          return data;\n        };\n        // Storing `$set` on `comp.data` lets us\n        // access it from `changed`.\n        dataFunc.$set = function (v) {\n          data = v;\n          dep.changed();\n        };\n\n        if (beforeId)\n          beforeId = LocalCollection._idStringify(beforeId);\n\n        var renderedItem = UI.render(content.extend({data: dataFunc}), self);\n        range.add(id, renderedItem.dom, beforeId);\n      },\n      removed: function (id, item) {\n        addToCount(-1);\n        range.remove(LocalCollection._idStringify(id));\n      },\n      movedTo: function (id, item, i, j, beforeId) {\n        range.moveBefore(\n          LocalCollection._idStringify(id),\n          beforeId && LocalCollection._idStringify(beforeId));\n      },\n      changed: function (id, newItem) {\n        range.get(LocalCollection._idStringify(id)).component.data.$set(newItem);\n      }\n    });\n\n      // on initial render, display the else clause if no items\n      addToCount(0);\n  },\n  destroyed: function () {\n    if (this.observeHandle)\n      this.observeHandle.stop();\n  }\n});\n","\nvar global = (function () { return this; })();\n\n// Searches for the given property in `comp` or a parent,\n// and returns it as is (without call it if it's a function).\nvar lookupComponentProp = function (comp, prop) {\n  comp = findComponentWithProp(prop, comp);\n  var result = (comp ? comp.data : null);\n  if (typeof result === 'function')\n    result = _.bind(result, comp);\n  return result;\n};\n\n// Component that's a no-op when used as a block helper like\n// `{{#foo}}...{{/foo}}`.\nvar noOpComponent = Component.extend({\n  kind: 'NoOp',\n  render: function () {\n    return this.__content;\n  }\n});\n\n// This map is searched first when you do something like `{{#foo}}` in\n// a template.\nvar builtInComponents = {\n  // for past compat:\n  'constant': noOpComponent,\n  'isolate': noOpComponent\n};\n\n_extend(UI.Component, {\n  // Options:\n  //\n  // - template {Boolean} If true, look at the list of templates after\n  //   helpers and before data context.\n  lookup: function (id, opts) {\n    var self = this;\n    var template = opts && opts.template;\n    var result;\n    var comp;\n\n    if (!id)\n      throw new Error(\"must pass id to lookup\");\n\n    if (/^\\./.test(id)) {\n      // starts with a dot. must be a series of dots which maps to an\n      // ancestor of the appropriate height.\n      if (!/^(\\.)+$/.test(id)) {\n        throw new Error(\"id starting with dot must be a series of dots\");\n      }\n\n      var compWithData = findComponentWithProp('data', self);\n      for (var i = 1; i < id.length; i++) {\n        compWithData = compWithData ? findComponentWithProp('data', compWithData.parent) : null;\n      }\n\n      return (compWithData ? compWithData.data : null);\n\n    } else if ((comp = findComponentWithProp(id, self))) {\n      // found a property or method of a component\n      // (`self` or one of its ancestors)\n      var result = comp[id];\n\n    } else if (_.has(builtInComponents, id)) {\n      return builtInComponents[id];\n\n    // Code to search the global namespace for capitalized names\n    // like component classes, `Template`, `StringUtils.foo`,\n    // etc.\n    //\n    // } else if (/^[A-Z]/.test(id) && (id in global)) {\n    //   // Only look for a global identifier if `id` is\n    //   // capitalized.  This avoids having `{{name}}` mean\n    //   // `window.name`.\n    //   result = global[id];\n    //   return function (/*arguments*/) {\n    //     var data = getComponentData(self);\n    //     if (typeof result === 'function')\n    //       return result.apply(data, arguments);\n    //     return result;\n    //   };\n    } else if (template && _.has(Template, id)) {\n      return Template[id];\n\n    } else if (Handlebars._globalHelpers[id]) {\n      // Backwards compatibility for helpers defined with\n      // `Handlebars.registerHelper`. XXX what is the future pattern\n      // for this? We should definitely not put it on the Handlebars\n      // namespace.\n      result = Handlebars._globalHelpers[id];\n\n    } else {\n      // Resolve id `foo` as `data.foo` (with a \"soft dot\").\n      return function (/*arguments*/) {\n        var data = getComponentData(self);\n        if (! data)\n          return data;\n        var result = data[id];\n        if (typeof result === 'function')\n          return result.apply(data, arguments);\n        return result;\n      };\n    }\n\n    if (typeof result === 'function' && ! result._isEmboxedConstant) {\n      // Wrap the function `result`, binding `this` to `getComponentData(self)`.\n      // This creates a dependency when the result function is called.\n      // Don't do this if the function is really just an emboxed constant.\n      return function (/*arguments*/) {\n        var data = getComponentData(self);\n        return result.apply(data, arguments);\n      };\n    } else {\n      return result;\n    };\n  },\n  lookupTemplate: function (id) {\n    return this.lookup(id, {template: true});\n  },\n  get: function (id) {\n    // support `this.get()` to get the data context.\n    if (id === undefined)\n      id = \".\";\n\n    var result = this.lookup(id);\n    return (typeof result === 'function' ? result() : result);\n  },\n  set: function (id, value) {\n    var comp = findComponentWithProp(id, this);\n    if (! comp || ! comp[id])\n      throw new Error(\"Can't find field: \" + id);\n    if (typeof comp[id] !== 'function')\n      throw new Error(\"Not a settable field: \" + id);\n    comp[id](value);\n  }\n});\n","Handlebars = {\n  _globalHelpers: {},\n\n  registerHelper: function (name, func) {\n    this._globalHelpers[name] = func;\n  }\n};\n\n// Utility to HTML-escape a string.\nHandlebars._escape = (function() {\n  var escape_map = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"`\": \"&#x60;\", /* IE allows backtick-delimited attributes?? */\n    \"&\": \"&amp;\"\n  };\n  var escape_one = function(c) {\n    return escape_map[c];\n  };\n\n  return function (x) {\n    return x.replace(/[&<>\"'`]/g, escape_one);\n  };\n})();\n\n// Return these from {{...}} helpers to achieve the same as returning\n// strings from {{{...}}} helpers\nHandlebars.SafeString = function(string) {\n  this.string = string;\n};\nHandlebars.SafeString.prototype.toString = function() {\n  return this.string.toString();\n};\n"]}