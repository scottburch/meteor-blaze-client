{"version":3,"file":"/packages/ui.js","sources":["ui/exceptions.js","ui/base.js","ui/attrs.js","ui/render.js","ui/builtins.js","ui/each.js","ui/fields.js","ui/handlebars_backcompat.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AACA,c;;AAEA,mF;AACA,8E;AACA,4E;AACA,sB;AACA,E;AACA,S;AACA,E;AACA,M;AACA,Q;AACA,yB;AACA,gB;AACA,0B;AACA,I;AACA,M;AACA,E;AACA,6D;;AAEA,uC;AACA,kB;AACA,wB;AACA,6B;AACA,6D;AACA,8E;AACA,gC;AACA,M;;AAEA,4E;AACA,gF;AACA,gE;AACA,sE;AACA,E;;;;;;;;;;;;;;;;;;;ACjCA,Q;;AAEA,2D;AACA,2D;AACA,iB;AACA,+B;AACA,oB;AACA,8B;AACA,sB;AACA,a;AACA,E;;AAEA,sD;AACA,Y;AACA,6C;AACA,iD;AACA,6C;AACA,mB;AACA,kD;AACA,O;AACA,qD;AACA,e;AACA,a;AACA,sB;AACA,G;AACA,a;AACA,E;;AAEA,4D;AACA,iE;AACA,4D;AACA,Q;AACA,4C;AACA,gE;AACA,qD;AACA,E;;AAEA,6D;AACA,iE;AACA,mE;AACA,qE;AACA,mD;AACA,c;;AAEA,4D;AACA,2D;AACA,8D;AACA,4D;AACA,iB;AACA,I;AACA,6D;AACA,8D;AACA,6D;AACA,4D;AACA,6B;AACA,qC;;AAEA,wD;AACA,4C;AACA,yD;AACA,uD;AACA,0D;AACA,sD;AACA,wD;AACA,gD;AACA,uB;AACA,yC;AACA,sC;AACA,a;AACA,8B;AACA,K;;AAEA,a;AACA,iC;;AAEA,+B;AACA,iD;AACA,I;AACA,yD;AACA,+C;AACA,gC;AACA,6B;AACA,e;AACA,kB;AACA,oB;AACA,mB;AACA,K;AACA,iB;AACA,I;AACA,uD;AACA,sD;AACA,iB;AACA,sC;AACA,sB;AACA,oF;AACA,I;AACA,gC;AACA,qB;AACA,4E;AACA,I;AACA,6B;AACA,gB;AACA,oF;AACA,G;AACA,G;;AAEA,yB;;AAEA,uB;AACA,2D;AACA,+D;AACA,2D;AACA,6D;AACA,4D;AACA,oC;AACA,I;AACA,qD;AACA,iD;AACA,6D;AACA,qD;AACA,qD;AACA,qD;AACA,4B;AACA,oB;AACA,Y;AACA,Y;AACA,yC;AACA,kB;AACA,+D;AACA,sB;AACA,qB;AACA,0D;AACA,iC;AACA,yC;AACA,e;;AAEA,yD;AACA,+C;AACA,4B;AACA,qD;AACA,2D;AACA,2B;;AAEA,sB;AACA,qD;AACA,0D;AACA,sD;AACA,wB;AACA,0D;;AAEA,e;AACA,2B;AACA,wD;AACA,oD;AACA,8B;AACA,4C;AACA,sD;AACA,oC;AACA,wB;AACA,Y;AACA,4B;AACA,K;;AAEA,yD;AACA,0D;AACA,uD;AACA,qD;AACA,4B;;AAEA,uB;AACA,mB;AACA,yB;;AAEA,c;AACA,wB;;AAEA,wD;AACA,sC;AACA,sC;AACA,mC;;AAEA,a;AACA,G;AACA,G;;AAEA,yD;AACA,wC;AACA,wD;AACA,0D;AACA,0D;AACA,sD;AACA,uC;AACA,oB;AACA,+D;AACA,E;AACA,sC;AACA,wC;AACA,I;;;AAGA,wE;AACA,sE;AACA,kB;AACA,qE;AACA,2C;AACA,2D;AACA,c;AACA,a;AACA,kC;AACA,yC;AACA,mD;AACA,U;AACA,8E;AACA,kF;AACA,sC;AACA,uC;AACA,e;AACA,oD;AACA,G;AACA,E;;AAEA,6C;AACA,gB;AACA,wC;AACA,kB;AACA,uB;AACA,G;AACA,c;AACA,E;;AAEA,oC;AACA,6C;AACA,gB;AACA,4C;AACA,qC;AACA,gB;AACA,E;;AAEA,0C;AACA,+D;AACA,e;AACA,mC;AACA,qC;;AAEA,sC;AACA,sD;AACA,uD;AACA,0D;AACA,yD;AACA,gC;AACA,sE;AACA,qC;AACA,U;AACA,qE;AACA,0B;AACA,yB;AACA,G;AACA,E;;AAEA,uB;AACA,iE;AACA,0B;AACA,4B;AACA,wB;AACA,I;AACA,2B;AACA,e;AACA,uC;AACA,4B;AACA,Q;AACA,mC;;AAEA,2C;AACA,uC;AACA,wE;AACA,yC;AACA,wC;AACA,+B;AACA,iB;;AAEA,sC;AACA,uC;AACA,uC;AACA,wC;AACA,wC;AACA,S;AACA,O;AACA,G;AACA,G;;AAEA,+D;AACA,uD;AACA,2C;AACA,kB;AACA,mD;AACA,0E;AACA,sD;AACA,0C;AACA,kE;AACA,mE;AACA,kE;AACA,gE;AACA,qE;AACA,iD;AACA,kD;AACA,4B;AACA,K;AACA,kE;AACA,iE;AACA,+D;AACA,2B;AACA,6C;AACA,2E;AACA,kD;AACA,qC;AACA,sC;AACA,wE;AACA,gE;AACA,4C;AACA,mE;AACA,sE;AACA,kD;AACA,+D;AACA,W;AACA,Q;;AAEA,4D;AACA,O;AACA,G;;AAEA,yC;AACA,sB;AACA,kC;AACA,mC;AACA,gD;AACA,O;AACA,G;;AAEA,sB;AACA,gD;AACA,iC;AACA,+B;AACA,qC;AACA,kD;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,c;AACA,uC;;;;;;;;;;;;;;;;;;;;AC7VA,gF;AACA,kE;AACA,uE;AACA,sB;AACA,E;AACA,gD;AACA,uE;AACA,4E;AACA,yE;AACA,uE;AACA,0E;AACA,yE;AACA,wE;AACA,sE;AACA,0E;AACA,+B;AACA,E;AACA,2E;AACA,kE;AACA,E;AACA,4E;AACA,0D;;AAEA,2C;AACA,mB;AACA,qB;AACA,E;;AAEA,sC;AACA,+C;AACA,yB;AACA,4B;AACA,2C;AACA,Y;AACA,kD;AACA,K;AACA,G;AACA,G;;AAEA,8C;AACA,qB;AACA,iE;AACA,4C;AACA,I;AACA,kC;AACA,kC;AACA,c;AACA,yC;AACA,iB;AACA,E;;AAEA,0D;AACA,gD;AACA,+C;AACA,gD;AACA,2E;;AAEA,oE;AACA,8D;;AAEA,gE;AACA,sE;;AAEA,qE;AACA,qC;AACA,uC;AACA,wC;AACA,O;AACA,qC;AACA,yC;AACA,oC;AACA,wB;AACA,O;;AAEA,8C;AACA,G;AACA,G;;AAEA,4C;AACA,6B;AACA,uC;AACA,6B;AACA,I;AACA,2C;AACA,kC;AACA,G;AACA,G;;AAEA,+C;AACA,uC;AACA,qC;AACA,I;AACA,2C;AACA,6C;AACA,G;AACA,G;;AAEA,8C;AACA,+C;AACA,yB;AACA,wB;AACA,2B;AACA,8B;AACA,Y;AACA,2B;AACA,K;AACA,G;AACA,G;;AAEA,4C;AACA,+C;AACA,uD;;AAEA,iB;AACA,4B;AACA,G;AACA,G;;AAEA,mD;AACA,oC;AACA,mC;AACA,E;;AAEA,iE;AACA,qD;AACA,sE;AACA,kE;AACA,yB;AACA,6B;AACA,8C;AACA,Y;AACA,2C;AACA,K;AACA,yD;AACA,2C;AACA,sE;AACA,mC;AACA,8D;AACA,kC;AACA,yC;AACA,U;AACA,6C;AACA,G;;AAEA,gE;AACA,oC;AACA,E;;;;;;;;;;;;;;;;;;;;AClJA,8C;AACA,kB;;AAEA,oB;AACA,6B;AACA,sB;AACA,uE;AACA,U;AACA,+C;AACA,G;;AAEA,+C;AACA,uB;;AAEA,kC;AACA,2B;AACA,kC;AACA,2C;AACA,kC;AACA,M;AACA,+B;AACA,0C;AACA,+B;AACA,M;AACA,oB;AACA,mB;AACA,e;AACA,uB;AACA,I;;AAEA,iC;;AAEA,gB;AACA,gB;;AAEA,qB;AACA,iC;AACA,6C;AACA,G;;AAEA,c;AACA,E;;AAEA,mC;AACA,c;AACA,E;;;AAGA,8E;AACA,8E;AACA,oD;AACA,E;AACA,yE;AACA,yE;AACA,uE;AACA,0E;AACA,2E;AACA,yE;AACA,4E;AACA,kB;AACA,E;AACA,0E;AACA,0E;AACA,qE;AACA,sE;AACA,yE;AACA,8D;AACA,E;AACA,0E;AACA,oE;AACA,uE;AACA,wE;AACA,0E;AACA,2E;AACA,2E;AACA,4E;AACA,sD;AACA,E;AACA,4E;AACA,8E;AACA,E;AACA,gD;AACA,0C;AACA,2B;;AAEA,yB;AACA,uE;AACA,mE;AACA,qE;AACA,c;AACA,yB;AACA,2B;;AAEA,wB;AACA,0B;AACA,4B;AACA,0E;AACA,4D;AACA,wB;AACA,S;;AAEA,2E;AACA,6E;AACA,uC;AACA,wC;;AAEA,oD;AACA,4C;AACA,sC;AACA,+B;AACA,+B;AACA,4D;AACA,8C;AACA,oC;AACA,a;AACA,a;AACA,W;AACA,O;;AAEA,wB;AACA,uC;AACA,oB;AACA,+E;AACA,wE;AACA,yD;AACA,yC;AACA,2D;AACA,2C;AACA,8E;AACA,wE;AACA,qE;AACA,6C;AACA,iE;AACA,uC;AACA,uC;AACA,qC;AACA,mB;AACA,mB;AACA,iB;AACA,a;AACA,a;AACA,S;AACA,O;;AAEA,uB;AACA,M;;AAEA,U;AACA,4B;AACA,8B;AACA,mB;AACA,M;AACA,qC;AACA,kB;AACA,G;AACA,E;;;AAGA,wC;;AAEA,gE;AACA,E;AACA,gF;AACA,yC;AACA,iD;AACA,4C;AACA,E;AACA,+E;AACA,kC;AACA,qD;AACA,e;AACA,uD;;AAEA,sC;AACA,oC;AACA,kD;AACA,8C;AACA,oD;AACA,U;AACA,iD;AACA,sE;AACA,G;AACA,E;;AAEA,mE;AACA,iD;AACA,E;AACA,uE;AACA,sE;AACA,uC;AACA,2D;;AAEA,iB;AACA,6B;AACA,yC;AACA,+D;AACA,8D;AACA,2D;AACA,wD;AACA,8B;AACA,kC;AACA,qC;AACA,6B;AACA,6C;AACA,2B;AACA,O;AACA,K;AACA,G;;AAEA,2B;AACA,uB;AACA,iB;AACA,4B;AACA,yD;AACA,2B;AACA,2B;AACA,uD;AACA,qB;AACA,gC;AACA,wB;AACA,O;AACA,Y;AACA,4B;AACA,+B;AACA,K;AACA,wC;AACA,4B;AACA,4C;AACA,yB;AACA,2B;AACA,K;AACA,G;AACA,E;;AAEA,8C;AACA,oB;AACA,4E;AACA,+C;;AAEA,+C;;AAEA,8B;AACA,mB;AACA,yB;;AAEA,0C;;AAEA,+B;AACA,4B;AACA,yB;AACA,mC;AACA,iD;AACA,K;AACA,I;;AAEA,c;AACA,E;;AAEA,qC;AACA,8B;AACA,4D;AACA,yB;AACA,uB;AACA,U;AACA,uB;AACA,6D;AACA,gC;AACA,G;AACA,E;;AAEA,uD;AACA,6C;AACA,2B;AACA,yD;;AAEA,sC;AACA,iC;AACA,iC;;AAEA,6B;AACA,yB;AACA,E;;AAEA,kE;AACA,mD;AACA,E;;AAEA,4E;AACA,6D;AACA,E;;AAEA,uE;AACA,yE;AACA,oE;AACA,qF;AACA,oF;AACA,0E;;AAEA,qB;AACA,yB;AACA,mB;AACA,uG;AACA,wB;AACA,0D;AACA,qC;AACA,yC;AACA,4D;AACA,0C;;AAEA,gC;AACA,2B;AACA,kD;AACA,2B;AACA,0D;AACA,gC;AACA,uB;AACA,kE;AACA,6B;;AAEA,sD;AACA,kD;AACA,8B;;AAEA,yB;AACA,4B;;AAEA,sC;AACA,6D;AACA,W;AACA,O;AACA,O;AACA,iC;AACA,0B;AACA,M;AACA,kC;AACA,wC;AACA,uD;AACA,a;AACA,8E;AACA,mC;AACA,6E;AACA,Y;AACA,kD;AACA,K;;AAEA,8B;AACA,iC;AACA,sC;AACA,kC;AACA,gC;AACA,oB;AACA,M;;AAEA,mB;AACA,mD;AACA,yB;AACA,0B;;AAEA,a;AACA,yE;AACA,+B;AACA,sB;AACA,kC;AACA,0E;AACA,4D;AACA,a;AACA,4D;AACA,W;AACA,qB;AACA,+B;AACA,S;AACA,S;AACA,uD;AACA,2B;AACA,S;AACA,K;AACA,uD;;AAEA,iC;AACA,sD;AACA,gB;AACA,oD;;AAEA,yC;AACA,4C;AACA,8D;AACA,4C;AACA,wE;AACA,wC;AACA,mE;AACA,wB;AACA,wD;AACA,8C;AACA,2C;AACA,8D;AACA,oF;AACA,kD;AACA,8D;AACA,U;AACA,qB;AACA,0D;AACA,G;AACA,E;;;;AAIA,4D;AACA,0D;AACA,6B;;AAEA,+B;AACA,e;AACA,mB;AACA,uB;AACA,6B;AACA,I;AACA,gC;AACA,qB;AACA,G;;AAEA,kC;AACA,qD;AACA,E;;AAEA,iD;AACA,+C;AACA,E;;AAEA,oD;AACA,qE;AACA,E;;;;;;;;;;;;;;;;;;;;AC9aA,4D;AACA,2E;;AAEA,sB;AACA,8B;AACA,0B;AACA,Q;AACA,sC;AACA,I;AACA,E;;;AAGA,gE;AACA,+E;;AAEA,sB;AACA,gC;AACA,0B;AACA,Q;AACA,sC;AACA,I;AACA,E;;AAEA,4E;AACA,6E;AACA,8E;AACA,mC;AACA,kC;AACA,c;AACA,iB;AACA,M;AACA,0E;AACA,qC;AACA,E;;AAEA,wE;AACA,E;AACA,yE;AACA,wE;AACA,gB;AACA,4C;AACA,2D;;AAEA,2B;AACA,wB;AACA,8D;AACA,kC;AACA,0B;AACA,O;AACA,G;AACA,kD;;AAEA,e;AACA,E;;AAEA,8D;AACA,6E;;AAEA,6B;AACA,wB;AACA,4B;AACA,mC;AACA,K;AACA,E;;AAEA,2F;AACA,oC;AACA,0E;AACA,qC;AACA,uF;AACA,6D;AACA,iG;AACA,E;;AAEA,yC;AACA,E;AACA,oC;AACA,8D;AACA,yD;AACA,6C;AACA,wC;AACA,uD;AACA,sD;AACA,wD;AACA,uD;AACA,uD;AACA,wC;AACA,+B;;AAEA,gD;AACA,mD;AACA,mB;AACA,Q;AACA,qB;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AChGA,gC;AACA,mB;AACA,+B;AACA,oB;AACA,iC;AACA,yC;;AAEA,gC;AACA,2D;AACA,yD;AACA,yD;AACA,yD;AACA,iC;AACA,Q;AACA,2D;AACA,2D;AACA,0D;AACA,uD;AACA,0D;AACA,2D;AACA,2D;AACA,6D;AACA,wB;AACA,iD;AACA,yB;AACA,oD;AACA,wB;AACA,c;AACA,W;;AAEA,yB;AACA,qB;AACA,c;AACA,2B;AACA,O;AACA,mB;AACA,Y;AACA,kB;AACA,K;AACA,I;AACA,yB;AACA,kC;;AAEA,yB;;AAEA,iC;AACA,yC;;AAEA,8D;AACA,sE;AACA,+D;AACA,sB;AACA,sC;AACA,qE;AACA,e;;AAEA,gC;AACA,8D;;AAEA,4B;AACA,6B;AACA,0B;AACA,O;AACA,yB;AACA,4B;AACA,uD;AACA,O;AACA,M;;AAEA,8D;AACA,+B;AACA,Q;AACA,iD;AACA,sB;AACA,8C;;AAEA,wB;AACA,sC;;AAEA,yC;AACA,oC;AACA,uB;AACA,sB;AACA,U;AACA,gD;AACA,oC;AACA,sC;AACA,mB;AACA,wB;AACA,U;;AAEA,qB;AACA,4D;;AAEA,6E;AACA,kD;AACA,Q;AACA,oC;AACA,uB;AACA,uD;AACA,Q;AACA,oD;AACA,yB;AACA,2C;AACA,8D;AACA,Q;AACA,uC;AACA,iF;AACA,O;AACA,O;;AAEA,+D;AACA,oB;AACA,I;AACA,0B;AACA,2B;AACA,gC;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;;ACrHA,8C;;AAEA,yD;AACA,6D;AACA,iD;AACA,2C;AACA,yC;AACA,mC;AACA,kC;AACA,gB;AACA,E;;AAEA,4D;AACA,yB;AACA,sC;AACA,e;AACA,uB;AACA,0B;AACA,G;AACA,G;;AAEA,sE;AACA,c;AACA,yB;AACA,qB;AACA,4B;AACA,0B;AACA,E;;AAEA,uB;AACA,a;AACA,I;AACA,sE;AACA,uC;AACA,+B;AACA,oB;AACA,yC;AACA,e;AACA,a;;AAEA,Y;AACA,gD;;AAEA,yB;AACA,qE;AACA,4C;AACA,gC;AACA,yE;AACA,O;;AAEA,6D;AACA,2C;AACA,gG;AACA,O;;AAEA,uD;;AAEA,0D;AACA,kD;AACA,yC;AACA,4B;;AAEA,8C;AACA,mC;;AAEA,gE;AACA,6D;AACA,W;AACA,M;AACA,wD;AACA,wD;AACA,4D;AACA,0B;AACA,6B;AACA,0C;AACA,6C;AACA,4C;AACA,kD;AACA,yB;AACA,W;AACA,iD;AACA,0B;;AAEA,+C;AACA,yD;AACA,oE;AACA,oE;AACA,mB;AACA,6C;;AAEA,Y;AACA,4D;AACA,uC;AACA,0C;AACA,mB;AACA,sB;AACA,8B;AACA,yC;AACA,+C;AACA,sB;AACA,Q;AACA,K;;AAEA,sE;AACA,gF;AACA,sE;AACA,0E;AACA,uC;AACA,0C;AACA,6C;AACA,Q;AACA,Y;AACA,oB;AACA,M;AACA,I;AACA,iC;AACA,6C;AACA,I;AACA,sB;AACA,oD;AACA,yB;AACA,e;;AAEA,iC;AACA,8D;AACA,I;AACA,6B;AACA,+C;AACA,6B;AACA,iD;AACA,uC;AACA,qD;AACA,oB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACvIA,c;AACA,qB;;AAEA,yC;AACA,qC;AACA,G;AACA,E;;AAEA,mC;AACA,kC;AACA,oB;AACA,gB;AACA,gB;AACA,kB;AACA,kB;AACA,kE;AACA,gB;AACA,I;AACA,gC;AACA,yB;AACA,I;;AAEA,uB;AACA,8C;AACA,I;AACA,K;;AAEA,qE;AACA,iC;AACA,0C;AACA,uB;AACA,E;AACA,uD;AACA,gC;AACA,E","sourcesContent":["\nvar debugFunc;\n\n// Meteor UI calls into user code in many places, and it's nice to catch exceptions\n// propagated from user code immediately so that the whole system doesn't just\n// break.  Catching exceptions is easy; reporting them is hard.  This helper\n// reports exceptions.\n//\n// Usage:\n//\n// ```\n// try {\n//   // ... someStuff ...\n// } catch (e) {\n//   reportUIException(e);\n// }\n// ```\n//\n// An optional second argument overrides the default message.\n\nreportUIException = function (e, msg) {\n  if (! debugFunc)\n    // adapted from Deps\n    debugFunc = function () {\n      return (typeof Meteor !== \"undefined\" ? Meteor._debug :\n              ((typeof console !== \"undefined\") && console.log ? console.log :\n               function () {}));\n    };\n\n  // In Chrome, `e.stack` is a multiline string that starts with the message\n  // and contains a stack trace.  Furthermore, `console.log` makes it clickable.\n  // `console.log` supplies the space between the two arguments.\n  debugFunc()(msg || 'Exception in Meteor UI:', e.stack || e.message);\n};\n","UI = {};\n\n// A very basic operation like Underscore's `_.extend` that\n// copies `src`'s own, enumerable properties onto `tgt` and\n// returns `tgt`.\n_extend = function (tgt, src) {\n  for (var k in src)\n    if (src.hasOwnProperty(k))\n      tgt[k] = src[k];\n  return tgt;\n};\n\n// Defines a single non-enumerable, read-only property\n// on `tgt`.\n// It won't be non-enumerable in IE 8, so its\n// non-enumerability can't be relied on for logic\n// purposes, it just makes things prettier in\n// the dev console.\nvar _defineNonEnum = function (tgt, name, value) {\n  try {\n    Object.defineProperty(tgt, name, {value: value});\n  } catch (e) {\n    // IE < 9\n    tgt[name] = value;\n  }\n  return tgt;\n};\n\n// Make `typeName` a non-empty string starting with an ASCII\n// letter or underscore and containing only letters, underscores,\n// and numbers.  This makes it safe to insert into evaled JS\n// code.\nvar sanitizeTypeName = function (typeName) {\n  return String(typeName).replace(/^[^a-zA-Z_]|[^a-zA-Z_0-9]+/g,\n                                  '') || 'Component';\n};\n\n// Named function (like `function Component() {}` below) make\n// inspection in debuggers more descriptive. In IE, this sets the\n// value of the `Component` var in the function scope in which it's\n// executed. We already have a top-level `Component` var so we create\n// a new function scope to not write it over in IE.\n(function () {\n\n  // Components and Component kinds are the same thing, just\n  // objects; there are no constructor functions, no `new`,\n  // and no `instanceof`.  A Component object is like a class,\n  // until it is inited, at which point it becomes more like\n  // an instance.\n  //\n  // `y = x.extend({ ...new props })` creates a new Component\n  // `y` with `x` as its prototype, plus additional properties\n  // on `y` itself.  `extend` is used both to subclass and to\n  // create instances (and the hope is we can gloss over the\n  // difference in the docs).\n  UI.Component = (function (constr) {\n\n    // Make sure the \"class name\" that Chrome infers for\n    // UI.Component is \"Component\", and that\n    // `new UI.Component._constr` (which is what `extend`\n    // does) also produces objects whose inferred class\n    // name is \"Component\".  Chrome's name inference rules\n    // are a little mysterious, but a function name in\n    // the source code (as in `function Component() {}`)\n    // seems to be reliable and high precedence.\n    var C = new constr;\n    _defineNonEnum(C, '_constr', constr);\n    _defineNonEnum(C, '_super', null);\n    return C;\n  })(function Component() {});\n})();\n\n_extend(UI, {\n  nextGuid: 2, // Component is 1!\n\n  isComponent: function (obj) {\n    return obj && UI.isKindOf(obj, UI.Component);\n  },\n  // `UI.isKindOf(a, b)` where `a` and `b` are Components\n  // (or kinds) asks if `a` is or descends from\n  // (transitively extends) `b`.\n  isKindOf: function (a, b) {\n    while (a) {\n      if (a === b)\n        return true;\n      a = a._super;\n    }\n    return false;\n  },\n  // use these to produce error messages for developers\n  // (though throwing a more specific error message is\n  // even better)\n  _requireNotDestroyed: function (c) {\n    if (c.isDestroyed)\n      throw new Error(\"Component has been destroyed; can't perform this operation\");\n  },\n  _requireInited: function (c) {\n    if (! c.isInited)\n      throw new Error(\"Component must be inited to perform this operation\");\n  },\n  _requireDom: function (c) {\n    if (! c.dom)\n      throw new Error(\"Component must be built into DOM to perform this operation\");\n  }\n});\n\nComponent = UI.Component;\n\n_extend(UI.Component, {\n  // If a Component has a `kind` property set via `extend`,\n  // we make it use that name when printed in Chrome Dev Tools.\n  // If you then extend this Component and don't supply any\n  // new `kind`, it should use the same value of kind (or the\n  // most specific one in the case of an `extend` chain with\n  // `kind` set at multiple points).\n  //\n  // To accomplish this, keeping performance in mind,\n  // any Component where `kind` is explicitly set\n  // also has a function property `_constr` whose source-code\n  // name is `kind`.  `extend` creates this `_constr`\n  // function, which can then be used internally as a\n  // constructor to quickly create new instances that\n  // pretty-print correctly.\n  kind: \"Component\",\n  guid: \"1\",\n  dom: null,\n  // Has this Component ever been inited?\n  isInited: false,\n  // Has this Component been destroyed?  Only inited Components\n  // can be destroyed.\n  isDestroyed: false,\n  // Component that created this component (typically also\n  // the DOM containment parent).\n  // No child pointers (except in `dom`).\n  parent: null,\n\n  // create a new subkind or instance whose proto pointer\n  // points to this, with additional props set.\n  extend: function (props) {\n    // this function should never cause `props` to be\n    // mutated in case people want to reuse `props` objects\n    // in a mixin-like way.\n\n    if (this.isInited)\n      // Disallow extending inited Components so that\n      // inited Components don't inherit instance-specific\n      // properties from other inited Components, just\n      // default values.\n      throw new Error(\"Can't extend an inited Component\");\n\n    var constr;\n    var constrMade = false;\n    // Any Component with a kind of \"Foo\" (say) is given\n    // a `._constr` of the form `function Foo() {}`.\n    if (props && props.kind) {\n      constr = Function(\"return function \" +\n                        sanitizeTypeName(props.kind) +\n                        \"() {};\")();\n      constrMade = true;\n    } else {\n      constr = this._constr;\n    }\n\n    // We don't know where we're getting `constr` from --\n    // it might be from some supertype -- just that it has\n    // the right function name.  So set the `prototype`\n    // property each time we use it as a constructor.\n    constr.prototype = this;\n\n    var c = new constr;\n    if (constrMade)\n      c._constr = constr;\n\n    if (props)\n      _extend(c, props);\n\n    // for efficient Component instantiations, we assign\n    // as few things as possible here.\n    _defineNonEnum(c, '_super', this);\n    c.guid = String(UI.nextGuid++);\n\n    return c;\n  }\n});\n\n//callChainedCallback = function (comp, propName, orig) {\n  // Call `comp.foo`, `comp._super.foo`,\n  // `comp._super._super.foo`, and so on, but in reverse\n  // order, and only if `foo` is an \"own property\" in each\n  // case.  Furthermore, the passed value of `this` should\n  // remain `comp` for all calls (which is achieved by\n  // filling in `orig` when recursing).\n//  if (comp._super)\n//    callChainedCallback(comp._super, propName, orig || comp);\n//\n//  if (comp.hasOwnProperty(propName))\n//    comp[propName].call(orig || comp);\n//};\n\n\n// Returns 0 if the nodes are the same or either one contains the other;\n// otherwise, -1 if a comes before b, or else 1 if b comes before a in\n// document order.\n// Requires: `a` and `b` are element nodes in the same document tree.\nvar compareElementIndex = function (a, b) {\n  // See http://ejohn.org/blog/comparing-document-position/\n  if (a === b)\n    return 0;\n  if (a.compareDocumentPosition) {\n    var n = a.compareDocumentPosition(b);\n    return ((n & 0x18) ? 0 : ((n & 0x4) ? -1 : 1));\n  } else {\n    // Only old IE is known to not have compareDocumentPosition (though Safari\n    // originally lacked it).  Thankfully, IE gives us a way of comparing elements\n    // via the \"sourceIndex\" property.\n    if (a.contains(b) || b.contains(a))\n      return 0;\n    return (a.sourceIndex < b.sourceIndex ? -1 : 1);\n  }\n};\n\nfindComponentWithProp = function (id, comp) {\n  while (comp) {\n    if (typeof comp[id] !== 'undefined')\n      return comp;\n    comp = comp.parent;\n  }\n  return null;\n};\n\ngetComponentData = function (comp) {\n  comp = findComponentWithProp('data', comp);\n  return (comp ?\n          (typeof comp.data === 'function' ?\n           comp.data() : comp.data) :\n          null);\n};\n\nupdateTemplateInstance = function (comp) {\n  // Populate `comp.templateInstance.{firstNode,lastNode,data}`\n  // on demand.\n  var tmpl = comp.templateInstance;\n  tmpl.data = getComponentData(comp);\n\n  if (comp.dom && !comp.isDestroyed) {\n    tmpl.firstNode = comp.dom.startNode().nextSibling;\n    tmpl.lastNode = comp.dom.endNode().previousSibling;\n    // Catch the case where the DomRange is empty and we'd\n    // otherwise pass the out-of-order nodes (end, start)\n    // as (firstNode, lastNode).\n    if (tmpl.lastNode && tmpl.lastNode.nextSibling === tmpl.firstNode)\n      tmpl.lastNode = tmpl.firstNode;\n  } else {\n    // on 'created' or 'destroyed' callbacks we don't have a DomRange\n    tmpl.firstNode = null;\n    tmpl.lastNode = null;\n  }\n};\n\n_extend(UI.Component, {\n  // We implement the old APIs here, including how data is passed\n  // to helpers in `this`.\n  helpers: function (dict) {\n    _extend(this, dict);\n  },\n  events: function (dict) {\n    var events;\n    if (this.hasOwnProperty('_events'))\n      events = this._events;\n    else\n      events = (this._events = []);\n\n    _.each(dict, function (handler, spec) {\n      var clauses = spec.split(/,\\s+/);\n      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\n      _.each(clauses, function (clause) {\n        var parts = clause.split(/\\s+/);\n        if (parts.length === 0)\n          return;\n\n        var newEvents = parts.shift();\n        var selector = parts.join(' ');\n        events.push({events: newEvents,\n                     selector: selector,\n                     handler: handler});\n      });\n    });\n  }\n});\n\n// XXX we don't really want this to be a user-visible callback,\n// it's just a particular signal we need from DomRange.\nUI.Component.notifyParented = function () {\n  var self = this;\n  for (var comp = self; comp; comp = comp._super) {\n    var events = (comp.hasOwnProperty('_events') && comp._events) || null;\n    if ((! events) && comp.hasOwnProperty('events') &&\n        typeof comp.events === 'object') {\n      // Provide limited back-compat support for `.events = {...}`\n      // syntax.  Pass `comp.events` to the original `.events(...)`\n      // function.  This code must run only once per component, in\n      // order to not bind the handlers more than once, which is\n      // ensured by the fact that we only do this when `comp._events`\n      // is falsy, and we cause it to be set now.\n      UI.Component.events.call(comp, comp.events);\n      events = comp._events;\n    }\n    _.each(events, function (esh) { // {events, selector, handler}\n      // wrap the handler here, per instance of the template that\n      // declares the event map, so we can pass the instance to\n      // the event handler.\n      var wrappedHandler = function (event) {\n        var comp = UI.DomRange.getContainingComponent(event.currentTarget);\n        var data = comp && getComponentData(comp);\n        updateTemplateInstance(self);\n        Deps.nonreactive(function () {\n          // Don't want to be in a deps context, even if we were somehow\n          // triggered synchronously in an existing deps context\n          // (the `blur` event can do this).\n          // XXX we should probably do what Spark did and block all\n          // event handling during our DOM manip.  Many apps had weird\n          // unanticipated bugs until we did that.\n          esh.handler.call(data, event, self.templateInstance);\n        });\n      };\n\n      self.dom.on(esh.events, esh.selector, wrappedHandler);\n    });\n  }\n\n  // XXX this is an undocumented callback\n  if (self.parented) {\n    Deps.nonreactive(function () {\n      updateTemplateInstance(self);\n      self.parented.call(self.templateInstance);\n    });\n  }\n\n  if (self.rendered) {\n    // Defer rendered callback until flush time.\n    Deps.afterFlush(function () {\n      if (! self.isDestroyed) {\n        updateTemplateInstance(self);\n        self.rendered.call(self.templateInstance);\n      }\n    });\n  }\n};\n\n// past compat\nUI.Component.preserve = function () {};\n","\n// An AttributeHandler object is responsible for updating a particular attribute\n// of a particular element.  AttributeHandler subclasses implement\n// browser-specific logic for dealing with particular attributes across\n// different browsers.\n//\n// To define a new type of AttributeHandler, use\n// `var FooHandler = AttributeHandler.extend({ update: function ... })`\n// where the `update` function takes arguments `(element, oldValue, value)`.\n// The `element` argument is always the same between calls to `update` on\n// the same instance.  `oldValue` and `value` are each either `null` or\n// a Unicode string of the type that might be passed to the value argument\n// of `setAttribute` (i.e. not an HTML string with character references).\n// When an AttributeHandler is installed, an initial call to `update` is\n// always made with `oldValue = null`.  The `update` method can access\n// `this.name` if the AttributeHandler class is a generic one that applies\n// to multiple attribute names.\n//\n// AttributeHandlers can store custom properties on `this`, as long as they\n// don't use the names `element`, `name`, `value`, and `oldValue`.\n//\n// AttributeHandlers can't influence how attributes appear in rendered HTML,\n// only how they are updated after materialization as DOM.\n\nAttributeHandler = function (name, value) {\n  this.name = name;\n  this.value = value;\n};\n\n_.extend(AttributeHandler.prototype, {\n  update: function (element, oldValue, value) {\n    if (value === null) {\n      if (oldValue !== null)\n        element.removeAttribute(this.name);\n    } else {\n      element.setAttribute(this.name, this.value);\n    }\n  }\n});\n\nAttributeHandler.extend = function (options) {\n  var curType = this;\n  var subType = function AttributeHandlerSubtype(/*arguments*/) {\n    AttributeHandler.apply(this, arguments);\n  };\n  subType.prototype = new curType;\n  subType.extend = curType.extend;\n  if (options)\n    _.extend(subType.prototype, options);\n  return subType;\n};\n\n// Extended below to support both regular and SVG elements\nvar BaseClassHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    if (!this.getCurrentValue || !this.setValue)\n      throw new Error(\"Missing methods in subclass of 'BaseClassHandler'\");\n\n    var oldClasses = oldValue ? _.compact(oldValue.split(' ')) : [];\n    var newClasses = value ? _.compact(value.split(' ')) : [];\n\n    // the current classes on the element, which we will mutate.\n    var classes = _.compact(this.getCurrentValue(element).split(' '));\n\n    // optimize this later (to be asymptotically faster) if necessary\n    _.each(oldClasses, function (c) {\n      if (_.indexOf(newClasses, c) < 0)\n        classes = _.without(classes, c);\n    });\n    _.each(newClasses, function (c) {\n      if (_.indexOf(oldClasses, c) < 0 &&\n          _.indexOf(classes, c) < 0)\n        classes.push(c);\n    });\n\n    this.setValue(element, classes.join(' '));\n  }\n});\n\nvar ClassHandler = BaseClassHandler.extend({\n  // @param rawValue {String}\n  getCurrentValue: function (element) {\n    return element.className;\n  },\n  setValue: function (element, className) {\n    element.className = className;\n  }\n});\n\nvar SVGClassHandler = BaseClassHandler.extend({\n  getCurrentValue: function (element) {\n    return element.className.baseVal;\n  },\n  setValue: function (element, className) {\n    element.setAttribute('class', className);\n  }\n});\n\nvar BooleanHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var name = this.name;\n    if (value == null) {\n      if (oldValue != null)\n        element[name] = false;\n    } else {\n      element[name] = true;\n    }\n  }\n});\n\nvar ValueHandler = AttributeHandler.extend({\n  update: function (element, oldValue, value) {\n    var focused = (element === document.activeElement);\n\n    if (!focused)\n      element.value = value;\n  }\n});\n\n// cross-browser version of `instanceof SVGElement`\nvar isSVGElement = function (elem) {\n  return 'ownerSVGElement' in elem;\n};\n\n// XXX make it possible for users to register attribute handlers!\nmakeAttributeHandler = function (elem, name, value) {\n  // generally, use setAttribute but certain attributes need to be set\n  // by directly setting a JavaScript property on the DOM element.\n  if (name === 'class') {\n    if (isSVGElement(elem)) {\n      return new SVGClassHandler(name, value);\n    } else {\n      return new ClassHandler(name, value);\n    }\n  } else if (name === 'selected' || name === 'checked') {\n    return new BooleanHandler(name, value);\n  } else if ((elem.tagName === 'TEXTAREA' || elem.tagName === 'INPUT')\n             && name === 'value') {\n    // internally, TEXTAREAs tracks their value in the 'value'\n    // attribute just like INPUTs.\n    return new ValueHandler(name, value);\n  } else {\n    return new AttributeHandler(name, value);\n  }\n\n  // XXX will need one for 'style' on IE, though modern browsers\n  // seem to handle setAttribute ok.\n};\n","\nUI.Component.instantiate = function (parent) {\n  var kind = this;\n\n  // check arguments\n  if (UI.isComponent(kind)) {\n    if (kind.isInited)\n      throw new Error(\"A component kind is required, not an instance\");\n  } else {\n    throw new Error(\"Expected Component kind\");\n  }\n\n  var inst = kind.extend(); // XXX args go here\n  inst.isInited = true;\n\n  // XXX messy to define this here\n  inst.templateInstance = {\n    findAll: function (selector) {\n      // XXX check that `.dom` exists here?\n      return inst.dom.$(selector);\n    },\n    find: function (selector) {\n      var result = this.findAll(selector);\n      return result[0] || null;\n    },\n    firstNode: null,\n    lastNode: null,\n    data: null,\n    __component__: inst\n  };\n\n  inst.parent = (parent || null);\n\n  if (inst.init)\n    inst.init();\n\n  if (inst.created) {\n    updateTemplateInstance(inst);\n    inst.created.call(inst.templateInstance);\n  }\n\n  return inst;\n};\n\nUI.Component.render = function () {\n  return null;\n};\n\n\n// Takes a reactive function (call it `inner`) and returns a reactive function\n// `outer` which is equivalent except in its reactive behavior.  Specifically,\n// `outer` has the following two special properties:\n//\n// 1. Isolation:  An invocation of `outer()` only invalidates its context\n//    when the value of `inner()` changes.  For example, `inner` may be a\n//    function that gets one or more Session variables and calculates a\n//    true/false value.  `outer` blocks invalidation signals caused by the\n//    Session variables changing and sends a signal out only when the value\n//    changes between true and false (in this example).  The value can be\n//    of any type, and it is compared with `===` unless an `equals` function\n//    is provided.\n//\n// 2. Value Sharing:  The `outer` function returned by `emboxValue` can be\n//    shared between different contexts, for example by assigning it to an\n//    object as a method that can be accessed at any time, such as by\n//    different templates or different parts of a template.  No matter\n//    how many times `outer` is called, `inner` is only called once until\n//    it changes.  The most recent value is stored internally.\n//\n// Conceptually, an emboxed value is much like a Session variable which is\n// kept up to date by an autorun.  Session variables provide storage\n// (value sharing) and they don't notify their listeners unless a value\n// actually changes (isolation).  The biggest difference is that such an\n// autorun would never be stopped, and the Session variable would never be\n// deleted even if it wasn't used any more.  An emboxed value, on the other\n// hand, automatically stops computing when it's not being used, and starts\n// again when called from a reactive context.  This means that when it stops\n// being used, it can be completely garbage-collected.\n//\n// If a non-function value is supplied to `emboxValue` instead of a reactive\n// function, then `outer` is still a function but it simply returns the value.\n//\nUI.emboxValue = function (funcOrValue, equals) {\n  if (typeof funcOrValue === 'function') {\n    var func = funcOrValue;\n\n    var curResult = null;\n    // There's one shared Dependency and Computation for all callers of\n    // our box function.  It gets kicked off if necessary, and when\n    // there are no more dependents, it gets stopped to avoid leaking\n    // memory.\n    var resultDep = null;\n    var computation = null;\n\n    return function () {\n      if (! computation) {\n        if (! Deps.active) {\n          // Not in a reactive context.  Just call func, and don't start a\n          // computation if there isn't one running already.\n          return func();\n        }\n\n        // No running computation, so kick one off.  Since this computation\n        // will be shared, avoid any association with the current computation\n        // by using `Deps.nonreactive`.\n        resultDep = new Deps.Dependency;\n\n        computation = Deps.nonreactive(function () {\n          return Deps.autorun(function (c) {\n            var oldResult = curResult;\n            curResult = func();\n            if (! c.firstRun) {\n              if (! (equals ? equals(curResult, oldResult) :\n                     curResult === oldResult))\n                resultDep.changed();\n            }\n          });\n        });\n      }\n\n      if (Deps.active) {\n        var isNew = resultDep.depend();\n        if (isNew) {\n          // For each new dependent, schedule a task for after that dependent's\n          // invalidation time and the subsequent flush. The task checks\n          // whether the computation should be torn down.\n          Deps.onInvalidate(function () {\n            if (resultDep && ! resultDep.hasDependents()) {\n              Deps.afterFlush(function () {\n                // use a second afterFlush to bump ourselves to the END of the\n                // flush, after computation re-runs have had a chance to\n                // re-establish their connections to our computation.\n                Deps.afterFlush(function () {\n                  if (resultDep && ! resultDep.hasDependents()) {\n                    computation.stop();\n                    computation = null;\n                    resultDep = null;\n                  }\n                });\n              });\n            }\n          });\n        }\n      }\n\n      return curResult;\n    };\n\n  } else {\n    var value = funcOrValue;\n    var result = function () {\n      return value;\n    };\n    result._isEmboxedConstant = true;\n    return result;\n  }\n};\n\n\n////////////////////////////////////////\n\n// Insert a DOM node or DomRange into a DOM element or DomRange.\n//\n// One of three things happens depending on what needs to be inserted into what:\n// - `range.add` (anything into DomRange)\n// - `UI.DomRange.insert` (DomRange into element)\n// - `elem.insertBefore` (node into element)\n//\n// The optional `before` argument is an existing node or id to insert before in\n// the parent element or DomRange.\nvar insert = function (nodeOrRange, parent, before) {\n  if (! parent)\n    throw new Error(\"Materialization parent required\");\n\n  if (parent instanceof UI.DomRange) {\n    parent.add(nodeOrRange, before);\n  } else if (nodeOrRange instanceof UI.DomRange) {\n    // parent is an element; inserting a range\n    UI.DomRange.insert(nodeOrRange, parent, before);\n  } else {\n    // parent is an element; inserting an element\n    parent.insertBefore(nodeOrRange, before || null); // `null` for IE\n  }\n};\n\n// Update attributes on `elem` to the dictionary `attrs`, using the\n// dictionary of existing `handlers` if provided.\n//\n// Values in the `attrs` dictionary are in pseudo-DOM form -- a string,\n// CharRef, or array of strings and CharRefs -- but they are passed to\n// the AttributeHandler in string form.\nvar updateAttributes = function(elem, newAttrs, handlers) {\n\n  if (handlers) {\n    for (var k in handlers) {\n      if (! newAttrs.hasOwnProperty(k)) {\n        // remove attributes (and handlers) for attribute names\n        // that don't exist as keys of `newAttrs` and so won't\n        // be visited when traversing it.  (Attributes that\n        // exist in the `newAttrs` object but are `null`\n        // are handled later.)\n        var handler = handlers[k];\n        var oldValue = handler.value;\n        handler.value = null;\n        handler.update(elem, oldValue, null);\n        delete handlers[k];\n      }\n    }\n  }\n\n  for (var k in newAttrs) {\n    var handler = null;\n    var oldValue;\n    var value = newAttrs[k];\n    if ((! handlers) || (! handlers.hasOwnProperty(k))) {\n      if (value !== null) {\n        // make new handler\n        handler = makeAttributeHandler(elem, k, value);\n        if (handlers)\n          handlers[k] = handler;\n        oldValue = null;\n      }\n    } else {\n      handler = handlers[k];\n      oldValue = handler.value;\n    }\n    if (handler && oldValue !== value) {\n      handler.value = value;\n      handler.update(elem, oldValue, value);\n      if (value === null)\n        delete handlers[k];\n    }\n  }\n};\n\nUI.render = function (kind, parentComponent) {\n  if (kind.isInited)\n    throw new Error(\"Can't render component instance, only component kind\");\n  var inst = kind.instantiate(parentComponent);\n\n  var content = (inst.render && inst.render());\n\n  var range = new UI.DomRange;\n  inst.dom = range;\n  range.component = inst;\n\n  materialize(content, range, null, inst);\n\n  range.removed = function () {\n    inst.isDestroyed = true;\n    if (inst.destroyed) {\n      updateTemplateInstance(inst);\n      inst.destroyed.call(inst.templateInstance);\n    }\n  };\n\n  return inst;\n};\n\nvar contentEquals = function (a, b) {\n  if (a instanceof HTML.Raw) {\n    return (b instanceof HTML.Raw) && (a.value === b.value);\n  } else if (a == null) {\n    return (b == null);\n  } else {\n    return (a === b) &&\n      ((typeof a === 'number') || (typeof a === 'boolean') ||\n       (typeof a === 'string'));\n  }\n};\n\nUI.InTemplateScope = function (tmplInstance, content) {\n  if (! (this instanceof UI.InTemplateScope))\n    // called without `new`\n    return new UI.InTemplateScope(tmplInstance, content);\n\n  var parentPtr = tmplInstance.parent;\n  if (parentPtr.__isTemplateWith)\n    parentPtr = parentPtr.parent;\n\n  this.parentPtr = parentPtr;\n  this.content = content;\n};\n\nUI.InTemplateScope.prototype.toHTML = function (parentComponent) {\n  return HTML.toHTML(this.content, this.parentPtr);\n};\n\nUI.InTemplateScope.prototype.toText = function (textMode, parentComponent) {\n  return HTML.toText(this.content, textMode, this.parentPtr);\n};\n\n// Convert the pseudoDOM `node` into reactive DOM nodes and insert them\n// into the element or DomRange `parent`, before the node or id `before`.\nvar materialize = function (node, parent, before, parentComponent) {\n  // XXX should do more error-checking for the case where user is supplying the tags.\n  // For example, check that CharRef has `html` and `str` properties and no content.\n  // Check that Comment has a single string child and no attributes.  Etc.\n\n  if (node == null) {\n    // null or undefined.\n    // do nothinge.\n  } else if ((typeof node === 'string') || (typeof node === 'boolean') || (typeof node === 'number')) {\n    node = String(node);\n    insert(document.createTextNode(node), parent, before);\n  } else if (node instanceof Array) {\n    for (var i = 0; i < node.length; i++)\n      materialize(node[i], parent, before, parentComponent);\n  } else if (typeof node === 'function') {\n\n    var range = new UI.DomRange;\n    var lastContent = null;\n    var rangeUpdater = Deps.autorun(function (c) {\n      var content = node();\n      // normalize content a little, for easier comparison\n      if (HTML.isNully(content))\n        content = null;\n      else if ((content instanceof Array) && content.length === 1)\n        content = content[0];\n\n      // update if content is different from last time\n      if (! contentEquals(content, lastContent)) {\n        lastContent = content;\n\n        if (! c.firstRun)\n          range.removeAll();\n\n        Deps.nonreactive(function () {\n          materialize(content, range, null, parentComponent);\n        });\n      }\n    });\n    range.removed = function () {\n      rangeUpdater.stop();\n    };\n    insert(range, parent, before);\n  } else if (node instanceof HTML.Tag) {\n    var tagName = HTML.properCaseTagName(node.tagName);\n    var elem;\n    if (HTML.isKnownSVGElement(tagName) && (! HTML.isKnownElement(tagName)) &&\n        document.createElementNS) {\n      elem = document.createElementNS('http://www.w3.org/2000/svg', tagName);\n    } else {\n      elem = document.createElement(node.tagName);\n    }\n\n    var rawAttrs = node.attrs;\n    var children = node.children;\n    if (node.tagName === 'TEXTAREA') {\n      rawAttrs = (rawAttrs || {});\n      rawAttrs.value = children;\n      children = [];\n    };\n\n    if (rawAttrs) {\n      var attrUpdater = Deps.autorun(function (c) {\n        if (! c.handlers)\n          c.handlers = {};\n\n        try {\n          var attrs = HTML.evaluateAttributes(rawAttrs, parentComponent);\n          var stringAttrs = {};\n          if (attrs) {\n            for (var k in attrs) {\n              stringAttrs[k] = HTML.toText(attrs[k], HTML.TEXTMODE.STRING,\n                                           parentComponent);\n            }\n            updateAttributes(elem, stringAttrs, c.handlers);\n          }\n        } catch (e) {\n          reportUIException(e);\n        }\n      });\n      UI.DomBackend.onRemoveElement(elem, function () {\n        attrUpdater.stop();\n      });\n    }\n    materialize(children, elem, null, parentComponent);\n\n    insert(elem, parent, before);\n  } else if (typeof node.instantiate === 'function') {\n    // component\n    var instance = UI.render(node, parentComponent);\n\n    insert(instance.dom, parent, before);\n  } else if (node instanceof HTML.CharRef) {\n    insert(document.createTextNode(node.str), parent, before);\n  } else if (node instanceof HTML.Comment) {\n    insert(document.createComment(node.sanitizedValue), parent, before);\n  } else if (node instanceof HTML.Raw) {\n    // Get an array of DOM nodes by using the browser's HTML parser\n    // (like innerHTML).\n    var htmlNodes = UI.DomBackend.parseHTML(node.value);\n    for (var i = 0; i < htmlNodes.length; i++)\n      insert(htmlNodes[i], parent, before);\n  } else if (HTML.Special && (node instanceof HTML.Special)) {\n    throw new Error(\"Can't materialize Special tag, it's just an intermediate rep\");\n  } else if (node instanceof UI.InTemplateScope) {\n    materialize(node.content, parent, before, node.parentPtr);\n  } else {\n    // can't get here\n    throw new Error(\"Unexpected node in htmljs: \" + node);\n  }\n};\n\n\n\n// XXX figure out the right names, and namespace, for these.\n// for example, maybe some of them go in the HTML package.\nUI.materialize = materialize;\n\nUI.body = UI.Component.extend({\n  kind: 'body',\n  contentParts: [],\n  render: function () {\n    return this.contentParts;\n  },\n  // XXX revisit how body works.\n  INSTANTIATED: false\n});\n\nUI.block = function (renderFunc) {\n  return UI.Component.extend({ render: renderFunc });\n};\n\nUI.toHTML = function (content, parentComponent) {\n  return HTML.toHTML(content, parentComponent);\n};\n\nUI.toRawText = function (content, parentComponent) {\n  return HTML.toText(content, HTML.TEXTMODE.STRING, parentComponent);\n};\n","\nUI.If = function (argFunc, contentBlock, elseContentBlock) {\n  checkBlockHelperArguments('If', argFunc, contentBlock, elseContentBlock);\n\n  return function () {\n    if (getCondition(argFunc))\n      return contentBlock;\n    else\n      return elseContentBlock || null;\n  };\n};\n\n\nUI.Unless = function (argFunc, contentBlock, elseContentBlock) {\n  checkBlockHelperArguments('Unless', argFunc, contentBlock, elseContentBlock);\n\n  return function () {\n    if (! getCondition(argFunc))\n      return contentBlock;\n    else\n      return elseContentBlock || null;\n  };\n};\n\n// Returns true if `a` and `b` are `===`, unless they are of a mutable type.\n// (Because then, they may be equal references to an object that was mutated,\n// and we'll never know.  We save only a reference to the old object; we don't\n// do any deep-copying or diffing.)\nvar safeEquals = function (a, b) {\n  if (a !== b)\n    return false;\n  else\n    return ((!a) || (typeof a === 'number') || (typeof a === 'boolean') ||\n            (typeof a === 'string'));\n};\n\n// Unlike Spacebars.With, there's no else case and no conditional logic.\n//\n// We don't do any reactive emboxing of `argFunc` here; it should be done\n// by the caller if efficiency and/or number of calls to the data source\n// is important.\nUI.With = function (argFunc, contentBlock) {\n  checkBlockHelperArguments('With', argFunc, contentBlock);\n\n  var block = contentBlock;\n  if ('data' in block) {\n    // XXX TODO: get religion about where `data` property goes\n    block = UI.block(function () {\n      return contentBlock;\n    });\n  }\n  block.data = UI.emboxValue(argFunc, safeEquals);\n\n  return block;\n};\n\nUI.Each = function (argFunc, contentBlock, elseContentBlock) {\n  checkBlockHelperArguments('Each', argFunc, contentBlock, elseContentBlock);\n\n  return UI.EachImpl.extend({\n    __sequence: argFunc,\n    __content: contentBlock,\n    __elseContent: elseContentBlock\n  });\n};\n\nvar checkBlockHelperArguments = function (which, argFunc, contentBlock, elseContentBlock) {\n  if (typeof argFunc !== 'function')\n    throw new Error('First argument to ' + which + ' must be a function');\n  if (! UI.isComponent(contentBlock))\n    throw new Error('Second argument to ' + which + ' must be a template or UI.block');\n  if (elseContentBlock && ! UI.isComponent(elseContentBlock))\n    throw new Error('Third argument to ' + which + ' must be a template or UI.block if present');\n};\n\n// Acts like `!! conditionFunc()` except:\n//\n// - Empty array is considered falsy\n// - The result is Deps.isolated (doesn't trigger invalidation\n//   as long as the condition stays truthy or stays falsy\nvar getCondition = function (conditionFunc) {\n  return Deps.isolateValue(function () {\n    // `condition` is emboxed; it is always a function,\n    // and it only triggers invalidation if its return\n    // value actually changes.  We still need to isolate\n    // the calculation of whether it is truthy or falsy\n    // in order to not re-render if it changes from one\n    // truthy or falsy value to another.\n    var cond = conditionFunc();\n\n    // empty arrays are treated as falsey values\n    if (cond instanceof Array && cond.length === 0)\n      return false;\n    else\n      return !! cond;\n  });\n};\n","UI.EachImpl = Component.extend({\n  typeName: 'Each',\n  render: function (modeHint) {\n    var self = this;\n    var content = self.__content;\n    var elseContent = self.__elseContent;\n\n    if (modeHint === 'STATIC') {\n      // This is a hack.  The caller gives us a hint if the\n      // value we return will be static (in HTML or text)\n      // or dynamic (materialized DOM).  The dynamic path\n      // returns `null` and then we populate the DOM from\n      // the `parented` callback.\n      //\n      // It would be much cleaner to always return the same\n      // value here, and to have that value be some special\n      // object that encapsulates the logic for populating\n      // the #each using a mode-agnostic interface that\n      // works for HTML, text, and DOM.  Alternatively, we\n      // could formalize the current pattern, e.g. defining\n      // a method like component.populate(domRange) and one\n      // like renderStatic() or even renderHTML / renderText.\n      var parts = _.map(\n        ObserveSequence.fetch(self.__sequence()),\n        function (item) {\n          return content.extend({data: function () {\n            return item;\n          }});\n        });\n\n      if (parts.length) {\n        return parts;\n      } else {\n        return elseContent;\n      }\n      return parts;\n    } else {\n      return null;\n    }\n  },\n  parented: function () {\n    var self = this.__component__;\n\n    var range = self.dom;\n\n    var content = self.__content;\n    var elseContent = self.__elseContent;\n\n    // if there is an else clause, keep track of the number of\n    // rendered items.  use this to display the else clause when count\n    // becomes zero, and remove it when count becomes positive.\n    var itemCount = 0;\n    var addToCount = function(delta) {\n      if (!elseContent) // if no else, no need to keep track of count\n        return;\n\n      if (itemCount + delta < 0)\n        throw new Error(\"count should never become negative\");\n\n      if (itemCount === 0) {\n        // remove else clause\n        range.removeAll();\n      }\n      itemCount += delta;\n      if (itemCount === 0) {\n        UI.materialize(elseContent, range, null, self);\n      }\n    };\n\n    this.observeHandle = ObserveSequence.observe(function () {\n      return self.__sequence();\n    }, {\n      addedAt: function (id, item, i, beforeId) {\n        addToCount(1);\n        id = LocalCollection._idStringify(id);\n\n        var data = item;\n        var dep = new Deps.Dependency;\n\n        // function to become `comp.data`\n        var dataFunc = function () {\n          dep.depend();\n          return data;\n        };\n        // Storing `$set` on `comp.data` lets us\n        // access it from `changed`.\n        dataFunc.$set = function (v) {\n          data = v;\n          dep.changed();\n        };\n\n        if (beforeId)\n          beforeId = LocalCollection._idStringify(beforeId);\n\n        var renderedItem = UI.render(content.extend({data: dataFunc}), self);\n        range.add(id, renderedItem.dom, beforeId);\n      },\n      removed: function (id, item) {\n        addToCount(-1);\n        range.remove(LocalCollection._idStringify(id));\n      },\n      movedTo: function (id, item, i, j, beforeId) {\n        range.moveBefore(\n          LocalCollection._idStringify(id),\n          beforeId && LocalCollection._idStringify(beforeId));\n      },\n      changed: function (id, newItem) {\n        range.get(LocalCollection._idStringify(id)).component.data.$set(newItem);\n      }\n    });\n\n      // on initial render, display the else clause if no items\n      addToCount(0);\n  },\n  destroyed: function () {\n    if (this.observeHandle)\n      this.observeHandle.stop();\n  }\n});\n","\nvar global = (function () { return this; })();\n\n// Searches for the given property in `comp` or a parent,\n// and returns it as is (without call it if it's a function).\nvar lookupComponentProp = function (comp, prop) {\n  comp = findComponentWithProp(prop, comp);\n  var result = (comp ? comp.data : null);\n  if (typeof result === 'function')\n    result = _.bind(result, comp);\n  return result;\n};\n\n// Component that's a no-op when used as a block helper like\n// `{{#foo}}...{{/foo}}`.\nvar noOpComponent = Component.extend({\n  kind: 'NoOp',\n  render: function () {\n    return this.__content;\n  }\n});\n\n// This map is searched first when you do something like `{{#foo}}` in\n// a template.\nvar builtInComponents = {\n  // for past compat:\n  'constant': noOpComponent,\n  'isolate': noOpComponent\n};\n\n_extend(UI.Component, {\n  // Options:\n  //\n  // - template {Boolean} If true, look at the list of templates after\n  //   helpers and before data context.\n  lookup: function (id, opts) {\n    var self = this;\n    var template = opts && opts.template;\n    var result;\n    var comp;\n\n    if (!id)\n      throw new Error(\"must pass id to lookup\");\n\n    if (/^\\./.test(id)) {\n      // starts with a dot. must be a series of dots which maps to an\n      // ancestor of the appropriate height.\n      if (!/^(\\.)+$/.test(id)) {\n        throw new Error(\"id starting with dot must be a series of dots\");\n      }\n\n      var compWithData = findComponentWithProp('data', self);\n      for (var i = 1; i < id.length; i++) {\n        compWithData = compWithData ? findComponentWithProp('data', compWithData.parent) : null;\n      }\n\n      return (compWithData ? compWithData.data : null);\n\n    } else if ((comp = findComponentWithProp(id, self))) {\n      // found a property or method of a component\n      // (`self` or one of its ancestors)\n      var result = comp[id];\n\n    } else if (_.has(builtInComponents, id)) {\n      return builtInComponents[id];\n\n    // Code to search the global namespace for capitalized names\n    // like component classes, `Template`, `StringUtils.foo`,\n    // etc.\n    //\n    // } else if (/^[A-Z]/.test(id) && (id in global)) {\n    //   // Only look for a global identifier if `id` is\n    //   // capitalized.  This avoids having `{{name}}` mean\n    //   // `window.name`.\n    //   result = global[id];\n    //   return function (/*arguments*/) {\n    //     var data = getComponentData(self);\n    //     if (typeof result === 'function')\n    //       return result.apply(data, arguments);\n    //     return result;\n    //   };\n    } else if (template && _.has(Template, id)) {\n      return Template[id];\n\n    } else if (Handlebars._globalHelpers[id]) {\n      // Backwards compatibility for helpers defined with\n      // `Handlebars.registerHelper`. XXX what is the future pattern\n      // for this? We should definitely not put it on the Handlebars\n      // namespace.\n      result = Handlebars._globalHelpers[id];\n\n    } else {\n      // Resolve id `foo` as `data.foo` (with a \"soft dot\").\n      return function (/*arguments*/) {\n        var data = getComponentData(self);\n        if (! data)\n          return data;\n        var result = data[id];\n        if (typeof result === 'function')\n          return result.apply(data, arguments);\n        return result;\n      };\n    }\n\n    if (typeof result === 'function' && ! result._isEmboxedConstant) {\n      // Wrap the function `result`, binding `this` to `getComponentData(self)`.\n      // This creates a dependency when the result function is called.\n      // Don't do this if the function is really just an emboxed constant.\n      return function (/*arguments*/) {\n        var data = getComponentData(self);\n        return result.apply(data, arguments);\n      };\n    } else {\n      return result;\n    };\n  },\n  lookupTemplate: function (id) {\n    return this.lookup(id, {template: true});\n  },\n  get: function (id) {\n    // support `this.get()` to get the data context.\n    if (id === undefined)\n      id = \".\";\n\n    var result = this.lookup(id);\n    return (typeof result === 'function' ? result() : result);\n  },\n  set: function (id, value) {\n    var comp = findComponentWithProp(id, this);\n    if (! comp || ! comp[id])\n      throw new Error(\"Can't find field: \" + id);\n    if (typeof comp[id] !== 'function')\n      throw new Error(\"Not a settable field: \" + id);\n    comp[id](value);\n  }\n});\n","Handlebars = {\n  _globalHelpers: {},\n\n  registerHelper: function (name, func) {\n    this._globalHelpers[name] = func;\n  }\n};\n\n// Utility to HTML-escape a string.\nHandlebars._escape = (function() {\n  var escape_map = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"`\": \"&#x60;\", /* IE allows backtick-delimited attributes?? */\n    \"&\": \"&amp;\"\n  };\n  var escape_one = function(c) {\n    return escape_map[c];\n  };\n\n  return function (x) {\n    return x.replace(/[&<>\"'`]/g, escape_one);\n  };\n})();\n\n// Return these from {{...}} helpers to achieve the same as returning\n// strings from {{{...}}} helpers\nHandlebars.SafeString = function(string) {\n  this.string = string;\n};\nHandlebars.SafeString.prototype.toString = function() {\n  return this.string.toString();\n};\n"]}